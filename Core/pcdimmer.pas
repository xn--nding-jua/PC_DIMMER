{*********************************************************************************}
{**                                                                             **}
{**  PHOENIXstudios PC_DIMMER                                                   **}
{**  Copyrights (c) 2004-2023 by PHOENIXstudios Remsfeld                        **}
{**                                                                             **}
{**  Author: Dr.-Ing. Christian Nöding, info@pcdimmer.de                        **}
{**  Co-Author: Martin Mikula (2012-2013)                                       **}
{**                                                                             **}
{**  Website: https://www.pcdimmer.de (Updates, Infos, etc.)                    **}
{**  Forum: https://forum.pcdimmer.de                                           **}
{**  Github: https://github.com/xn--nding-jua/PC_DIMMER                         **}
{**                                                                             **}
{**  This software is licensed under the GNU Public license                     **}
{**                                                                             **}
{**                                                                             **}
{*********************************************************************************}


unit PCDIMMER;

interface

uses
  // Delphi Units
  VCLFixPack, Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls, ComCtrls, ExtCtrls, Registry, Buttons, Menus,
  ToolWin, ImgList, ShellApi, ActnColorMaps, ActnMan, Printers,
  Math, DateUtils, Grids, CheckLst, MPlayer, Variants, MMSystem,
  ComObj, ActiveX, WinINet, WinSock, Contnrs,
  // eigene Units
  insscene, SetNames, splashscreen, optionen, About, Action,
  pat, gpl, protocol, presskey, skripttimer_edit, blenddownfrm, progressscreen,
  messagesystem, druckenfrm, projektverwaltungfrm, editmidievent, midievent,
  figureneditor, szenenverwaltung, bewegungsszeneneditor,kontrollpanelform,
  audioszeneeditorform, befehleditorform2, Tastenabfragefrm, buehnenansicht,
  {deviceformprototypfrm,} editdatainevent, datainevent,
  // fremde Units
  GR32, spectrum_vis, osc_vis, CommonTypes, Bass, BASS_AC3, Basscd, BASSmix, Bass_fx,
  JvComponent, JvZlibMultiple, AudioIO, antTaskbarIcon, IAeverProgressBar,
  CPDrv, PowerButton, JvSimScope, MidiIn, MidiType, Monprocs, JvBaseDlg,
  JclDebug, JvInterpreter, JvInterpreter_all, JvComponentBase, pngimage,
  PngImageList, PngBitBtn, JvThreadTimer, uMultimediaTimer, Mask, JvExMask,
  JvSpin, JvProgressBar, JvXPProgressBar, JvExControls, JvWaitingGradient,
  JvExExtCtrls, JvExtComponent, JvCaptionPanel, JvSpecialProgress, JclSysInfo,
  JvAppStorage, JvAppXMLStorage, IdBaseComponent, IdComponent, MidiOut,
  DECUtil, DECCipher, DECHash, DECFmt, DECRandom, IdTCPConnection,
  IdTCPClient, pcdHTTPServer, IdHTTPServer, JvComputerInfoEx, PowerButton1, gnugettext,
  ScktComp, TB2ToolWindow, UdpSockUtil, CSVUtils, IdTCPServer,
  Tokentools, dxBar, dxSkinsCore, dxStatusBar, dxRibbonStatusBar, cxClasses,
  dxRibbonForm, dxRibbon, cxControls, dxBarExtItems, JvPanel, JvColorBox,
  JvOfficeColorPanel, JvColorButton, cxStyles, dxGDIPlusClasses, SHDocVw,
  graphutil, IdCustomTCPServer, IdCustomHTTPServer, idContext, VistaAltFixUnit2,
  SVATimer, cxGraphics, cxLookAndFeels, cxLookAndFeelPainters, pcdMEVP,
  dxRibbonSkins, dxBarApplicationMenu, D7GesturesHeader, jpeg,
  JvHidControllerClass, Hid, OverbyteIcsMQTT;

const
  maincaption = 'PC_DIMMER';
  actualprojectversion=491;
  maxres = 255; // maximale Auflösung der Fader
  {$I GlobaleKonstanten.inc} // maximale Kanalzahl für PC_DIMMER !Vorsicht! Bei Ändern des Wertes müssen einzelne Plugins und Forms ebenfalls verändert werden, da dort auch chan gesetzt wird! Auch die GUI muss angepasst werden
  maxaudioeffektlayers = 8;
  blowfishscramblekey = 'rejnbfui34w87fr243hf8bv8734g38zbf873cb48';

  // Konstanten für Thread-Multicore-Zuweisung
  THREAD_TERMINATE                 = $0001;
  THREAD_SUSPEND_RESUME            = $0002;
  THREAD_GET_CONTEXT               = $0008;
  THREAD_SET_CONTEXT               = $0010;
  THREAD_SET_INFORMATION           = $0020;
  THREAD_QUERY_INFORMATION         = $0040;
  THREAD_SET_THREAD_TOKEN          = $0080;
  THREAD_IMPERSONATE               = $0100;
  THREAD_DIRECT_IMPERSONATION      = $0200;
  THREAD_SET_LIMITED_INFORMATION   = $0400;
  THREAD_QUERY_LIMITED_INFORMATION = $0800;
  THREAD_ALL_ACCESS                = STANDARD_RIGHTS_REQUIRED or SYNCHRONIZE or $03FF;

  // WORKAROUND FOR MEVP
  MEVP_VERSION=12;
  MEVP_NB_UNIVERSES=4;
  MEVP_MAX_FIXTURES=1000;
  MEVP_DMX_MAX_CHANNEL=512;
  MEVP_DMX_ARRAY_SIZE=MEVP_NB_UNIVERSES * MEVP_DMX_MAX_CHANNEL;
  MEVP_MAX_STR_LEN=300;

  MEVP_CLOSE_VISUALIZER=0;
  MEVP_SET_LANGUAGE=1;
  MEVP_READ_PATCH=2;

  MEVP_CREATE_SHARED_MEM=0;
  MEVP_FREE_SHARED_MEM=1;
  MEVP_WRITE_PATCH=2;
  // END OF WORKAROUND FOR MEVP

// GUIDs für Projektdateiinformationen
  IID_IPropertySetStorage           : TGUID =
    '{0000013A-0000-0000-C000-000000000046}';
  FMTID_SummaryInformation          : TGUID =
    '{F29F85E0-4FF9-1068-AB91-08002B27B3D9}';
  FMTID_DocSummaryInformation       : TGUID =
    '{D5CDD502-2E9C-101B-9397-08002B2CF9AE}';
  FMTID_UserDefinedProperties       : TGUID =
    '{D5CDD505-2E9C-101B-9397-08002B2CF9AE}';
  FMTID_AudioSummaryInformation     : TGuid =
    '{64440490-4C8B-11D1-8B70-080036B11A03}';
  FMTID_VideoSummaryInformation     : TGUID =
    '{64440491-4C8B-11D1-8B70-080036B11A03}';
  FMTID_ImageSummaryInformation     : TGUID =
    '{6444048f-4c8b-11d1-8b70-080036b11a03}';
  FMTID_MediaFileSummaryInformation : TGUID =
    '{64440492-4c8b-11d1-8b70-080036b11a03}';

  STGFMT_STORAGE     = 0;
  STGFMT_FILE        = 3;
  STGFMT_ANY         = 4;
  STGFMT_DOCFILE     = 5;

  // Summary Information
  PID_TITLE = 2;
  PID_SUBJECT = 3;
  PID_AUTHOR = 4;
  PID_KEYWORDS = 5;
  PID_COMMENTS = 6;
  PID_TEMPLATE = 7;
  PID_LASTAUTHOR = 8;
  PID_REVNUMBER = 9;
  PID_EDITTIME = 10;
  PID_LASTPRINTED = 11;
  PID_CREATE_DTM = 12;
  PID_LASTSAVE_DTM = 13;
  PID_PAGECOUNT = 14;
  PID_WORDCOUNT = 15;
  PID_CHARCOUNT = 16;
  PID_THUMBNAIL = 17;
  PID_APPNAME = 18;
  PID_SECURITY = 19;

  // Document Summary Information
  PID_CATEGORY = 2;
  PID_PRESFORMAT = 3;
  PID_BYTECOUNT = 4;
  PID_LINECOUNT = 5;
  PID_PARCOUNT = 6;
  PID_SLIDECOUNT = 7;
  PID_NOTECOUNT = 8;
  PID_HIDDENCOUNT = 9;
  PID_MMCLIPCOUNT = 10;
  PID_SCALE = 11;
  PID_HEADINGPAIR = 12;
  PID_DOCPARTS = 13;
  PID_MANAGER = 14;
  PID_COMPANY = 15;
  PID_LINKSDIRTY = 16;
  PID_CHARCOUNT2 = 17;

  // FMTID_MediaFileSummaryInfo
  PIDMSI_EDITOR      = $00000002;     // VT_LPWSTR
  PIDMSI_SUPPLIER    = $00000003;
  PIDMSI_SOURCE      = $00000004;
  PIDMSI_SEQUENCE_NO = $00000005;
  PIDMSI_PROJECT     = $00000006;
  PIDMSI_STATUS      = $00000007;     // VT_UI4
  PIDMSI_OWNER       = $00000008;     // VT_LPWSTR
  PIDMSI_RATING      = $00000009;
  PIDMSI_PRODUCTION  = $0000000A;     // VT_FILETIME (UTC)
  PIDMSI_COPYRIGHT   = $0000000B;     // VT_LPWSTR

  // FMTID_AudioSummaryInformation
  PIDASI_FORMAT        = $00000002;   // VT_BSTR
  PIDASI_TIMELENGTH    = $00000003;   // VT_UI4, milliseconds
  PIDASI_AVG_DATA_RATE = $00000004;   // VT_UI4,  Hz
  PIDASI_SAMPLE_RATE   = $00000005;   // VT_UI4,  bits
  PIDASI_SAMPLE_SIZE   = $00000006;   // VT_UI4,  bits
  PIDASI_CHANNEL_COUNT = $00000007;   // VT_UI4
  PIDASI_STREAM_NUMBER = $00000008;   // VT_UI2
  PIDASI_STREAM_NAME   = $00000009;   // VT_LPWSTR
  PIDASI_COMPRESSION   = $0000000A;   // VT_LPWSTR

  // FMTID_VideoSummaryInformation
  PIDVSI_STREAM_NAME   = $00000002;   // "StreamName", VT_LPWSTR
  PIDVSI_FRAME_WIDTH   = $00000003;   // "FrameWidth", VT_UI4
  PIDVSI_FRAME_HEIGHT  = $00000004;   // "FrameHeight", VT_UI4
  PIDVSI_TIMELENGTH    = $00000007;   // "TimeLength", VT_UI4, milliseconds
  PIDVSI_FRAME_COUNT   = $00000005;   // "FrameCount". VT_UI4
  PIDVSI_FRAME_RATE    = $00000006;   // "FrameRate", VT_UI4, frames/millisecond
  PIDVSI_DATA_RATE     = $00000008;   // "DataRate", VT_UI4, bytes/second
  PIDVSI_SAMPLE_SIZE   = $00000009;   // "SampleSize", VT_UI4
  PIDVSI_COMPRESSION   = $0000000A;   // "Compression", VT_LPWSTR
  PIDVSI_STREAM_NUMBER = $0000000B;   // "StreamNumber", VT_UI2

  function GetFileSummaryInfo(const FileName: WideString): WideString;
  //function SetFileSummaryInfo(const FileName: WideString; PID_InfoType: Cardinal;
  //  InfoStr: string): DWORD;
  function SetFileSummaryInfo(const FileName: WideString; GUID_InfoType: TGUID;
    PID_InfoType: Cardinal; InfoStr: WideString): boolean;
  function StgOpenStorageEx(
    const pwcsName: POleStr; //Pointer to the path of the
                               //file containing storage object
  grfMode: LongInt; //Specifies the access mode for the object
  stgfmt: DWORD; //Specifies the storage file format
  grfAttrs: DWORD; //Reserved; must be zero
  pStgOptions: Pointer; //Address of STGOPTIONS pointer
  reserved2: Pointer; //Reserved; must be zero
  riid: PGUID; //Specifies the GUID of the interface pointer
  out stgOpen: //Address of an interface pointer
  IStorage): HResult; stdcall; external 'ole32.dll';
// Ende Funktionen für Projektdateiinformationen

type
  // Plugin-Prototypen deklarieren
  TOutputPlugin = record
    Filename: string;
    IsActive: boolean;
    IsEnabled: boolean;
    IsBlacklisted: boolean;
    Handle: THandle;
    Name: string;
    Version: string;
    Icon: TBitmap;

    Startaddress: integer;
    Stopaddress: integer;

    SendData: procedure(address, startvalue, endvalue, fadetime:integer; channelname:PChar);stdcall;
    SendMessage: procedure(MSG:Byte; Data1, Data2:Variant);stdcall;
    IsSending: function:boolean;stdcall;
  end;
  TProgramPlugin = record
    Filename: string;
    Handle: THandle;
    Name: string;
    Version: string;
    Icon: TBitmap;
    SendData: procedure(address, startvalue, endvalue, fadetime:integer; channelname:PChar);stdcall;
    SendMessage: procedure(MSG:Byte; Data1, Data2:Variant);stdcall;
  end;

  // PCD_Helper_Thread deklarieren
  THelperThread = class(TThread)
  private
  protected
    procedure Execute; override;
  public
    constructor create();
  end;
  // Thread für Akkuanzeige deklarieren
  TAccuEvent = procedure () of object;
  TAccuThread = class(TThread)
  private
    FAccuEvent:TAccuEvent;
  protected
    procedure Execute; override;
  public
    constructor create(AccuEvent:TAccuEvent);
  end;
  // Thread für Waveanzeige deklarieren
  TScanEvent = procedure (decoder: HSTREAM) of object;
  TScanThread = class(TThread)
  private
    Fdecoder : HSTREAM;
  protected
    procedure Execute; override;
  public
    constructor create(decoder:HSTREAM);
  end;

  {$I Typdefinitionen.inc}

  ITaskbarList = interface
    ['{56FDF342-FD6D-11d0-958A-006097C9A090}']
    function HrInit: HResult; stdcall;
    function AddTab(hwnd: Cardinal): HResult; stdcall;
    function DeleteTab(hwnd: Cardinal): HResult; stdcall;
    function ActivateTab(hwnd: Cardinal): HResult; stdcall;
    function SetActiveAlt(hwnd: Cardinal): HResult; stdcall;
  end;

  TMainform = class(TdxRibbonForm) //TForm  TdxRibbonForm
    N16: TMenuItem;
    Beenden1: TMenuItem;
    Info1: TMenuItem;
    N20: TMenuItem;
    PCDimmeranzeigen1: TMenuItem;
    OpenDialog: TOpenDialog;
    SaveDialog: TSaveDialog;
    XPColorMap1: TXPColorMap;
    Uhrzeit_Timer: TTimer;
    systrayicon: TantTaskbarIcon;
    systraypopup: TPopupMenu;
    openmedia: TOpenDialog;
    ColorDialog: TColorDialog;
    AudioIn: TAudioIn;
    Compress: TJvZlibMultiple;
    Timer1: TTimer;
    PowerButton1: TPowerButton;
    Onlineupdate1: TMenuItem;
    textbox: TListBox;
    MidiInput1: TMidiInput;
    ScriptInterpreter: TJvInterpreterProgram;
    PngImageList1: TPngImageList;
    Autobackuptimer: TTimer;
    XML: TJvAppXMLFileStorage;
    MidiOutput1: TMidiOutput;
    AkkuTimer: TTimer;
    N2: TMenuItem;
    ippsundTricks2: TMenuItem;
    Startoptionen2: TMenuItem;
    MidiCallbackTimer: TTimer;
    JvComputerInfoEx1: TJvComputerInfoEx;
    MediaCenterSocket: TClientSocket;
    CommandServer: TIdTCPServer;
    devicepictures128: TPngImageCollection;
    devicepictures96: TPngImageCollection;
    devicepictures64: TPngImageCollection;
    devicepictures32: TPngImageCollection;
    HomeRibbonTab: TdxRibbonTab;
    dxRibbon1: TdxRibbon;
    dxRibbonStatusBar1: TdxRibbonStatusBar;
    dxBarManager1: TdxBarManager;
    dxBarManager1Bar1: TdxBar;
    DateiRibbonGroup: TdxBar;
    dxBarButton1: TdxBarButton;
    NewRibbonBtn: TdxBarLargeButton;
    New2RibbonBtn: TdxBarButton;
    Open2RibbonBtn: TdxBarButton;
    Save2RibbonBtn: TdxBarButton;
    OpenRibbonBtn: TdxBarLargeButton;
    SaveRibbonBtn: TdxBarLargeButton;
    SaveAsRibbonBtn: TdxBarLargeButton;
    VerwaltungRibbonGroup: TdxBar;
    VerwaltungRibbonBtn: TdxBarLargeButton;
    PrintChannelNamesRibbonBtn: TdxBarLargeButton;
    RecoverRibbonBtn: TdxBarLargeButton;
    PluginRibbonTab: TdxRibbonTab;
    PluginsRibbonGroup: TdxBar;
    FensterRibbonTab: TdxRibbonTab;
    DeviceRibbonTab: TdxRibbonTab;
    EinstellungRibbonTab: TdxRibbonTab;
    SonstigesRibbonTab: TdxRibbonTab;
    LetzteProjekteRibbonBtn: TdxBarSubItem;
    openhistory1ribbon: TdxBarButton;
    openhistory2ribbon: TdxBarButton;
    openhistory5ribbon: TdxBarButton;
    openhistory3ribbon: TdxBarButton;
    openhistory4ribbon: TdxBarButton;
    DeviceListRibbonGroup: TdxBar;
    DeviceListRibbonBtn: TdxBarLargeButton;
    ExportDeviceListRibbonBtn: TdxBarLargeButton;
    AnzeigenRibbonGroup: TdxBar;
    ControlRibbonGroup: TdxBar;
    PlayerRibbonGroup: TdxBar;
    SzenenverwaltungRibbonBtn: TdxBarLargeButton;
    KanaluebersichtRibbonBtn: TdxBarLargeButton;
    ProjektassistentRibbonBtn: TdxBarLargeButton;
    BuehnenansichtRibbonBtn: TdxBarLargeButton;
    EasyViewRibbonBtn: TdxBarLargeButton;
    KontrollpanelRibbonBtn: TdxBarLargeButton;
    DeviceManagementRibbonGroup: TdxBar;
    GeraetesteuerungRibbonBtn: TdxBarLargeButton;
    InputRibbonGroup: TdxBar;
    JoystickRibbonBtn: TdxBarLargeButton;
    AudioeffektRibbonBtn: TdxBarLargeButton;
    EffektsequenzerRibbonBtn: TdxBarLargeButton;
    CuelistRibbonBtn: TdxBarLargeButton;
    TextbuchRibbonBtn: TdxBarLargeButton;
    TimecodeRibbonBtn: TdxBarLargeButton;
    VideoscreenRibbonBtn: TdxBarLargeButton;
    CDPlayerRibbonBtn: TdxBarLargeButton;
    DeviceeditorRibbonBtn: TdxBarLargeButton;
    dxBarLargeButton1: TdxBarLargeButton;
    dxBarManager1Bar2: TdxBar;
    ClockRibbonBtn: TdxBarLargeButton;
    BeattoolRibbonBtn: TdxBarLargeButton;
    ZeitsteuerungRibbonBtn: TdxBarLargeButton;
    TastatursteuerungRibbonBtn: TdxBarLargeButton;
    MIDISetupRibbonBtn: TdxBarLargeButton;
    MIDIRibbonSub: TdxBarSubItem;
    DataInRibbonSub: TdxBarSubItem;
    dxBarButton3: TdxBarButton;
    InfrarotRibbonBtn: TdxBarLargeButton;
    JoystickRibbonSub: TdxBarSubItem;
    NetzwerkRibbonSub: TdxBarSubItem;
    dxBarManager1Bar3: TdxBar;
    ErweitertRibbonGroup: TdxBar;
    DeutschRibbonBtn: TdxBarButton;
    EnglishRibbonBtn: TdxBarButton;
    FrancaisRibbonBtn: TdxBarButton;
    ErweiterteEinstellungenRibbonBtn: TdxBarLargeButton;
    AnsichtRibbonGroup: TdxBar;
    dxBarSubItem1: TdxBarSubItem;
    MonitorRibbonGroup: TdxBar;
    MonitorStandbyRibbonBtn: TdxBarButton;
    MonitorOffRibbonBtn: TdxBarButton;
    MonitorOnRibbonBtn: TdxBarButton;
    OnlineRibbonGroup: TdxBar;
    WebsitesRibbonSub: TdxBarSubItem;
    pcdimmerforumRibbonBtn: TdxBarButton;
    pcdimmerhomeRibbonBtn: TdxBarButton;
    SonstigesRibbonGroup: TdxBar;
    TippsRibbonBtn: TdxBarLargeButton;
    EinleitungRibbonBtn: TdxBarLargeButton;
    StartparamsRibbonBtn: TdxBarButton;
    GPLRibbonBtn: TdxBarButton;
    ChangeLogRibbonBtn: TdxBarButton;
    InfoRibbonBtn: TdxBarLargeButton;
    FaderpanelRibbonBtn: TdxBarButton;
    SubmasterRibbonBtn: TdxBarButton;
    MasterRibbonBtn: TdxBarButton;
    ZugriffRibbonGroup: TdxBar;
    LockPCdimmerRibbonBtn: TdxBarLargeButton;
    DebugRibbonBtn: TdxBarButton;
    ProtokollRibbonBtn: TdxBarButton;
    dxBarManager1Bar4: TdxBar;
    RefreshPluginsRibbonBtn: TdxBarLargeButton;
    dxRibbonStatusBar1Container3: TdxStatusBarContainerControl;
    dxRibbonStatusBar1Container5: TdxStatusBarContainerControl;
    statusbar_imagegreen: TImage;
    statusbar_imageyellow: TImage;
    statusbar_imagered: TImage;
    BlenddownRibbonBtn: TdxBarButton;
    BlackoutRibbonBtn: TdxBarButton;
    OutputOffRibbonBtn: TdxBarButton;
    StopRibbonBtn: TdxBarButton;
    Panel1: TPanel;
    PageControl1: TPageControl;
    TabSheet1: TTabSheet;
    TabSheet2: TTabSheet;
    TabSheet3: TTabSheet;
    Bevel3: TBevel;
    Bevel2: TBevel;
    Label13: TLabel;
    Label11: TLabel;
    CheckBox1: TCheckBox;
    CheckBox2: TCheckBox;
    CheckBox5: TCheckBox;
    Button1: TButton;
    BankSelect: TComboBox;
    BankCopy: TComboBox;
    AddBtn: TPngBitBtn;
    ChangeBtn: TPngBitBtn;
    DeleteBtn: TPngBitBtn;
    CheckBox3: TCheckBox;
    Button2: TButton;
    Label23: TLabel;
    TrackBar1: TTrackBar;
    Button6: TButton;
    colorbox1: TJvOfficeColorPanel;
    Label1: TLabel;
    Label2: TLabel;
    Label6: TLabel;
    Label7: TLabel;
    WidthTrackbar: TTrackBar;
    Label5: TLabel;
    TrackBar2: TTrackBar;
    Label3: TLabel;
    buttonname: TEdit;
    Label4: TLabel;
    buttonfarbe: TJvColorButton;
    Label8: TLabel;
    ComboBox1: TComboBox;
    buttonglyphbtn: TPngBitBtn;
    Label9: TLabel;
    Label10: TLabel;
    zeilen: TJvSpinEdit;
    spalten: TJvSpinEdit;
    Label12: TLabel;
    Label14: TLabel;
    btnwidth: TJvSpinEdit;
    btnheight: TJvSpinEdit;
    PngBitBtn2: TPngBitBtn;
    PngBitBtn1: TPngBitBtn;
    PngBitBtn3: TPngBitBtn;
    szenebearbeiten: TPngBitBtn;
    dxBarButton4: TdxBarButton;
    dxBarButton5: TdxBarButton;
    PowerRibbonBtn: TdxBarButton;
    cxStyleRepository1: TcxStyleRepository;
    cxStyle1: TcxStyle;
    dxBarManager1Bar5: TdxBar;
    MinimizeRibbonBtn: TdxBarLargeButton;
    ResetWindowsRibbonBtn: TdxBarButton;
    SaveWindowsRibbonBtn: TdxBarButton;
    dxBarManager1Bar6: TdxBar;
    dxRibbonStatusBar1Container8: TdxStatusBarContainerControl;
    AutosaveProgress: TProgressBar;
    accupercent: TLabel;
    acculevel2: TIAeverProgressBar;
    Panel2: TPanel;
    FaderpanelhideTimer: TTimer;
    Image1: TImage;
    Image2: TImage;
    Image3: TImage;
    ScrollBar2: TScrollBar;
    Panel3: TPanel;
    PaintBox1: TPaintBox;
    MainformScreenRefreshTimer: TTimer;
    ScrollBar1: TScrollBar;
    Panel4: TPanel;
    Panel5: TPanel;
    Panel6: TPanel;
    SmallWindowRibbonBtn: TdxBarLargeButton;
    debuglistbox: TListBox;
    mainpanel: TPanel;
    Image4: TImage;
    Shape4: TShape;
    PaintBox2: TPaintBox;
    ActiveJoystickRibbonBox: TdxBarButton;
    DataInActiveRibbonBox: TdxBarButton;
    MIDIActiveRibbonBox: TdxBarButton;
    ActivatePDAServerRibbonBtn: TdxBarButton;
    ActivateCommandReceiverRibbonBox: TdxBarButton;
    MCTRibbonBox: TdxBarButton;
    SidebarRibbonBtn: TdxBarButton;
    LeistungssteuerungRibbonBtn: TdxBarButton;
    commandedit: TEdit;
    Image5: TImage;
    Image6: TImage;
    Image7: TImage;
    dxBarLargeButton2: TdxBarLargeButton;
    dxBarLargeButton3: TdxBarLargeButton;
    dxBarSubItem2: TdxBarSubItem;
    NetherlandsRibbonBtn: TdxBarButton;
    dxBarSubItem3: TdxBarSubItem;
    Image8: TImage;
    Image9: TImage;
    Image10: TImage;
    dxBarButton22: TdxBarButton;
    dxBarButton23: TdxBarButton;
    SidebarselectRibbonBtn: TdxBarButton;
    FaderpanelPopupMenu1: TPopupMenu;
    NurKanlemitGertenanzeigen1: TMenuItem;
    Panelautomatischausblenden1: TMenuItem;
    Kstchenimmervoll1: TMenuItem;
    GoboPictures: TPngImageCollection;
    CheckBox4: TCheckBox;
    ComboBox2: TComboBox;
    Button4: TButton;
    MediaCenterTimecodeSocket: TUdpSockUtil;
    SpecialRibbon: TdxRibbonTab;
    dxBarManager1Bar7: TdxBar;
    AmbilightRibbonBtn: TdxBarLargeButton;
    PartyMuckenModulRibbonBtn: TdxBarLargeButton;
    dxBarManager1Bar8: TdxBar;
    dxBarLargeButton4: TdxBarLargeButton;
    DDFAssistantRibbonBtn: TdxBarLargeButton;
    DDFCreatorRibbonGroup: TdxBar;
    dxBarLargeButton5: TdxBarLargeButton;
    dxBarButton24: TdxBarButton;
    dxBarButton25: TdxBarButton;
    dxBarButton26: TdxBarButton;
    dxBarButton27: TdxBarButton;
    dxBarGroup1: TdxBarGroup;
    dxBarButton28: TdxBarButton;
    dxBarButton29: TdxBarButton;
    dxBarSeparator1: TdxBarSeparator;
    dxBarSeparator2: TdxBarSeparator;
    ShortCutChecker: TSVATimer;
    AutoFader: TSVATimer;
    BewegungsszenenTimer: TSVATimer;
    Optotimer: TSVATimer;
    VistaAltFix21: TVistaAltFix2;
    BrightnessEditRibbon: TdxBarEdit;
    dxBarApplicationMenu1: TdxBarApplicationMenu;
    dxRibbonStatusBar1Container9: TdxStatusBarContainerControl;
    dxBarPopupMenu1: TdxBarPopupMenu;
    StopVisualizer: TdxBarButton;
    dxBarButton2: TdxBarButton;
    dxBarButton6: TdxBarButton;
    NodeControlRibbonBtn: TdxBarLargeButton;
    OnlineUpdateRibbonBtn: TdxBarLargeButton;
    CheckBox6: TCheckBox;
    Label16: TLabel;
    PluginDemoRibbonBtn: TdxBarLargeButton;
    dxBarLargeButton6: TdxBarLargeButton;
    dxBarLargeButton7: TdxBarLargeButton;
    HTTPServerActivateRibbonBox: TdxBarButton;
    dxBarSubItem4: TdxBarSubItem;
    dxBarButton7: TdxBarButton;
    dxBarLargeButton8: TdxBarLargeButton;
    TrackBar3: TTrackBar;
    Label15: TLabel;
    dxBarLargeButton9: TdxBarLargeButton;
    dxBarLargeButton10: TdxBarLargeButton;
    RibbonButtonPNGList: TPngImageList;
    mqtt: TIcsMQTTClient;
    MQTTClientActivateRibbonBox: TdxBarButton;
    procedure FormCreate(Sender: TObject);
    procedure Exit1Click(Sender: TObject);
    procedure DefaultSettings1Click(Sender: TObject);
    procedure About1Click(Sender: TObject);
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
    procedure PCDimmeranzeigen1Click(Sender: TObject);
    procedure ZuSystrayminimieren1Click(Sender: TObject);
    procedure Uhrzeit_TimerTimer(Sender: TObject);
    procedure pluginsaktualisieren(Sender: TObject);
    function AudioInBufferFilled(Buffer: PAnsiChar;
      var Size: Integer): Boolean;
    procedure input_number(var pos:integer; var s:string);
    procedure input_number_minus(var pos:integer; var s:string);
    procedure Optotimer_oldTimer(Sender: TObject);
    procedure GNULizenz1Click(Sender: TObject);
    procedure Changelog1Click(Sender: TObject);
    procedure Debugger1Click(Sender: TObject);
    procedure FormCloseQuery(Sender: TObject; var CanClose: Boolean);
    procedure poweroffswitch_on_offClick(Sender: TObject);
    procedure startmidiin(Sender: TObject);
    procedure startmidiout(Sender: TObject);
    procedure refreshmidi;
    procedure refreshdatain;
	  procedure stopmidi(Sender: TObject);
    procedure Optionen1Click(Sender: TObject);
    procedure ToolButton12Click(Sender: TObject);
    procedure brightness_barChange(Sender: TObject);
    procedure brightness_barContextPopup(Sender: TObject; MousePos: TPoint;
      var Handled: Boolean);
    procedure ToolButton1Click(Sender: TObject);
    procedure ToolButton4Click(Sender: TObject);
    procedure ToolButton3Click(Sender: TObject);
    procedure openhistory1Click(Sender: TObject);
    procedure Projektspeichern1Click(Sender: TObject);
    procedure BlackoutClick(Sender: TObject);
    procedure PCDIMMERForum1Click(Sender: TObject);
    procedure Homepage1Click(Sender: TObject);
    procedure Timer1Timer(Sender: TObject);
    procedure CompressProgress(Sender: TObject; Position, Total: Integer);
    procedure CompressDecompressingFile(Sender: TObject;
      const FileName: String; var WriteFile: Boolean);
    procedure CompressCompressingFile(Sender: TObject;
      const FileName: String);
    procedure CompressDecompressedFile(Sender: TObject;
      const FileName: String; const FileSize: Cardinal);
    procedure CompressCompressedFile(Sender: TObject;
      const FileName: String);
    procedure FWM_DropFiles(var Msg: TMessage); message WM_DROPFILES;
    procedure Startoptionen1Click(Sender: TObject);
    procedure Kanalnamendrucken1Click(Sender: TObject);
    procedure PowerButton1PowerbuttonPress(Sender: TObject);
    procedure Pluginsreaktivieren1Click(Sender: TObject);
    procedure Projektverwaltung1Click(Sender: TObject);
    procedure SendMSG(MSG:Byte; Data1, Data2:Variant);
    function CountFiles(const Path, FileType: string):Integer;
    procedure Schnellspeichern1Click(Sender: TObject);
    procedure MidiInput1MidiInput(Sender: TObject);
    procedure MIDIEinstellungen1Click(Sender: TObject);
    procedure FormShow(Sender: TObject);
    procedure Szenenverwaltung1Click(Sender: TObject);
    procedure Figureneditor1Click(Sender: TObject);

    procedure SetSceneTime(ID:TGUID; Zeit:integer);
    function IsSceneActive(ID:TGUID):boolean;
    function EditScene(ID:TGUID):String;
    function ChangeSceneWithLibrary(ID:TGUID):TGUID;
    procedure StartEinfacheSzene(ID: TGUID; NoFadetime, NoDelay:boolean; Fadetime:integer);
    procedure RestoreLastScene(fadezeit:integer);
    procedure StopEinfacheSzene(ID: TGUID);
    procedure StartAudioSzene(ID: TGUID);
    procedure StopAudioSzene(ID: TGUID);
    procedure StartBewegungsSzene(ID: TGUID);
    procedure StopBewegungsSzene(ID: TGUID);
    procedure StartKompositionsszene(ID: TGUID; NoFadetime, NoDelay:boolean; Fadetime:integer);
    procedure StopKompositionsszene(ID : TGUID);
    procedure StartEffekt(ID: TGUID);
    procedure StopEffekt(ID: TGUID);
    procedure StartEffektstep(ID: TGUID; Schrittnummer:Word);
    procedure Effektschaltvorgang(WelcherEffekt:Integer; Sender: TObject);
    procedure StartPreset(ID: TGUID);
    procedure StartPresetScene(ID: TGUID);
    procedure StartAutoszene(ID: TGUID; NoFadetime, NoDelay:boolean; Fadetime:integer);
    procedure StopAutoszene(ID: TGUID);
    procedure StartMediaCenterSzene(ID: TGUID);
    procedure StartDeviceScene(ID: TGUID; NoFadetime, NoDelay:boolean; Intensity:Byte; Fadetime:integer);
    procedure StartDeviceSceneBefehl(ID, Typ: TGUID; Value, Fadetime, Delay:Integer);
    function GetDeviceSceneChannelValue(ID: TGUID; Channel: integer):integer;
    procedure StopDeviceScene(ID: TGUID);
    procedure Kontrollpanel1Click(Sender: TObject);
    procedure Effektsequenzer1Click(Sender: TObject);
    procedure GlobaleTastenabfrage1Click(Sender: TObject);
    procedure Gertesteuerung2Click(Sender: TObject);
    procedure AppException(Sender: TObject; E: Exception);
    procedure Bhnenansicht1Click(Sender: TObject);
    procedure Submaster1Click(Sender: TObject);
    procedure Joysticksteuerung1Click(Sender: TObject);
    procedure DataInEinstellungenClick(Sender: TObject);
    procedure ippsundTricks1Click(Sender: TObject);
    procedure ResetWindowPositionsClick(Sender: TObject);
    procedure AutobackuptimerTimer(Sender: TObject);
    procedure LoadAutoBackupBtnClick(Sender: TObject);
    procedure AutoFaderTimer(Sender: TObject);
    procedure BewegungsszenenTimerTimer(Sender: TObject);
    procedure TBItem20Click(Sender: TObject);
    procedure TBItem13Click(Sender: TObject);
    procedure TBItem22Click(Sender: TObject);
    procedure TBItem23Click(Sender: TObject);
    procedure AkkuTimerTimer(Sender: TObject);
    procedure TBItem25Click(Sender: TObject);
    procedure ShortCutCheckerTimer(Sender: TObject);
    procedure TBItem27Click(Sender: TObject);
    procedure TBItem29Click(Sender: TObject);
    procedure TBItem31Click(Sender: TObject);
    procedure FormDeactivate(Sender: TObject);
    procedure FormActivate(Sender: TObject);
    procedure TBItem34Click(Sender: TObject);
    procedure SaveWindowPositions(Window:string);
    procedure TBItem35Click(Sender: TObject);
    procedure TBItem36Click(Sender: TObject);
    procedure TBItem37Click(Sender: TObject);
    procedure TBItem39Click(Sender: TObject);
    procedure MidiCallbackTimerTimer(Sender: TObject);
    procedure TBItem41Click(Sender: TObject);
    procedure TBItem43Click(Sender: TObject);
    procedure TBItem46Click(Sender: TObject);
    procedure TBItem48Click(Sender: TObject);
    procedure TBItem50Click(Sender: TObject);
    procedure TBItem51Click(Sender: TObject);
    procedure TBItem52Click(Sender: TObject);
    procedure CompressCompletedAction(Sender: TObject);
    procedure TBItem53Click(Sender: TObject);
    procedure WriteSettingsToRegistry;
    procedure WriteConfiguration;
    procedure ReadConfiguration;
    procedure TBItem54Click(Sender: TObject);
    procedure TBItem56Click(Sender: TObject);
    procedure MediaCenterSocketRead(Sender: TObject;
      Socket: TCustomWinSocket);
    procedure MediaCenterSocketError(Sender: TObject;
      Socket: TCustomWinSocket; ErrorEvent: TErrorEvent;
      var ErrorCode: Integer);
    procedure commandeditoldEnter(Sender: TObject);
    procedure commandeditoldExit(Sender: TObject);
    procedure commandeditoldKeyUp(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure TBItem57Click(Sender: TObject);
    procedure TBItem59Click(Sender: TObject);
    procedure TBItem60Click(Sender: TObject);
    procedure TBItem61Click(Sender: TObject);
    procedure TBItem63Click(Sender: TObject);
    procedure TBItem62Click(Sender: TObject);
    procedure TBItem64Click(Sender: TObject);
    procedure TBItem17Click(Sender: TObject);
    procedure TBItem66Click(Sender: TObject);
    procedure TBItem67Click(Sender: TObject);
    procedure CommandservericonClick(Sender: TObject);
    procedure CommandServerException(AContext: TIdContext;
      AException: Exception);
    procedure CommandServerExecute(AContext: TIdContext);
    procedure ExecuteCommandServerCmd(cmd: string);
    procedure FormMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure TBItem68Click(Sender: TObject);
    procedure TBItem70Click(Sender: TObject);
    procedure dxBarApplicationMenu1ExtraPaneItemClick(Sender: TObject;
      AIndex: Integer);
    procedure BrightnessBarRibbonChange(Sender: TObject);
    procedure BlenddownRibbonBtnClick(Sender: TObject);
    procedure PaintBox1MouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure PaintBox1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure PaintBox1MouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure CheckBox1MouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure CheckBox2MouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure CheckBox2KeyUp(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure CheckBox1KeyUp(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure Button2Click(Sender: TObject);
    procedure Button1Click(Sender: TObject);
    procedure BankSelectSelect(Sender: TObject);
    procedure AddBtnClick(Sender: TObject);
    procedure ChangeBtnClick(Sender: TObject);
    procedure DeleteBtnClick(Sender: TObject);
    procedure BankCopySelect(Sender: TObject);
    procedure Button6Click(Sender: TObject);
    procedure TrackBar1Change(Sender: TObject);
    procedure FormResize(Sender: TObject);
    procedure WidthTrackbarChange(Sender: TObject);
    procedure ScrollBar1Enter(Sender: TObject);
    procedure ScrollBar1Scroll(Sender: TObject; ScrollCode: TScrollCode;
      var ScrollPos: Integer);
    procedure PaintBox1DblClick(Sender: TObject);
    procedure TrackBar2Change(Sender: TObject);
    procedure TrackBar2Enter(Sender: TObject);
    procedure TrackBar2Exit(Sender: TObject);
    procedure PageControl1Change(Sender: TObject);
    procedure PngBitBtn2MouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure PngBitBtn1MouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure PngBitBtn3MouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure buttonnameEnter(Sender: TObject);
    procedure buttonnameKeyUp(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure ComboBox1Select(Sender: TObject);
    procedure buttonglyphbtnClick(Sender: TObject);
    procedure zeilenChange(Sender: TObject);
    procedure spaltenChange(Sender: TObject);
    procedure btnwidthChange(Sender: TObject);
    procedure buttonfarbeChange(Sender: TObject);
    procedure szenebearbeitenClick(Sender: TObject);
    procedure MinimizeRibbonBtnClick(Sender: TObject);
    procedure FaderpanelhideTimerTimer(Sender: TObject);
    procedure ScrollBar2Change(Sender: TObject);
    procedure MainformScreenRefreshTimerTimer(Sender: TObject);
    procedure ScrollBar2Enter(Sender: TObject);
    procedure SmallWindowRibbonBtnClick(Sender: TObject);
    procedure FormCanResize(Sender: TObject; var NewWidth,
      NewHeight: Integer; var Resize: Boolean);
    procedure dxRibbon1HelpButtonClick(Sender: TdxCustomRibbon);
    procedure NetherlandsRibbonBtnClick(Sender: TObject);
    procedure Image8MouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure dxBarButton22Click(Sender: TObject);
    procedure SidebarselectRibbonBtnClick(Sender: TObject);
    procedure NurKanlemitGertenanzeigen1Click(Sender: TObject);
    procedure Panelautomatischausblenden1Click(Sender: TObject);
    procedure Kstchenimmervoll1Click(Sender: TObject);
    procedure CheckBox4MouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure CheckBox4KeyUp(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure Button4Click(Sender: TObject);
    procedure ComboBox2Select(Sender: TObject);
    procedure MediaCenterTimecodeSocketReceive(Sender: TObject);
    procedure AmbilightRibbonBtnClick(Sender: TObject);
    procedure PartyMuckenModulRibbonBtnClick(Sender: TObject);
    procedure dxBarLargeButton4Click(Sender: TObject);
    procedure DDFAssistantRibbonBtnClick(Sender: TObject);
    procedure dxBarLargeButton5Click(Sender: TObject);
    procedure dxBarButton24Click(Sender: TObject);
    procedure dxBarButton25Click(Sender: TObject);
    procedure dxBarButton26Click(Sender: TObject);
    procedure dxBarButton29Click(Sender: TObject);
    procedure StopVisualizerClick(Sender: TObject);
    procedure dxBarButton2Click(Sender: TObject);
    procedure dxBarButton6Click(Sender: TObject);
    procedure NodeControlRibbonBtnClick(Sender: TObject);
    procedure OnlineUpdateRibbonBtnClick(Sender: TObject);
    procedure CheckBox6KeyUp(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure CheckBox6MouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure CheckBox5KeyUp(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure CheckBox5MouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure CheckBox3MouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure CheckBox3KeyUp(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure FormDragDrop(Sender, Source: TObject; X, Y: Integer);
    procedure dxBarLargeButton6Click(Sender: TObject);
    procedure dxBarLargeButton7Click(Sender: TObject);
    procedure HTTPServerActivateRibbonBoxClick(Sender: TObject);
    procedure dxBarButton7Click(Sender: TObject);
    procedure dxBarLargeButton8Click(Sender: TObject);
    procedure TrackBar3Change(Sender: TObject);
    procedure dxBarLargeButton9Click(Sender: TObject);
    procedure dxBarLargeButton10Click(Sender: TObject);
    procedure HidCtlDeviceCreateError(
      Controller: TJvHidDeviceController; PnPInfo: TJvHidPnPInfo;
      var Handled, RetryCreate: Boolean);
    procedure HidCtlDeviceChange(Sender: TObject);
    function HidCtlEnumerate(HidDev: TJvHidDevice;
      const Idx: Integer): Boolean;
    procedure HidCtlDeviceData(HidDev: TJvHidDevice; ReportID: Byte;
      const Data: Pointer; Size: Word);
    procedure MQTTClientActivateRibbonBoxClick(Sender: TObject);
  private
    { Private declarations }
    FirstStart:boolean;

    // Dinge für Faderpanel
    faderchannel:array of Word;
    mousey,mouseoverfader,maxfaders:integer;
    faderselected,faderselectedalt,faderselectedshift:array of boolean;
    abletomove:boolean;
    GedrehteSchrift:HGDIOBJ;
    faderpanelup:boolean;
    faderpaneltimerbyte:byte;
    DimmerkernelChanges,DimmerkernelChangesPerSecond:Cardinal;
    scrolltoleft, scrolltoright:boolean;
    MIDIInPackets, MIDIOutPackets, DataInPackets, DMXOutPackets:integer;
    MIDIInPacketsFreq, MIDIOutPacketsFreq, DataInPacketsFreq, DMXOutPacketsFreq:integer;

    // Dinge für Bühnenansicht
    CurrentMousePositionX, CurrentMousePositionY:integer;
    CurrentMouseMoveShiftState:TShiftState;
    HandleMouseMove:boolean;

    // Dinge für Kanalübersicht
    oldvaluesChannelview:array[1..8192] of byte;
    ChannelWidth,ChannelHeight:integer;
    ErsteZeile:integer;
    mouseychannel:integer;
    AktuellerKanal:integer;
    SelektierteKanaele:array[1..chan] of boolean;
    MouseOverKanal:integer;
    ChannelValueOnClick:integer;
    lastposition:integer;
    TrackBarSelected:boolean;
    lastx,lasty:integer;
    scrollbarpositiononmousedown:integer;

    historyribbonitem:TdxBarExtraPaneItem;
    mainpriority:integer;
    channelvalue_blackout,channelvalue_blackoutR,channelvalue_blackoutG,channelvalue_blackoutB,channelvalue_blackoutC,channelvalue_blackoutM,channelvalue_blackoutY,channelvalue_blackoutA,channelvalue_blackoutW,channelvalue_blackoutUV:array of integer;
    dontstartaccu:boolean;
    LastSessionWasCorrupt:boolean;
    RestoreLastValues:boolean;
    Autobackupcountermax:cardinal;
    Counter:integer;
    Autobackupcounter:cardinal;
    firststartaftercreate:boolean;
    saveonclosing:boolean;
    FirstStartofStageview:boolean;
    showakkuwarnings:boolean;
    akkuwarningmessageshownext:integer;
    flashscrolllockled:boolean;
    netzbetrieb:boolean;
    beat_next:boolean;
    fadesplash:boolean;
    fastsaved:boolean;
    autoload_project_file:string;
    LastEvent:string;
    commandline_changechannel:array[1..chan] of bool;
    LastMidiClock:Int64;
    LastMidiTempo:extended;
    LastMidiMMR:byte;
    MidiClockValues:array[1..5] of Extended;
    MidiClockCounter,MidiClockTickCounter:integer;
    TerminalSystem:TTerminalSystem;
    terminalport, mediacenterport:integer;
    RefreshValuesOfSelectedDevicesByMIDI:boolean;

    // Globale Animationstimerdeklaration
    channelvalue_temp:array[1..chan] of integer;

    // WORKAROUND FOR MEVP
    // Funktionsprototypen für 3D Visualizer
    DasMevAreFixturesModified : function(Reset:boolean):boolean;cdecl;
    DasMevClose : function:boolean;cdecl;
    DasMevCommand : function(iType:integer; iParam:integer):integer;cdecl;
    DasMevGetFixtureParam : function(iIndex:integer; iDmxAddress:Pointer; iDmxUniverse:Pointer; iNbChannels:Pointer; sName:PChar; fPosX, fPosY, fPosZ, fRotX, fRotY, fRotZ:Pointer):boolean;cdecl;
    DasMevGetFixturesCount : function:integer;cdecl;
    DasMevGetLanguage : function:integer;cdecl;
    DasMevGetSupportedDeviceTypes : function: integer;cdecl;
    DasMevGetVersion : function : integer;cdecl;
    DasMevIsOpened : function : integer;cdecl;
    DasMevIsUsingDasHard : function : boolean;cdecl;
    DasMevSetLanguage : function(Language:integer) : boolean;cdecl;
    DasMevSetSupportedDeviceTypes : function(Types:integer):boolean;cdecl;
    DasMevStart : function(sController:PChar; sPassWrd:PChar):boolean;cdecl;
    DasMevWriteDmx : function(iUniverse:integer; DmxArray:Pointer):integer;cdecl;
    // END OF WORKAROUND FOR MEVP

    procedure NewProject(PreserveValues:boolean=false);
    function Saveproject(savewithoutprompt,fastsave, Autosave:boolean):boolean;
    function Openproject(openfile:string; OnlyProject:boolean):boolean;
    function pcdimmerreset(Sender: TObject):boolean;
    function FilterWithDimmcurve(channel:Word; value:byte):byte;
    procedure ConvertBefehlToBefehl2;
    procedure ConvertMidiToMidi2;
    procedure ConvertDataInToDataIn2;
    procedure ConvertJoystickToJoystick2;
    procedure ConvertHotkeysToHotkeys2;
    procedure GetAccuLevel;
    procedure CreateValueBackup;
    procedure RestoreValueBackup;
    procedure DrawFaderpanel(DrawCanvas: TCanvas; X1, Y1, X2, Y2:integer);
    procedure SplashSwitchinfo(Text:string);
    procedure SplashCaptioninfo(Text:string);
    procedure SplashVersioninfo(Text:string);
    procedure RetranslateProgram(language: string);
    function FilterTextForNetwork(Text: string):string;

    procedure DebugAdd(Text: string; Save: boolean = true; InitText: boolean = true);
    procedure DebugAddToLine(Text: string; Save: boolean = true);
  public
    { Public declarations }
    FHTTPServer: TPCDHTTPServer;
    currentprojectversion:integer;
    BeatTime, BeatInterval:integer;
    BeatEnabled:boolean;
    StartupFinished:boolean;
    BeginValueBackups:boolean;
    smallwindowstyle:boolean;

    ScannerSyncTempArray:array[0..16] of TScannerCalibration;
    ScannerSyncTempArrayBackup:array[0..16] of TScannerCalibration;

    _MainformBuffer,_MainformPreBuffer: TBitmap32;
    RefreshMainformScreen:boolean;

    plugin_blacklist, plugin_blacklist_new:string;
    splashscreenvalue:integer;
    UseBilinearInterpolation:boolean;
    MBS_Online:boolean;
    MBS_MSGon,MBS_MSGoff:byte;
    MBS_Data1on,MBS_Data1off:byte;
    MBS_Data2on,MBS_Data2off:byte;
    SelektierteGeraete:array of integer;
    UseGroupForValue2Midi:boolean;
    lastmidiinputdevices:string;
    lastmidioutputdevices:string;
    UseMidiBackTrack:boolean;
    UseControl7ForLevel:boolean;
    UseMIDIThru:boolean;
    LastMIDINote:array[1..16] of Byte;
    LastMIDIController:array[1..16] of Byte;
		MidiInControls: array of Pointer;
		MidiInTimeCode: array of TMidiTimecode;
		MidiOutControls: array of Pointer;
    LastMidiMSG, LastMidiData1, LastMidiData2: Byte;
    LastDataInChannel:Word;
    LastDataInValue: Byte;
    DimmerkernelResolution, MinDimmerkernelResolution:Cardinal; // in ms 1/44Hz=22,72ms - oder Automatisch
    DimmerkernelResolutionAutoset:boolean;

    Rfr_Main, Rfr_AEP, Rfr_Buehnenansicht, Rfr_Cuelist, Rfr_Faderpanel,
    Rfr_Kanaluebersicht, Rfr_Kontrollpanel, Rfr_KontrollpanelCheckForActive,
    Rfr_Submaster: Byte;

    CDPlayerDrives, CDPlayerTracks:TStrings;

    windowsmajorversion,windowsminorversion,windowsbuildnumber:byte;
    ShowIconInTaskSwitcher:boolean;
    ShowButtonInTaskbar:boolean;
    CPUCount:cardinal;
    lastbeatsource:byte;
    blendoutforms:boolean;
    blendvalue:byte;
    kanalsetzmodus:byte;
    skripttimer_todo:integer;
    skripttimer_offline:boolean;
    NextMovingSceneStep:boolean;
    IsBlackoutMode,IsFreezeMode:boolean;
    waveformdata_record : TWaveformdata;
    akkulevel:integer;
    projekttitel,projektversion,projektbearbeiter,projektprogrammversion,projektdatum,projektuhrzeit,projektspeicheranzahl:string[255];
    projektprogrammversionint:integer;
    autoinsertcomputerusername:boolean;
    pcdimmerresetting:boolean;
    maxautobackupfiles:integer;
    animationtimer:integer;
    UseAutoAmberCalculation:boolean;
    ddfsource:byte; // 0: geraetesteuerung, 1: ddfwindow
    _killthreads : boolean;
    _killaccu : boolean;
    _killscan : boolean;
    _killanimation : boolean;
    _KillAudioeffektVisualizer:boolean;
    _KillBuehnenansicht:boolean;
    Longitude, Latitude: double;
    DeviceChannelNames:array of string;
//    MaximumChan:Cardinal;
    ActualLanguage:string;
    Mevp: TPCDMevp;
    errorhandlingmode:integer;
    effekttimeline_isplaying:boolean;
    QuitWithoutConfirmation:boolean;
    CheckUpdatesOnStartup: boolean;
    killsplash:boolean;
    OutputPlugins: array of TOutputPlugin;
    ProgramPlugins: array of TProgramPlugin;
// Dimmerkernel-Variablen deklarieren
    data_in_channels:array[1..chan] of byte;
    channel_endvalue:array[1..chan] of byte;
    channel_value:array[1..chan] of byte;
    channel_value_highresolution:array[1..chan] of Single; // auf 7-8 Stellen genau - sollte hier reichen ;-)
    channel_value_highresolution_filtered: Single; // auf 7-8 Stellen genau - sollte hier reichen ;-)
    channel_minvalue:array[1..chan] of byte;
    channel_maxvalue:array[1..chan] of byte;
    channel_dimmcurve:array[1..chan] of byte;
    channel_absolutedimmcurve:array[1..chan] of byte;
    changedchannels:array[1..chan] of boolean;
    DimmerKernelChannelArray:Array of Pointer;
    pDimmerChannel,pDimmerKernelChannel,pDimmerKernelChannel2:^tDimmerKernelChannel;
//    MeasureKernelLaufzeit:boolean;
    KernelLaufzeit:Double;

    FileStream:TFileStream;
    data: Tdata;
    project_file : String;
    project_folder : String;
    AudioMin, AudioMax : Integer;
    AudioTempMax : Integer;
    pcdimmerdirectory, userdirectory:string;
    datanames:string[255];
    SzenenablaufArray : array of array of TGUID;
    shutdown:boolean;
    showtipofday:boolean;
    showfirststeps:boolean;
    EnableHotKeys:boolean;
    EnableJoystick:boolean;
    usepowermanagement:boolean;
    startingup:boolean;
    Befehlssystem:array of TBefehlssystem;

 	  osversion:string;
    recordchannelvalue: array[1..chan] of Integer;
	  showlastplugins:boolean;
    levelanzeigeoptionen:integer;
    startupwitholdscene:boolean;
    switchofflightsatshutdown:boolean;
    autolocktime:byte;
    autolocktimecounter:integer;
    autolockcode:string[255];
    autolockcodescrambled:string[255];
    autologouttime:byte;
    autologouttimecounter:integer;
    httppasswordscrambled:string[255];
    mqttpasswordscrambled:string[255];
    dontloadproject,gotosystray:boolean;
    askforsaveproject:boolean;
    powerswitchoff:boolean;
    lastchan:integer;
    sounddevicespeakers:integer;
    sounddevice:integer;
		deactivateoutputdllsonclose:boolean;
		deactivateinputdllsonclose:boolean;
    filesinprojectdirectory:integer;
		MidiEventArray : array of TMIDIEventArray;//array[1..7] of Byte;
    SendValueOfSelectedDevicesToMidi: array of TSendValueOfSelectedDevicesToMidi;

		DataInEventArray : array of TDataInEventArray;//array[1..7] of Byte;

    // Arrays
    Figuren : array of TFigur;
    Effekttimeline : array of TTimeline;
    AblaufTimer: array of TAblaufTimer;
    AktuellerTimer : TAblaufTimer;
    Effektaudio_record : array of TEffektaudio;
    Effektaudiodatei_record : TEffektaudiodatei;
    Submasterfader:array of TSubmasterfader;
    Submasterbank:array of TSubmasterbank;
    DeviceChannelSelection:array of TDeviceChannelSelection;
    Cuelistbank:array of TCuelistbank;
    TimeCodePlayerBank:array of TTimeCodePlayer;
    IREvent:array of TIREvent;
    XTouchPCDDevicesOrGroups:array of TXTouchPCDDeviceOrGroup;
    XTouchDevices:array of TXTouch;
    XTouchBefehle:array of array[0..17] of TBefehl2; // 8x Fader, Masterfader, 8x Dials, JogDial 
    ElgatoStreamDeckArray:array of TElgatoStreamDeck;
    ElgatoStreamSerials:array of string;
    // Szenenbibliothek
    EinfacheSzenen : array of TEinfacheSzene;
    DeviceScenes: array of TDeviceScene;
    AktuelleDeviceScene: TDeviceScene;
    Bewegungsszenen : array of TBewegungsszene;
    BewegungsszenenZeit : array of array of array of Cardinal;
    BewegungsszenenAktiv : array of TBewegungsszeneAktiv;
    AktuelleBewegungsszene : TBewegungsszene;
    AudioszeneOld: TAudioszeneOld;
    Audioszenen : array of TAudioszene;
    AudioszenenCHAN : array of TAudioszeneCHAN;
    OldBefehle : array of TBefehl;
    Befehle2 : array of TBefehl2;
    Kompositionsszenen : array of TKompositionsszene;
    buehnenansichtdevices : array of TBuehnenansichtDevice;
    buehnenansichtsetup : TBuehnenansicht;
    buehnenansicht_background: array of string[255];
    ambilights:array of array of TGUID;
    pmmlights:array of TGUID;
    PartyMuckenModul:array of TPartyMuckenModul;
    PresetScenes: array of TPresetScene;
    CodeScenes: array of TCodeScene;
    GlobalVariables: array of Variant;
    NodeControlSets: array of TNodeControlSet;
    UserAccounts: array of TUserAccount;
    CurrentUser, StartupUser: String;
    CurrentUserAccessLevel: Integer;

//    DeviceForms:array of Tdeviceformprototyp;
    Desktopproperties : array[1..9] of TDesktopproperties;
    JoystickEvents:array[0..43] of TJoystickEvent;
    OldJoystickEvents:array[0..43] of TOldJoystickEvent;
    kontrollpanelrecord:Tkontrollpanelrecord;
    kontrollpanelbuttons:array of array of Tkontrollpanelbutton;
    leistungsdaten:TLeistungsdaten;
    programmfunktionen:array of string;

    FogTimer : TFogTimer;

    OldTastencodeArray : array of TOldTastencode;
    TastencodeArray : array of TTastencode;
    TastencodePressedArray : array of boolean;

    // Geräte
    Devices : array of TDevice;
    DeviceSelected : array of boolean;
    DeviceSelectedIDs : array of array of TGUID;
    DeviceSelectedIDsName : array of String[255];
    DevicePresets : array of TDevicePreset;
    DeviceGroups : array of TDeviceGroup;
    Autoszenen : array of TAutoszene;
    AktuelleAutoszene : TAutoszene;
    MediaCenterSzenen : array of TMediaCenterScene;
    AktuelleMediaCenterSzene: TMediaCenterScene;
    PluginSzenen : array of TPluginScene;
    FFTDataIn : array[0..31] of TFFTDataIn;
    BeatImpuls:TBeatImpuls;
    Softpatch : array of TSoftpatch;
    Softpatch2 : array of TSoftpatch2;
    Effektsequenzereffekte : array of TEffektsequenzereffekt;
    AktuellerEffekt: array of TRunningEffekt;
    EffektsequenzerTabs:array of string[255];

    accuThread: TAccuThread;
    HelperThread: THelperThread;
    HidCtl:TJvHidDeviceController;

    // WORKAROUND FOR MEVP
    MEVPDLL:THandle;
    MEVPDLLDMXARRAY0,MEVPDLLDMXARRAY1,MEVPDLLDMXARRAY2,MEVPDLLDMXARRAY3:array[0..511] of byte;
    // END OF WORKAROUND FOR MEVP

    procedure AddToOpenHistory(FileName: string);
    function SetThreadAffinityMaskByID(ID, AffinityMask: Cardinal): Boolean;

    procedure StartScene(ID:TGUID; NoFadetime, NoDelay:boolean);overload;
    procedure StartScene(ID:TGUID; NoFadetime, NoDelay:boolean; Fadetime:integer);overload;
    procedure StartScene(ID:TGUID; NoFadetime, NoDelay:boolean; Intensity:Byte; Fadetime:integer);overload;
    procedure StartScene(ID:TGUID; Fadetime:integer);overload;
    procedure StartScene(ID:TGUID);overload;
    procedure StartSceneWithoutRecord(ID:TGUID; NoFadetime, NoDelay:boolean; Intensity:Byte; Fadetime:integer);overload;
    procedure StopScene(ID:TGUID);overload;
    procedure StopSceneWithoutRecord(ID:TGUID);overload;
    procedure BlackoutDeviceScene(ID:TGUID; Fadetime:integer);
    function DoesSceneExists(ID:TGUID):boolean;
    procedure StopAllEffects;
    procedure InitCodeScene(ID: TGUID);
    procedure ExecuteCodeScene(ID: TGUID; Command: String);

    procedure StartBefehl(ID: TGUID); overload;
    procedure StartBefehl(ID: TGUID; Inputvalue: integer); overload;
    procedure StartBefehl(AktuellerBefehl:TBefehl2; Inputvalue: integer; Source:String); overload;
  	procedure GetBefehlState(AktuellerBefehl:TBefehl2; var Text_PCD_Function:string; var Text_Function:string; var Text_Value:string; var Value:integer);

    procedure ErrorPop(str: string);
    procedure Senddata(address, startvalue, endvalue, fadetime:integer);overload;
    procedure Senddata(address, startvalue, endvalue, fadetime:integer; delay: integer);overload;
    function MyMessageDlg(const Msg: string; DlgType : TMsgDlgType;
      Buttons : TMsgDlgButtons; Captions: array of string) : Integer;
		function GetFileVersion(Const FileName:String):String;
		function GetFileVersionBuild(Const FileName:String):String;
    function GetDirSize(dir: string; subdir: Boolean): Longint;
		function DeleteFile(const AFile: string): boolean;
		function DeleteDir(Dir : String) : Boolean;
    procedure DeleteFiles(FilenameMask: String);
    function DeleteDirectory(ADirName: String): Boolean;
    function levelstr(pos:integer):string;
    function MillisecondsToTime(ms:Integer):String;
    function MillisecondsToTimeShort(ms:Integer):String;
    function GetFileSize2(const FileName: String): Int64;
    function FileSize2String(filesize: cardinal):string;
    procedure DeSelectAllDevices;
    procedure DeSelectDeviceGroup(ID: TGUID);
    procedure SelectDeviceGroup(ID: TGUID; KeepOldSelection: boolean);
    procedure DeviceSelectionChanged(Sender: TObject);
    procedure EffectsChanged;
    function SearchFileBeneathProject(filename: string):string;
    function FileSearch(Pathname, Filename:string; IncludeSubdirectories:boolean):string;
    procedure MidiBackTrack;
    procedure GetSceneInfo(ID: TGUID; var Name: string; var Beschreibung: string; var Blendzeit: string; var Typ:string);
    function GetSceneInfo2(ID: TGUID; InfoType:string):string;
    procedure SetSceneCategory(ID: TGUID; Cat:String);
    function GetSceneType(ID: TGUID):integer;
    procedure GetInfo(ID: TGUID; var Name: string);
    procedure OpenPCDIMMERFile(FileName: string);
    procedure SendMidi(MSG, Data1, Data2: byte);
    procedure GetMidi(MSG, Data1, Data2:byte);
    function RecordScene(RecordType: integer):TGUID;
    procedure LoadDDFPictures;
    procedure ExecuteBeat(Sender: TObject);
    procedure SplashAddText(Text:string);
    procedure RefreshSplashText;
    procedure SplashProgress(bar, position, max:integer);
    procedure ExecuteDataInEvent(address, endvalue:integer);
    procedure ResetBass;
    procedure ConvertBMPtoJPG(bmpSource, jpgDestination: string);
    procedure ConvertBMPtoPNG(bmpSource, pngDestination: string);
    procedure SavePng(Bitmap: TBitmap; Destination:string);
    procedure SaveJpg(Bitmap: TBitmap; Destination:string);
    procedure PluginRibbonBtnClick(Sender: TObject);
    function UserAccessGranted(Level: integer; ShowLoginWindow: boolean=true):boolean;
    function ChangeUser(ShowWarning:boolean=true; ChangeToUser: String=''; ChangeToAccessLevel: integer=4):boolean;
  end;

// Callbackfunktionen der Plugin-Dlls
procedure CallbackGetDLLValue(address,startvalue,endvalue,fadetime,delay:integer);stdcall;
procedure CallbackGetDLLValueEvent(address,endvalue:integer);stdcall;
procedure CallbackGetDLLName(address:integer; channelname:PChar);stdcall;
function CallbackSetDLLValue(address:integer):integer;stdcall;
procedure CallbackMessage(MSG:Byte; Data1, Data2: Variant);stdcall;

procedure LockWindow(const Handle: HWND);
procedure UnLockWindow(const Handle: HWND);

var
  MainForm : TMainform;

// Audioeffektplayer
  p: BASS_DX8_PARAMEQ;
  pChorus: BASS_DX8_CHORUS;
  pCompressor: BASS_DX8_COMPRESSOR;
  pDistortion: BASS_DX8_DISTORTION;
  pEcho:BASS_DX8_ECHO;
  pFlanger:BASS_DX8_FLANGER;
  pGargle:BASS_DX8_GARGLE;
  pI3DL2Reverb:BASS_DX8_I3DL2REVERB;
  pReverb: BASS_DX8_REVERB;
  fx: array[1..11] of array[0..3] of integer;
  eq: array[0..10] of array[0..3] of integer;

// Transparentes Hauptfenster
  FullRgn, ClientRgn, CtlRgn : THandle;
  seeking_effektaudio: Integer = -1;

implementation

uses
  kompositionsszeneeditorform, effektsequenzerfrm,
  geraetesteuerungfrm, exceptionfrm, submasterfrm, joystickfrm,
  tippofthedayfrm, ddfwindowfrm, devicescenefrm, autoszenefrm,
  preseteditorform, projekteigenschaftenfrm, ddfeditorfrm, accumessagefrm,
  ownmessagefrm, audioeffektplayerfrm,
  timecodeplayerfrm, schedulerfrm,
  videoscreenfrm, kanaluebersichtfrm, recoveryfrm, beatfrm,
  clockfrm, DimmerKernelQueue, textbuchfrm, scenenotfoundfrm,
  cuelistfrm, masterfrm, cdplayerfrm, reordergroupfrm, USBViewMain,
  splashscreen2frm, firststepsfrm, winlircfrm,
  mediacenterfrm, sidebarfrm, leistungssteuerungfrm2,
  geraeteremovedfrm, editskript, compileerrorfrm, lockedfrm, devicelistfrm,
  faderpanelfrm, picturechangefrm, sidebarselectfrm, adddevicetogroupfrm,
  addfunctionfrm, audioeffektplayerstretchfrm, codeeditorfrm,
  colormanagerfrm, devicechannelselectionfrm, devicepicturechangefrm,
  devicepowerfrm, dimmcurvefrm, effekttimelinefrm, joysticksetupfrm,
  lauflichtassistentfrm, lauflichtassistentownpatternfrm, matrixeditorfrm,
  layerbezeichnungenfrm, scannersynchronisationfrm,
  videoscreensynchronisierenfrm, ambilight, pmm, touchscreenfrm,
  ddfeditorassistant, dynguifrm, audiomanagerfrm, ProgressScreenSmallFrm,
  presetsceneeditorform, adddevicefrm, pcdUtils, pcdRegistry,
  nodecontrolfrm, usermgmtfrm, changeuserfrm, xtouchcontrolfrm,
  elgatostreamdeckfrm;

{$R *.DFM}

function OpenThread(dwDesiredAccess: DWord;
                    bInheritHandle: Bool;
                    dwThreadId: DWord): DWord; stdcall; external 'kernel32.dll';

{------------------------------------------------------------------------------}
{  Author   : mr Serhiy Perevoznyk                                             }
{  Email    : serge_perevoznyk@hotmail.com                                     }
{  Homepage : http://users.chello.be/ws36637/                                  }
{------------------------------------------------------------------------------}

function PropertyPIDToCaption(const ePID: Cardinal): string;
begin
  case ePID of
    PID_TITLE:
      Result := 'Title';
    PID_SUBJECT:
      Result := 'Subject';
    PID_AUTHOR:
      Result := 'Author';
    PID_KEYWORDS:
      Result := 'Keywords';
    PID_COMMENTS:
      Result := 'Comments';
    PID_TEMPLATE:
      Result := 'Template';
    PID_LASTAUTHOR:
      Result := 'Last Saved By';
    PID_REVNUMBER:
      Result := 'Revision Number';
    PID_EDITTIME:
      Result := 'Total Editing Time';
    PID_LASTPRINTED:
      Result := 'Last Printed';
    PID_CREATE_DTM:
      Result := 'Create Time/Date';
    PID_LASTSAVE_DTM:
      Result := 'Last Saved Time/Date';
    PID_PAGECOUNT:
      Result := 'Number of Pages';
    PID_WORDCOUNT:
      Result := 'Number of Words';
    PID_CHARCOUNT:
      Result := 'Number of Characters';
    PID_THUMBNAIL:
      Result := 'Thumbnail';
    PID_APPNAME:
      Result := 'Creating Application';
    PID_SECURITY:
      Result := 'Security';
  else
    Result := Format('%X', [ePID]);
  end
end;

{------------------------------------------------------------------------------}
{  Author   : mr Serhiy Perevoznyk                                             }
{  Email    : serge_perevoznyk@hotmail.com                                     }
{  Homepage : http://users.chello.be/ws36637/                                  }
{------------------------------------------------------------------------------}

function GetFileSummaryInfo(const FileName: WideString): WideString;

var
  I: Integer;
  PropSetStg: IPropertySetStorage;
  PropSpec: array of TPropSpec;
  PropStg: IPropertyStorage;
  PropVariant: array of TPropVariant;
  Rslt: HResult;
  S: Widestring;
  Stg: IStorage;
  PropEnum: IEnumSTATPROPSTG;
  HR: HResult;
  PropStat: STATPROPSTG;
  k: integer;

begin
  Result := '';
  try
    OleCheck(StgOpenStorageEx(PWideChar(FileName), STGM_READ or
      STGM_SHARE_DENY_WRITE, STGFMT_FILE, 0, nil, nil, @IID_IPropertySetStorage,
      stg));

    PropSetStg := Stg as IPropertySetStorage;

    OleCheck(PropSetStg.Open(FmtID_SummaryInformation, STGM_READ or
      STGM_SHARE_EXCLUSIVE, PropStg));

    OleCheck(PropStg.Enum(PropEnum));
    I := 0;

    hr := PropEnum.Next(1, PropStat, nil);
    while hr = S_OK do
    begin
      inc(I);
      SetLength(PropSpec, I);
      PropSpec[i - 1].ulKind := PRSPEC_PROPID;
      PropSpec[i - 1].propid := PropStat.propid;
      hr := PropEnum.Next(1, PropStat, nil);
    end;

    SetLength(PropVariant, i);
    Rslt := PropStg.ReadMultiple(i, @PropSpec[0], @PropVariant[0]);

    if Rslt = S_FALSE then
      Exit;

    for k := 0 to i - 1 do
    begin
      S := '';
      if PropVariant[k].vt = VT_LPWSTR then
      begin
        if Assigned(PropVariant[k].pwszVal) then
        begin
          S := PropVariant[k].pwszVal;
          if PropSpec[k].propid = PID_COMMENTS then
            Result := S;
        end;
      end;
    end;
  finally
  end;
end;

{------------------------------------------------------------------------------}
{  Author   : mr Serhiy Perevoznyk                                             }
{  Email    : serge_perevoznyk@hotmail.com                                     }
{  Homepage : http://users.chello.be/ws36637/                                  }
{------------------------------------------------------------------------------}

{
function SetFileSummaryInfo(const FileName: WideString; PID_InfoType: Cardinal;
  InfoStr: string): DWORD;
var
  PropSetStg: IPropertySetStorage;
  PropSpec: array of TPropSpec;
  PropStg: IPropertyStorage;
  PropVariant: array of TPropVariant;
  Stg: IStorage;
  Author, Title, Subject, Keywords, Comments: string;
begin
  SetLastError(0);
  Author := '';
  Title := '';
  Subject := '';
  Keywords := '';
  Comments := '';
  OleCheck(StgOpenStorageEx(PWideChar(FileName),
    STGM_SHARE_EXCLUSIVE or STGM_READWRITE,
    STGFMT_ANY,
    0, nil, nil, @IID_IPropertySetStorage, stg));

  PropSetStg := Stg as IPropertySetStorage;

  OleCheck(PropSetStg.Create(FmtID_SummaryInformation, FmtID_SummaryInformation,
    PROPSETFLAG_DEFAULT,
    STGM_CREATE or STGM_READWRITE or STGM_SHARE_EXCLUSIVE, PropStg));

  Setlength(PropSpec, 5);
  PropSpec[0].ulKind := PRSPEC_PROPID;
  PropSpec[0].propid := PID_AUTHOR;

  PropSpec[1].ulKind := PRSPEC_PROPID;
  PropSpec[1].propid := PID_TITLE;

  PropSpec[2].ulKind := PRSPEC_PROPID;
  PropSpec[2].propid := PID_SUBJECT;

  PropSpec[3].ulKind := PRSPEC_PROPID;
  PropSpec[3].propid := PID_KEYWORDS;

  PropSpec[4].ulKind := PRSPEC_PROPID;
  PropSpec[4].propid := PID_COMMENTS;

  SetLength(PropVariant, 5);
  case PID_InfoType of
    PID_AUTHOR: Author := PWideChar(WideString(InfoStr));
    PID_TITLE: Title := PWideChar(WideString(InfoStr));
    PID_SUBJECT: Subject := PWideChar(WideString(InfoStr));
    PID_KEYWORDS: Keywords := PWideChar(WideString(InfoStr));
    PID_COMMENTS: Comments := PWideChar(WideString(InfoStr));
  end;
  PropVariant[0].vt := VT_LPWSTR;
  PropVariant[0].pwszVal := PWideChar(WideString(Author));
  PropVariant[1].vt := VT_LPWSTR;
  PropVariant[1].pwszVal := PWideChar(WideString(Title));
  PropVariant[2].vt := VT_LPWSTR;
  PropVariant[2].pwszVal := PWideChar(WideString(Subject));
  PropVariant[3].vt := VT_LPWSTR;
  PropVariant[3].pwszVal := PWideChar(WideString(Keywords));
  PropVariant[4].vt := VT_LPWSTR;
  PropVariant[4].pwszVal := PWideChar(WideString(Comments));

  OleCheck(PropStg.WriteMultiple(5, @PropSpec[0], @PropVariant[0], 2));
  PropStg.Commit(STGC_DEFAULT);
  Result := GetLastError();
  if Result = 997 then
    Result := 0;
end;
}

function SetFileSummaryInfo(const FileName: WideString; GUID_InfoType: TGUID;
  PID_InfoType: Cardinal; InfoStr: WideString): boolean;
var
  PropSetStg  : IPropertySetStorage;
  PropSpec    : TPropSpec;
  hr          : HRESULT;
  PropStg     : IPropertyStorage;
  PropVariant : TPropVariant;
  Stg         : IStorage;
begin
  Result := false;

  if(StgOpenStorageEx(pwidechar(FileName),STGM_SHARE_EXCLUSIVE or
    STGM_READWRITE,STGFMT_ANY,0,nil,nil,@IID_IPropertySetStorage,stg) =
    S_OK) then
  begin
    PropSetStg := Stg as IPropertySetStorage;

    // try to open an existing Property set
    hr         := PropSetStg.Open(GUID_InfoType,STGM_READWRITE or
      STGM_SHARE_EXCLUSIVE,PropStg);

    // create a new set
    if(hr <> S_OK) then
      hr       := PropSetStg.Create(GUID_InfoType,GUID_InfoType,
        PROPSETFLAG_DEFAULT,STGM_CREATE or STGM_READWRITE or
        STGM_SHARE_EXCLUSIVE,PropStg);

    if(hr = S_OK) then
    begin
      PropSpec.ulKind     := PRSPEC_PROPID;
      PropSpec.propid     := PID_InfoType;
      PropVariant.vt      := VT_LPWSTR;
      PropVariant.pwszVal := PWideChar(InfoStr);

      if(PropStg.WriteMultiple(1,@PropSpec,@PropVariant,2) = S_OK) then
      begin
        Result := (PropStg.Commit(STGC_DEFAULT) = S_OK);
      end;
    end;
  end;
end;
// Ende Projektdateiinformationen

procedure SetLedState(KeyCode: TKeyType; bOn: Boolean);
var
  KBState: TKeyboardState;
  Code: Byte;
begin
  Code := VK_SCROLL;
  case KeyCode of
    ktScrollLock: Code := VK_SCROLL;
    ktCapsLock: Code := VK_CAPITAL;
    ktNumLock: Code := VK_NUMLOCK;
  end;
  GetKeyboardState(KBState);
  if (Win32Platform = VER_PLATFORM_WIN32_NT) then
  begin
    if Boolean(KBState[Code]) <> bOn then
    begin
      keybd_event(Code,
                  MapVirtualKey(Code, 0),
                  KEYEVENTF_EXTENDEDKEY,
                  0);

      keybd_event(Code,
                  MapVirtualKey(Code, 0),
                  KEYEVENTF_EXTENDEDKEY or KEYEVENTF_KEYUP,
                  0);
    end;
  end
  else
  begin
    KBState[Code] := Ord(bOn);
    SetKeyboardState(KBState);
  end;
end;

function TMainform.CountFiles(const Path, FileType: string):Integer;
var
  SearchRec: TSearchRec;
  p: string;
  anzahl:Integer;
begin
  anzahl:=0;
  p := path + FileType;
  if FindFirst(p, faAnyFile, SearchRec) = 0 then
  begin
   repeat
     if (SearchRec.Attr and faDirectory) = faDirectory then
     begin
      if (SearchRec.Name <> '.') and (SearchRec.Name <> '..') then
        anzahl:=anzahl+CountFiles(Path + SearchRec.Name + '\',FileType);
     end
     else anzahl:=anzahl+1;//Form1.Memo1.Lines.Add(Path + SearchRec.Name);
   until
     FindNext(SearchRec) <> 0;
   FindClose(SearchRec);
  end;
  Result:=anzahl;
end;

procedure TMainform.DeleteFiles(FilenameMask: String);
var LRec: TSearchRec;
    LPath: String;
begin
  if FindFirst(FilenameMask, faAnyFile, LRec) = 0 then
  begin
    LPath := ExtractFilePath(FilenameMask);
    repeat
      if (LRec.Name <> '.') and (LRec.Name <> '..') then
        DeleteFile(LPath + LRec.Name);
    until FindNext(LRec) <> 0;
  end;
  FindClose(LRec);
end;

function TMainform.DeleteDirectory(ADirName: String): Boolean;
var LRec: TSearchRec;
begin
  DeleteFiles(ADirName + '\*');
{$WARNINGS OFF}
  if FindFirst(ADirName + '\*', faDirectory + faHidden + faSysFile, LRec) = 0 then
  begin
    repeat
      if (copy(LRec.name, 1, 1) <> '.') and DirectoryExists(ADirName + '\' + LRec.Name) then
        DeleteDirectory(ADirName + '\' + LRec.Name);
    until FindNext(LRec) <> 0;
  end;
{$WARNINGS ON}
  FindClose(LRec);
  Result := RemoveDir(ADirName)
end;

function TMainform.DeleteFile(const AFile: string): boolean;
var
 sh: SHFileOpStruct;
begin
 ZeroMemory(@sh, sizeof(sh));
 with sh do
   begin
   Wnd := Application.Handle;
   wFunc := fo_Delete;
   pFrom := PChar(AFile +#0);
   fFlags := fof_Silent or fof_NoConfirmation;
   end;
 result := SHFileOperation(sh) = 0;
end;

function TMainform.DeleteDir(Dir : String) : Boolean;
var
 FileOption : TSHFileOpStruct;
begin
 ZeroMemory(@FileOption,SizeOf(FileOption));
 with FileOption do
 begin
   wFunc := FO_DELETE;
   fFlags := FOF_SILENT or FOF_NOCONFIRMATION;
   pFrom := PChar(Dir + #0);
 end;
 Result := (ShFileOperation(FileOption) = 0);
end;

procedure TMainform.FormCreate(Sender: TObject);
var
  i,j,k,zeilenanzahl,Count, Count2: integer;
  text,text1,text2,tempstring, sprache, LastLanguage:string;
  SR: TSearchRec;
  FuncCall,FuncCall2,FuncCall3 : function : PChar;stdcall;
  ProcCall: procedure(funktionsadresse0,funktionsadresse1,funktionsadresse2,funktionsadresse3:Pointer;funktionsadresse4:Pointer);stdcall;
  ProcCall2:procedure;stdcall;
	LReg:TPCDRegistry;
  DLL:THandle;
  ActualPlugin, PluginsToLoad:integer;

  // Startoptionen
  key:Word;
  Shift:TShiftState;
  ShiftNumber:Cardinal;

  LSHIFT,RSHIFT,ESCAPE,CONTROL,MENU:boolean;

  // TdxRibbon Workaround für GnuGetText
  AObjects: TObjectList;
begin
  // PC_DIMMER nur auf dem ersten CPU-Core ausführen (andernfalls Abstürze durch BASS.DLL!!!)
  SetProcessAffinityMask(GetCurrentProcess, 1); // 1=CPU0 , 2=CPU1

  ///////////////////////////////
  // SPLASHSCREEN
  ///////////////////////////////

  firststart:=true;
  splashscreenvalue:=-1;
  StartupFinished:=false;
  BeginValueBackups:=false;
  CurrentUser:='Admin';
  StartupUser:=CurrentUser;
  CurrentUserAccessLevel:=0;

  for i:=1 to paramcount do
  begin
    if (paramstr(i)='/nosplash') then
    begin
      splashscreenvalue:=0;
    end;
  end;

  for i:=1 to paramcount do
  begin
    if paramstr(i)='/sp1' then
    begin
      splashscreenvalue:=1;
      break;
    end;
    if paramstr(i)='/sp2' then
    begin
      splashscreenvalue:=2;
      break;
    end;
  end;

  if splashscreenvalue=-1 then
    splashscreenvalue:=2;

  GetWindowsVersionInfo(WindowsMajorVersion, WindowsMinorVersion, WindowsBuildNumber);
  osversion:=GetWindowsVersion;

  case splashscreenvalue of
    0:
    begin
      // kein Splashscreen
    end;
    1:
    begin
      splash:=tsplash.Create(Application,true);

      // Splashscreen anzeigen
      splash.versioninfo:=GetFileVersionBuild(paramstr(0))+' (' + osversion + ')';
      splash.captioninfo:=_('Initialisiere Anwendung...');

      splash.Show;
      splash.BlendValue:=255;
      splash.Timer1.Enabled:=false;
      splash.Timer1Timer(nil);
    end;
    2:
    begin
      splashscreen2:=Tsplashscreen2.Create(splashscreen2);
      splashscreen2.Show;
      splashscreen2.Refresh;
      splashscreen2.label3.caption:=GetFileVersionBuild(paramstr(0));
      splashscreen2.label3.refresh;
      splashscreen2.label2.caption:=_('Initialisiere Anwendung...');
      splashscreen2.label2.refresh;
    end;
  end;

  ///////////////////////////////
  // SPRACHE
  ///////////////////////////////

  sprache:=GetWindowsLanguage;

  LReg := TPCDRegistry.Create;
  if LReg.OpenRegKey('') then
  begin
    LastLanguage := LReg.ReadWriteStr('Language', sprache);
    LReg.CloseKey;
  end;
  LReg.Free;

  if LastLanguage='' then
    LastLanguage:='EN';
  if ((uppercase(LastLanguage)<>'DE') and (not DirectoryExists(pcdimmerdirectory+'locale\'+LastLanguage))) or
     ((uppercase(LastLanguage)<>'DE') and (not DirectoryExists(pcdimmerdirectory+'locale\'+LastLanguage+'\LC_MESSAGES'))) then
  begin
    ShowMessage(_('The PC_DIMMER does not have a languagefile for your language "')+LastLanguage+_('". The PC_DIMMER will start in English now...'));
    LastLanguage:='EN';
  end;
  UseLanguage(LastLanguage);

  LReg := TPCDRegistry.Create;
  if LReg.OpenRegKey('') then
  begin
    LReg.WriteString('Language', LastLanguage);
    LReg.CloseKey;
  end;
  LReg.Free;

  TP_GlobalIgnoreClass(Twebbrowser);
  TP_GlobalIgnoreClass(TNotebook);
  TP_GlobalIgnoreClass(TJvComputerInfoEx);
  TP_GlobalIgnoreClass(Tinprogress);
//  TP_GlobalIgnoreClass(Texceptionform);
  TP_GlobalIgnoreClassProperty(TJvIdentification,'LocalUserName');
  TP_GlobalIgnoreClassProperty(TJvIdentification,'RegisteredOwner');
  TP_GlobalIgnoreClassProperty(TEdit,'Text');

  // Workaround für TdxRibbon Translate
  inherited;
  AObjects := TObjectList.Create(False);
  try
    for i := 0 to dxBarManager1.Categories.Count - 1 do
    begin
      AObjects.Add(dxBarManager1.Categories.Objects[i]);
      dxBarManager1.Categories.Objects[i] := nil;
    end;
    TranslateComponent(self);
    for i := 0 to AObjects.Count - 1 do
      dxBarManager1.Categories.Objects[i] := AObjects[i];
  finally
    AObjects.Free;
  end;

  ///////////////////////////////
  // VARIABLEN
  ///////////////////////////////

  pcdimmerdirectory:=ExtractFilePath(paramstr(0));
  userdirectory:=GetEnvironmentVariable('APPDATA')+'\PHOENIXstudios\PC_DIMMER\';
  if not DirectoryExists(userdirectory) then
  begin
    CreateDir(GetEnvironmentVariable('APPDATA')+'\PHOENIXstudios\');
    CreateDir(GetEnvironmentVariable('APPDATA')+'\PHOENIXstudios\PC_DIMMER');
    CreateDir(GetEnvironmentVariable('APPDATA')+'\PHOENIXstudios\PC_DIMMER\Temp');
  end;

  currentprojectversion:=actualprojectversion;

  gotosystray:=false;
  dontloadproject:=false;
  dontstartaccu:=false;
  UseBilinearInterpolation:=true;

  if GetKeyState(VK_LSHIFT) then LSHIFT:=true;//ShowMessage('L Shift Taste');
  if GetKeyState(VK_RSHIFT) then RSHIFT:=true;//ShowMessage('R Shift Taste');
  if GetKeyState(VK_ESCAPE) then ESCAPE:=true;//ShowMessage('Escape Taste');
  if GetKeyState(VK_CONTROL) then CONTROL:=true;//ShowMessage('STRG Taste');
  if GetKeyState(VK_MENU) then MENU:=true;//ShowMessage('ALT Taste');

  if LSHIFT then
  begin
    if messagedlg(_('Sie haben während des Startens die linke Shift-Taste gedrückt.'+#13#10#10#10+'Soll das Laden der letzten Projektdatei verhindert werden?'),mtConfirmation,
      [mbYes,mbNo],0)=mrYes then
      begin
        dontloadproject:=true;
      end;
  end;
  if RSHIFT then
  begin
    if messagedlg(_('Sie haben während des Startens die rechte Shift-Taste gedrückt.'+#13#10#10#10+'Soll der Start der Akkukontrolle verhindert werden?'),mtConfirmation,
      [mbYes,mbNo],0)=mrYes then
      begin
        dontstartaccu:=true;
      end;
  end;

  CPUCount:=JvComputerInfoEx1.CPU.ProcessorCount;

  // Fehlerbehandlung erzeugen
  exceptionform:=Texceptionform.Create(Application);
  // Error-Handler initialisieren
  firststartaftercreate:=true;
  // Eigene Fehlerbehandlung aktivieren
  JclStackTrackingOptions := JclStackTrackingOptions + [stRawMode];
  {$IFNDEF HOOK_DLL_EXCEPTIONS}
  JclStackTrackingOptions := JclStackTrackingOptions + [stStaticModuleList];
  {$ENDIF HOOK_DLL_EXCEPTIONS}
    //    JclDebugThreadList.OnSyncException := Texceptionform.ExceptionThreadHandler;
  JclStartExceptionTracking;
  {$IFDEF HOOK_DLL_EXCEPTIONS}
  if HookTApplicationHandleException then
    JclTrackExceptionsFromLibraries;
  {$ENDIF HOOK_DLL_EXCEPTIONS}
  Application.OnException:=AppException;
  Application.OnRestore:=FormShow;

  // WORKAROUND FOR MEVP
  DasMevAreFixturesModified:=nil;
  DasMevClose:=nil;
  DasMevCommand:=nil;
  DasMevGetFixtureParam:=nil;
  DasMevGetFixturesCount:=nil;
  DasMevGetLanguage:=nil;
  DasMevGetSupportedDeviceTypes:=nil;
  DasMevGetVersion:=nil;
  DasMevIsOpened:=nil;
  DasMevIsUsingDasHard:=nil;
  DasMevSetLanguage:=nil;
  DasMevSetSupportedDeviceTypes:=nil;
  DasMevStart:=nil;
  DasMevWriteDmx:=nil;
  MEVPDLL:=0;
  // END OF WORKAROUND FOR MEVP

  Mevp := TPCDMevp.Create;

  DimmerkernelResolution:=20; // in ms 1/44Hz=22,72ms - oder Automatisch
//  MaximumChan:=512;
  lastchan:=512;
  setlength(data.ch,lastchan+1);
  setlength(data.names,lastchan+1);
  setlength(data.sdirect,lastchan+1);
  setlength(data.combine,lastchan+1);

  // Kanalübersicht
  ChannelWidth:=64;
  ChannelHeight:=51;
  AktuellerKanal:=1;

  {$I Channels_Commandsystem.inc}

  debuglistbox.Clear;
  fadesplash:=false;
  Randomize;

  ///////////////////////////////
  // STARTSCHALTER
  ///////////////////////////////
  for i:=1 to paramcount do
  begin
    if (paramstr(i)='/debug') then
    begin
      SplashSwitchinfo(' /debug');
      DebugAdd('Startparameter: /debug activated. Debuglistbox will be shown.', false);
      debuglistbox.Visible:=true;
      debuglistbox.BringToFront;
    end;
    if (paramstr(i)='/noaccu') then
    begin
      SplashSwitchinfo(' /noaccu');
      DebugAdd('Startparameter: /noaccu activated. No continuos Accu-Refresh.', false);
      dontstartaccu:=true;
      _killaccu:=true;
    end;
    if (paramstr(i)='/noproject') then
    begin
      SplashSwitchinfo(' /noproject');
      DebugAdd('Startparameter: /nolastproject activated. No projectfile will be loaded on startup.', false);
      dontloadproject:=true;
    end;
    if (paramstr(i)='/minimized') then
    begin
      SplashSwitchinfo(' /minimized');
      DebugAdd('Startparameter: /minimized activated. PC_DIMMER will go to Systray.', false);
      gotosystray:=true;
    end;
  end;

  if splashscreenvalue>0 then
  begin
    SplashVersioninfo(GetFileVersionBuild(paramstr(0))+' (' + osversion + ')');
    SplashCaptioninfo(_('Startwerte...'));

    if dontloadproject then SplashSwitchinfo(' /noproject');
    if dontstartaccu then SplashSwitchinfo(' /noaccu');
  end;

  DebugAdd('PC_DIMMER '+GetFileVersionBuild(paramstr(0))+' starting up...', false);
  DebugAdd('----------------------------------------------------------------------------', false);
  DebugAdd('INIT: pcdimmerdirectory: "'+pcdimmerdirectory+'"', false);
  DebugAdd('INIT: userdirectory: "'+userdirectory+'"', false);
  try
  	debuglistbox.Items.SaveToFile(userdirectory+'\PC_DIMMER.log');
  except
//    MessageDlg('PC_DIMMER kann nicht auf die Protokolldatei "PC_DIMMER.log" zugreifen!', mtError, [mbOk], 0);
    ownmessageform.captionlbl.Caption:=_('Fehler in Protokolldatei');
    ownmessageform.descriptionlbl.Caption:='';
    ownmessageform.meldung.Clear;
    ownmessageform.meldung.Lines.Add(_('PC_DIMMER kann nicht auf die Protokolldatei "PC_DIMMER.log" zugreifen!'));
    ownmessageform.ClientHeight:=209;
    ownmessageform.ClientWidth:=377;
    ownmessageform.CancelBtn.Visible:=false;
    ownmessageform.caption:=_('Fehler in Protokolldatei');
    ownmessageform.showmodal;
  end;
  DebugAdd('INIT: Using '+osversion+' Frontend.');

  If not DirectoryExists(userdirectory+'ProjectTemp') then
  begin
  	CreateDir(userdirectory+'ProjectTemp');
  	CreateDir(userdirectory+'ProjectTemp\Kontrollpanel');
  end;

  project_folder:=userdirectory+'ProjectTemp\';

  akkulevel:=100;
  akkuwarningmessageshownext:=15;
  startingup:=true;
  FirstStartofStageview:=true;

  PluginRibbonTab.Visible:=false;

  // Audioeffektplayer initialisieren
  setlength(effektaudio_record,0);

  If not DirectoryExists(userdirectory+'ProjectTemp') then
  begin
   	CreateDir(userdirectory+'ProjectTemp');
  	CreateDir(userdirectory+'ProjectTemp\Kontrollpanel');
  end;

  left:=0;
  top:=0;

  for i:=1 to lastchan do
    changedchannels[i]:=false;

  ///////////////////////////////
  // REGISTRYWERTE
  ///////////////////////////////

  DebugAdd('INIT: Reading Registryvalues...');
  SplashProgress(1, 0, 100);
  SplashCaptioninfo(_('Registrywerte auslesen'));
  RefreshSplashText;

  LReg := TPCDRegistry.Create;
  if LReg.OpenRegKey('') then
  begin
    LReg.WriteString('Version',GetFileVersionBuild(paramstr(0)));

    if not LReg.ValueExists('Firststart') then
    begin
      FirstStart := true;
      LReg.WriteBool('Firststart', false);
    end;

    if LReg.ValueExists('Running') then
    begin
      LastSessionWasCorrupt := LReg.ReadBool('Running');
    end;
    LReg.WriteBool('Running', true);

    LReg.WriteString('Last used directory', userdirectory);

    MainPriority := LReg.ReadWriteInt('Processpriority', 3);
    if MainPriority < 2 then
      showmessage(_('Die Ausführungs-Priorität des PC_DIMMERs liegt unterhalb von "Normal".'+#10#13#10#13+'Bitte kontrollieren Sie diese Einstellung in den erweiterten Einstellungen des PC_DIMMERs unter dem Punkt "Hardware" und korrigieren Sie die Priorität ggfs. auf "Normal" oder "Höher".'));

    case MainPriority of
      0: begin SetPriorityClass(GetCurrentProcess, IDLE_PRIORITY_CLASS); end;
      1: begin SetPriorityClass(GetCurrentProcess, 16384); end;
      2: begin SetPriorityClass(GetCurrentProcess, NORMAL_PRIORITY_CLASS); end;    // 32
      3: begin SetPriorityClass(GetCurrentProcess, 32768); end; // Higher
      4: begin SetPriorityClass(GetCurrentProcess, HIGH_PRIORITY_CLASS); end; // 128
      5: begin SetPriorityClass(GetCurrentProcess, REALTIME_PRIORITY_CLASS); end; // 128
    end;

    MinDimmerkernelResolution := LReg.ReadWriteInt('MinimumDimmerkernelResolution', 20);
    DimmerkernelResolution := MinDimmerkernelResolution;
    DimmerkernelResolutionAutoset := LReg.ReadWriteBool('Autoset DimmerkernelResolution', true);

    if LReg.ValueExists('Plugin Blacklist') then
      plugin_blacklist:=LReg.ReadString('Plugin Blacklist');
    if LReg.ValueExists('MidiBeatSignal On') then
      MBS_Online:=LReg.ReadBool('MidiBeatSignal On');
    if LReg.ValueExists('MidiBeatSignal MSG On') then
      MBS_MSGon:=LReg.ReadInteger('MidiBeatSignal MSG On');
    if LReg.ValueExists('MidiBeatSignal MSG Off') then
      MBS_MSGoff:=LReg.ReadInteger('MidiBeatSignal MSG Off');
    if LReg.ValueExists('MidiBeatSignal Data1 On') then
      MBS_Data1on:=LReg.ReadInteger('MidiBeatSignal Data1 On');
    if LReg.ValueExists('MidiBeatSignal Data1 Off') then
      MBS_Data1off:=LReg.ReadInteger('MidiBeatSignal Data1 Off');
    if LReg.ValueExists('MidiBeatSignal Data2 On') then
      MBS_Data2on:=LReg.ReadInteger('MidiBeatSignal Data2 On');
    if LReg.ValueExists('MidiBeatSignal Data2 Off') then
      MBS_Data2off:=LReg.ReadInteger('MidiBeatSignal Data2 Off');

    LastMidiInputDevices := LReg.ReadWriteStr('Last Midi Inputdevices', '');
    LastMidiOutputDevices := LReg.ReadWriteStr('Last Midi Outputdevices', '');
    UseMidiBackTrack := LReg.ReadWriteBool('Use Midi Backtrack', true);
    MidiCallbackTimer.Interval := LReg.ReadWriteInt('Midi Backtrack Interval', 150);
    UseControl7ForLevel := LReg.ReadWriteBool('Use Midi Control7', false);
    for i:=1 to 16 do
      LastMIDIController[i] := LReg.ReadWriteInt('Midi Control Channel '+inttostr(i), 7);
    UseMIDIThru := LReg.ReadWriteBool('Use Midi Thru', false);
    AnimationTimer := LReg.ReadWriteInt('Timer', 0);
    StartupWithOldScene := LReg.ReadWriteBool('Startup with old scene', true);
    SwitchoffLightsatShutdown := LReg.ReadWriteBool('Switchoff Lights on Shutdown', true);
    Autoload_project_file := LReg.ReadWriteStr('Last projectfile', '');
    ActualLanguage := LReg.ReadWriteStr('Language', GetWindowsLanguage);
    AskForSaveProject := LReg.ReadWriteBool('Ask for saving projectfile', false);
    PowerSwitchOff := LReg.ReadWriteBool('Deactivate powerbutton', true);
    LevelAnzeigeOptionen := LReg.ReadWriteInt('Style of Leveldisplay', 0);
    DeactivateOutputDllsOnClose := LReg.ReadWriteBool('Deactivate Outputplugins on Shutdown', true);
    DeactivateInputDllsOnClose := LReg.ReadWriteBool('Deactivate Inputplugins on Shutdown', true);
    SoundDeviceSpeakers := LReg.ReadWriteInt('Used Speakers', 1);
//  ShowIconInTaskSwitcher := LReg.ReadWriteBool('Show Icon in Taskswitcher', true);
    ShowIconInTaskSwitcher := true;
    ShowButtonInTaskbar := true;
    SoundDevice := LReg.ReadWriteInt('Last used Audiodevice', 0);
    BlendValue := LReg.ReadWriteInt('AlphaBlendValue', 160);
//  TTrackBar(BrightnessBarRibbon.Properties).Min:=LReg.ReadWriteInt('Min Screenbrightness', 25);
    ShowLastPlugins := LReg.ReadWriteBool('Show last used Plugins', true);
    LastBeatSource := LReg.ReadWriteInt('Beatsource', 0);
    ShowTipOfDay := LReg.ReadWriteBool('Show TipOfDay', true);
    ShowFirstSteps := LReg.ReadWriteBool('Show FirstSteps', true);
    FlashScrolllockLed := LReg.ReadWriteBool('Beat to Scroll-Lock LED', false);
    ShowAkkuWarnings := LReg.ReadWriteBool('Show Accuwarnings', true);
    BlendoutForms := LReg.ReadWriteBool('Blendout unfocused forms', false);
    EnableHotKeys := LReg.ReadWriteBool('Enable HotKeys', true);
    EnableJoystick := LReg.ReadWriteBool('Enable Joystick', false);
    DataInActiveRibbonBox.Down := LReg.ReadWriteBool('Enable DataIn', false);
    UsePowerManagement := LReg.ReadWriteBool('Enable Powermanagement', false);
//  ErrorHandlingMode := LReg.ReadWriteInt('Errorhandlingmode', 0);
    ErrorHandlingMode := 0;
    AutoInsertComputerUsername := LReg.ReadWriteBool('Insert Username into Project automaticly', true);
    mevp.MEVPDLLPath := LReg.ReadWriteStr('Position of MEVP.DLL', pcdimmerdirectory+'MEVP.DLL');
    mevp.UseThread := LReg.ReadWriteBool('Mevp Use Thread', false);
    mevp.ThreadPriority := IntToThreadPriority(LReg.ReadWriteInt('Mevp Thread Priority', 3));
    MaxAutobackupFiles := LReg.ReadWriteInt('Autobackup Files', 5);
    AutoBackupCounterMax := LReg.ReadWriteInt('Autobackup', 10);
    if AutoBackupCounterMax > 0 then
    begin
      AutoBackupCounter := 0;
    end;
    AutoBackupTimer.Enabled := AutoBackupCounterMax > 0;
    TerminalPort := LReg.ReadWriteInt('Terminal IP Port', 10160);
    MediaCenterPort := LReg.ReadWriteInt('MediaCenter IP Port', 10154);
    CheckUpdatesOnStartup := LReg.ReadWriteBool('Check updates on Startup', true);
    QuitWithoutConfirmation := LReg.ReadWriteBool('Do not ask for exit', false);
    UseAutoAmberCalculation := LReg.ReadWriteBool('AutoAmberCalculation', false);

    if LReg.ValueExists('Number of Useraccounts') then
    begin
      count:=LReg.ReadInteger('Number of Useraccounts');
      setlength(UserAccounts, count);
      for i:=0 to length(UserAccounts)-1 do
      begin
        LReg.ReadBinaryData('UserAccount '+inttostr(i)+' ID', UserAccounts[i].ID, sizeof(UserAccounts[i].ID));
        LReg.ReadBinaryData('UserAccount '+inttostr(i)+' Name', UserAccounts[i].Name, sizeof(UserAccounts[i].Name));
        LReg.ReadBinaryData('UserAccount '+inttostr(i)+' Password', UserAccounts[i].PasswordScrambled, sizeof(UserAccounts[i].PasswordScrambled));

        with TCipher_Blowfish.Create do
        try
          Init(blowfishscramblekey);
          UserAccounts[i].Password := DecodeBinary(UserAccounts[i].PasswordScrambled, TFormat_Copy);
        finally
          Free;
        end;

        LReg.ReadBinaryData('UserAccount '+inttostr(i)+' AccessLevel', UserAccounts[i].AccessLevel, sizeof(UserAccounts[i].AccessLevel));
      end;
    end;
    if length(UserAccounts)=0 then
    begin
      setlength(UserAccounts, 1);
      CreateGUID(UserAccounts[0].ID);
      UserAccounts[0].Name:='Admin';
      UserAccounts[0].Password:='';

      with TCipher_Blowfish.Create do
      try
        Init(blowfishscramblekey);
        UserAccounts[0].PasswordScrambled:=EncodeBinary(UserAccounts[0].Password, TFormat_Copy);
      finally
        Free;
      end;

      UserAccounts[0].AccessLevel:=0;
    end;
    
    
    LReg.LoadWndPos(mainForm);

    if not LReg.ValueExists('Longitude') then
      LReg.WriteFloat('Longitude',50.9770800);
    Longitude := LReg.ReadFloat('Longitude');
    if not LReg.ValueExists('Latitude') then
      LReg.WriteFloat('Latitude',9.4864600);
    Latitude:=LReg.ReadFloat('Latitude');

    LReg.CloseKey;
  end;
  LReg.Free;

  DebugAddToLine(' - OK', false);
  DebugAdd('INIT: Reading Configuration...');
  SplashProgress(1, 1, 100);
  SplashCaptioninfo(_('Konfiguration öffnen'));
  RefreshSplashText;

  ReadConfiguration;

  SplashProgress(1, 2, 100);
  SplashCaptioninfo(_('Oberfläche vorbereiten...'));
  RefreshSplashText;

  for i:=0 to length(data.ch)-1 do
  begin
    data.ch[i]:=maxres;
    data.names[i]:=_('Kanal ')+inttostr(i);
  end;

  kontrollpanelrecord.zeilenanzahl:=0;
  kontrollpanelrecord.spaltenanzahl:=3;
  kontrollpanelrecord.formwidth:=632;
  kontrollpanelrecord.formheight:=272;

  setlength(ambilights,5);

  ///////////////////////////////
  // PLUGINS SUCHEN
  ///////////////////////////////

  DebugAdd('INIT: Reading Configurationfile successful...', false);
  DebugAdd('', false, false);
  DebugAdd('PLUGIN: Listing all I/O-Plugins...');
  SplashProgress(1, 3, 100);
  SplashCaptioninfo(_('Plugins suchen...'));
  RefreshSplashText;

  PluginsToLoad:=CountFiles(pcdimmerdirectory+'Plugins\','*.dll');
  ActualPlugin:=-1;

// DLLs suchen und Output- und Program-DLLs rausfiltern
  setlength(OutputPlugins, 0);
  setlength(ProgramPlugins, 0);

  if (FindFirst(pcdimmerdirectory+'\plugins\*.dll',faAnyFile-faDirectory,SR)=0) then
  begin
    repeat
      if (SR.Name<>'.') and (SR.Name<>'..') and (SR.Attr<>faDirectory) then
      begin
        if (Pos(SR.Name, plugin_blacklist)=0) then
        begin
          try
            DLL:=LoadLibrary(PChar(pcdimmerdirectory+'\plugins\'+SR.Name));
            FuncCall := GetProcAddress(DLL,'DLLIdentify');
            FuncCall2 := GetProcAddress(DLL,'DLLGetName');
            FuncCall3 := GetProcAddress(DLL,'DLLGetVersion');
            if Assigned(FuncCall) then
            begin
              ActualPlugin:=ActualPlugin+1;
              SplashProgress(1, 3+round(15*(ActualPlugin/PluginsToLoad)), 100);

              if FuncCall[0]=StrPas('O') then
              begin
                setlength(OutputPlugins, length(OutputPlugins)+1);

                OutputPlugins[length(OutputPlugins)-1].Filename:=SR.Name;
                DebugAdd('PLUGIN: Found Outputplugin '+SR.Name);
                OutputPlugins[length(OutputPlugins)-1].Name:=FuncCall2;
                OutputPlugins[length(OutputPlugins)-1].Version:=FuncCall3;
                SplashAddText(_('Outputplugin: ')+OutputPlugins[length(OutputPlugins)-1].Name);
                RefreshSplashText;
              end else if FuncCall[0]=StrPas('I') then
              begin
                setlength(ProgramPlugins, length(ProgramPlugins)+1);

                ProgramPlugins[length(ProgramPlugins)-1].Filename:=SR.Name;
                DebugAdd('PLUGIN: Found Programplugin '+SR.Name);
                ProgramPlugins[length(ProgramPlugins)-1].Name:=FuncCall2;
                ProgramPlugins[length(ProgramPlugins)-1].Version:=FuncCall3;

                SplashAddText(_('Programmplugin: ')+ProgramPlugins[length(ProgramPlugins)-1].Name);
                RefreshSplashText;
              end;
            end else
            begin
              DebugAdd('WARNING: '+SR.Name+' is not a proper PC_DIMMER plugin. Ignored.', false);
              DebugAdd('MESSAGE: '+SR.Name+': '+SysErrorMessage(GetLastError));
            end;
            FreeLibrary(DLL);
          except
            DebugAdd('PLUGIN: The file '+SR.Name+' caused an error. - ERROR');
          end;
        end else
        begin
          if Pos(SR.Name, plugin_blacklist)>0 then
          begin
            DebugAdd('WARNING: Ignored Outputplugin '+SR.Name+' because of pluginblacklist.');
          end;
        end;
      end;
    until FindNext(SR)<>0;
    FindClose(SR);
  end;

  if length(OutputPlugins)=0 then
  begin
    text:=_('Es sind keine Ausgabeplugins installiert.'+#10+#10+'Plugins sind auf der Website "http://downloads.pcdimmer.de" kostenlos herunterladbar.');
    MessageBox(Handle, PChar(text), 'Hinweis', MB_ICONWARNING or MB_OK);
  end;

  DebugAdd('PLUGIN: Found '+inttostr(length(OutputPlugins))+' Outputplugin(s)...', false);
  DebugAdd('PLUGIN: Found '+inttostr(length(ProgramPlugins))+' Programplugin(s)...', false);
  DebugAdd('', true, false);

  for i:=1 to chan do
  begin
    channel_minvalue[i]:=0;
    channel_maxvalue[i]:=maxres;
  end;

  ///////////////////////////////
  // AUDIO
  ///////////////////////////////

  DebugAdd('INIT: Starting Audiodevices...');
  SplashProgress(1, 19, 100);
  SplashCaptioninfo(_('Audiosystem einrichten...'));
  RefreshSplashText;

// Audioplayer vorbereiten
//  inttohex(BASS_GetVersion,8); //0x02040101
  DebugAdd('Bass.dll in Version '+copy(inttohex(BASS_GetVersion,8),0,2)+'.'+copy(inttohex(BASS_GetVersion,8),3,2)+'.'+copy(inttohex(BASS_GetVersion,8),5,2)+'.'+inttostr(strtoint(copy(inttohex(BASS_GetVersion,8),7,2)))+' found (minimum version: '+inttostr(strtoint(copy(inttohex(BASSVERSION,4),0,2)))+'.'+copy(inttohex(BASSVERSION,4),3,2)+').');

	if (HIWORD(BASS_GetVersion) < BASSVERSION) then
	begin
  	MessageBox(0,PChar(String(_('Die Datei "bass.dll" liegt in einer falschen Version (')+inttostr(strtoint(copy(inttohex(BASS_GetVersion,8),0,2)))+'.'+inttostr(strtoint(copy(inttohex(BASS_GetVersion,8),3,2)))+_(') statt ')+inttostr(strtoint(copy(inttohex(BASSVERSION,4),0,2)))+'.'+inttostr(strtoint(copy(inttohex(BASSVERSION,4),3,2)))+_(' vor.'))),nil,MB_ICONERROR);
    DebugAddToLine(' - ERROR', false);
    DebugAdd('Die Datei "bass.dll" liegt in einer falschen Version ('+inttostr(strtoint(copy(inttohex(BASS_GetVersion,4),0,2)))+'.'+inttostr(strtoint(copy(inttohex(BASS_GetVersion,4),3,2)))+' statt '+inttostr(strtoint(copy(inttohex(BASSVERSION,4),0,2)))+'.'+inttostr(strtoint(copy(inttohex(BASSVERSION,4),3,2)))+') vor.');
  end else
  begin
    DebugAddToLine(' - OK');
  end;
  DebugAdd('Bassfx.dll in Version '+copy(inttohex(BASS_FX_GetVersion,8),0,2)+'.'+copy(inttohex(BASS_FX_GetVersion,8),3,2)+'.'+copy(inttohex(BASS_FX_GetVersion,8),5,2)+'.'+copy(inttohex(BASS_FX_GetVersion,8),7,2)+' found.', false);
 	DebugAddToLine(' - OK', false);
  DebugAdd('Bassmix.dll in Version '+copy(inttohex(BASS_Mixer_GetVersion,8),0,2)+'.'+copy(inttohex(BASS_Mixer_GetVersion,8),3,2)+'.'+copy(inttohex(BASS_Mixer_GetVersion,8),5,2)+'.'+copy(inttohex(BASS_Mixer_GetVersion,8),7,2)+' found.', false);
 	DebugAddToLine(' - OK', false);
  DebugAdd('Initializing BASS-System...');

  BASS_Init(sounddevice+1, BASSDLLFREQUENZ, BASS_DEVICE_SPEAKERS, Handle, nil);
  DebugAddToLine(' - OK');

  SplashProgress(1, 20, 100);
  SplashCaptioninfo(_('Power-Button deaktivieren...'));
  RefreshSplashText;

// PowerOFF-Schalter am Computer deaktivieren
  powerbutton1.PowerOffEnable:=true;
  if powerswitchoff then
  begin
    powerbutton1.PowerOffEnable:=false;
    PowerRibbonBtn.Down:=false;
  end;

  if dontloadproject then
  begin
    // Projektverzeichnis reinigen
    DeleteDirectory(userdirectory+'ProjectTemp');
    CreateDir(userdirectory+'ProjectTemp');
  	CreateDir(userdirectory+'ProjectTemp\Kontrollpanel');
  end;

  for i:=1 to lastchan do
    changedchannels[i]:=false;

  SplashProgress(1, 21, 100);
  SplashCaptioninfo(_('Hauptfenster erstellen...'));
  RefreshSplashText;

  GedrehteSchrift:=CreateFont(10, 4, 900, 0, fw_normal, 0, 0, 0, 1, 0, $10, 2, 4, PChar('Arial'));
  _MainformBuffer := TBitmap32.Create;
  _MainformBuffer.Width:=paintbox1.Width;
  _MainformBuffer.Height:=paintbox1.Height;
  _MainformPreBuffer := TBitmap32.Create;
  _MainformPreBuffer.Width:=paintbox1.Width;
  _MainformPreBuffer.Height:=paintbox1.Height;

  DebugAdd('INIT: Starting PC_DIMMER Desktop...');

  // Weiter in FormShow!
end;

function TMainform.GetDirSize(dir: string; subdir: Boolean): Longint;
var
  rec: TSearchRec;
  found: Integer;
begin
  Result := 0;
  if dir[Length(dir)] <> '\' then dir := dir + '\';
  found := FindFirst(dir + '*.*', faAnyFile, rec);
  while found = 0 do
  begin
    Inc(Result, rec.Size);
    if (rec.Attr and faDirectory > 0) and (rec.Name <> '.') and (rec.Name <> '..') and (subdir = True) then
      Inc(Result, GetDirSize(dir + rec.Name, True));
    found := FindNext(rec);
  end;
  FindClose(rec);
end;

Function TMainform.GetFileVersion(Const FileName: String): String;
  Var i, W: LongWord;
    P: Pointer;
    FI: PVSFixedFileInfo;

  Begin
    Result := 'NoVersionInfo';
    i := GetFileVersionInfoSize(PChar(FileName), W);
    If i = 0 Then Exit;
    GetMem(P, i);
    Try
      If not GetFileVersionInfo(PChar(FileName), W, i, P)
        or not VerQueryValue(P, '\', Pointer(FI), W) Then Exit;
      Result := IntToStr(FI^.dwFileVersionMS shr 16)
        + '.' + IntToStr(FI^.dwFileVersionMS and $FFFF)
        + '.' + IntToStr(FI^.dwFileVersionLS shr 16)
        + '.' + IntToStr(FI^.dwFileVersionLS and $FFFF);
      If FI^.dwFileFlags and VS_FF_DEBUG        <> 0 Then Result := Result + 'Debug ';
      If FI^.dwFileFlags and VS_FF_PRERELEASE   <> 0 Then Result := Result + 'Beta ';
      If FI^.dwFileFlags and VS_FF_PRIVATEBUILD <> 0 Then Result := Result + 'Private ';
      If FI^.dwFileFlags and VS_FF_SPECIALBUILD <> 0 Then Result := Result + 'RC ';
    Finally
      FreeMem(P);
    End;
End;

Function TMainform.GetFileVersionBuild(Const FileName: String): String;
  Var i, W: LongWord;
    P: Pointer;
    FI: PVSFixedFileInfo;
    version,zusatz,text,text2:string;
  Begin
    version := 'NoVersionInfo';
    i := GetFileVersionInfoSize(PChar(FileName), W);
    If i = 0 Then Exit;
    GetMem(P, i);
    Try
      If not GetFileVersionInfo(PChar(FileName), W, i, P)
        or not VerQueryValue(P, '\', Pointer(FI), W) Then Exit;
      version := IntToStr(FI^.dwFileVersionMS shr 16)
        + '.' + IntToStr(FI^.dwFileVersionMS and $FFFF)
        + '.' + IntToStr(FI^.dwFileVersionLS shr 16)
        + '.' + IntToStr(FI^.dwFileVersionLS and $FFFF);
      If FI^.dwFileFlags and VS_FF_DEBUG        <> 0 Then zusatz := 'Debug ';
      If FI^.dwFileFlags and VS_FF_PRERELEASE   <> 0 Then zusatz := 'Beta ';
      If FI^.dwFileFlags and VS_FF_PRIVATEBUILD <> 0 Then zusatz := 'Private ';
      If FI^.dwFileFlags and VS_FF_SPECIALBUILD <> 0 Then zusatz := 'RC ';
    Finally
      FreeMem(P);
    End;

    text:=version; //4.0.0.0
    text2:=copy(text,0,pos('.',text)); // 4.
    text:=copy(text,pos('.',text)+1,length(text)); // 0.0.0
    text2:=text2+copy(text,pos('.',text)-1,pos('.',text)); // 4.0.
    text:=copy(text,pos('.',text)+1,length(text)); // 0.0
    text2:=text2+copy(text,pos('.',text)-1,pos('.',text)-1); // 4.0.0.
    text:=copy(text,pos('.',text)+1,length(text)); // 0

    result:='Version '+text2+' Build '+text+' '+zusatz;
End;

function TMainform.levelstr(pos:integer):string;
begin
  result:='';
  case MainForm.levelanzeigeoptionen of
    0: result:=inttostr(round((pos*100) / maxres))+'%';
    1: result:=inttostr(round((pos*100) / maxres))+'.'+copy(inttostr((pos*100) mod maxres),0,1)+'%';
    2: result:=inttostr(pos);
    3: result:='0x'+inttohex(pos,2);
    4: result:=inttostr(round((pos*100) / maxres))+'%/'+inttostr(pos);
  end;
end;

function timestr(t:integer):string;
var
  h,m,s:integer;
begin
  h:=t div 360000; t:=t mod 360000;
  m:=t div 6000; t:=t mod 6000;
  s:=t div 100; t:=t mod 100;
  result:=inttostr(h)+':';
  if m<10 then result:=result+'0';
  result:=result+inttostr(m)+':';
  if s<10 then result:=result+'0';
  result:=result+inttostr(s)+'.';
  if t<10 then result:=result+'0';
  result:=result+inttostr(t)+'0';
end;

procedure TMainform.Senddata(address, startvalue, endvalue, fadetime:integer);
begin
  senddata(address, startvalue, endvalue, fadetime, 0);
end;

procedure TMainform.Senddata(address,startvalue,endvalue,fadetime:integer; delay:integer);
var
  i,j,k,m,oldstartvalue,oldendvalue:integer;
  newname:string[255];
  useCalibrationValue:boolean;
  startvalue_Calibrated,endvalue_Calibrated:integer;
  P01x,P01y:single;
  Px,Py,valuex,valuey:double;
  SetStartValue:boolean;
  DimmerChannel:TDimmerKernelChannel;
  IsPanTiltChannel: boolean;
  FineChannel:Word;
  virtualdimmerfaktor:single;
  panchan, tiltchan, panfinechan, tiltfinechan:integer;
begin
  // hier ist 255=aus und 0=100%
  IsPanTiltChannel:=false;
  FineChannel:=0;

  if address<1 then exit;
  if address>lastchan then exit;

  if (startvalue=-1) then
  begin
    SetStartvalue:=false;
    startvalue:=maxres-channel_value[address];
  end else
  begin
    SetStartvalue:=true;
  end;

  if startvalue>maxres then startvalue:=maxres;
  if startvalue<0 then startvalue:=0;
  if endvalue>maxres then endvalue:=maxres;
  if endvalue<0 then endvalue:=0;
  i:=DimmerkernelResolution;
  if fadetime<i then fadetime:=0;
  if delay<0 then delay:=0;

  if (maxres-endvalue)<channel_minvalue[address] then
    endvalue:=maxres-channel_minvalue[address];
  if (maxres-endvalue)>channel_maxvalue[address] then
    endvalue:=maxres-channel_maxvalue[address];

  if not shutdown then
  begin
    IsBlackoutMode:=false;

    startvalue_Calibrated:=0;
    endvalue_Calibrated:=0;

    // Werte umrechnen
    startvalue:=maxres-startvalue;
    endvalue:=maxres-endvalue;

    oldstartvalue:=startvalue;
    oldendvalue:=endvalue;

    if (delay=0) then
    begin
      if fadetime=0 then
      begin // Wert ohne Dimmerkernel ausgeben, da Fadetime=0 und Delay=0
        // Zunächst alle anderen Dimmerkanäle im Dimmerkernel mit gleicher Adresse zum Löschen freigeben, sofern sie bereits dimmen
        for j:=length(DimmerKernelChannelArray)-1 downto 0 do
        begin
          pDimmerChannel:=DimmerKernelChannelArray[j];
          if (pDimmerChannel.channel=address) and (pDimmerChannel.channel_delay=0) then
          begin
            // Kanal hat kein Delay und hat gleiche Adresse. Also kann gelöscht werden.
            channel_endvalue[pDimmerChannel.channel]:=channel_value[pDimmerChannel.channel];
            pDimmerChannel.DeleteChannel:=true;
          end;
        end;

        data.ch[address]:=maxres-endvalue;
        channel_value[address]:=endvalue;
        channel_endvalue[address]:=endvalue;

        // Daten per internem Nachrichtensystem verbreiten
        if (not IsFreezeMode) then
          SendMSG(MSG_ACTUALCHANNELVALUE,address,channel_value[address]);

        if (not startingup) then
        begin
          // DDF-Fenster aktualisieren
          for j:=0 to length(DDFWindows)-1 do
            DDFWindows[j].refreshchannel[address]:=true;
          // DeviceScene-Fenster aktualisieren
          if DDFWindowDeviceScene.Showing then
            DDFWindowDeviceScene.refreshchannel[address]:=true;
          // Gerätesteuerungsfenster aktualisieren
          if geraetesteuerung.Showing then
            geraetesteuerung.refreshchannel[address]:=true;
        end;
      end;

      // Werte an Plugin-DLLs senden
      // Strings für Plugins nullterminieren
      newname:=data.names[address]+#0;
      for i:=0 to length(ProgramPlugins)-1 do
      begin
        if (@ProgramPlugins[i].SendData<>nil) then
        begin
          ProgramPlugins[i].SendData(address,oldstartvalue,oldendvalue,fadetime,@newname);
        end;
      end;

      // Eintragen, dass für diesen Kanal ein neuer Wert gesetzt wurde
      if channel_value[address]<>(255-endvalue) then
        changedchannels[address]:=true;

      // Werte an Output-DLLs senden
      if (not IsFreezeMode) then
      begin
        useCalibrationValue:=false;

        // bilineare Interpolation durchführen k,l,m,valuex,valuey
        for k:=0 to length(devices)-1 do
        begin
          if ((address-devices[k].Startaddress)<length(devices[k].kanaltyp)) and ((address-devices[k].Startaddress)>=0) then
          begin
            // Filterfunktionen für Pan, Tilt, Dimmer und Farbkanäle RGBA
            // !! Achtung weitere Filterfunktion findet in der Funktion .senddata statt!!

            // prüfen, ob ein Gerät den zu ändernden Kanal als PAN(fine) oder TILT(fine) nutzt
            if ((devices[k].kanaltyp[address-devices[k].Startaddress]='pan') or (devices[k].kanaltyp[address-devices[k].Startaddress]='panfine') or (devices[k].kanaltyp[address-devices[k].Startaddress]='tilt') or (devices[k].kanaltyp[address-devices[k].Startaddress]='tiltfine')) then
            begin
              // Gerät nutzt bei aktuellem Kanal PAN(fine) oder TILT(fine)
              // finde Kanäle für PAN, PANFINE, TILT und TILTFINE
              panfinechan:=-1;
              tiltfinechan:=-1;
              for m:=0 to devices[k].MaxChan-1 do
              begin
                if (lowercase(devices[k].kanaltyp[m])='pan') then
                  panchan:=m;
                if (lowercase(devices[k].kanaltyp[m])='tilt') then
                  tiltchan:=m;
                if (lowercase(devices[k].kanaltyp[m])='panfine') then
                  panfinechan:=m;
                if (lowercase(devices[k].kanaltyp[m])='tiltfine') then
                  tiltfinechan:=m;
              end;

              if (devices[k].kanaltyp[address-devices[k].Startaddress]='pan') then
              begin // falls aktueller Kanal PAN
                mainform.devices[k].Panstartvalue:=startvalue;
                mainform.devices[k].Panendvalue:=endvalue;
                IsPanTiltChannel:=true;
                if panfinechan>-1 then
                  FineChannel:=devices[k].Startaddress+panfinechan;
              end;

              if (devices[k].kanaltyp[address-devices[k].Startaddress]='tilt') then
              begin // falls aktueller Kanal TILT
                mainform.devices[k].Tiltstartvalue:=startvalue;
                mainform.devices[k].Tiltendvalue:=endvalue;
                IsPanTiltChannel:=true;
                if tiltfinechan>-1 then
                  FineChannel:=devices[k].Startaddress+tiltfinechan;
              end;

              if (devices[k].kanaltyp[address-devices[k].Startaddress]='panfine') then
              begin // falls aktueller Kanal PANFINE
                mainform.devices[k].PanFinestartvalue:=startvalue;
                mainform.devices[k].PanFineendvalue:=endvalue;
                IsPanTiltChannel:=false;
              end;

              if (devices[k].kanaltyp[address-devices[k].Startaddress]='tiltfine') then
              begin // falls aktueller Kanal TILTFINE
                mainform.devices[k].TiltFinestartvalue:=startvalue;
                mainform.devices[k].TiltFineendvalue:=endvalue;
                IsPanTiltChannel:=false;
              end;

              // Startwert berechnen
              if (panfinechan>-1) and (tiltfinechan>-1) then
              begin
                // Fine-Kanäle sind vorhanden
                // Punkt mit 16-Bit X/Y-Koordinaten erzeugen
                Px:=devices[k].PanStartvalue+(devices[k].PanFineStartvalue/(maxres+1));
                Py:=devices[k].TiltStartvalue+(devices[k].TiltFineStartvalue/(maxres+1));
              end else
              begin
                // keine Fine-Kanäle vorhanden
                // Punkt mit 8-Bit X/Y-Koordinaten erzeugen
                Px:=devices[k].PanStartvalue;
                Py:=devices[k].TiltStartvalue;
              end;

              if (devices[k].typeofscannercalibration>0) then
              begin
                // Gerätekalibrierung dauerhaft anwenden
                // bilineare Interpolation durchführen
                P01x:=Px/(maxres);
                P01y:=Py/(maxres);
                valuex:=trunc((1-P01x)*(1-P01y)*mainform.devices[k].ScannerCalibrations[mainform.devices[k].typeofscannercalibration].PointA.x+(1-P01x)*P01y*mainform.devices[k].ScannerCalibrations[mainform.devices[k].typeofscannercalibration].PointD.x+P01x*(1-P01y)*mainform.devices[k].ScannerCalibrations[mainform.devices[k].typeofscannercalibration].PointB.x+P01x*P01y*mainform.devices[k].ScannerCalibrations[mainform.devices[k].typeofscannercalibration].PointC.x);
                valuey:=trunc((1-P01x)*(1-P01y)*mainform.devices[k].ScannerCalibrations[mainform.devices[k].typeofscannercalibration].PointA.y+(1-P01x)*P01y*mainform.devices[k].ScannerCalibrations[mainform.devices[k].typeofscannercalibration].PointD.y+P01x*(1-P01y)*mainform.devices[k].ScannerCalibrations[mainform.devices[k].typeofscannercalibration].PointB.y+P01x*P01y*mainform.devices[k].ScannerCalibrations[mainform.devices[k].typeofscannercalibration].PointC.y);
              end else
              begin
                valuex:=Px;
                valuey:=Py;
              end;

              if not devices[k].invertpan then
              begin
                if (lowercase(devices[k].kanaltyp[address-devices[k].Startaddress])='pan') then
                  startvalue_Calibrated:=trunc(valuex);
                if (lowercase(devices[k].kanaltyp[address-devices[k].Startaddress])='panfine') then
                  startvalue_Calibrated:=trunc(frac(valuex)*(maxres+1));
              end else
              begin
                if (lowercase(devices[k].kanaltyp[address-devices[k].Startaddress])='pan') then
                  startvalue_Calibrated:=maxres-trunc(valuex);
                if (lowercase(devices[k].kanaltyp[address-devices[k].Startaddress])='panfine') then
                  startvalue_Calibrated:=maxres-trunc(frac(valuex)*(maxres+1));
              end;
              if not devices[k].inverttilt then
              begin
                if (lowercase(devices[k].kanaltyp[address-devices[k].Startaddress])='tilt') then
                  startvalue_Calibrated:=trunc(valuey);
                if (lowercase(devices[k].kanaltyp[address-devices[k].Startaddress])='tiltfine') then
                  startvalue_Calibrated:=trunc(frac(valuey)*(maxres+1));
              end else
              begin
                if (lowercase(devices[k].kanaltyp[address-devices[k].Startaddress])='tilt') then
                  startvalue_Calibrated:=maxres-trunc(valuey);
                if (lowercase(devices[k].kanaltyp[address-devices[k].Startaddress])='tiltfine') then
                  startvalue_Calibrated:=maxres-trunc(frac(valuey)*(maxres+1));
              end;

              // Endwert berechnen
              if (panfinechan>-1) and (tiltfinechan>-1) then
              begin
                // Fine-Kanäle sind vorhanden
                // Punkt mit 16-Bit X/Y-Koordinaten erzeugen
                Px:=devices[k].PanEndvalue+(devices[k].PanFineEndvalue/(maxres+1));
                Py:=devices[k].TiltEndvalue+(devices[k].TiltFineEndvalue/(maxres+1));
              end else
              begin
                // keine Fine-Kanäle vorhanden
                // Punkt mit 8-Bit X/Y-Koordinaten erzeugen
                Px:=devices[k].PanEndvalue;
                Py:=devices[k].TiltEndvalue;
              end;

              if (devices[k].typeofscannercalibration>0) then
              begin
                // Gerätekalibrierung dauerhaft anwenden
                // bilineare Interpolation durchführen
                P01x:=Px/(maxres+1);
                P01y:=Py/(maxres+1);
                valuex:=trunc((1-P01x)*(1-P01y)*mainform.devices[k].ScannerCalibrations[mainform.devices[k].typeofscannercalibration].PointA.x+(1-P01x)*P01y*mainform.devices[k].ScannerCalibrations[mainform.devices[k].typeofscannercalibration].PointD.x+P01x*(1-P01y)*mainform.devices[k].ScannerCalibrations[mainform.devices[k].typeofscannercalibration].PointB.x+P01x*P01y*mainform.devices[k].ScannerCalibrations[mainform.devices[k].typeofscannercalibration].PointC.x);
                valuey:=trunc((1-P01x)*(1-P01y)*mainform.devices[k].ScannerCalibrations[mainform.devices[k].typeofscannercalibration].PointA.y+(1-P01x)*P01y*mainform.devices[k].ScannerCalibrations[mainform.devices[k].typeofscannercalibration].PointD.y+P01x*(1-P01y)*mainform.devices[k].ScannerCalibrations[mainform.devices[k].typeofscannercalibration].PointB.y+P01x*P01y*mainform.devices[k].ScannerCalibrations[mainform.devices[k].typeofscannercalibration].PointC.y);
              end else
              begin
                valuex:=Px;
                valuey:=Py;
              end;

              if not devices[k].invertpan then
              begin
                if (lowercase(devices[k].kanaltyp[address-devices[k].Startaddress])='pan') then
                  endvalue_Calibrated:=trunc(valuex);
                if (lowercase(devices[k].kanaltyp[address-devices[k].Startaddress])='panfine') then
                  endvalue_Calibrated:=trunc(frac(valuex)*(maxres+1));
              end else
              begin
                if (lowercase(devices[k].kanaltyp[address-devices[k].Startaddress])='pan') then
                  endvalue_Calibrated:=maxres-trunc(valuex);
                if (lowercase(devices[k].kanaltyp[address-devices[k].Startaddress])='panfine') then
                  endvalue_Calibrated:=maxres-trunc(frac(valuex)*(maxres+1));
              end;
              if not devices[k].inverttilt then
              begin
                if (lowercase(devices[k].kanaltyp[address-devices[k].Startaddress])='tilt') then
                  endvalue_Calibrated:=trunc(valuey);
                if (lowercase(devices[k].kanaltyp[address-devices[k].Startaddress])='tiltfine') then
                  endvalue_Calibrated:=trunc(frac(valuey)*(maxres+1));
              end else
              begin
                if (lowercase(devices[k].kanaltyp[address-devices[k].Startaddress])='tilt') then
                  endvalue_Calibrated:=maxres-trunc(valuey);
                if (lowercase(devices[k].kanaltyp[address-devices[k].Startaddress])='tiltfine') then
                  endvalue_Calibrated:=maxres-trunc(frac(valuey)*(maxres+1));
              end;

              useCalibrationValue:=true;
            end;

            if (devices[k].kanaltyp[address-devices[k].Startaddress]='dimmer') or (devices[k].kanaltyp[address-devices[k].Startaddress]='r') or
             (devices[k].kanaltyp[address-devices[k].Startaddress]='g') or (devices[k].kanaltyp[address-devices[k].Startaddress]='b') or
             (devices[k].kanaltyp[address-devices[k].Startaddress]='a') or (devices[k].kanaltyp[address-devices[k].Startaddress]='w') or
             (devices[k].kanaltyp[address-devices[k].Startaddress]='uv') or (devices[k].kanaltyp[address-devices[k].Startaddress]='c') or
             (devices[k].kanaltyp[address-devices[k].Startaddress]='m') or (devices[k].kanaltyp[address-devices[k].Startaddress]='y') then
            begin
              // falls aktueller Kanal DIMMER, R, G, B, A, UV, C, M, Y
              startvalue_Calibrated:=round(((maxres-masterform.dimmermaster.position)/maxres)*startvalue);
              endvalue_Calibrated:=round(((maxres-masterform.dimmermaster.position)/maxres)*endvalue);
              useCalibrationValue:=true;

              if devices[k].hasVirtualRGBAWDimmer then
              begin
                if ((devices[k].kanaltyp[address-devices[k].Startaddress]='r') or
                  (devices[k].kanaltyp[address-devices[k].Startaddress]='g') or
                  (devices[k].kanaltyp[address-devices[k].Startaddress]='b') or
                  (devices[k].kanaltyp[address-devices[k].Startaddress]='a') or
                  (devices[k].kanaltyp[address-devices[k].Startaddress]='w') or
                  (devices[k].kanaltyp[address-devices[k].Startaddress]='uv') or
                  (devices[k].kanaltyp[address-devices[k].Startaddress]='c') or
                  (devices[k].kanaltyp[address-devices[k].Startaddress]='m') or
                  (devices[k].kanaltyp[address-devices[k].Startaddress]='y')) then
                begin
                  // falls aktueller Kanal R,G,B,A,W, UV, C, M, Y
                  virtualdimmerfaktor:=(geraetesteuerung.get_channel(devices[k].ID, 'DIMMER')/maxres)*((maxres-masterform.dimmermaster.position)/maxres);
                  startvalue_Calibrated:=round(maxres-(virtualdimmerfaktor*(maxres-startvalue)));
                  endvalue_Calibrated:=round(maxres-(virtualdimmerfaktor*(maxres-endvalue)));
                  useCalibrationValue:=true;
                end;
                if (devices[k].kanaltyp[address-devices[k].Startaddress]='dimmer') then
                begin
                  // R,G,B,A,W,UV aktualisieren
                  geraetesteuerung.set_channel(devices[k].ID, 'r', -1, geraetesteuerung.get_channel(devices[k].ID, 'r'), 0);
                  geraetesteuerung.set_channel(devices[k].ID, 'g', -1, geraetesteuerung.get_channel(devices[k].ID, 'g'), 0);
                  geraetesteuerung.set_channel(devices[k].ID, 'b', -1, geraetesteuerung.get_channel(devices[k].ID, 'b'), 0);
                  geraetesteuerung.set_channel(devices[k].ID, 'a', -1, geraetesteuerung.get_channel(devices[k].ID, 'a'), 0);
                  geraetesteuerung.set_channel(devices[k].ID, 'w', -1, geraetesteuerung.get_channel(devices[k].ID, 'w'), 0);
                  geraetesteuerung.set_channel(devices[k].ID, 'uv', -1, geraetesteuerung.get_channel(devices[k].ID, 'uv'), 0);
                  geraetesteuerung.set_channel(devices[k].ID, 'c', -1, geraetesteuerung.get_channel(devices[k].ID, 'c'), 0);
                  geraetesteuerung.set_channel(devices[k].ID, 'm', -1, geraetesteuerung.get_channel(devices[k].ID, 'm'), 0);
                  geraetesteuerung.set_channel(devices[k].ID, 'y', -1, geraetesteuerung.get_channel(devices[k].ID, 'y'), 0);
                end;
              end;
            end;
          end;
        end;

        DMXOutPackets:=DMXOutPackets+1;

        for i:=0 to length(OutputPlugins)-1 do
        begin
  	      if OutputPlugins[i].IsActive and (@OutputPlugins[i].SendData<>nil) and (not (OutputPlugins[i].IsSending)) and
            (address>=OutputPlugins[i].Startaddress) and (address<=OutputPlugins[i].Stopaddress) and
            ((address-OutputPlugins[i].Startaddress+1)>=1) and ((address-OutputPlugins[i].Startaddress+1)<=8192) then
          begin
            if useCalibrationValue then
              OutputPlugins[i].SendData(address-OutputPlugins[i].Startaddress+1,startvalue_Calibrated,endvalue_Calibrated,fadetime,@newname)
            else
              OutputPlugins[i].SendData(address-OutputPlugins[i].Startaddress+1,FilterWithDimmcurve(address,startvalue),FilterWithDimmcurve(address,endvalue),fadetime,@newname);
          end;
        end;
      end;

      if fadetime>0 then
      begin
        // Neues DimmerChannel-Objekt erstellen und dem Dimmerkernel übergeben
        new(pDimmerChannel);
        pDimmerChannel.ChannelType:=0;
        pDimmerChannel.channel:=address;
        pDimmerChannel.channel_delay := 0;
//        pDimmerChannel.channel_steps := (abs(startvalue-endvalue)+1)*256;
        pDimmerChannel.channel_increase:=0;
        pDimmerChannel.SetStartvalue:=SetStartvalue;
        pDimmerChannel.channel_startvalue := startvalue;
        pDimmerChannel.channel_endvalue := endvalue;
        pDimmerChannel.channel_fadetime := fadetime;
        pDimmerChannel.DeleteChannel:=false;
        pDimmerChannel.DontSetValues:=false;
        pDimmerChannel.IsDelayedChan:=false;
        pDimmerChannel.IsPanTiltChannel:=IsPanTiltChannel;
        pDimmerChannel.FineChannel:=FineChannel;
        pDimmerChannel.FadeDirection:=0;
        channel_value[address]:=startvalue;

        setlength(DimmerKernelChannelArray,length(DimmerKernelChannelArray)+1);
        DimmerKernelChannelArray[length(DimmerKernelChannelArray)-1]:=pDimmerChannel;
      end;
    end else
    begin
      // Neues DimmerChannel-Objekt erstellen und der Warteschleife im Dimmerkernel übergeben
      new(pDimmerChannel);
      pDimmerChannel.ChannelType:=0;
      pDimmerChannel.channel:=address;
      pDimmerChannel.channel_delay := delay;
//      pDimmerChannel.channel_steps := (abs(startvalue-endvalue)+1)*256;
      pDimmerChannel.channel_increase:=0;
      pDimmerChannel.SetStartvalue:=SetStartvalue;
      pDimmerChannel.channel_startvalue := startvalue;
      pDimmerChannel.channel_endvalue := endvalue;
      pDimmerChannel.channel_fadetime := fadetime;
      pDimmerChannel.DeleteChannel:=false;
      pDimmerChannel.DontSetValues:=false;
      pDimmerChannel.IsDelayedChan:=(Delay>0);
      pDimmerChannel.IsPanTiltChannel:=IsPanTiltChannel;
      pDimmerChannel.FineChannel:=FineChannel;
      pDimmerChannel.FadeDirection:=0;

      setlength(DimmerKernelChannelArray,length(DimmerKernelChannelArray)+1);
      DimmerKernelChannelArray[length(DimmerKernelChannelArray)-1]:=pDimmerChannel;
    end;
  end;
end;

procedure TMainform.SendMSG(MSG:Byte; Data1, Data2:Variant);
var
	i,j,k,m,tempvalue:integer;
  useCalibrationValue:boolean;
  panchan,tiltchan, panfinechan, tiltfinechan, Value:integer;
  valuex,valuey, P01x,P01y, Px, Py:single;
  virtualdimmerfaktor:single;
begin
  if IsFreezeMode then exit;

  DimmerkernelChanges:=DimmerkernelChanges+1;

  panchan:=0;
  tiltchan:=0;
  useCalibrationValue:=false;
  Value:=0;

  // Werte an Plugin-DLLs senden
  for i:=0 to length(ProgramPlugins)-1 do
  begin
    if (@ProgramPlugins[i].SendMessage<>nil) then
    begin
      ProgramPlugins[i].SendMessage(MSG, Data1, Data2);
    end;
  end;

  if (MSG=MSG_ACTUALCHANNELVALUE) then
  begin
    DMXOutPackets:=DMXOutPackets+1;

    // Werte selektierter Kanäle an MIDI-Controller senden
    RefreshValuesOfSelectedDevicesByMIDI:=true;

    if not startingup then
    begin
      // DDF-Fenster aktualisieren
      for j:=0 to length(DDFWindows)-1 do
      begin
        if not DDFWindows[j].dontrefreshDDFWindow then
          DDFWindows[j].refreshchannel[Integer(Data1)]:=true;
        DDFWindows[j].dontrefreshDDFWindow:=false;
      end;
      // DeviceScene-Fenster aktualisieren
      if not DDFWindowDeviceScene.dontrefreshDDFWindow then
        DDFWindowDeviceScene.refreshchannel[Integer(Data1)]:=true;
      DDFWindowDeviceScene.dontrefreshDDFWindow:=false;
    end;

    if UseBilinearInterpolation then
    begin
      // bilineare Interpolation durchführen k,l,m,valuex,valuey
      useCalibrationValue:=false;
      for k:=0 to length(devices)-1 do
      begin
        if not (devices[k].hasDimmer or devices[k].hasRGB or devices[k].hasCMY or devices[k].hasPANTILT) then continue;

        tempvalue:=Integer(Data1)-devices[k].Startaddress;
        if (tempvalue>=0) and (tempvalue<length(devices[k].kanaltyp)) then
        begin
          // Filterfunktionen für Pan, Tilt, Dimmer und Farbkanäle RGBA
          // !! Achtung weitere Filterfunktion findet in der Funktion .senddata statt!!
          if (devices[k].kanaltyp[tempvalue]='dimmer') or (devices[k].kanaltyp[tempvalue]='r') or
           (devices[k].kanaltyp[tempvalue]='g') or (devices[k].kanaltyp[tempvalue]='b') or
           (devices[k].kanaltyp[tempvalue]='a') or (devices[k].kanaltyp[tempvalue]='w') or
           (devices[k].kanaltyp[tempvalue]='uv') or (devices[k].kanaltyp[tempvalue]='c') or
           (devices[k].kanaltyp[tempvalue]='m') or (devices[k].kanaltyp[tempvalue]='y') then
          begin
            // Gerät benutzt auf aktuellem Kanal DIMMER, R,G,B,A,UV,C,M,Y

            // falls aktueller Kanal DIMMER oder R, G, B, A, UV, C, M, Y
            Value:=round(((maxres-masterform.dimmermaster.position)/maxres)*FilterWithDimmcurve(Data1,Data2));
            useCalibrationValue:=true;

            if devices[k].hasVirtualRGBAWDimmer then
            begin
              if ((devices[k].kanaltyp[tempvalue]='r') or
                (devices[k].kanaltyp[tempvalue]='g') or
                (devices[k].kanaltyp[tempvalue]='b') or
                (devices[k].kanaltyp[tempvalue]='a') or
                (devices[k].kanaltyp[tempvalue]='w') or
                (devices[k].kanaltyp[tempvalue]='uv') or
                (devices[k].kanaltyp[tempvalue]='c') or
                (devices[k].kanaltyp[tempvalue]='m') or
                (devices[k].kanaltyp[tempvalue]='y')) then
              begin
                // falls aktueller Kanal R,G,B,A,W, UV, C,M,Y und aktivierter VirtualDimmer, dann diesen berechnen
                virtualdimmerfaktor:=(geraetesteuerung.get_channel(devices[k].ID, 'DIMMER')/255)*((maxres-masterform.dimmermaster.position)/maxres);
                Value:=round(virtualdimmerfaktor*Integer(Data2));
              end;
              if (devices[k].kanaltyp[tempvalue]='dimmer') then
              begin
                // R,G,B,A,W,UV,C,M,Y aktualisieren
                geraetesteuerung.set_channel(devices[k].ID, 'r', -1, geraetesteuerung.get_channel(devices[k].ID, 'r'), 0);
                geraetesteuerung.set_channel(devices[k].ID, 'g', -1, geraetesteuerung.get_channel(devices[k].ID, 'g'), 0);
                geraetesteuerung.set_channel(devices[k].ID, 'b', -1, geraetesteuerung.get_channel(devices[k].ID, 'b'), 0);
                geraetesteuerung.set_channel(devices[k].ID, 'a', -1, geraetesteuerung.get_channel(devices[k].ID, 'a'), 0);
                geraetesteuerung.set_channel(devices[k].ID, 'w', -1, geraetesteuerung.get_channel(devices[k].ID, 'w'), 0);
                geraetesteuerung.set_channel(devices[k].ID, 'uv', -1, geraetesteuerung.get_channel(devices[k].ID, 'uv'), 0);
                geraetesteuerung.set_channel(devices[k].ID, 'c', -1, geraetesteuerung.get_channel(devices[k].ID, 'c'), 0);
                geraetesteuerung.set_channel(devices[k].ID, 'm', -1, geraetesteuerung.get_channel(devices[k].ID, 'm'), 0);
                geraetesteuerung.set_channel(devices[k].ID, 'y', -1, geraetesteuerung.get_channel(devices[k].ID, 'y'), 0);
              end;
            end;
          end else if ((devices[k].kanaltyp[tempvalue]='pan') or (devices[k].kanaltyp[tempvalue]='panfine') or (devices[k].kanaltyp[tempvalue]='tilt') or (devices[k].kanaltyp[tempvalue]='tiltfine')) then
          begin
            // Gerät nutzt bei aktuellem Kanal PAN(fine) oder TILT(fine)
            // finde Kanäle für PAN, PANFINE, TILT und TILTFINE
            panfinechan:=-1;
            tiltfinechan:=-1;
            for m:=0 to devices[k].MaxChan-1 do
            begin
              if (lowercase(devices[k].kanaltyp[m])='pan') then
                panchan:=m;
              if (lowercase(devices[k].kanaltyp[m])='tilt') then
                tiltchan:=m;
              if (lowercase(devices[k].kanaltyp[m])='panfine') then
                panfinechan:=m;
              if (lowercase(devices[k].kanaltyp[m])='tiltfine') then
                tiltfinechan:=m;
            end;

            if (panfinechan>-1) and (tiltfinechan>-1) then
            begin
              // Fine-Kanäle sind vorhanden
              // Punkt mit 16-Bit X/Y-Koordinaten erzeugen
              Px:=(maxres+(maxres/(maxres+1)))-(data.ch[devices[k].Startaddress+panchan]+(data.ch[devices[k].Startaddress+panfinechan]/(maxres+1)));
              Py:=(maxres+(maxres/(maxres+1)))-(data.ch[devices[k].Startaddress+tiltchan]+(data.ch[devices[k].Startaddress+tiltfinechan]/(maxres+1)));
            end else
            begin
              // keine Fine-Kanäle vorhanden
              // Punkt mit 8-Bit X/Y-Koordinaten erzeugen
              Px:=maxres-data.ch[devices[k].Startaddress+panchan];
              Py:=maxres-data.ch[devices[k].Startaddress+tiltchan];
            end;

            if (devices[k].typeofscannercalibration>0) then
            begin
              // Gerätekalibrierung dauerhaft anwenden
              // bilineare Interpolation durchführen
              P01x:=Px/maxres;
              P01y:=Py/maxres;
              valuex:=((1-P01x)*(1-P01y)*mainform.devices[k].ScannerCalibrations[mainform.devices[k].typeofscannercalibration].PointA.x+(1-P01x)*P01y*mainform.devices[k].ScannerCalibrations[mainform.devices[k].typeofscannercalibration].PointD.x+P01x*(1-P01y)*mainform.devices[k].ScannerCalibrations[mainform.devices[k].typeofscannercalibration].PointB.x+P01x*P01y*mainform.devices[k].ScannerCalibrations[mainform.devices[k].typeofscannercalibration].PointC.x);
              valuey:=((1-P01x)*(1-P01y)*mainform.devices[k].ScannerCalibrations[mainform.devices[k].typeofscannercalibration].PointA.y+(1-P01x)*P01y*mainform.devices[k].ScannerCalibrations[mainform.devices[k].typeofscannercalibration].PointD.y+P01x*(1-P01y)*mainform.devices[k].ScannerCalibrations[mainform.devices[k].typeofscannercalibration].PointB.y+P01x*P01y*mainform.devices[k].ScannerCalibrations[mainform.devices[k].typeofscannercalibration].PointC.y);
            end else
            begin
              valuex:=Px;
              valuey:=Py;
            end;

            if not devices[k].invertpan then
            begin
              if (lowercase(devices[k].kanaltyp[tempvalue])='pan') then
                Value:=trunc(valuex);
              if (lowercase(devices[k].kanaltyp[tempvalue])='panfine') then
                Value:=trunc(frac(valuex)*(maxres+1));
            end else
            begin
              if (lowercase(devices[k].kanaltyp[tempvalue])='pan') then
                Value:=maxres-trunc(valuex);
              if (lowercase(devices[k].kanaltyp[tempvalue])='panfine') then
                Value:=maxres-trunc(frac(valuex)*(maxres+1));
            end;
            if not devices[k].inverttilt then
            begin
              if (lowercase(devices[k].kanaltyp[tempvalue])='tilt') then
                Value:=trunc(valuey);
              if (lowercase(devices[k].kanaltyp[tempvalue])='tiltfine') then
                Value:=trunc(frac(valuey)*(maxres+1));
            end else
            begin
              if (lowercase(devices[k].kanaltyp[tempvalue])='tilt') then
                Value:=maxres-trunc(valuey);
              if (lowercase(devices[k].kanaltyp[tempvalue])='tiltfine') then
                Value:=maxres-trunc(frac(valuey)*(maxres+1));
            end;

            useCalibrationValue:=true;
          end;
          break;
        end;
      end;
    end;
    
    // Softpatch anwenden
    for i:=0 to length(softpatch)-1 do
    begin
      if softpatch[i].Channel=Data1 then
      begin
        for j:=0 to length(softpatch[i].RouteToInputChan)-1 do
        begin
          CallbackGetDLLValueEvent(softpatch[i].RouteToInputChan[j],FilterWithDimmcurve(Data1,Data2));
        end;
      end;
    end;
  end;

  // WORKAROUND FOR MEVP
  // Daten an 3D Visualizer senden
  if (MSG=MSG_ACTUALCHANNELVALUE) and (MEVPDLL<>0) and (@DasMevWriteDmx<>nil) and (Data1<=2048) then
  begin
    case ((Data1-1) div 512) of
      0:
      begin
        if useCalibrationValue then
        begin
          MEVPDLLDMXARRAY0[Integer(Data1-1)]:=Value;
        end else
        begin
          MEVPDLLDMXARRAY0[Integer(Data1-1)]:=FilterWithDimmcurve(Data1,Data2);
        end;

        DasMevWriteDmx(0, @MEVPDLLDMXARRAY0);
      end;
      1:
      begin
        if useCalibrationValue then
        begin
          MEVPDLLDMXARRAY1[Integer(Data1-1-512)]:=Value;
        end else
        begin
          MEVPDLLDMXARRAY1[Integer(Data1-1-512)]:=FilterWithDimmcurve(Data1,Data2);
        end;

        DasMevWriteDmx(1, @MEVPDLLDMXARRAY1);
      end;
      2:
      begin
        if useCalibrationValue then
        begin
          MEVPDLLDMXARRAY2[Integer(Data1-1-1024)]:=Value;
        end else
        begin
          MEVPDLLDMXARRAY2[Integer(Data1-1-1024)]:=FilterWithDimmcurve(Data1,Data2);
        end;

        DasMevWriteDmx(2, @MEVPDLLDMXARRAY2);
      end;
      3:
      begin
        if useCalibrationValue then
        begin
          MEVPDLLDMXARRAY3[Integer(Data1-1-1536)]:=Value;
        end else
        begin
          MEVPDLLDMXARRAY3[Integer(Data1-1-1536)]:=FilterWithDimmcurve(Data1,Data2);
        end;

        DasMevWriteDmx(3, @MEVPDLLDMXARRAY3);
      end;
    end;
  end;

  if (MSG=MSG_SETLANGUAGE) and (MEVPDLL<>0) and (@DasMevSetLanguage<>nil) then
  begin
    DasMevSetLanguage(Integer(Data1));
  end;

  // END OF WORKAROUND FOR MEVP
{
  // NEW CODE FOR MEVP
  // Daten an 3D Visualizer senden
  if (MSG=MSG_ACTUALCHANNELVALUE) and (mevp <> nil) and mevp.Running then
    if useCalibrationValue then
    begin
      mevp.SetChannel(Data1, Value);
    end else
    begin
      mevp.SetChannel(Data1, FilterWithDimmcurve(Data1,Data2));
    end;

  if (MSG = MSG_SETLANGUAGE) and (mevp <> nil) then
    mevp.Language := Data1;

  // END OF NEW CODE FOR MEVP
}

  // Ausgabeplugins bedienen
  for i:=0 to length(OutputPlugins)-1 do
  begin
    if OutputPlugins[i].IsActive then
	  begin
      case MSG of
        MSG_ACTUALCHANNELVALUE:
        begin
          if (Integer(Data1)>=OutputPlugins[i].Startaddress) and (Integer(Data1)<=OutputPlugins[i].Stopaddress) and
            ((Integer(Data1)-OutputPlugins[i].Startaddress+1)>=1) and ((Integer(Data1)-OutputPlugins[i].Startaddress+1)<=8192) then
          begin
            if useCalibrationValue then
            begin
              OutputPlugins[i].SendMessage(MSG, Data1-OutputPlugins[i].Startaddress+1, Value);
            end else
            begin
              OutputPlugins[i].SendMessage(MSG, Data1-OutputPlugins[i].Startaddress+1, FilterWithDimmcurve(Data1,Data2));
            end;
          end;
        end else
        begin
          OutputPlugins[i].SendMessage(MSG, Data1, Data2);
        end;
      end;
    end;
  end;
end;

procedure TMainform.input_number(var pos:integer; var s:string);
var
  i:integer;
begin
  i:=1;
  while i<=length(s) do
    begin
      if (s[i]<'0') or (s[i]>'9') then
        begin
          delete(s,i,1);
          dec(pos);
        end
      else
        inc(i);
    end;
end;

procedure TMainform.Exit1Click(Sender: TObject);
begin
  Close;
end;

procedure TMainform.DefaultSettings1Click(Sender: TObject);
begin
  if messagedlg(_('Möchten Sie wirklich alle Einstellungen des PC_DIMMERs zurücksetzen?'),mtWarning,
  [mbYes,mbNo],0)=mrYes then
    pcdimmerreset(Sender);
end;

procedure TMainform.About1Click(Sender: TObject);
begin
  if AboutBox=nil then
    AboutBox:=TAboutBox.Create(AboutBox);

  aboutbox.Version.Caption:=GetFileVersionBuild(paramstr(0))+' (' + osversion + ')';
  Aboutbox.showmodal;

  Aboutbox.Free;
  Aboutbox:=nil;
end;

procedure TMainform.FormClose(Sender: TObject; var Action: TCloseAction);
var
  i:integer;
  funccall:function:boolean; stdcall;
  LReg:TPCDRegistry;
begin
  if switchofflightsatshutdown then
  begin
    for i:=1 to lastchan do
      senddata(i, -1, 255, 0);
  end;

  SetPriorityClass(GetCurrentProcess, NORMAL_PRIORITY_CLASS);

  SaveWindowPositions('all');

  inprogress.label8.Caption:=_(' Beende PC_DIMMER... ');
  inprogress.ProgressBar1.Max:=100;
  inprogress.Label1.caption:='';
  inprogress.Label2.caption:='';
  inprogress.Show;
  inprogress.Refresh;

  application.processmessages;
  inprogress.filename.Caption:=_('Bereite Shutdown vor...');
  inprogress.ProgressBar1.Position:=0;
  inprogress.Refresh;

  shutdown:=true;

  // Fenster schließen

  if DimmerkernelQueueForm<>nil then
    if DimmerkernelQueueForm.Showing then
      DimmerkernelQueueForm.close;
  if szenenverwaltung_formarray[0].Showing then
   szenenverwaltung_formarray[0].close;
  if videoscreenform<>nil then
    if videoscreenform.Showing then
      videoscreenform.close;
  if cdplayerform<>nil then
    if cdplayerform.Showing then
    begin
      mainform.SaveWindowPositions('cdplayer');
      cdplayerform.shutdown:=true;
      cdplayerform.Close;
    end;
  if (tippoftheday<>nil) and (tippoftheday.showing) then
    tippoftheday.Close;

  if projektverwaltung.showing then
    projektverwaltung.close;
  if beatform.showing then
    beatform.close;
  if kontrollpanel.showing then
    kontrollpanel.close;
  if effektsequenzer.showing then
    effektsequenzer.close;
  if geraetesteuerung.showing then
    geraetesteuerung.close;
  if grafischebuehnenansicht.showing then
    grafischebuehnenansicht.close;
  if submasterform.showing then
    submasterform.close;
  if joystickform.showing then
    joystickform.close;
  if joysticksetupform.showing then
    joysticksetupform.close;
  if schedulerform.showing then
    schedulerform.close;
  if editmidieventfrm.showing then
    editmidieventfrm.close;
  if midieventfrm.showing then
    midieventfrm.close;
  if figureneditorform.showing then
    figureneditorform.close;
  if bewegungsszeneneditorform.showing then
    bewegungsszeneneditorform.close;
  if askforremovingform.showing then
    askforremovingform.close;
  if firststepsform.showing then
    firststepsform.close;
  if Tastenabfrage.showing then
    Tastenabfrage.close;
  if editskriptfrm.showing then
    editskriptfrm.close;
  if audioszeneneditor.showing then
    audioszeneneditor.close;
  if ActionDlg.showing then
    ActionDlg.close;
  if insscenedlg.showing then
    insscenedlg.close;
  if OptionenBox.showing then
    OptionenBox.close;
  if preseteditor.showing then
    preseteditor.close;
  if dataineventfrm.showing then
    dataineventfrm.close;
  if editdataineventfrm.showing then
    editdataineventfrm.close;
  if ddfeditorform.showing then
    ddfeditorform.close;
  if compileerrorform.showing then
    compileerrorform.close;
  if devicesceneform.showing then
    devicesceneform.close;
  if dimmcurveform.showing then
    dimmcurveform.close;
  if devicepowerform.showing then
    devicepowerform.close;
  if devicepicturechangeform.showing then
    devicepicturechangeform.close;
  if autoszeneform.showing then
    autoszeneform.close;
  if colormanagerform.showing then
    colormanagerform.close;
  if mediacenterform.showing then
    mediacenterform.close;
  if ownmessageform.showing then
    ownmessageform.close;
  if accumessageform.showing then
    accumessageform.close;
  if scannersynchronisationform.showing then
    scannersynchronisationform.close;
  if timecodeplayerform.showing then
    timecodeplayerform.close;
  if videoscreensynchronisierenform.showing then
    videoscreensynchronisierenform.close;
  if layerbezeichnungenform.showing then
    layerbezeichnungenform.close;
  if kanaluebersichtform.showing then
    kanaluebersichtform.close;
  if codeeditorform.showing then
    codeeditorform.close;
  if addfunctionform.showing then
    addfunctionform.close;
  if clockform.showing then
    clockform.close;
  if ProgressScreenSmall.showing then
    ProgressScreenSmall.close;
  if textbuchform.showing then
    textbuchform.close;
  if scenenotfoundform.showing then
    scenenotfoundform.close;
  if devicechannelselectionform.showing then
    devicechannelselectionform.close;
  if cuelistform.showing then
    cuelistform.close;
  if masterform.showing then
    masterform.close;
  if DDFWindowDeviceScene.showing then
    DDFWindowDeviceScene.close;
  if audioeffektplayerform.showing then
    audioeffektplayerform.close;
  if groupeditorform.showing then
    groupeditorform.close;
  if adddevicetogroupform.showing then
    adddevicetogroupform.close;
  if winlircform.showing then
    winlircform.close;
  if sidebarform.showing then
    sidebarform.close;
  if sidebarselectform.showing then
    sidebarselectform.close;
  if leistungssteuerungform2.showing then
    leistungssteuerungform2.close;
  if audioeffektplayerstretchform.showing then
    audioeffektplayerstretchform.close;
  if lauflichtassistentform.showing then
    lauflichtassistentform.close;
  if matrixeditorform.showing then
    matrixeditorform.close;
  if lauflichtassistentownpatternform.showing then
    lauflichtassistentownpatternform.close;
  if lockedform.showing then
    lockedform.close;
  if devicelistform.showing then
    devicelistform.close;
  if faderpanelform.showing then
    faderpanelform.close;
  if picturechangeform.showing then
    picturechangeform.close;
  if ambilightform.showing then
    ambilightform.close;
  if pmmform.showing then
    pmmform.close;
  if touchscreenform.showing then
    touchscreenform.close;
  if ddfeditorassistantform.showing then
    ddfeditorassistantform.close;
  if dynguiform.showing then
    dynguiform.close;
  if audiomanagerform.showing then
    audiomanagerform.close;
  if presetsceneeditor.showing then
    presetsceneeditor.close;
  if nodecontrolform.showing then
    nodecontrolform.close;
  if xtouchcontrolform.showing then
    xtouchcontrolform.close;
  if elgatostreamdeckform.showing then
    elgatostreamdeckform.close;

  // WORKAROUND FOR MEVP
  // 3D Visualizer schließen und freigeben
  if (MEVPDLL<>0) then
  begin
    if Assigned(DasMevClose) then
      DasMevClose();

    DasMevAreFixturesModified:=nil;
    DasMevClose:=nil;
    DasMevCommand:=nil;
    DasMevGetFixtureParam:=nil;
    DasMevGetFixturesCount:=nil;
    DasMevGetLanguage:=nil;
    DasMevGetSupportedDeviceTypes:=nil;
    DasMevGetVersion:=nil;
    DasMevIsOpened:=nil;
    DasMevIsUsingDasHard:=nil;
    DasMevSetLanguage:=nil;
    DasMevSetSupportedDeviceTypes:=nil;
    DasMevStart:=nil;
    DasMevWriteDmx:=nil;
    FreeLibrary(MEVPDLL);
    MEVPDLL:=0;
  end;
  // END OF WORKAROUND FOR MEVP

  // 3D Visualizer schließen und freigeben
  mevp.Destroy;

  for i:=0 to length(szenenverwaltung_formarray)-1 do
  begin
    szenenverwaltung_formarray[i].Free;
  end;
  setlength(szenenverwaltung_formarray,0);

  DebugAdd('', false, false);
  DebugAdd('----------------------------------------------------------------------------', false);
  DebugAdd('SHUTDOWN: Closing Timers...');

  // Timer beenden
  AutoFader.Enabled:=false;
  BewegungsszenenTimer.Enabled:=false;
  audioeffektplayerform.audioeffekttimer.Enabled:=false;
  audioeffektplayerform.audioeffektplaytimer.Enabled:=false;
  Uhrzeit_Timer.Enabled:=false;
  Timer1.Enabled:=false;
  Optotimer.Enabled:=false;
  schedulerform.Skripttimer_timer.Enabled:=false;
  joystickform.JoystickTimer.enabled:=false;
  kontrollpanel.beattime_blinker.enabled:=false;
  kontrollpanel.CheckFileExists.enabled:=false;
  insscenedlg.ChangedChannels.enabled:=false;
  bewegungsszeneneditorform.Repaint.Enabled:=false;
  bewegungsszeneneditorform.BewegungsszeneTimer.enabled:=false;
  grafischebuehnenansicht.RefreshTimer.enabled:=false;
  AkkuTimer.Enabled:=false;
  ShortCutChecker.Enabled:=false;
  MidiCallbackTimer.Enabled:=false;
  MainformScreenRefreshTimer.Enabled:=false;
  leistungssteuerungform2.Timer2.enabled:=false;
  ElgatoStreamDeckForm.ElgatoStreamDeckTimer.Enabled:=false;
  ElgatoStreamDeckForm.ElgatoStreamDeckDisplayTimer.Enabled:=false;

  DebugAddToLine(' - OK', false);
  DebugAdd('SHUTDOWN: Sending Close-Message...');

  _killthreads:=true;
  _killanimation:=true;
  _KillBuehnenansicht:=true;
  _killaccu := true;

  // Letzte Werte in Datei speichern (bei Switchlightoffatshutown alle auf 0%)
  DebugAdd('SHUTDOWN: Saving current DMX-values...');
  CreateValueBackup;

  BASS_CD_Door(curdrive, BASS_CD_DOOR_UNLOCK);

  // Live Audio-In deaktivieren
  AudioIn.StopAtOnce;
  StopMIDI(nil);
  joystickform.gcp.Free;

  inprogress.filename.Caption:=_('Schreibe Konfigurationsdatei...');
  inprogress.ProgressBar1.Position:=81;
  inprogress.ProgressBar1.Position:=80;
  inprogress.Refresh;

  DebugAdd('SHUTDOWN: Writing Configurationsfile...');
// alle Infos in die Konfigurationssoftware schreiben

  LReg := TPCDRegistry.Create;
  if LReg.OpenRegKey('') then
  begin
    LReg.WriteBool('Audioeffectplayer Two-Color-Waveform',audioeffektplayerform.Wavedarstellungzweifarbig1.Checked);
    LReg.WriteString('Last projectfile',project_file);
    LReg.WriteBool('Show TipOfDay',showtipofday);
    LReg.WriteBool('Show FirstSteps',showfirststeps);
    LReg.WriteBool('Enable HotKeys',EnableHotKeys);
    LReg.WriteBool('Enable Joystick',EnableJoystick);
    LReg.WriteBool('Enable DataIn',DataInActiveRibbonBox.Down);
    LReg.WriteBool('Enable Powermanagement',usepowermanagement);
//  LReg.WriteInteger('Errorhandlingmode',errorhandlingmode);
    LReg.WriteInteger('Processpriority',mainpriority);
    LReg.WriteString('Language',ActualLanguage);
    LReg.WriteBool('Running',false);
    LReg.WriteInteger('PosX',mainform.Left);
    LReg.WriteInteger('PosY',mainform.Top);
    LReg.WriteBool('Insert Username into Project automaticly',autoinsertcomputerusername);
    LReg.WriteInteger('Keyboardinterval',ShortCutChecker.Interval);
    LReg.WriteInteger('Refresh_Main',Rfr_Main);
    LReg.WriteInteger('Refresh_AEP',Rfr_AEP);
    LReg.WriteInteger('Refresh_Buehnenansicht',Rfr_Buehnenansicht);
    LReg.WriteInteger('Refresh_Cuelist',Rfr_Cuelist);
    LReg.WriteInteger('Refresh_Faderpanel',Rfr_Faderpanel);
    LReg.WriteInteger('Refresh_Kanaluebersicht',Rfr_Kanaluebersicht);
    LReg.WriteInteger('Refresh_Kontrollpanel',Rfr_Kontrollpanel);
    LReg.WriteInteger('Refresh_KontrollpanelCheckForActive',Rfr_KontrollpanelCheckForActive);
    LReg.WriteInteger('Refresh_Submaster',Rfr_Submaster);
    LReg.WriteBool('Start HTTP-Server',FHTTPServer.Active);
    LReg.WriteBool('Start MQTT-Client',MQTTClientActivateRibbonBox.Down);
    LReg.WriteInteger('Beatsource',lastbeatsource);
    LReg.WriteString('Last Midi Inputdevices',lastmidiinputdevices);
    LReg.WriteString('Last Midi Outputdevices',lastmidioutputdevices);
    LReg.WriteInteger('Midi Backtrack Interval',MidiCallbackTimer.Interval);
    LReg.WriteBool('Small Windowstyle',mainpanel.Visible);

    LReg.WriteInteger('Number of Useraccounts', length(UserAccounts));
    for i:=0 to length(UserAccounts)-1 do
    begin
      LReg.WriteBinaryData('UserAccount '+inttostr(i)+' ID', UserAccounts[i].ID, sizeof(UserAccounts[i].ID));
      LReg.WriteBinaryData('UserAccount '+inttostr(i)+' Name', UserAccounts[i].Name, sizeof(UserAccounts[i].Name));

      with TCipher_Blowfish.Create do
      try
        Init(blowfishscramblekey);
        UserAccounts[i].PasswordScrambled:=EncodeBinary(UserAccounts[i].Password, TFormat_Copy);
      finally
        Free;
      end;

      LReg.WriteBinaryData('UserAccount '+inttostr(i)+' Password', UserAccounts[i].PasswordScrambled, sizeof(UserAccounts[i].PasswordScrambled));
      LReg.WriteBinaryData('UserAccount '+inttostr(i)+' AccessLevel', UserAccounts[i].AccessLevel, sizeof(UserAccounts[i].AccessLevel));
    end;
    
    LReg.CloseKey;
  end;
  LReg.Free;

  WriteConfiguration;
  DebugAddToLine(' - OK');

// Power-Switch am Computer-Gehäuse wieder aktivieren
  powerbutton1.PowerOffEnable:=true;
// Bildschirmhelligkeit wiederherstellen
    if strtoint(brightnesseditribbon.text)<>128 then
      repeat
        if strtoint(brightnesseditribbon.text)<128 then
          brightnesseditribbon.text:=inttostr(strtoint(brightnesseditribbon.text)+3);
        if strtoint(brightnesseditribbon.text)>128 then
          brightnesseditribbon.text:=inttostr(strtoint(brightnesseditribbon.text)-3);
      until ((strtoint(brightnesseditribbon.text)>120) and (strtoint(brightnesseditribbon.text)<136));


  // Program-Plugins deaktivieren
  DebugAdd('SHUTDOWN: Deactivating Input-Plugins...');
  if deactivateinputdllsonclose then
  begin
    for i:=0 to length(ProgramPlugins)-1 do
    begin
      funccall := GetProcAddress(ProgramPlugins[i].Handle,'DLLDestroy');
      if not Assigned(funccall) then
        funccall := GetProcAddress(ProgramPlugins[i].Handle,'DLLDeactivate');
      if Assigned(funccall) then
      begin
        inprogress.filename.Caption:=_('Deaktiviere Input-Plugin ')+ProgramPlugins[i].Filename;
        inprogress.ProgressBar1.Position:=41;
        inprogress.ProgressBar1.Position:=40;
        inprogress.Refresh;
        DebugAdd('SHUTDOWN: Deactivating Plugin '+ProgramPlugins[i].Filename);
        if funccall then
        begin
          DebugAddToLine(' - OK');
        end else
        begin
          ShowMessage('Das Plugin "'+ProgramPlugins[i].Filename+'" hat einen Fehler beim Deaktivieren gemeldet.');
          DebugAddToLine(' - ERROR');
        end;
//	        FreeLibrary(InputDLL[i]);
      end else
      begin
        DebugAddToLine(' - ERROR');
//	        FreeLibrary(InputDLL[i]);
      end;
    end;
    DebugAdd('SHUTDOWN: -----------------------------------', false);
  end else
  begin
    ShowMessage(_('Hinweis: Das Deaktivieren der Programmplugins ist in den Optionen deaktiviert.'+#13+'Dies ist nur für Testzwecke zu empfehlen. Bitte die Einstellungen kontrollieren.'));
    DebugAdd('SHUTDOWN: Deactivating all Inputplugins disabled...', false);
  end;

// Output-Plugin deaktivieren
  DebugAdd('SHUTDOWN: Deactivating Output-Plugins...');
  if deactivateoutputdllsonclose then
  begin
    for i:=0 to length(OutputPlugins)-1 do
    begin
      FuncCall := GetProcAddress(OutputPlugins[i].Handle,'DLLDestroy');
      if not Assigned(FuncCall) then
        FuncCall := GetProcAddress(OutputPlugins[i].Handle,'DLLDeactivate');
      try
        if Assigned(funccall) then
        begin
          inprogress.filename.Caption:=_('Deaktiviere Output-Plugin ')+OutputPlugins[i].Filename;
          inprogress.ProgressBar1.Position:=61;
          inprogress.ProgressBar1.Position:=60;
          inprogress.Refresh;
          DebugAdd('SHUTDOWN: Deactivating Plugin '+OutputPlugins[i].Filename);
          if funccall then
          begin
            DebugAddToLine(' - OK');
          end else
          begin
            ShowMessage(_('Das Plugin "')+OutputPlugins[i].Filename+_('" hat einen Fehler beim Deaktivieren gemeldet.'));
            DebugAddToLine(' - ERROR');
          end;
        end;
      except
      end;
    end;
    DebugAdd('SHUTDOWN: -----------------------------------');
  end else
  begin
    ShowMessage(_('Hinweis: Das Deaktivieren der Ausgabeplugins ist in den Optionen deaktiviert.'+#13+'Dies ist nur für Testzwecke zu empfehlen. Bitte die Einstellungen kontrollieren.'));
    DebugAdd('SHUTDOWN: Deactivating Outputplugins disabled...', false);
    DebugAdd('SHUTDOWN: Closing Audio-, Joystick- and MIDI-Input...');
  end;

  // Pluginreferenzen entfernen
  if deactivateinputdllsonclose or deactivateoutputdllsonclose then
  begin
    inprogress.filename.Caption:=_('Entferne DLL-Referenzen...');
    inprogress.ProgressBar1.Position:=91;
    inprogress.ProgressBar1.Position:=90;
    inprogress.Refresh;
    DebugAdd('SHUTDOWN: Freeing DLLs...');

    DebugAddToLine('OutputDLLs...', false);
    for i:=0 to length(OutputPlugins)-1 do
      FreeLibrary(OutputPlugins[i].Handle);

    DebugAddToLine('ProgramDLLs...', false);
    for i:=0 to length(ProgramPlugins)-1 do
      FreeLibrary(ProgramPlugins[i].Handle);

    DebugAddToLine(' - OK');
  end;

  inprogress.filename.Caption:=_('Entferne Fenster...');
  inprogress.ProgressBar1.Position:=95;
  inprogress.Refresh;

  // Wait for accu thread to stop
  inprogress.filename.Caption:=_('Stoppe Akku-Thread...');
  inprogress.ProgressBar1.Position:=97;
  inprogress.Refresh;
  WaitForSingleObject(accuThread.Handle, 4000);
  inprogress.filename.Caption:=_('Stoppe Helper-Thread...');
  inprogress.ProgressBar1.Position:=98;
  inprogress.Refresh;
  WaitForSingleObject(HelperThread.Handle, 4000);

  // Fenster löschen

  if DimmerkernelQueueForm<>nil then
    DimmerkernelQueueForm.free;
  if videoscreenform<>nil then
    videoscreenform.free;
  if cdplayerform<>nil then
    cdplayerform.free;
  if (tippoftheday<>nil) then
    tippoftheday.free;

  projektverwaltung.free;
  beatform.free;
  kontrollpanel.free;
  effektsequenzer.free;
  geraetesteuerung.free;
  grafischebuehnenansicht.free;
  submasterform.free;
  joystickform.free;
  joysticksetupform.free;
  schedulerform.free;
  editmidieventfrm.free;
  midieventfrm.free;
  figureneditorform.free;
  bewegungsszeneneditorform.free;
  askforremovingform.free;
  firststepsform.free;
  Tastenabfrage.free;
  editskriptfrm.free;
  audioszeneneditor.free;
  ActionDlg.free;
  insscenedlg.free;
  OptionenBox.free;
  preseteditor.free;
  dataineventfrm.free;
  editdataineventfrm.free;
  ddfeditorform.free;
  compileerrorform.free;
  devicesceneform.free;
  dimmcurveform.free;
  devicepowerform.free;
  devicepicturechangeform.free;
  autoszeneform.free;
  colormanagerform.free;
  mediacenterform.free;
  ownmessageform.free;
  accumessageform.free;
  scannersynchronisationform.free;
  timecodeplayerform.free;
  videoscreensynchronisierenform.free;
  layerbezeichnungenform.free;
  kanaluebersichtform.free;
  codeeditorform.free;
  addfunctionform.free;
  clockform.free;
  ProgressScreenSmall.free;
  textbuchform.free;
  scenenotfoundform.free;
  devicechannelselectionform.free;
  cuelistform.free;
  masterform.free;
  DDFWindowDeviceScene.free;
  audioeffektplayerform.free;
  groupeditorform.free;
  adddevicetogroupform.free;
  winlircform.free;
  sidebarform.free;
  sidebarselectform.free;
  leistungssteuerungform2.free;
  audioeffektplayerstretchform.free;
  lauflichtassistentform.free;
  matrixeditorform.free;
  lauflichtassistentownpatternform.free;
  lockedform.free;
  devicelistform.free;
  faderpanelform.free;
  picturechangeform.free;
  ambilightform.free;
  pmmform.free;
  touchscreenform.free;
  ddfeditorassistantform.free;
  dynguiform.free;
  audiomanagerform.free;
  presetsceneeditor.free;
  nodecontrolform.free;
  usermgmtform.free;
  xtouchcontrolform.Free;
  elgatostreamdeckform.Free;

  // Finito :)

  inprogress.filename.Caption:=_('Beende Programm...');
  inprogress.ProgressBar1.Position:=100;
  inprogress.Refresh;

  // Eigene Fehlerbehandlung schließen
  Application.OnException := nil;
  exceptionform.Free;

  DebugAdd('----------------------------------------------------------------------------', false);
  DebugAdd('PC_DIMMER closed successfully - Goodbye :D');

  inprogress.close;
  inprogress.free;
end;

function TMainform.pcdimmerreset(Sender: TObject):boolean;
var
	i:integer;
begin
  DebugAdd('SETUP: Processing PC_DIMMER reset...');

  for i:=0 to length(OutputPlugins)-1 do
  begin
    OutputPlugins[i].Startaddress:=1;
    OutputPlugins[i].Stopaddress:=512;
    OutputPlugins[i].IsActive:=false;
    OutputPlugins[i].IsEnabled:=false;
  end;

  for i:=0 to 4 do
    data.openhistory[i]:='';

  openhistory1ribbon.Visible:=ivNever;
  openhistory2ribbon.Visible:=ivNever;
  openhistory3ribbon.Visible:=ivNever;
  openhistory4ribbon.Visible:=ivNever;
  openhistory5ribbon.Visible:=ivNever;

  dxBarApplicationMenu1.ExtraPane.Items.Clear;

// Optionen zurücksetzen
  startupwitholdscene:=True;
  switchofflightsatshutdown:=true;
  powerswitchoff:=true;
  lastchan:=512;
  askforsaveproject:=false;
  levelanzeigeoptionen:=0;
  sounddevicespeakers:=1;
  showlastplugins:=true;
  showakkuwarnings:=true;
  deactivateoutputdllsonclose:=true;
  deactivateinputdllsonclose:=true;
  showlastplugins:=true;
  showakkuwarnings:=true;
  blendoutforms:=false;
  errorhandlingmode:=0;
  Autobackupcounter:=0;
  autobackupcountermax:=10;
  animationtimer:=0;
  flashscrolllockled:=false;
  Autobackuptimer.Enabled:=Autobackupcountermax>0;
  autolocktime:=0;
  autolockcode:='';
  autologouttime:=0;
  MBS_Online:=false;
  MBS_MSGon:=144;
  MBS_MSGoff:=144;
  MBS_Data1on:=64;
  MBS_Data1off:=64;
  MBS_Data2on:=127;
  MBS_Data2off:=0;

  DebugAdd('SETUP: Writing values into registry...');
  WriteSettingsToRegistry;
  DebugAdd('SETUP: Writing values into registry successful...');

  // Daten in der Konfigurationsdatei speichern
  WriteConfiguration;

  DebugAdd('SETUP: PC_DIMMER reset successful.', false);
  DebugAdd('', true, false);

  result:=true;
end;

procedure Tmainform.NewProject(PreserveValues: boolean=false);
var
	i:integer;
  LReg:TPCDRegistry;
begin
  if not UserAccessGranted(2) then exit;

  projekttitel:=_('Neues Projekt');
  projektversion:='1.0';
  projektbearbeiter:=JvComputerInfoEx1.Identification.LocalUserName;
  projektdatum:=DateToStr(now);
  projektuhrzeit:=TimeToStr(now);
  projektspeicheranzahl:='0';

  pcdimmerresetting:=true;

	// Alle Plugins resetten
	SendMSG(MSG_NEW,0,0);

  // Oberfläche resetten
  mainform.Caption:=maincaption+_(' - [Neues Projekt]');
  fastsaved:=false;

  // Alle Fenster schließen
  effekttimeline_isplaying:=false; // Effekttimeline anhalten
  if audioeffektplayerform.StopEffektaudio.Enabled then audioeffektplayerform.StopEffektaudio.Click; // Audioeffektplayer anhalten

//  project_folder:='';
  project_folder:=userdirectory+'ProjectTemp\';
  project_file:='';

  LReg := TPCDRegistry.Create;
  if LReg.OpenRegKey('') then
  begin
    LReg.WriteString('Last projectfile','');
    LReg.CloseKey;
  end;
  LReg.Free;

//    audioeffektplayerform.audioeffekttimer.Enabled:=false;
  BASS_ChannelStop(audioeffektplayerform._chan[0]);
  BASS_ChannelStop(audioeffektplayerform._chan[1]);
  BASS_ChannelStop(audioeffektplayerform._chan[2]);
  BASS_ChannelStop(audioeffektplayerform._chan[3]);
  BASS_StreamFree(audioeffektplayerform._chan[0]);
  BASS_StreamFree(audioeffektplayerform._chan[1]);
  BASS_StreamFree(audioeffektplayerform._chan[2]);
  BASS_StreamFree(audioeffektplayerform._chan[3]);
  BASS_StreamFree(audioeffektplayerform._decodechan);
  audioeffektplayerform._chan[0]:=0;
  audioeffektplayerform._chan[1]:=0;
  audioeffektplayerform._chan[2]:=0;
  audioeffektplayerform._chan[3]:=0;
  BASS_Free;

	audioeffektplayerform.layerbox.ItemIndex:=0;

  if not PreserveValues then
  begin
    for i:=1 to lastchan do
    begin
      changedchannels[i]:=false;
      channel_dimmcurve[i]:=0;
      channel_minvalue[i]:=0;
      channel_maxvalue[i]:=maxres;
      data.Names[i]:=_('Kanal ')+inttostr(i);
      data.ch[i]:=maxres;
    end;
  end;

  schedulerform.skripttimer_listbox.Clear;
  setlength(AblaufTimer,0);

	// Audioeffektplayer zurücksetzen
  // gesamte Arrays auf Null setzen
  setlength(effektaudio_record,0);
  // 'Neue Audiodatei...' setzen
  audioeffektplayerform.audioeffektfilenamebox.Clear;
  audioeffektplayerform.audioeffektfilenamebox.ItemIndex:=audioeffektplayerform.audioeffektfilenamebox.Items.Add(_('Neue Audiodatei...'));
  audioeffektplayerform.Button18.Enabled:=false;
  audioeffektplayerform.button21.Enabled:=false;
  audioeffektplayerform.layerbox.ItemIndex:=0;
  audioeffektplayerform.layerboxChange(nil);
  audioeffektplayerform.Check_audioeffektbuttons();

  ShortCutChecker.Enabled:=false;
  sleep(100);

  // Arrays auf Null
  setlength(SendValueOfSelectedDevicesToMidi,0);

  setlength(Figuren,0);
  setlength(EinfacheSzenen,0);
  setlength(Audioszenen,0);
  setlength(AudioszenenCHAN,0);
  setlength(Bewegungsszenen,0);
  setlength(BewegungsszenenZeit,0);
  setlength(BewegungsszenenAktiv,0);
  setlength(Befehle2,0);
  setlength(Kompositionsszenen,0);
  setlength(effektsequenzereffekte,0);
  setlength(Devices,0);
  setlength(DeviceSelected,0);
  setlength(Devicepresets,0);
  setlength(DeviceGroups,0);
  setlength(DeviceScenes,0);
  setlength(MediaCenterSzenen,0);
  setlength(PluginSzenen,0);
  setlength(Submasterfader,16);
//  setlength(submasterform.scrollbarvalue,16);
  setlength(cuelistbank,0);
  setlength(MidiEventArray,0);
  setlength(DataInEventArray,0);
  setlength(OldTastencodeArray,0);
  setlength(TastencodeArray,0);
  setlength(TastencodePressedArray,0);
  Tastenabfrage.RestoreDefautKeymap;
  setlength(buehnenansichtdevices,0);
  setlength(softpatch,0);
  setlength(softpatch2,0);
  setlength(Effektsequenzereffekte,0);
  setlength(AktuellerEffekt,0);
  setlength(PluginSzenen,0);
  setlength(CodeScenes,0);

  setlength(Autoszenen,6);
//////////////////////
// Standard-Autoszenen erstellen
  CreateGUID(Autoszenen[0].ID);
  Autoszenen[0].Name:=_('Rot');
  Autoszenen[0].Beschreibung:=_('Setzt alle Geräte mit aktiviertem Autoscening auf Rot');
  Autoszenen[0].fadetime:=3000;
  Autoszenen[0].R:=255;
  Autoszenen[0].G:=0;
  Autoszenen[0].B:=0;
  Autoszenen[0].A:=0;
  Autoszenen[0].W:=0;
  Autoszenen[0].accuracy:=1;
  Autoszenen[0].helligkeit:=255;

  CreateGUID(Autoszenen[1].ID);
  Autoszenen[1].Name:=_('Grün');
  Autoszenen[1].Beschreibung:=_('Setzt alle Geräte mit aktiviertem Autoscening auf Grün');
  Autoszenen[1].fadetime:=3000;
  Autoszenen[1].R:=0;
  Autoszenen[1].G:=255;
  Autoszenen[1].B:=0;
  Autoszenen[1].A:=0;
  Autoszenen[1].W:=0;
  Autoszenen[1].accuracy:=1;
  Autoszenen[1].helligkeit:=255;

  CreateGUID(Autoszenen[2].ID);
  Autoszenen[2].Name:=_('Blau');
  Autoszenen[2].Beschreibung:=_('Setzt alle Geräte mit aktiviertem Autoscening auf Blau');
  Autoszenen[2].fadetime:=3000;
  Autoszenen[2].R:=0;
  Autoszenen[2].G:=0;
  Autoszenen[2].B:=255;
  Autoszenen[2].A:=0;
  Autoszenen[2].W:=0;
  Autoszenen[2].accuracy:=1;
  Autoszenen[2].helligkeit:=255;

  CreateGUID(Autoszenen[3].ID);
  Autoszenen[3].Name:=_('Gelb');
  Autoszenen[3].Beschreibung:=_('Setzt alle Geräte mit aktiviertem Autoscening auf Gelb');
  Autoszenen[3].fadetime:=3000;
  Autoszenen[3].R:=255;
  Autoszenen[3].G:=255;
  Autoszenen[3].B:=0;
  Autoszenen[3].A:=0;
  Autoszenen[3].W:=0;
  Autoszenen[3].accuracy:=1;
  Autoszenen[3].helligkeit:=255;

  CreateGUID(Autoszenen[4].ID);
  Autoszenen[4].Name:=_('Orange');
  Autoszenen[4].Beschreibung:=_('Setzt alle Geräte mit aktiviertem Autoscening auf Orange');
  Autoszenen[4].fadetime:=3000;
  Autoszenen[4].R:=255;
  Autoszenen[4].G:=127;
  Autoszenen[4].B:=0;
  Autoszenen[4].A:=0;
  Autoszenen[4].W:=0;
  Autoszenen[4].accuracy:=1;
  Autoszenen[4].helligkeit:=255;

  CreateGUID(Autoszenen[5].ID);
  Autoszenen[5].Name:=_('Violett');
  Autoszenen[5].Beschreibung:=_('Setzt alle Geräte mit aktiviertem Autoscening auf Violett');
  Autoszenen[5].fadetime:=3000;
  Autoszenen[5].R:=127;
  Autoszenen[5].G:=0;
  Autoszenen[5].B:=255;
  Autoszenen[5].A:=0;
  Autoszenen[5].W:=0;
  Autoszenen[5].accuracy:=1;
  Autoszenen[5].helligkeit:=255;
//////////////////////

  grafischebuehnenansicht.NewPanel;
  submasterform.NewFile;
  kontrollpanel.MSGNew;
  effektsequenzer.NewFile;
  geraetesteuerung.NewFile;
  textbuchform.MSGNew;
  cuelistform.MSGNew;
  TimeCodePlayerForm.NewFile;
  winlircform.MSGNew;
  nodecontrolform.MSGNew;
  joystickform.MSGNew;
  beatform.MSGNew;
  xtouchcontrolform.MSGNew;
  elgatostreamdeckform.MSGNew;

  for i:=0 to 31 do
  begin
    FFTDataIn[i].Active:=false;
    FFTDataIn[i].Channel:=1;
    FFTDataIn[i].Faktor:=255;
  end;
  BeatImpuls.Active:=false;
  BeatImpuls.Channel:=400;
  BeatImpuls.OnValue:=255;
  BeatImpuls.OffValue:=0;
  BeatImpuls.SceneOnBeatLost:=StringToGUID('{00000000-0000-0000-0000-000000000000}');
  BeatImpuls.SceneOnBeatStart:=StringToGUID('{00000000-0000-0000-0000-000000000000}');
  BeatImpuls.Timeout:=5;
  BeatImpuls.SendVolumeToDataIn:=false;
  BeatImpuls.SendVolumeToDataInChannel:=401;

  ShortCutChecker.Enabled:=true;

  pcdimmerresetting:=false;

  // MidiEvent Form zurücksetzen
  midieventfrm.MIDIGrid.RowCount:=2;
  midieventfrm.MIDIGrid.cells[0,1]:='';
  midieventfrm.MIDIGrid.cells[1,1]:='';
  midieventfrm.MIDIGrid.cells[2,1]:='';
  midieventfrm.MIDIGrid.cells[3,1]:='';
  midieventfrm.MIDIGrid.cells[4,1]:='';
  midieventfrm.MIDIGrid.cells[5,1]:='';
  midieventfrm.MIDIGrid.cells[6,1]:='';
  midieventfrm.MIDIGrid.cells[7,1]:='';
  midieventfrm.MIDIGrid.cells[8,1]:='';
  midieventfrm.MIDIGrid.cells[9,1]:='';
  midieventfrm.MIDIGrid.cells[10,1]:='';
  midieventfrm.deletemidievent.Enabled:=false;
  midieventfrm.editmidievent.Enabled:=false;

  // DataInEvent Form zurücksetzen
  dataineventfrm.DataGrid.RowCount:=2;
  dataineventfrm.DataGrid.cells[0,1]:='';
  dataineventfrm.DataGrid.cells[1,1]:='';
  dataineventfrm.DataGrid.cells[2,1]:='';
  dataineventfrm.DataGrid.cells[3,1]:='';
  dataineventfrm.DataGrid.cells[4,1]:='';
  dataineventfrm.DataGrid.cells[5,1]:='';
  dataineventfrm.DataGrid.cells[6,1]:='';
  dataineventfrm.DataGrid.cells[7,1]:='';
  dataineventfrm.DataGrid.cells[8,1]:='';
  dataineventfrm.deletedatainevent.Enabled:=false;
  dataineventfrm.editdatainevent.Enabled:=false;

  for i:=0 to 4 do
    setlength(ambilights[i],0);
  if ambilightform.Showing then
    ambilightform.RefreshListboxes;

  setlength(partymuckenmodul,0);
  setlength(pmmlights,0);
  setlength(pmmform.selected,0);
  if pmmform.showing then
    pmmform.RefreshListBoxes;

  for i:=1 to lastchan do
    senddata(i,data.ch[i],data.ch[i],0);

  if szenenverwaltung_formarray[0].Showing then
    szenenverwaltung_formarray[0].FormShow(nil);
  szenenverwaltung_formarray[0].TreeView2.Items.Clear;

  // Projektverzeichnis reinigen
  DeleteDirectory(userdirectory+'ProjectTemp');
  //DeleteDir(userdirectory+'ProjectTemp');
  CreateDir(userdirectory+'ProjectTemp');
  CreateDir(userdirectory+'ProjectTemp\Kontrollpanel');
  BASS_Init(sounddevice+1, BASSDLLFREQUENZ, BASS_DEVICE_SPEAKERS, Handle, nil);

  if showfirststeps then
  begin
    firststepsform.Show;
    firststepsform.BringToFront;
  end;
end;

function TMainform.Saveproject(savewithoutprompt,fastsave, Autosave:boolean):boolean;
var
  i,j,k,l,m,effektanzahl,laenge, Count, Count2, Count3, Count4:integer;
  savefile,projectfilename,projectfilepath:string;
  text:string[30];
begin
{
  Die folgenden Tools können ebenfalls speichern und laden (Projektversion wird jeweils im Header abgespeichert):
  -> Effektsequenzer
  -> Cuelist
  -> Submaster
  -> Audioeffektplayer
  -> Lauflicht
  -> Matrix
}

  if not UserAccessGranted(2) then exit;

  if fastsave then fastsaved:=true;
  result:=false;

  if (not savewithoutprompt) then
  begin
    savedialog.InitialDir:=JvComputerInfoEx1.Folders.Desktop;
    savedialog.Title:=_('PC_DIMMER Projekt speichern...');
    savedialog.Filter:=_('PC_DIMMER Projekt (*.pcdproj)|*.pcdproj|*.*|*.*');
	  savedialog.FileName:='';
    savedialog.DefaultExt:='*.pcdproj';
	  if not savedialog.execute then
	    exit;
    savefile:=savedialog.filename;
    projectfilepath:=ExtractFilepath(savefile);
    projectfilename:=ExtractFileName(savefile);
//    project_folder:=projectfilepath;
    project_folder:=userdirectory+'ProjectTemp\';
    mainform.Caption:=maincaption+' - ['+projectfilename+']';
    project_file:=savefile;
  end;

  // Anzeigen vorbereiten
  inprogress.Caption:=_('Speichere Projekt...');
  inprogress.filename.Caption:=_('Bereite Speicherung vor...');
  inprogress.Label2.caption:=_('Projektgröße: ');
  inprogress.label8.Caption:=_(' Speichere Datei... ');
  inprogress.ProgressBar1.Position:=0;
  if not Autosave then
    inprogress.Show;
  inprogress.Refresh;

  Application.ProcessMessages;
  inprogress.Label2.caption:=_('Projektgröße: ')+Floattostrf(GetDirSize(userdirectory+'ProjectTemp',true) / 1048576, ffGeneral, 4, 2) + ' MB';
  inprogress.Refresh;

  AutosaveProgress.Visible:=true;
  AutosaveProgress.Position:=0;

  // OpenHistory aktualisieren
  if not Autosave then
    AddToOpenHistory(projectfilepath+projectfilename);

  projectfilepath:=ExtractFilepath(project_file);
  projectfilename:=ExtractFileName(project_file);
  project_folder:=userdirectory+'ProjectTemp\';

  inprogress.filename.Caption:=_('Sende Plugins Speichern-Befehl...');
  inprogress.ProgressBar1.Position:=20;
  AutosaveProgress.Position:=20;
  inprogress.Refresh;

  SendMSG(MSG_SAVE,userdirectory+'ProjectTemp\',0);

  kontrollpanel.MSGSave(nil);
  effektsequenzer.MSGSave;
  kanaluebersichtform.MSGSave;
  geraetesteuerung.MSGSave;
  submasterform.MSGSave;
  grafischebuehnenansicht.MSGSave;
  audioeffektplayerform.MSGSave;
  beatform.MSGSave;
  kanaluebersichtform.MSGSave;
  szenenverwaltung_formarray[0].MSGSave;
  nodecontrolform.MSGSave;
  SaveWindowPositions('all');

  inprogress.filename.Caption:=_('Sammle Hauptprogrammdaten...');
  inprogress.ProgressBar1.Position:=40;
  AutosaveProgress.Position:=40;
  inprogress.Refresh;

  audioeffektplayerform.audioeffektfilenameboxDropDown(nil);

  for i:=1 to 8 do
  begin
    Waveformdata_record.fadervalues[i]:=TScrollbar(audioeffektplayerform.FindComponent('eq_scrollbar'+inttostr(i))).position;
    Waveformdata_record.effekte[i]:=TCheckBox(audioeffektplayerform.FindComponent('eq_check'+inttostr(i))).checked;
  end;

  for i:=0 to 10 do
    Waveformdata_record.equalizer[i]:=TProgressBar(audioeffektplayerform.FindComponent('equalizer_progressbar'+inttostr(i))).Position;

	if length(effektaudio_record)>0 then
  begin
  	effektaudio_record[audioeffektplayerform.audioeffektfilenamebox.ItemIndex].waveform.fadervalues:=waveformdata_record.fadervalues;
  	effektaudio_record[audioeffektplayerform.audioeffektfilenamebox.ItemIndex].waveform.equalizer:=waveformdata_record.equalizer;
  	effektaudio_record[audioeffektplayerform.audioeffektfilenamebox.ItemIndex].waveform.effekte:=waveformdata_record.effekte;
  end;

  inprogress.filename.Caption:=_('Schreibe Datei...');
  inprogress.Refresh;
  inprogress.ProgressBar1.Position:=60;
  AutosaveProgress.Position:=60;
  projektprogrammversion:=inttostr(actualprojectversion);//getfileversion(paramstr(0));

  if Autosave then
    FileStream:=TFileStream.Create(userdirectory+'Autobackup.pcdbkup',fmCreate)
  else
    FileStream:=TFileStream.Create(userdirectory+'ProjectTemp\Projekt',fmCreate);
  // Projekt-Header speichern
  inprogress.filename.Caption:=_('Schreibe Datei... Projekt-Header');
  inprogress.Refresh;
  FileStream.WriteBuffer(projektprogrammversion,256);
  projektdatum:=DateToStr(now);
  FileStream.WriteBuffer(projektdatum,256);
  projektuhrzeit:=TimeToStr(now);
  FileStream.WriteBuffer(projektuhrzeit,256);
  FileStream.WriteBuffer(lastchan,sizeof(lastchan));
  FileStream.WriteBuffer(LastChan,sizeof(LastChan));
  if projekttitel=_('Neues Projekt') then
    projekttitel:=copy(projectfilename, 1, Pos('.', projectfilename)-1);
  FileStream.WriteBuffer(projekttitel,256);
  FileStream.WriteBuffer(projektversion,256);
  if autoinsertcomputerusername then
    projektbearbeiter:=JvComputerInfoEx1.Identification.LocalUserName;
  FileStream.WriteBuffer(projektbearbeiter,256);
  if projektspeicheranzahl<>'' then
    if not Autosave then
      projektspeicheranzahl:=inttostr(strtoint(projektspeicheranzahl)+1)
  else
    projektspeicheranzahl:='1';
  FileStream.WriteBuffer(projektspeicheranzahl,256);

  //Effektaudio speichern
  inprogress.filename.Caption:=_('Schreibe Datei... Audioeffektplayer');
  inprogress.Refresh;
  //Länge der Array feststellen und als erstes abspeichern
  laenge:=length(Effektaudio_record);
  FileStream.WriteBuffer(laenge,sizeof(laenge));
  // nun alle Array einzeln nacheinander speichern
  for i:=0 to laenge-1 do
  begin
    if pos('\ProjectTemp\',Effektaudio_record[i].audiopfad)>0 then
      Effektaudio_record[i].audiopfad:=userdirectory+copy(Effektaudio_record[i].audiopfad,pos('ProjectTemp\',Effektaudio_record[i].audiopfad),length(Effektaudio_record[i].audiopfad));

    Filestream.WriteBuffer(Effektaudio_record[i].audiodatei,sizeof(Effektaudio_record[i].audiodatei));
    Filestream.WriteBuffer(Effektaudio_record[i].audiopfad,sizeof(Effektaudio_record[i].audiopfad));
    // Einzelne Layer und Effekte speichern
    Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layeranzahl,sizeof(Effektaudio_record[i].effektaudiodatei.layeranzahl));
    for j:=1 to maxaudioeffektlayers do
    begin
      // Effektanzahl herausfinden und abspeichern
      effektanzahl:=length(Effektaudio_record[i].effektaudiodatei.layer[j].effekt);
      FileStream.WriteBuffer(effektanzahl,sizeof(effektanzahl));
      // Effektarray abspeichern
      for k:=0 to effektanzahl-1 do
      begin
        Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].ID,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].ID));
        Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Name,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Name));
        Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Beschreibung,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Beschreibung));
        Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].StopScene,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].StopScene));
        Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].audioeffektposition,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].audioeffektposition));
        Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].UseIDScene,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].UseIDScene));
        Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].fadetime,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].fadetime));
//	        Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].ch,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].ch));
//	        Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].active,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].active));
        Count:=length(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices);
        Filestream.WriteBuffer(Count,sizeof(Count));
        for l:=0 to Count-1 do
        begin
          Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ID,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ID));
          Count2:=length(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanActive);
          Filestream.WriteBuffer(Count2,sizeof(Count2));
          for m:=0 to Count2-1 do
          begin
            Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanActive[m],sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanActive[m]));
            Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanValue[m],sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanValue[m]));
            Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanActiveRandom[m],sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanActiveRandom[m]));
            Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanValueRandom[m],sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanValueRandom[m]));
            Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanDelay[m],sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanDelay[m]));
            Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanFadetime[m],sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanFadetime[m]));
          end;
        end;
        Count:=length(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle);
        Filestream.WriteBuffer(Count,sizeof(Count));
        for l:=0 to Count-1 do
        begin
          Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].ID,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].ID));
          Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].Typ,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].Typ));
          Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].Name,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].Name));
          Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].Beschreibung,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].Beschreibung));
          Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].OnValue,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].OnValue));
          Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].SwitchValue,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].SwitchValue));
          Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].InvertSwitchValue,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].InvertSwitchValue));
          Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].OffValue,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].OffValue));
          Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].ScaleValue,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].ScaleValue));

          Count2:=length(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].ArgInteger);
          Filestream.WriteBuffer(Count2,sizeof(Count2));
          for m:=0 to Count2-1 do
            Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].ArgInteger[m],sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].ArgInteger[m]));
          Count2:=length(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].ArgString);
          Filestream.WriteBuffer(Count2,sizeof(Count2));
          for m:=0 to Count2-1 do
            Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].ArgString[m],sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].ArgString[m]));
          Count2:=length(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].ArgGUID);
          Filestream.WriteBuffer(Count2,sizeof(Count2));
          for m:=0 to Count2-1 do
            Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].ArgGUID[m],sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].ArgGUID[m]));


          Count2:=length(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanActive);
          Filestream.WriteBuffer(Count2,sizeof(Count2));
          for m:=0 to Count2-1 do
          begin
            Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanActive[m],sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanActive[m]));
            Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanValue[m],sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanValue[m]));
            Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanActiveRandom[m],sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanActiveRandom[m]));
            Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanValueRandom[m],sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanValueRandom[m]));
            Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanDelay[m],sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanDelay[m]));
            Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanFadetime[m],sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanFadetime[m]));
          end;
        end;
      end;
      Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].layeractive,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].layeractive));
    end;
    Filestream.WriteBuffer(Effektaudio_record[i].waveform,sizeof(Effektaudio_record[i].waveform));
    Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.repeatjump,sizeof(Effektaudio_record[i].effektaudiodatei.repeatjump));
    Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.repeatdestination,sizeof(Effektaudio_record[i].effektaudiodatei.repeatdestination));
    Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.repeatactive,sizeof(Effektaudio_record[i].effektaudiodatei.repeatactive));
    Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.volume,sizeof(Effektaudio_record[i].effektaudiodatei.volume));
    Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.videoseeking,sizeof(Effektaudio_record[i].effektaudiodatei.videoseeking));
    Filestream.WriteBuffer(Effektaudio_record[i].effektaudiodatei.layername,sizeof(Effektaudio_record[i].effektaudiodatei.layername));
  end;
//Effektaudio fertig
//Projekteinstellungen speichern
    inprogress.filename.Caption:=_('Schreibe Datei... Projekteinstellungen');
    inprogress.Refresh;
    Count:=length(data.ch);
    Filestream.WriteBuffer(Count,sizeof(Count));
    for i:=0 to Count-1 do
      Filestream.WriteBuffer(data.ch[i],sizeof(data.ch[i]));
    Count:=length(data.names);
    Filestream.WriteBuffer(Count,sizeof(Count));
    for i:=0 to Count-1 do
      Filestream.WriteBuffer(data.names[i],sizeof(data.names[i]));
    Count:=length(data.sdirect);
    Filestream.WriteBuffer(Count,sizeof(Count));
    for i:=0 to Count-1 do
      Filestream.WriteBuffer(data.sdirect[i],sizeof(data.sdirect[i]));
    Count:=length(data.combine);
    Filestream.WriteBuffer(Count,sizeof(Count));
    for i:=0 to Count-1 do
      Filestream.WriteBuffer(data.combine[i],sizeof(data.combine[i]));
    Filestream.WriteBuffer(data.page,sizeof(data.page));
    Filestream.WriteBuffer(data.Shortcutnames,sizeof(data.Shortcutnames));
//Projekteinstellungen fertig

// Kanalmin/maxwerte speichern
    Count:=length(channel_minvalue);
    Filestream.WriteBuffer(Count,sizeof(Count));
    for i:=1 to Count do
    begin
      Filestream.WriteBuffer(channel_minvalue[i],sizeof(channel_minvalue[i]));
      Filestream.WriteBuffer(channel_maxvalue[i],sizeof(channel_maxvalue[i]));
    end;
// Kanalmin/maxwerte speichern fertig

//Figuren speichern
    inprogress.filename.Caption:=_('Schreibe Datei... Figuren');
    inprogress.Refresh;
    Count:=length(Figuren);
    Filestream.WriteBuffer(Count,sizeof(Count));
    for i:=0 to Count-1 do
    begin
      Filestream.WriteBuffer(Figuren[i].ID,sizeof(Figuren[i].ID));
      Filestream.WriteBuffer(Figuren[i].name,sizeof(Figuren[i].name));
      Filestream.WriteBuffer(Figuren[i].invertpan,sizeof(Figuren[i].invertpan));
      Filestream.WriteBuffer(Figuren[i].inverttilt,sizeof(Figuren[i].inverttilt));
      Count2:=length(Figuren[i].posx);
      Filestream.WriteBuffer(Count2,sizeof(Count2));
      for k:=0 to Count2-1 do
      begin
        Filestream.WriteBuffer(Figuren[i].posx[k],sizeof(Figuren[i].posx[k]));
        Filestream.WriteBuffer(Figuren[i].posy[k],sizeof(Figuren[i].posy[k]));
      end;
      Filestream.WriteBuffer(Figuren[i].gesamtlaenge,sizeof(Figuren[i].gesamtlaenge));
    end;
// Ende Figuren speichern
// Einfache-, Bewegungs- und Audioszenen, sowie Befehle speichern
  inprogress.filename.Caption:=_('Schreibe Datei... Szenen');
  inprogress.Refresh;
    Count:=length(Einfacheszenen);
    Filestream.WriteBuffer(Count,sizeof(Count));
    for i:=0 to length(Einfacheszenen)-1 do
    begin
      Filestream.WriteBuffer(Einfacheszenen[i].ID,sizeof(Einfacheszenen[i].ID));
      Filestream.WriteBuffer(Einfacheszenen[i].Name,sizeof(Einfacheszenen[i].Name));
      Filestream.WriteBuffer(Einfacheszenen[i].Beschreibung,sizeof(Einfacheszenen[i].Beschreibung));
      Filestream.WriteBuffer(Einfacheszenen[i].einblendzeit,sizeof(Einfacheszenen[i].einblendzeit));
      Filestream.WriteBuffer(Einfacheszenen[i].kanal,sizeof(Einfacheszenen[i].kanal));
      Filestream.WriteBuffer(Einfacheszenen[i].kanalaktiv,sizeof(Einfacheszenen[i].kanalaktiv));
      Filestream.WriteBuffer(Einfacheszenen[i].Category,sizeof(Einfacheszenen[i].Category));
    end;

    Count:=length(Audioszenen);
    Filestream.WriteBuffer(Count,sizeof(Count));
    for i:=0 to length(Audioszenen)-1 do
    begin
      Filestream.WriteBuffer(Audioszenen[i].ID,sizeof(Audioszenen[i].ID));
      Filestream.WriteBuffer(Audioszenen[i].Name,sizeof(Audioszenen[i].Name));
      Filestream.WriteBuffer(Audioszenen[i].Beschreibung,sizeof(Audioszenen[i].Beschreibung));
      Filestream.WriteBuffer(Audioszenen[i].Datei,sizeof(Audioszenen[i].Datei));
      Filestream.WriteBuffer(Audioszenen[i].Dauer,sizeof(Audioszenen[i].Dauer));
      Filestream.WriteBuffer(Audioszenen[i].Volume,sizeof(Audioszenen[i].Volume));
      Filestream.WriteBuffer(Audioszenen[i].FadeinTime,sizeof(Audioszenen[i].FadeinTime));
      Filestream.WriteBuffer(Audioszenen[i].FadeoutTime,sizeof(Audioszenen[i].FadeoutTime));
      Filestream.WriteBuffer(Audioszenen[i].matrix,sizeof(Audioszenen[i].matrix));
      Filestream.WriteBuffer(Audioszenen[i].Kanalsettings,sizeof(Audioszenen[i].Kanalsettings));
      Filestream.WriteBuffer(Audioszenen[i].Category,sizeof(Audioszenen[i].Category));
    end;

    Count:=length(Bewegungsszenen);
    Filestream.WriteBuffer(Count,sizeof(Count));
    for i:=0 to length(Bewegungsszenen)-1 do
    begin
      Filestream.WriteBuffer(Bewegungsszenen[i].ID,sizeof(Bewegungsszenen[i].ID));
      Filestream.WriteBuffer(Bewegungsszenen[i].Name,sizeof(Bewegungsszenen[i].Name));
      Filestream.WriteBuffer(Bewegungsszenen[i].Beschreibung,sizeof(Bewegungsszenen[i].Beschreibung));
      Filestream.WriteBuffer(Bewegungsszenen[i].IsBeatControlled,sizeof(Bewegungsszenen[i].IsBeatControlled));
      Filestream.WriteBuffer(Bewegungsszenen[i].figur,sizeof(Bewegungsszenen[i].figur));
      Filestream.WriteBuffer(Bewegungsszenen[i].dauer,sizeof(Bewegungsszenen[i].dauer));
      Filestream.WriteBuffer(Bewegungsszenen[i].DontFade,sizeof(Bewegungsszenen[i].DontFade));
      Filestream.WriteBuffer(Bewegungsszenen[i].repeats,sizeof(Bewegungsszenen[i].repeats));
      Filestream.WriteBuffer(Bewegungsszenen[i].identischespurgeschwidigkeit,sizeof(Bewegungsszenen[i].identischespurgeschwidigkeit));
      Filestream.WriteBuffer(Bewegungsszenen[i].startpositionrelativ,sizeof(Bewegungsszenen[i].startpositionrelativ));
      Filestream.WriteBuffer(Bewegungsszenen[i].Category,sizeof(Bewegungsszenen[i].Category));
      Count2:=length(Bewegungsszenen[i].Devices);
      Filestream.WriteBuffer(Count2,sizeof(Count2));
      for j:=0 to Count2-1 do
      begin
        Filestream.WriteBuffer(Bewegungsszenen[i].Devices[j].ID,sizeof(Bewegungsszenen[i].Devices[j].ID));

        Count3:=length(Bewegungsszenen[i].Devices[j].DeviceChannel);
        Filestream.WriteBuffer(Count3,sizeof(Count3));
        for k:=0 to Count3-1 do
        begin
          Filestream.WriteBuffer(Bewegungsszenen[i].Devices[j].DeviceChannel[k],sizeof(Bewegungsszenen[i].Devices[j].DeviceChannel[k]));

          Count4:=length(Bewegungsszenen[i].Devices[j].Szenen[k]);
          Filestream.WriteBuffer(Count4,sizeof(Count4));
          for l:=0 to Count4-1 do
          begin
            Filestream.WriteBuffer(Bewegungsszenen[i].Devices[j].Szenen[k][l],sizeof(Bewegungsszenen[i].Devices[j].Szenen[k][l]));
          end;
        end;
      end;
    end;

    Count:=length(Befehle2);
    Filestream.WriteBuffer(Count,sizeof(Count));
    for i:=0 to Count-1 do
    begin
      Filestream.WriteBuffer(Befehle2[i].ID,sizeof(Befehle2[i].ID));
      Filestream.WriteBuffer(Befehle2[i].Typ,sizeof(Befehle2[i].Typ));
      Filestream.WriteBuffer(Befehle2[i].Name,sizeof(Befehle2[i].Name));
      Filestream.WriteBuffer(Befehle2[i].Beschreibung,sizeof(Befehle2[i].Beschreibung));
      Filestream.WriteBuffer(Befehle2[i].OnValue,sizeof(Befehle2[i].OnValue));
      Filestream.WriteBuffer(Befehle2[i].SwitchValue,sizeof(Befehle2[i].SwitchValue));
      Filestream.WriteBuffer(Befehle2[i].InvertSwitchValue,sizeof(Befehle2[i].InvertSwitchValue));
      Filestream.WriteBuffer(Befehle2[i].OffValue,sizeof(Befehle2[i].OffValue));
      Filestream.WriteBuffer(Befehle2[i].ScaleValue,sizeof(Befehle2[i].ScaleValue));
      Filestream.WriteBuffer(Befehle2[i].RunOnProjectLoad,sizeof(Befehle2[i].RunOnProjectLoad));
      Filestream.WriteBuffer(Befehle2[i].Category,sizeof(Befehle2[i].Category));
      Count2:=length(Befehle2[i].ArgInteger);
      Filestream.WriteBuffer(Count2,sizeof(Count2));
      for j:=0 to Count2-1 do
      begin
        Filestream.WriteBuffer(Befehle2[i].ArgInteger[j],sizeof(Befehle2[i].ArgInteger[j]));
      end;
      Count2:=length(Befehle2[i].ArgString);
      Filestream.WriteBuffer(Count2,sizeof(Count2));
      for j:=0 to Count2-1 do
      begin
        Filestream.WriteBuffer(Befehle2[i].ArgString[j],sizeof(Befehle2[i].ArgString[j]));
      end;
      Count2:=length(Befehle2[i].ArgGUID);
      Filestream.WriteBuffer(Count2,sizeof(Count2));
      for j:=0 to Count2-1 do
      begin
        Filestream.WriteBuffer(Befehle2[i].ArgGUID[j],sizeof(Befehle2[i].ArgGUID[j]));
      end;
    end;

    Count:=length(Kompositionsszenen);
    Filestream.WriteBuffer(Count,sizeof(Count));
    for i:=0 to length(Kompositionsszenen)-1 do
    begin
      Filestream.WriteBuffer(Kompositionsszenen[i].ID,sizeof(Kompositionsszenen[i].ID));
      Filestream.WriteBuffer(Kompositionsszenen[i].Name,sizeof(Kompositionsszenen[i].Name));
      Filestream.WriteBuffer(Kompositionsszenen[i].Beschreibung,sizeof(Kompositionsszenen[i].Beschreibung));
      Filestream.WriteBuffer(Kompositionsszenen[i].Category,sizeof(Kompositionsszenen[i].Category));

      Count2:=length(Kompositionsszenen[i].IDs);
      Filestream.WriteBuffer(Count2, sizeof(Count2));
      for j:=0 to length(Kompositionsszenen[i].IDs)-1 do
      begin
        Filestream.WriteBuffer(Kompositionsszenen[i].IDs[j],sizeof(Kompositionsszenen[i].IDs[j]));
        Filestream.WriteBuffer(Kompositionsszenen[i].StopScene[j],sizeof(Kompositionsszenen[i].StopScene[j]));
      end;
    end;

    Count:=length(SzenenablaufArray);
    Filestream.WriteBuffer(Count,sizeof(Count));
    for i:=0 to length(SzenenablaufArray)-1 do
    begin
      Filestream.WriteBuffer(text,sizeof(text));
      Count2:=length(SzenenablaufArray[i]);
      Filestream.WriteBuffer(Count2,sizeof(Count2));
      for j:=0 to Count2-1 do
        Filestream.WriteBuffer(SzenenablaufArray[i][j],sizeof(SzenenablaufArray[i][j]));
    end;
// Ende Szenenspeichern
// Timeline speichern
	  inprogress.filename.Caption:=_('Schreibe Datei... Timeline');
  	inprogress.Refresh;
    Count:=length(Effekttimeline);
		Filestream.WriteBuffer(Count,sizeof(Count));
    for i:=0 to Count-1 do
  	begin
    	Filestream.WriteBuffer(Effekttimeline[i].name,sizeof(Effekttimeline[i].name));
      Count2:=length(Effekttimeline[i].value);
    	Filestream.WriteBuffer(Count2,sizeof(Count2));
      for j:=0 to Count2-1 do
      	Filestream.WriteBuffer(Effekttimeline[i].value[j],sizeof(Effekttimeline[i].value[j]));
    	Filestream.WriteBuffer(Effekttimeline[i].checked,sizeof(Effekttimeline[i].checked));
    	Filestream.WriteBuffer(Effekttimeline[i].steps,sizeof(Effekttimeline[i].steps));
    	Filestream.WriteBuffer(Effekttimeline[i].blendzeit,sizeof(Effekttimeline[i].blendzeit));
    	Filestream.WriteBuffer(Effekttimeline[i].blitzfunktion,sizeof(Effekttimeline[i].blitzfunktion));
    	Filestream.WriteBuffer(Effekttimeline[i].blitzzeit,sizeof(Effekttimeline[i].blitzzeit));
    	Filestream.WriteBuffer(Effekttimeline[i].pendeln,sizeof(Effekttimeline[i].pendeln));
    	Filestream.WriteBuffer(Effekttimeline[i].zufall,sizeof(Effekttimeline[i].zufall));
    end;
// Ende Timeline speichern
// Skripttimer speichern
	  inprogress.filename.Caption:=_('Schreibe Datei... Skripttimer');
  	inprogress.Refresh;
    Count:=length(AblaufTimer);
		Filestream.WriteBuffer(Count,sizeof(Count));
    for i:=0 to Count-1 do
    begin
  		Filestream.WriteBuffer(AblaufTimer[i].Aktiviert,sizeof(AblaufTimer[i].Aktiviert));
  		Filestream.WriteBuffer(AblaufTimer[i].Name,sizeof(AblaufTimer[i].Name));
  		Filestream.WriteBuffer(AblaufTimer[i].Beschreibung,sizeof(AblaufTimer[i].Beschreibung));
  		Filestream.WriteBuffer(AblaufTimer[i].Datum,sizeof(AblaufTimer[i].Datum));
  		Filestream.WriteBuffer(AblaufTimer[i].Uhrzeit,sizeof(AblaufTimer[i].Uhrzeit));
  		Filestream.WriteBuffer(AblaufTimer[i].TimerTyp,sizeof(AblaufTimer[i].TimerTyp));
  		Filestream.WriteBuffer(AblaufTimer[i].Skriptdatei,sizeof(AblaufTimer[i].Skriptdatei));
  		Filestream.WriteBuffer(AblaufTimer[i].LoadTyp,sizeof(AblaufTimer[i].LoadTyp));
  		Filestream.WriteBuffer(AblaufTimer[i].LoadID,sizeof(AblaufTimer[i].LoadID));
  		Filestream.WriteBuffer(AblaufTimer[i].Weekday,sizeof(AblaufTimer[i].Weekday));
    end;
// Ende Skripttimer speichern

// Hotkeys speichern
	  inprogress.filename.Caption:=_('Schreibe Datei... Hotkeys');
  	inprogress.Refresh;

    Count:=length(TastencodeArray);
		Filestream.WriteBuffer(Count,sizeof(Count));
    for i:=0 to Count-1 do
  	begin
    	Filestream.WriteBuffer(TastencodeArray[i].ID,sizeof(TastencodeArray[i].ID));
    	Filestream.WriteBuffer(TastencodeArray[i].active,sizeof(TastencodeArray[i].active));
    	Filestream.WriteBuffer(TastencodeArray[i].Hotkey,sizeof(TastencodeArray[i].Hotkey));
    	Filestream.WriteBuffer(TastencodeArray[i].Global,sizeof(TastencodeArray[i].Global));
    	Filestream.WriteBuffer(TastencodeArray[i].Repeated,sizeof(TastencodeArray[i].Repeated));
    	Filestream.WriteBuffer(TastencodeArray[i].UseKeyUp,sizeof(TastencodeArray[i].UseKeyUp));
      Filestream.WriteBuffer(TastencodeArray[i].KeyDownValue,sizeof(TastencodeArray[i].KeyDownValue));
      Filestream.WriteBuffer(TastencodeArray[i].KeyUpValue,sizeof(TastencodeArray[i].KeyUpValue));

      Filestream.WriteBuffer(TastencodeArray[i].Befehl.Typ,sizeof(TastencodeArray[i].Befehl.Typ));
      Filestream.WriteBuffer(TastencodeArray[i].Befehl.OnValue,sizeof(TastencodeArray[i].Befehl.OnValue));
      Filestream.WriteBuffer(TastencodeArray[i].Befehl.SwitchValue,sizeof(TastencodeArray[i].Befehl.SwitchValue));
      Filestream.WriteBuffer(TastencodeArray[i].Befehl.InvertSwitchValue,sizeof(TastencodeArray[i].Befehl.InvertSwitchValue));
      Filestream.WriteBuffer(TastencodeArray[i].Befehl.OffValue,sizeof(TastencodeArray[i].Befehl.OffValue));
      Filestream.WriteBuffer(TastencodeArray[i].Befehl.ScaleValue,sizeof(TastencodeArray[i].Befehl.ScaleValue));
      Count2:=length(TastencodeArray[i].Befehl.ArgInteger);
      Filestream.WriteBuffer(Count2,sizeof(Count2));
      for j:=0 to Count2-1 do
        Filestream.WriteBuffer(TastencodeArray[i].Befehl.ArgInteger[j],sizeof(TastencodeArray[i].Befehl.ArgInteger[j]));
      Count2:=length(TastencodeArray[i].Befehl.ArgString);
      Filestream.WriteBuffer(Count2,sizeof(Count2));
      for j:=0 to Count2-1 do
        Filestream.WriteBuffer(TastencodeArray[i].Befehl.ArgString[j],sizeof(TastencodeArray[i].Befehl.ArgString[j]));
      Count2:=length(TastencodeArray[i].Befehl.ArgGUID);
      Filestream.WriteBuffer(Count2,sizeof(Count2));
      for j:=0 to Count2-1 do
        Filestream.WriteBuffer(TastencodeArray[i].Befehl.ArgGUID[j],sizeof(TastencodeArray[i].Befehl.ArgGUID[j]));
    end;
// Ende Hotkey speichern

// Nebelmaschineneinstellungen
	  inprogress.filename.Caption:=_('Schreibe Datei... Nebelmaschine');
  	inprogress.Refresh;
 		Filestream.WriteBuffer(fogtimer,sizeof(fogtimer));
// Ende Nebelmaschineneinstellungen

// Geräte speichern
	  inprogress.filename.Caption:=_('Schreibe Datei... Geräte');
  	inprogress.Refresh;
    Count:=length(mainform.Devices);
	  Filestream.WriteBuffer(Count,sizeof(Count));
    for i:=0 to Count-1 do
    begin
   	  Filestream.WriteBuffer(mainform.Devices[i].ID,sizeof(mainform.Devices[i].ID));
   	  Filestream.WriteBuffer(mainform.Devices[i].Name,sizeof(mainform.Devices[i].Name));
   	  Filestream.WriteBuffer(mainform.Devices[i].DeviceName,sizeof(mainform.Devices[i].DeviceName));
   	  Filestream.WriteBuffer(mainform.Devices[i].Beschreibung,sizeof(mainform.Devices[i].Beschreibung));
   	  Filestream.WriteBuffer(mainform.Devices[i].Vendor,sizeof(mainform.Devices[i].Vendor));
   	  Filestream.WriteBuffer(mainform.Devices[i].Bildadresse,sizeof(mainform.Devices[i].Bildadresse));
   	  Filestream.WriteBuffer(mainform.Devices[i].Startaddress,sizeof(mainform.Devices[i].Startaddress));
   	  Filestream.WriteBuffer(mainform.Devices[i].MaxChan,sizeof(mainform.Devices[i].MaxChan));
   	  Filestream.WriteBuffer(mainform.Devices[i].invertpan,sizeof(mainform.Devices[i].invertpan));
   	  Filestream.WriteBuffer(mainform.Devices[i].inverttilt,sizeof(mainform.Devices[i].inverttilt));
   	  Filestream.WriteBuffer(mainform.Devices[i].typeofscannercalibration,sizeof(mainform.Devices[i].typeofscannercalibration));

      Count2:=17;//length(mainform.Devices[i].ScannerCalibrations);
      Filestream.WriteBuffer(Count2,sizeof(Count2));
      for j:=0 to Count2-1 do
   	    Filestream.WriteBuffer(mainform.Devices[i].ScannerCalibrations[j],sizeof(mainform.Devices[i].ScannerCalibrations[j]));

      // Bilddarstellung für Bühnenansicht
   	  Filestream.WriteBuffer(mainform.Devices[i].ShowInStageView,sizeof(mainform.Devices[i].ShowInStageView));
   	  Filestream.WriteBuffer(mainform.Devices[i].color,sizeof(mainform.Devices[i].color));
   	  Filestream.WriteBuffer(mainform.Devices[i].picturesize,sizeof(mainform.Devices[i].picturesize));
   	  Filestream.WriteBuffer(mainform.Devices[i].pictureangle,sizeof(mainform.Devices[i].pictureangle));
   	  Filestream.WriteBuffer(mainform.Devices[i].picturefliphor,sizeof(mainform.Devices[i].picturefliphor));
   	  Filestream.WriteBuffer(mainform.Devices[i].pictureflipver,sizeof(mainform.Devices[i].pictureflipver));
   	  Filestream.WriteBuffer(mainform.Devices[i].pictureispng,sizeof(mainform.Devices[i].pictureispng));

      Count2:=length(mainform.Devices[i].top);
   	  Filestream.WriteBuffer(Count2,sizeof(Count2));
      for j:=0 to Count2-1 do
      begin
     	  Filestream.WriteBuffer(mainform.Devices[i].top[j],sizeof(mainform.Devices[i].top[j]));
     	  Filestream.WriteBuffer(mainform.Devices[i].left[j],sizeof(mainform.Devices[i].left[j]));
     	  Filestream.WriteBuffer(mainform.Devices[i].bank[j],sizeof(mainform.Devices[i].bank[j]));
      end;
   	  Filestream.WriteBuffer(mainform.Devices[i].hasDimmer,sizeof(mainform.Devices[i].hasDIMMER));
   	  Filestream.WriteBuffer(mainform.Devices[i].hasShutter,sizeof(mainform.Devices[i].hasShutter));
   	  Filestream.WriteBuffer(mainform.Devices[i].hasVirtualRGBAWDimmer,sizeof(mainform.Devices[i].hasVirtualRGBAWDIMMER));
   	  Filestream.WriteBuffer(mainform.Devices[i].hasRGB,sizeof(mainform.Devices[i].hasRGB));
   	  Filestream.WriteBuffer(mainform.Devices[i].hasCMY,sizeof(mainform.Devices[i].hasCMY));
   	  Filestream.WriteBuffer(mainform.Devices[i].hasAmber,sizeof(mainform.Devices[i].hasAmber));
   	  Filestream.WriteBuffer(mainform.Devices[i].hasWhite,sizeof(mainform.Devices[i].hasWhite));
   	  Filestream.WriteBuffer(mainform.Devices[i].hasUV,sizeof(mainform.Devices[i].hasUV));
   	  Filestream.WriteBuffer(mainform.Devices[i].hasFog,sizeof(mainform.Devices[i].hasFog));
   	  Filestream.WriteBuffer(mainform.Devices[i].UseAmberMixing,sizeof(mainform.Devices[i].UseAmberMixing));
   	  Filestream.WriteBuffer(mainform.Devices[i].AmberMixingCompensateRG,sizeof(mainform.Devices[i].AmberMixingCompensateRG));
   	  Filestream.WriteBuffer(mainform.Devices[i].AmberMixingCompensateBlue,sizeof(mainform.Devices[i].AmberMixingCompensateBlue));
   	  Filestream.WriteBuffer(mainform.Devices[i].AmberRatioR,sizeof(mainform.Devices[i].AmberRatioR));
   	  Filestream.WriteBuffer(mainform.Devices[i].AmberRatioG,sizeof(mainform.Devices[i].AmberRatioG));
   	  Filestream.WriteBuffer(mainform.Devices[i].hasPANTILT,sizeof(mainform.Devices[i].hasPANTILT));
   	  Filestream.WriteBuffer(mainform.Devices[i].hasColor,sizeof(mainform.Devices[i].hasColor));
   	  Filestream.WriteBuffer(mainform.Devices[i].hasColor2,sizeof(mainform.Devices[i].hasColor2));
   	  Filestream.WriteBuffer(mainform.Devices[i].hasGobo,sizeof(mainform.Devices[i].hasGobo));
   	  Filestream.WriteBuffer(mainform.Devices[i].hasGobo2,sizeof(mainform.Devices[i].hasGobo2));

      Count2:=length(mainform.Devices[i].colors);
   	  Filestream.WriteBuffer(Count2,sizeof(Count2));
      for j:=0 to Count2-1 do
    	begin
        Filestream.WriteBuffer(mainform.Devices[i].colors[j],sizeof(mainform.Devices[i].colors[j]));
        Filestream.WriteBuffer(mainform.Devices[i].colorlevels[j],sizeof(mainform.Devices[i].colorlevels[j]));
        Filestream.WriteBuffer(mainform.Devices[i].colorendlevels[j],sizeof(mainform.Devices[i].colorendlevels[j]));
        Filestream.WriteBuffer(mainform.Devices[i].colornames[j],sizeof(mainform.Devices[i].colornames[j]));
   	  end;
      Filestream.WriteBuffer(mainform.Devices[i].colortolerance,sizeof(mainform.Devices[i].colortolerance));
      Filestream.WriteBuffer(mainform.Devices[i].autoscening,sizeof(mainform.Devices[i].autoscening));

      Count2:=length(mainform.Devices[i].colors2);
   	  Filestream.WriteBuffer(Count2,sizeof(Count2));
      for j:=0 to Count2-1 do
    	begin
        Filestream.WriteBuffer(mainform.Devices[i].colors2[j],sizeof(mainform.Devices[i].colors2[j]));
        Filestream.WriteBuffer(mainform.Devices[i].colorlevels2[j],sizeof(mainform.Devices[i].colorlevels2[j]));
        Filestream.WriteBuffer(mainform.Devices[i].colorendlevels2[j],sizeof(mainform.Devices[i].colorendlevels2[j]));
        Filestream.WriteBuffer(mainform.Devices[i].colornames2[j],sizeof(mainform.Devices[i].colornames2[j]));
   	  end;
      Count2:=length(mainform.Devices[i].gobos);
   	  Filestream.WriteBuffer(Count2,sizeof(Count2));
      for j:=0 to Count2-1 do
    	begin
        Filestream.WriteBuffer(mainform.Devices[i].gobos[j],sizeof(mainform.Devices[i].gobos[j]));
        Filestream.WriteBuffer(mainform.Devices[i].gobolevels[j],sizeof(mainform.Devices[i].gobolevels[j]));
        Filestream.WriteBuffer(mainform.Devices[i].goboendlevels[j],sizeof(mainform.Devices[i].goboendlevels[j]));
        Filestream.WriteBuffer(mainform.Devices[i].gobonames[j],sizeof(mainform.Devices[i].gobonames[j]));
        Count3:=length(mainform.Devices[i].bestgobos[j]);
        Filestream.WriteBuffer(Count3,sizeof(Count3));
        for k:=0 to length(mainform.Devices[i].bestgobos[j])-1 do
        begin
          Filestream.WriteBuffer(mainform.Devices[i].bestgobos[j][k].GoboName,sizeof(mainform.Devices[i].bestgobos[j][k].GoboName));
          Filestream.WriteBuffer(mainform.Devices[i].bestgobos[j][k].Percent,sizeof(mainform.Devices[i].bestgobos[j][k].Percent));
        end;
   	  end;
      Count2:=length(mainform.Devices[i].gobos2);
   	  Filestream.WriteBuffer(Count2,sizeof(Count2));
      for j:=0 to Count2-1 do
    	begin
        Filestream.WriteBuffer(mainform.Devices[i].gobos2[j],sizeof(mainform.Devices[i].gobos2[j]));
        Filestream.WriteBuffer(mainform.Devices[i].gobolevels2[j],sizeof(mainform.Devices[i].gobolevels2[j]));
        Filestream.WriteBuffer(mainform.Devices[i].goboendlevels2[j],sizeof(mainform.Devices[i].goboendlevels2[j]));
        Filestream.WriteBuffer(mainform.Devices[i].gobonames2[j],sizeof(mainform.Devices[i].gobonames2[j]));
        Count3:=length(mainform.Devices[i].bestgobos2[j]);
        Filestream.WriteBuffer(Count3,sizeof(Count3));
        for k:=0 to length(mainform.Devices[i].bestgobos2[j])-1 do
        begin
          Filestream.WriteBuffer(mainform.Devices[i].bestgobos2[j][k].GoboName,sizeof(mainform.Devices[i].bestgobos2[j][k].GoboName));
          Filestream.WriteBuffer(mainform.Devices[i].bestgobos2[j][k].Percent,sizeof(mainform.Devices[i].bestgobos2[j][k].Percent));
        end;
   	  end;

      Filestream.WriteBuffer(mainform.Devices[i].ShutterOpenValue,sizeof(mainform.Devices[i].ShutterOpenValue));
      Filestream.WriteBuffer(mainform.Devices[i].ShutterCloseValue,sizeof(mainform.Devices[i].ShutterCloseValue));
      Filestream.WriteBuffer(mainform.Devices[i].ShutterChannel,sizeof(mainform.Devices[i].ShutterChannel));
      Filestream.WriteBuffer(mainform.Devices[i].StrobeOffValue,sizeof(mainform.Devices[i].StrobeOffValue));
      Filestream.WriteBuffer(mainform.Devices[i].StrobeMinValue,sizeof(mainform.Devices[i].StrobeMinValue));
      Filestream.WriteBuffer(mainform.Devices[i].StrobeMaxValue,sizeof(mainform.Devices[i].StrobeMaxValue));
      Filestream.WriteBuffer(mainform.Devices[i].StrobeChannel,sizeof(mainform.Devices[i].StrobeChannel));
      Filestream.WriteBuffer(mainform.Devices[i].DimmerOffValue,sizeof(mainform.Devices[i].DimmerOffValue));
      Filestream.WriteBuffer(mainform.Devices[i].DimmerMaxValue,sizeof(mainform.Devices[i].DimmerMaxValue));
      Filestream.WriteBuffer(mainform.Devices[i].FogOffValue,sizeof(mainform.Devices[i].FogOffValue));
      Filestream.WriteBuffer(mainform.Devices[i].FogMaxValue,sizeof(mainform.Devices[i].FogMaxValue));
      Filestream.WriteBuffer(mainform.Devices[i].Gobo1RotLeftminValue,sizeof(mainform.Devices[i].Gobo1RotLeftminValue));
      Filestream.WriteBuffer(mainform.Devices[i].Gobo1RotLeftValue,sizeof(mainform.Devices[i].Gobo1RotLeftValue));
      Filestream.WriteBuffer(mainform.Devices[i].Gobo1RotOffValue,sizeof(mainform.Devices[i].Gobo1RotOffValue));
      Filestream.WriteBuffer(mainform.Devices[i].Gobo1RotRightminValue,sizeof(mainform.Devices[i].Gobo1RotRightminValue));
      Filestream.WriteBuffer(mainform.Devices[i].Gobo1RotRightValue,sizeof(mainform.Devices[i].Gobo1RotRightValue));
      Filestream.WriteBuffer(mainform.Devices[i].Gobo1RotChannel,sizeof(mainform.Devices[i].Gobo1RotChannel));
      Filestream.WriteBuffer(mainform.Devices[i].Gobo2RotLeftminValue,sizeof(mainform.Devices[i].Gobo2RotLeftminValue));
      Filestream.WriteBuffer(mainform.Devices[i].Gobo2RotLeftValue,sizeof(mainform.Devices[i].Gobo2RotLeftValue));
      Filestream.WriteBuffer(mainform.Devices[i].Gobo2RotOffValue,sizeof(mainform.Devices[i].Gobo2RotOffValue));
      Filestream.WriteBuffer(mainform.Devices[i].Gobo2RotRightminValue,sizeof(mainform.Devices[i].Gobo2RotRightminValue));
      Filestream.WriteBuffer(mainform.Devices[i].Gobo2RotRightValue,sizeof(mainform.Devices[i].Gobo2RotRightValue));
      Filestream.WriteBuffer(mainform.Devices[i].Gobo2RotChannel,sizeof(mainform.Devices[i].Gobo2RotChannel));

      Filestream.WriteBuffer(mainform.Devices[i].PrismaSingleValue,sizeof(mainform.Devices[i].PrismaSingleValue));
      Filestream.WriteBuffer(mainform.Devices[i].PrismaTripleValue,sizeof(mainform.Devices[i].PrismaTripleValue));
      Filestream.WriteBuffer(mainform.Devices[i].PrismaRotOffValue,sizeof(mainform.Devices[i].PrismaRotOffValue));
      Filestream.WriteBuffer(mainform.Devices[i].PrismaRotLeftminValue,sizeof(mainform.Devices[i].PrismaRotLeftminValue));
      Filestream.WriteBuffer(mainform.Devices[i].PrismaRotLeftmaxValue,sizeof(mainform.Devices[i].PrismaRotLeftmaxValue));
      Filestream.WriteBuffer(mainform.Devices[i].PrismaRotRightminValue,sizeof(mainform.Devices[i].PrismaRotRightminValue));
      Filestream.WriteBuffer(mainform.Devices[i].PrismaRotRightmaxValue,sizeof(mainform.Devices[i].PrismaRotRightmaxValue));
      Filestream.WriteBuffer(mainform.Devices[i].PrismaRotChannel,sizeof(mainform.Devices[i].PrismaRotChannel));
      Filestream.WriteBuffer(mainform.Devices[i].IrisCloseValue,sizeof(mainform.Devices[i].IrisCloseValue));
      Filestream.WriteBuffer(mainform.Devices[i].IrisOpenValue,sizeof(mainform.Devices[i].IrisOpenValue));
      Filestream.WriteBuffer(mainform.Devices[i].IrisMinValue,sizeof(mainform.Devices[i].IrisMinValue));
      Filestream.WriteBuffer(mainform.Devices[i].IrisMaxValue,sizeof(mainform.Devices[i].IrisMaxValue));

      Filestream.WriteBuffer(mainform.Devices[i].UseChannelBasedPower,sizeof(mainform.Devices[i].UseChannelBasedPower));
      //Filestream.WriteBuffer(mainform.Devices[i].AlwaysOn,sizeof(mainform.Devices[i].AlwaysOn));
      Filestream.WriteBuffer(mainform.Devices[i].ChannelForPower,sizeof(mainform.Devices[i].ChannelForPower));
      Filestream.WriteBuffer(mainform.Devices[i].Power,sizeof(mainform.Devices[i].Power));
      Filestream.WriteBuffer(mainform.Devices[i].Phase,sizeof(mainform.Devices[i].Phase));
      Filestream.WriteBuffer(mainform.Devices[i].CalcPowerAboveValue,sizeof(mainform.Devices[i].CalcPowerAboveValue));
      Filestream.WriteBuffer(mainform.Devices[i].ContinuousPower,sizeof(mainform.Devices[i].ContinuousPower));
      Filestream.WriteBuffer(mainform.Devices[i].UseFullPowerOnChannelvalue,sizeof(mainform.Devices[i].UseFullPowerOnChannelvalue));

      Filestream.WriteBuffer(mainform.Devices[i].MatrixDeviceLevel,sizeof(mainform.Devices[i].MatrixDeviceLevel));
      Filestream.WriteBuffer(mainform.Devices[i].MatrixMainDeviceID,sizeof(mainform.Devices[i].MatrixMainDeviceID));
      Filestream.WriteBuffer(mainform.Devices[i].MatrixOrderType,sizeof(mainform.Devices[i].MatrixOrderType));
      Filestream.WriteBuffer(mainform.Devices[i].MatrixXCount,sizeof(mainform.Devices[i].MatrixXCount));
      Filestream.WriteBuffer(mainform.Devices[i].MatrixYCount,sizeof(mainform.Devices[i].MatrixYCount));
      Filestream.WriteBuffer(mainform.Devices[i].MatrixXPosition,sizeof(mainform.Devices[i].MatrixXPosition));
      Filestream.WriteBuffer(mainform.Devices[i].MatrixYPosition,sizeof(mainform.Devices[i].MatrixYPosition));

      Count2:=length(mainform.Devices[i].kanaltyp);
  	  Filestream.WriteBuffer(Count2,sizeof(Count2));
      for j:=0 to length(mainform.Devices[i].kanaltyp)-1 do
      begin
     	  Filestream.WriteBuffer(mainform.Devices[i].KanalMinValue[j],sizeof(mainform.Devices[i].KanalMinValue[j]));
     	  Filestream.WriteBuffer(mainform.Devices[i].KanalMaxValue[j],sizeof(mainform.Devices[i].KanalMaxValue[j]));
     	  Filestream.WriteBuffer(mainform.Devices[i].kanaltyp[j],sizeof(mainform.Devices[i].kanaltyp[j]));
     	  Filestream.WriteBuffer(mainform.Devices[i].kanalname[j],sizeof(mainform.Devices[i].kanalname[j]));
     	  Filestream.WriteBuffer(mainform.Devices[i].kanalfade[j],sizeof(mainform.Devices[i].kanalfade[j]));
     	  Filestream.WriteBuffer(mainform.Devices[i].kanaldimmcurve[j],sizeof(mainform.Devices[i].kanaldimmcurve[j]));
     	  Filestream.WriteBuffer(mainform.Devices[i].kanalabsolutedimmcurve[j],sizeof(mainform.Devices[i].kanalabsolutedimmcurve[j]));
      end;
    end;
// Ende Geräte
// Presets speichern
	  inprogress.filename.Caption:=_('Schreibe Datei... Presets');
  	inprogress.Refresh;
    Count:=length(mainform.DevicePresets);
	  Filestream.WriteBuffer(Count,sizeof(Count));
    for i:=0 to Count-1 do
    begin
   	  Filestream.WriteBuffer(mainform.DevicePresets[i].ID,sizeof(mainform.DevicePresets[i].ID));
   	  Filestream.WriteBuffer(mainform.DevicePresets[i].Name,sizeof(mainform.DevicePresets[i].Name));
   	  Filestream.WriteBuffer(mainform.DevicePresets[i].Beschreibung,sizeof(mainform.DevicePresets[i].Beschreibung));
   	  Filestream.WriteBuffer(mainform.DevicePresets[i].Category,sizeof(mainform.DevicePresets[i].Category));
      count2:=length(mainform.DevicePresets[i].ChanTyp);
   	  Filestream.WriteBuffer(count2,sizeof(count2));
      for k:=0 to count2-1 do
      begin
     	  Filestream.WriteBuffer(mainform.DevicePresets[i].ChanTyp[k],sizeof(mainform.DevicePresets[i].ChanTyp[k]));
     	  Filestream.WriteBuffer(mainform.DevicePresets[i].ChanValue[k],sizeof(mainform.DevicePresets[i].ChanValue[k]));
     	  Filestream.WriteBuffer(mainform.DevicePresets[i].ChanActive[k],sizeof(mainform.DevicePresets[i].ChanActive[k]));
      end;

      Filestream.WriteBuffer(mainform.DevicePresets[i].UseNewInterface,sizeof(mainform.DevicePresets[i].UseNewInterface));
      Filestream.WriteBuffer(mainform.DevicePresets[i].Color,sizeof(mainform.DevicePresets[i].Color));
      Filestream.WriteBuffer(mainform.DevicePresets[i].Shutter,sizeof(mainform.DevicePresets[i].Shutter));
      Filestream.WriteBuffer(mainform.DevicePresets[i].Dimmer,sizeof(mainform.DevicePresets[i].Dimmer));
      Filestream.WriteBuffer(mainform.DevicePresets[i].Iris,sizeof(mainform.DevicePresets[i].Iris));
      Filestream.WriteBuffer(mainform.DevicePresets[i].Focus,sizeof(mainform.DevicePresets[i].Focus));
      Filestream.WriteBuffer(mainform.DevicePresets[i].PrismaRot,sizeof(mainform.DevicePresets[i].PrismaRot));
      Filestream.WriteBuffer(mainform.DevicePresets[i].PrismaEnabled,sizeof(mainform.DevicePresets[i].PrismaEnabled));
      Filestream.WriteBuffer(mainform.DevicePresets[i].Strobe,sizeof(mainform.DevicePresets[i].Strobe));
      Filestream.WriteBuffer(mainform.DevicePresets[i].Pan,sizeof(mainform.DevicePresets[i].Pan));
      Filestream.WriteBuffer(mainform.DevicePresets[i].Tilt,sizeof(mainform.DevicePresets[i].Tilt));
      Filestream.WriteBuffer(mainform.DevicePresets[i].PanFine,sizeof(mainform.DevicePresets[i].PanFine));
      Filestream.WriteBuffer(mainform.DevicePresets[i].TiltFine,sizeof(mainform.DevicePresets[i].TiltFine));
      Filestream.WriteBuffer(mainform.DevicePresets[i].Gobo,sizeof(mainform.DevicePresets[i].Gobo));
      Filestream.WriteBuffer(mainform.DevicePresets[i].GoboRot1,sizeof(mainform.DevicePresets[i].GoboRot1));
      Filestream.WriteBuffer(mainform.DevicePresets[i].GoboRot2,sizeof(mainform.DevicePresets[i].GoboRot2));
    end;
// Ende Presets
// Geräteszenen speichern
	  inprogress.filename.Caption:=_('Schreibe Datei... Geräteszenen');
  	inprogress.Refresh;
      Count:=length(DeviceScenes);
   	  Filestream.WriteBuffer(Count,sizeof(Count));
      for i:=0 to length(DeviceScenes)-1 do
    	begin
        Filestream.WriteBuffer(DeviceScenes[i].ID,sizeof(DeviceScenes[i].ID));
        Filestream.WriteBuffer(DeviceScenes[i].Name,sizeof(DeviceScenes[i].Name));
        Filestream.WriteBuffer(DeviceScenes[i].Beschreibung,sizeof(DeviceScenes[i].Beschreibung));
        Filestream.WriteBuffer(DeviceScenes[i].Fadetime,sizeof(DeviceScenes[i].Fadetime));
        Filestream.WriteBuffer(DeviceScenes[i].Category,sizeof(DeviceScenes[i].Category));
        Count2:=length(DeviceScenes[i].Devices);
     	  Filestream.WriteBuffer(Count2,sizeof(Count2));
        for j:=0 to Count2-1 do
        begin
          Filestream.WriteBuffer(DeviceScenes[i].Devices[j].ID,sizeof(DeviceScenes[i].Devices[j].ID));
          Count3:=length(DeviceScenes[i].Devices[j].ChanActive);
       	  Filestream.WriteBuffer(Count3,sizeof(Count3));
          for k:=0 to Count3-1 do
            Filestream.WriteBuffer(DeviceScenes[i].Devices[j].ChanActive[k],sizeof(DeviceScenes[i].Devices[j].ChanActive[k]));

          Count3:=length(DeviceScenes[i].Devices[j].ChanValue);
       	  Filestream.WriteBuffer(Count3,sizeof(Count3));
          for k:=0 to Count3-1 do
            Filestream.WriteBuffer(DeviceScenes[i].Devices[j].ChanValue[k],sizeof(DeviceScenes[i].Devices[j].ChanValue[k]));

          Count3:=length(DeviceScenes[i].Devices[j].ChanActiveRandom);
       	  Filestream.WriteBuffer(Count3,sizeof(Count3));
          for k:=0 to Count3-1 do
            Filestream.WriteBuffer(DeviceScenes[i].Devices[j].ChanActiveRandom[k],sizeof(DeviceScenes[i].Devices[j].ChanActiveRandom[k]));

          Count3:=length(DeviceScenes[i].Devices[j].ChanValueRandom);
       	  Filestream.WriteBuffer(Count3,sizeof(Count3));
          for k:=0 to Count3-1 do
            Filestream.WriteBuffer(DeviceScenes[i].Devices[j].ChanValueRandom[k],sizeof(DeviceScenes[i].Devices[j].ChanValueRandom[k]));

          Count3:=length(DeviceScenes[i].Devices[j].ChanDelay);
       	  Filestream.WriteBuffer(Count3,sizeof(Count3));
          for k:=0 to Count3-1 do
            Filestream.WriteBuffer(DeviceScenes[i].Devices[j].ChanDelay[k],sizeof(DeviceScenes[i].Devices[j].ChanDelay[k]));

          Count3:=length(DeviceScenes[i].Devices[j].ChanFadetime);
       	  Filestream.WriteBuffer(Count3,sizeof(Count3));
          for k:=0 to Count3-1 do
            Filestream.WriteBuffer(DeviceScenes[i].Devices[j].ChanFadetime[k],sizeof(DeviceScenes[i].Devices[j].ChanFadetime[k]));
        end;
        Count:=length(DeviceScenes[i].Befehle);
        Filestream.WriteBuffer(Count,sizeof(Count));
        for l:=0 to Count-1 do
        begin
          Filestream.WriteBuffer(DeviceScenes[i].Befehle[l].ID,sizeof(DeviceScenes[i].Befehle[l].ID));
          Filestream.WriteBuffer(DeviceScenes[i].Befehle[l].Typ,sizeof(DeviceScenes[i].Befehle[l].Typ));
          Filestream.WriteBuffer(DeviceScenes[i].Befehle[l].Name,sizeof(DeviceScenes[i].Befehle[l].Name));
          Filestream.WriteBuffer(DeviceScenes[i].Befehle[l].Beschreibung,sizeof(DeviceScenes[i].Befehle[l].Beschreibung));
          Filestream.WriteBuffer(DeviceScenes[i].Befehle[l].OnValue,sizeof(DeviceScenes[i].Befehle[l].OnValue));
          Filestream.WriteBuffer(DeviceScenes[i].Befehle[l].SwitchValue,sizeof(DeviceScenes[i].Befehle[l].SwitchValue));
          Filestream.WriteBuffer(DeviceScenes[i].Befehle[l].InvertSwitchValue,sizeof(DeviceScenes[i].Befehle[l].InvertSwitchValue));
          Filestream.WriteBuffer(DeviceScenes[i].Befehle[l].OffValue,sizeof(DeviceScenes[i].Befehle[l].OffValue));
          Filestream.WriteBuffer(DeviceScenes[i].Befehle[l].ScaleValue,sizeof(DeviceScenes[i].Befehle[l].ScaleValue));

          Count2:=length(DeviceScenes[i].Befehle[l].ArgInteger);
          Filestream.WriteBuffer(Count2,sizeof(Count2));
          for m:=0 to Count2-1 do
            Filestream.WriteBuffer(DeviceScenes[i].Befehle[l].ArgInteger[m],sizeof(DeviceScenes[i].Befehle[l].ArgInteger[m]));
          Count2:=length(DeviceScenes[i].Befehle[l].ArgString);
          Filestream.WriteBuffer(Count2,sizeof(Count2));
          for m:=0 to Count2-1 do
            Filestream.WriteBuffer(DeviceScenes[i].Befehle[l].ArgString[m],sizeof(DeviceScenes[i].Befehle[l].ArgString[m]));
          Count2:=length(DeviceScenes[i].Befehle[l].ArgGUID);
          Filestream.WriteBuffer(Count2,sizeof(Count2));
          for m:=0 to Count2-1 do
            Filestream.WriteBuffer(DeviceScenes[i].Befehle[l].ArgGUID[m],sizeof(DeviceScenes[i].Befehle[l].ArgGUID[m]));


          Count2:=length(DeviceScenes[i].Befehlswerte[l].ChanActive);
          Filestream.WriteBuffer(Count2,sizeof(Count2));
          for m:=0 to Count2-1 do
          begin
            Filestream.WriteBuffer(DeviceScenes[i].Befehlswerte[l].ChanActive[m],sizeof(DeviceScenes[i].Befehlswerte[l].ChanActive[m]));
            Filestream.WriteBuffer(DeviceScenes[i].Befehlswerte[l].ChanValue[m],sizeof(DeviceScenes[i].Befehlswerte[l].ChanValue[m]));
            Filestream.WriteBuffer(DeviceScenes[i].Befehlswerte[l].ChanActiveRandom[m],sizeof(DeviceScenes[i].Befehlswerte[l].ChanActiveRandom[m]));
            Filestream.WriteBuffer(DeviceScenes[i].Befehlswerte[l].ChanValueRandom[m],sizeof(DeviceScenes[i].Befehlswerte[l].ChanValueRandom[m]));
            Filestream.WriteBuffer(DeviceScenes[i].Befehlswerte[l].ChanDelay[m],sizeof(DeviceScenes[i].Befehlswerte[l].ChanDelay[m]));
            Filestream.WriteBuffer(DeviceScenes[i].Befehlswerte[l].ChanFadetime[m],sizeof(DeviceScenes[i].Befehlswerte[l].ChanFadetime[m]));
          end;
        end;
      end;
// Ende Geräteszenen
// Gruppen speichern
	  inprogress.filename.Caption:=_('Schreibe Datei... Gerätegruppen');
  	inprogress.Refresh;
    Count:=length(mainform.DeviceGroups);
	  Filestream.WriteBuffer(Count,sizeof(Count));
    for i:=0 to Count-1 do
    begin
   	  Filestream.WriteBuffer(mainform.DeviceGroups[i].Active,sizeof(mainform.DeviceGroups[i].Active));
   	  Filestream.WriteBuffer(mainform.DeviceGroups[i].ID,sizeof(mainform.DeviceGroups[i].ID));
   	  Filestream.WriteBuffer(mainform.DeviceGroups[i].Name,sizeof(mainform.DeviceGroups[i].Name));
   	  Filestream.WriteBuffer(mainform.DeviceGroups[i].Beschreibung,sizeof(mainform.DeviceGroups[i].Beschreibung));
      Count2:=length(mainform.DeviceGroups[i].IDs);
  	  Filestream.WriteBuffer(Count2,sizeof(Count2));
      for k:=0 to Count2-1 do
      begin
     	  Filestream.WriteBuffer(mainform.DeviceGroups[i].IDs[k],sizeof(mainform.DeviceGroups[i].IDs[k]));
     	  Filestream.WriteBuffer(mainform.DeviceGroups[i].IDActive[k],sizeof(mainform.DeviceGroups[i].IDActive[k]));
     	  Filestream.WriteBuffer(mainform.DeviceGroups[i].Delays[k],sizeof(mainform.DeviceGroups[i].Delays[k]));
      end;
      Filestream.WriteBuffer(mainform.DeviceGroups[i].MasterDevice,sizeof(mainform.DeviceGroups[i].MasterDevice));
   	  Filestream.WriteBuffer(mainform.DeviceGroups[i].UseMaster,sizeof(mainform.DeviceGroups[i].UseMaster));
   	  Filestream.WriteBuffer(mainform.DeviceGroups[i].FanMode,sizeof(mainform.DeviceGroups[i].FanMode));
   	  Filestream.WriteBuffer(mainform.DeviceGroups[i].FanMorph,sizeof(mainform.DeviceGroups[i].FanMorph));
   	  Filestream.WriteBuffer(mainform.DeviceGroups[i].Delay,sizeof(mainform.DeviceGroups[i].Delay));
    end;
// Ende Gruppen
// Softpatch speichern
	  inprogress.filename.Caption:=_('Schreibe Datei... Softpatch');
  	inprogress.Refresh;
    Count:=length(mainform.Softpatch);
    Filestream.WriteBuffer(Count,sizeof(Count));
    for i:=0 to Count-1 do
    begin
   	  Filestream.WriteBuffer(mainform.softpatch[i].Channel,sizeof(mainform.softpatch[i].Channel));
      Count2:=length(mainform.Softpatch[i].RouteToInputChan);
      Filestream.WriteBuffer(Count2,sizeof(Count2));
      for k:=0 to Count2-1 do
      begin
     	  Filestream.WriteBuffer(mainform.softpatch[i].RouteToInputChan[k],sizeof(mainform.softpatch[i].RouteToInputChan[k]));
      end;
    end;

    Count:=length(mainform.Softpatch2);
    Filestream.WriteBuffer(Count,sizeof(Count));
    for i:=0 to Count-1 do
    begin
      Filestream.WriteBuffer(mainform.softpatch2[i].Channel2,sizeof(mainform.softpatch2[i].Channel2));
      Count2:=length(mainform.softpatch2[i].RouteToPC_DIMMERChan);
      Filestream.WriteBuffer(Count2,sizeof(Count2));
      for k:=0 to Count2-1 do
      begin
        Filestream.WriteBuffer(mainform.softpatch2[i].RouteToPC_DIMMERChan[k],sizeof(mainform.softpatch2[i].RouteToPC_DIMMERChan[k]));
      end;
    end;
// Ende Softpatch
// Effekte speichern
	  inprogress.filename.Caption:=_('Schreibe Datei... Effekte');
  	inprogress.Refresh;
    Count:=length(Effektsequenzereffekte);
    Filestream.WriteBuffer(Count, sizeof(Count));
    for i:=0 to Count-1 do
    begin
      Filestream.WriteBuffer(Effektsequenzereffekte[i].ID,sizeof(Effektsequenzereffekte[i].ID));
      Filestream.WriteBuffer(Effektsequenzereffekte[i].Name,sizeof(Effektsequenzereffekte[i].Name));
      Filestream.WriteBuffer(Effektsequenzereffekte[i].Beschreibung,sizeof(Effektsequenzereffekte[i].Beschreibung));
      Filestream.WriteBuffer(Effektsequenzereffekte[i].TabPosition,sizeof(Effektsequenzereffekte[i].TabPosition));
      Filestream.WriteBuffer(Effektsequenzereffekte[i].AnzahlderDurchlaufe,sizeof(Effektsequenzereffekte[i].AnzahlderDurchlaufe));
      Filestream.WriteBuffer(Effektsequenzereffekte[i].modus,sizeof(Effektsequenzereffekte[i].modus));
      Filestream.WriteBuffer(Effektsequenzereffekte[i].Repeating,sizeof(Effektsequenzereffekte[i].Repeating));
      Filestream.WriteBuffer(Effektsequenzereffekte[i].intensitaet,sizeof(Effektsequenzereffekte[i].intensitaet));
      Filestream.WriteBuffer(Effektsequenzereffekte[i].speed,sizeof(Effektsequenzereffekte[i].speed));
      Filestream.WriteBuffer(Effektsequenzereffekte[i].startwithstepone,sizeof(Effektsequenzereffekte[i].startwithstepone));
      Filestream.WriteBuffer(Effektsequenzereffekte[i].blackoutonstop,sizeof(Effektsequenzereffekte[i].blackoutonstop));
      Filestream.WriteBuffer(Effektsequenzereffekte[i].Startscene,sizeof(Effektsequenzereffekte[i].Startscene));
      Filestream.WriteBuffer(Effektsequenzereffekte[i].Stopscene,sizeof(Effektsequenzereffekte[i].Stopscene));

      Count2:=length(Effektsequenzereffekte[i].effektschritte);
      Filestream.WriteBuffer(Count2, sizeof(Count2));
      for k:=0 to Count2-1 do
      begin
        Count3:=length(Effektsequenzereffekte[i].effektschritte[k].IDs);
        Filestream.WriteBuffer(Count3, sizeof(Count3));
        for l:=0 to Count3-1 do
          Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].IDs[l],sizeof(Effektsequenzereffekte[i].effektschritte[k].IDs[l]));
        Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].Typ,sizeof(Effektsequenzereffekte[i].effektschritte[k].Typ));
        Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].Name,sizeof(Effektsequenzereffekte[i].effektschritte[k].Name));
        Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].Beschreibung,sizeof(Effektsequenzereffekte[i].effektschritte[k].Beschreibung));
        Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].einblendzeit,sizeof(Effektsequenzereffekte[i].effektschritte[k].einblendzeit));
        Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].wartezeit,sizeof(Effektsequenzereffekte[i].effektschritte[k].wartezeit));
        Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].AnzahlBeats,sizeof(Effektsequenzereffekte[i].effektschritte[k].AnzahlBeats));
        Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].DeactivateLastScene,sizeof(Effektsequenzereffekte[i].effektschritte[k].DeactivateLastScene));

        Count3:=length(Effektsequenzereffekte[i].effektschritte[k].Devices);
        Filestream.WriteBuffer(Count3,sizeof(Count3));
        for l:=0 to Count3-1 do
        begin
          Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ID,sizeof(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ID));
          Count4:=length(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanActive);
          Filestream.WriteBuffer(Count4,sizeof(Count4));
          for m:=0 to Count4-1 do
          begin
            Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanActive[m],sizeof(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanActive[m]));
            Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanValue[m],sizeof(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanValue[m]));
            Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanActiveRandom[m],sizeof(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanActiveRandom[m]));
            Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanValueRandom[m],sizeof(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanValueRandom[m]));
            Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanDelay[m],sizeof(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanDelay[m]));
            Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanFadetime[m],sizeof(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanFadetime[m]));
          end;
        end;
        Count:=length(Effektsequenzereffekte[i].effektschritte[k].Befehle);
        Filestream.WriteBuffer(Count,sizeof(Count));
        for l:=0 to Count-1 do
        begin
          Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].ID,sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].ID));
          Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].Typ,sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].Typ));
          Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].Name,sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].Name));
          Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].Beschreibung,sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].Beschreibung));
          Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].OnValue,sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].OnValue));
          Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].SwitchValue,sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].SwitchValue));
          Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].InvertSwitchValue,sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].InvertSwitchValue));
          Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].OffValue,sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].OffValue));
          Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].ScaleValue,sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].ScaleValue));

          Count2:=length(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].ArgInteger);
          Filestream.WriteBuffer(Count2,sizeof(Count2));
          for m:=0 to Count2-1 do
            Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].ArgInteger[m],sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].ArgInteger[m]));
          Count2:=length(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].ArgString);
          Filestream.WriteBuffer(Count2,sizeof(Count2));
          for m:=0 to Count2-1 do
            Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].ArgString[m],sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].ArgString[m]));
          Count2:=length(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].ArgGUID);
          Filestream.WriteBuffer(Count2,sizeof(Count2));
          for m:=0 to Count2-1 do
            Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].ArgGUID[m],sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].ArgGUID[m]));

          Count2:=length(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanActive);
          Filestream.WriteBuffer(Count2,sizeof(Count2));
          for m:=0 to Count2-1 do
          begin
            Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanActive[m],sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanActive[m]));
            Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanValue[m],sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanValue[m]));
            Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanActiveRandom[m],sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanActiveRandom[m]));
            Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanValueRandom[m],sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanValueRandom[m]));
            Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanDelay[m],sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanDelay[m]));
            Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanFadetime[m],sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanFadetime[m]));
          end;
        end;
        Filestream.WriteBuffer(Effektsequenzereffekte[i].effektschritte[k].ActivateTimecontrol,sizeof(Effektsequenzereffekte[i].effektschritte[k].ActivateTimecontrol));
      end;
    end;

    Count:=length(EffektsequenzerTabs);
    Filestream.WriteBuffer(Count,sizeof(Count));
    for i:=0 to Count-1 do
      Filestream.WriteBuffer(EffektsequenzerTabs[i],sizeof(EffektsequenzerTabs[i]));
// Ende Effekte speichern
// Bühnenansicht speichern
	  inprogress.filename.Caption:=_('Schreibe Datei... Bühnenansicht');
  	inprogress.Refresh;
    FileStream.WriteBuffer(mainform.buehnenansichtsetup,sizeof(mainform.buehnenansichtsetup));

    count:=grafischebuehnenansicht.BankSelect.Items.Count;
    FileStream.WriteBuffer(count,sizeof(count));
    for i:=0 to grafischebuehnenansicht.BankSelect.Items.Count-1 do
    begin
      text:=grafischebuehnenansicht.BankSelect.Items[i];
      FileStream.WriteBuffer(text, sizeof(text));
      FileStream.WriteBuffer(buehnenansicht_background[i], sizeof(buehnenansicht_background[i]));
    end;

    count:=length(mainform.buehnenansichtdevices);
    FileStream.WriteBuffer(count,sizeof(count));
    for i:=0 to count-1 do
    begin
    	FileStream.WriteBuffer(mainform.buehnenansichtdevices[i].channel,sizeof(mainform.buehnenansichtdevices[i].channel));
    	FileStream.WriteBuffer(mainform.buehnenansichtdevices[i].color,sizeof(mainform.buehnenansichtdevices[i].color));
    	FileStream.WriteBuffer(mainform.buehnenansichtdevices[i].picture,sizeof(mainform.buehnenansichtdevices[i].picture));
      FileStream.WriteBuffer(mainform.buehnenansichtdevices[i].picturesize,sizeof(mainform.buehnenansichtdevices[i].picturesize));
      FileStream.WriteBuffer(mainform.buehnenansichtdevices[i].pictureangle,sizeof(mainform.buehnenansichtdevices[i].pictureangle));
      FileStream.WriteBuffer(mainform.buehnenansichtdevices[i].picturefliphor,sizeof(mainform.buehnenansichtdevices[i].picturefliphor));
      FileStream.WriteBuffer(mainform.buehnenansichtdevices[i].pictureflipver,sizeof(mainform.buehnenansichtdevices[i].pictureflipver));
      FileStream.WriteBuffer(mainform.buehnenansichtdevices[i].pictureispng,sizeof(mainform.buehnenansichtdevices[i].pictureispng));
    	FileStream.WriteBuffer(mainform.buehnenansichtdevices[i].top,sizeof(mainform.buehnenansichtdevices[i].top));
    	FileStream.WriteBuffer(mainform.buehnenansichtdevices[i].left,sizeof(mainform.buehnenansichtdevices[i].left));
    	FileStream.WriteBuffer(mainform.buehnenansichtdevices[i].bank,sizeof(mainform.buehnenansichtdevices[i].bank));
    end;
// Bühnenansicht ende
// Submaster (alt) speichern
    count:=length(mainform.Submasterfader);
    FileStream.WriteBuffer(count,sizeof(count));
    for i:=0 to count-1 do
    begin
    	FileStream.WriteBuffer(mainform.Submasterfader[i],sizeof(mainform.Submasterfader[i]));
    end;
// Submaster Ende
// Desktopproperties speichern
	  inprogress.filename.Caption:=_('Schreibe Datei... Desktopeinstellungen');
  	inprogress.Refresh;
  for i:=1 to 9 do
  begin
    FileStream.WriteBuffer(desktopproperties[i].name,sizeof(desktopproperties[i].name));
    FileStream.WriteBuffer(desktopproperties[i].maintop,sizeof(desktopproperties[i].maintop));
    FileStream.WriteBuffer(desktopproperties[i].mainleft,sizeof(desktopproperties[i].mainleft));
    FileStream.WriteBuffer(desktopproperties[i].mainheight,sizeof(desktopproperties[i].mainheight));
    FileStream.WriteBuffer(desktopproperties[i].mainwidth,sizeof(desktopproperties[i].mainwidth));
    count:=length(desktopproperties[i].top);
    FileStream.WriteBuffer(Count,sizeof(Count));
    for k:=0 to Count-1 do
    begin
      FileStream.WriteBuffer(desktopproperties[i].top[k],sizeof(desktopproperties[i].top[k]));
      FileStream.WriteBuffer(desktopproperties[i].left[k],sizeof(desktopproperties[i].left[k]));
      FileStream.WriteBuffer(desktopproperties[i].height[k],sizeof(desktopproperties[i].height[k]));
      FileStream.WriteBuffer(desktopproperties[i].width[k],sizeof(desktopproperties[i].width[k]));
      FileStream.WriteBuffer(desktopproperties[i].visible[k],sizeof(desktopproperties[i].visible[k]));
    end;
  end;
// Desktopproperties Ende
// Joystickeinstellungen Speichern
	  inprogress.filename.Caption:=_('Schreibe Datei... Joystickeinstellungen');
  	inprogress.Refresh;
    for i:=0 to length(JoystickEvents)-1 do
    begin
      Filestream.WriteBuffer(JoystickEvents[i].ID,sizeof(JoystickEvents[i].ID));
      Filestream.WriteBuffer(JoystickEvents[i].UseEvent,sizeof(JoystickEvents[i].UseEvent));
      Filestream.WriteBuffer(JoystickEvents[i].positionrelativ,sizeof(JoystickEvents[i].positionrelativ));
      Filestream.WriteBuffer(JoystickEvents[i].invert,sizeof(JoystickEvents[i].invert));
      Filestream.WriteBuffer(JoystickEvents[i].deaktivierterbereich,sizeof(JoystickEvents[i].deaktivierterbereich));
      Filestream.WriteBuffer(JoystickEvents[i].beschleunigung,sizeof(JoystickEvents[i].beschleunigung));
      Filestream.WriteBuffer(JoystickEvents[i].offset,sizeof(JoystickEvents[i].offset));
      Filestream.WriteBuffer(JoystickEvents[i].PermanentUpdate,sizeof(JoystickEvents[i].PermanentUpdate));

      Filestream.WriteBuffer(JoystickEvents[i].Befehl.Typ,sizeof(JoystickEvents[i].Befehl.Typ));
      Filestream.WriteBuffer(JoystickEvents[i].Befehl.OnValue,sizeof(JoystickEvents[i].Befehl.OnValue));
      Filestream.WriteBuffer(JoystickEvents[i].Befehl.SwitchValue,sizeof(JoystickEvents[i].Befehl.SwitchValue));
      Filestream.WriteBuffer(JoystickEvents[i].Befehl.InvertSwitchValue,sizeof(JoystickEvents[i].Befehl.InvertSwitchValue));
      Filestream.WriteBuffer(JoystickEvents[i].Befehl.OffValue,sizeof(JoystickEvents[i].Befehl.OffValue));
      Filestream.WriteBuffer(JoystickEvents[i].Befehl.ScaleValue,sizeof(JoystickEvents[i].Befehl.ScaleValue));
      Count2:=length(JoystickEvents[i].Befehl.ArgInteger);
      Filestream.WriteBuffer(Count2,sizeof(Count2));
      for j:=0 to Count2-1 do
        Filestream.WriteBuffer(JoystickEvents[i].Befehl.ArgInteger[j],sizeof(JoystickEvents[i].Befehl.ArgInteger[j]));
      Count2:=length(JoystickEvents[i].Befehl.ArgString);
      Filestream.WriteBuffer(Count2,sizeof(Count2));
      for j:=0 to Count2-1 do
        Filestream.WriteBuffer(JoystickEvents[i].Befehl.ArgString[j],sizeof(JoystickEvents[i].Befehl.ArgString[j]));
      Count2:=length(JoystickEvents[i].Befehl.ArgGUID);
      Filestream.WriteBuffer(Count2,sizeof(Count2));
      for j:=0 to Count2-1 do
        Filestream.WriteBuffer(JoystickEvents[i].Befehl.ArgGUID[j],sizeof(JoystickEvents[i].Befehl.ArgGUID[j]));
    end;
// Joystickeinstellungen Ende
// Kontrollpanel speichern
	  inprogress.filename.Caption:=_('Schreibe Datei... Kontrollpanel');
  	inprogress.Refresh;

    mainform.kontrollpanelrecord.zeilenanzahl:=kontrollpanel.zeilen.AsInteger-1;
    mainform.kontrollpanelrecord.spaltenanzahl:=kontrollpanel.spalten.AsInteger-1;
    mainform.kontrollpanelrecord.formwidth:=kontrollpanel.Width;
    mainform.kontrollpanelrecord.formheight:=kontrollpanel.Height;

    Filestream.WriteBuffer(kontrollpanelrecord,sizeof(kontrollpanelrecord));

    Count:=round(kontrollpanel.zeilen.value);
    Filestream.WriteBuffer(Count,sizeof(Count));
    Count:=round(kontrollpanel.spalten.value);
    Filestream.WriteBuffer(Count,sizeof(Count));
    for i:=0 to round(kontrollpanel.zeilen.value)-1 do
    for j:=0 to round(kontrollpanel.spalten.value)-1 do
    begin
      Filestream.WriteBuffer(kontrollpanelbuttons[i][j].ID,sizeof(kontrollpanelbuttons[i][j].ID));
      Filestream.WriteBuffer(kontrollpanelbuttons[i][j].Name,sizeof(kontrollpanelbuttons[i][j].Name));
      Filestream.WriteBuffer(kontrollpanelbuttons[i][j].Color,sizeof(kontrollpanelbuttons[i][j].Color));
      Filestream.WriteBuffer(kontrollpanelbuttons[i][j].Typ,sizeof(kontrollpanelbuttons[i][j].Typ));
      Filestream.WriteBuffer(kontrollpanelbuttons[i][j].Shortcut,sizeof(kontrollpanelbuttons[i][j].Shortcut));
      Filestream.WriteBuffer(kontrollpanelbuttons[i][j].Picture,sizeof(kontrollpanelbuttons[i][j].Picture));
    end;
// Kontrollpanel ende
// MIDI-IN Event speichern
	  inprogress.filename.Caption:=_('Schreibe Datei... MIDI-In');
  	inprogress.Refresh;
    Count:=length(MidiEventArray);
    Filestream.WriteBuffer(Count,sizeof(Count));
    for i:=0 to Count-1 do
    begin
      Filestream.WriteBuffer(MidiEventArray[i].ID,sizeof(MidiEventArray[i].ID));
      Filestream.WriteBuffer(MidiEventArray[i].MIDIMessage,sizeof(MidiEventArray[i].MIDIMessage));
      Filestream.WriteBuffer(MidiEventArray[i].MIDIData1,sizeof(MidiEventArray[i].MIDIData1));
      Filestream.WriteBuffer(MidiEventArray[i].MIDIData2,sizeof(MidiEventArray[i].MIDIData2));

      Filestream.WriteBuffer(MidiEventArray[i].Befehl.Typ,sizeof(MidiEventArray[i].Befehl.Typ));
      Filestream.WriteBuffer(MidiEventArray[i].Befehl.Name,sizeof(MidiEventArray[i].Befehl.Name));
      Filestream.WriteBuffer(MidiEventArray[i].Befehl.Beschreibung,sizeof(MidiEventArray[i].Befehl.Beschreibung));
      Filestream.WriteBuffer(MidiEventArray[i].Befehl.OnValue,sizeof(MidiEventArray[i].Befehl.OnValue));
      Filestream.WriteBuffer(MidiEventArray[i].Befehl.SwitchValue,sizeof(MidiEventArray[i].Befehl.SwitchValue));
      Filestream.WriteBuffer(MidiEventArray[i].Befehl.InvertSwitchValue,sizeof(MidiEventArray[i].Befehl.InvertSwitchValue));
      Filestream.WriteBuffer(MidiEventArray[i].Befehl.OffValue,sizeof(MidiEventArray[i].Befehl.OffValue));
      Filestream.WriteBuffer(MidiEventArray[i].Befehl.ScaleValue,sizeof(MidiEventArray[i].Befehl.ScaleValue));
      Count2:=length(MidiEventArray[i].Befehl.ArgInteger);
      Filestream.WriteBuffer(Count2,sizeof(Count2));
      for j:=0 to Count2-1 do
        Filestream.WriteBuffer(MidiEventArray[i].Befehl.ArgInteger[j],sizeof(MidiEventArray[i].Befehl.ArgInteger[j]));
      Count2:=length(MidiEventArray[i].Befehl.ArgString);
      Filestream.WriteBuffer(Count2,sizeof(Count2));
      for j:=0 to Count2-1 do
        Filestream.WriteBuffer(MidiEventArray[i].Befehl.ArgString[j],sizeof(MidiEventArray[i].Befehl.ArgString[j]));
      Count2:=length(MidiEventArray[i].Befehl.ArgGUID);
      Filestream.WriteBuffer(Count2,sizeof(Count2));
      for j:=0 to Count2-1 do
        Filestream.WriteBuffer(MidiEventArray[i].Befehl.ArgGUID[j],sizeof(MidiEventArray[i].Befehl.ArgGUID[j]));

      Filestream.WriteBuffer(MidiEventArray[i].Data1orData2,sizeof(MidiEventArray[i].Data1orData2));
      Filestream.WriteBuffer(MidiEventArray[i].UseMidiBacktrack,sizeof(MidiEventArray[i].UseMidiBacktrack));
    end;
// MIDI-IN Event Ende
// Data-IN Event speichern
	  inprogress.filename.Caption:=_('Schreibe Datei... Data-In');
  	inprogress.Refresh;
    Count:=length(DataInEventArray);
    Filestream.WriteBuffer(Count,sizeof(Count));
    for i:=0 to Count-1 do
    begin
      Filestream.WriteBuffer(DataInEventArray[i].ID,sizeof(DataInEventArray[i].ID));
      Filestream.WriteBuffer(DataInEventArray[i].Channel,sizeof(DataInEventArray[i].Channel));
      Filestream.WriteBuffer(DataInEventArray[i].Value,sizeof(DataInEventArray[i].Value));

      Filestream.WriteBuffer(DatainEventArray[i].Befehl.Typ,sizeof(DatainEventArray[i].Befehl.Typ));
      Filestream.WriteBuffer(DatainEventArray[i].Befehl.Name,sizeof(DatainEventArray[i].Befehl.Name));
      Filestream.WriteBuffer(DatainEventArray[i].Befehl.Beschreibung,sizeof(DatainEventArray[i].Befehl.Beschreibung));
      Filestream.WriteBuffer(DatainEventArray[i].Befehl.OnValue,sizeof(DatainEventArray[i].Befehl.OnValue));
      Filestream.WriteBuffer(DatainEventArray[i].Befehl.SwitchValue,sizeof(DatainEventArray[i].Befehl.SwitchValue));
      Filestream.WriteBuffer(DatainEventArray[i].Befehl.InvertSwitchValue,sizeof(DatainEventArray[i].Befehl.InvertSwitchValue));
      Filestream.WriteBuffer(DatainEventArray[i].Befehl.OffValue,sizeof(DatainEventArray[i].Befehl.OffValue));
      Filestream.WriteBuffer(DatainEventArray[i].Befehl.ScaleValue,sizeof(DatainEventArray[i].Befehl.ScaleValue));
      Count2:=length(DatainEventArray[i].Befehl.ArgInteger);
      Filestream.WriteBuffer(Count2,sizeof(Count2));
      for j:=0 to Count2-1 do
        Filestream.WriteBuffer(DatainEventArray[i].Befehl.ArgInteger[j],sizeof(DatainEventArray[i].Befehl.ArgInteger[j]));
      Count2:=length(DatainEventArray[i].Befehl.ArgString);
      Filestream.WriteBuffer(Count2,sizeof(Count2));
      for j:=0 to Count2-1 do
        Filestream.WriteBuffer(DatainEventArray[i].Befehl.ArgString[j],sizeof(DatainEventArray[i].Befehl.ArgString[j]));
      Count2:=length(DatainEventArray[i].Befehl.ArgGUID);
      Filestream.WriteBuffer(Count2,sizeof(Count2));
      for j:=0 to Count2-1 do
        Filestream.WriteBuffer(DatainEventArray[i].Befehl.ArgGUID[j],sizeof(DatainEventArray[i].Befehl.ArgGUID[j]));
    end;
// Data-IN Event Ende
// Leistungsdaten speichern
	  inprogress.filename.Caption:=_('Schreibe Datei... Leistungssteuerung');
  	inprogress.Refresh;
  Filestream.WriteBuffer(leistungsdaten.ampere,sizeof(leistungsdaten.ampere));
  Filestream.WriteBuffer(leistungsdaten.usesinus,sizeof(leistungsdaten.usesinus));
  Count:=length(leistungsdaten.channel);
  Filestream.WriteBuffer(Count,sizeof(Count));
  for i:=0 to Count-1 do
  begin
    Filestream.WriteBuffer(leistungsdaten.channel[i],sizeof(leistungsdaten.channel[i]));
    Filestream.WriteBuffer(leistungsdaten.phase[i],sizeof(leistungsdaten.phase[i]));
    Filestream.WriteBuffer(leistungsdaten.leistung[i],sizeof(leistungsdaten.leistung[i]));
    Filestream.WriteBuffer(leistungsdaten.deactivatechannelonoverload[i],sizeof(leistungsdaten.deactivatechannelonoverload[i]));
  end;
// Leistungsdaten Ende
// Leistungsdaten2 speichern
  for i:=0 to 11 do
    Filestream.WriteBuffer(leistungssteuerungform2.maxpower[i],sizeof(leistungssteuerungform2.maxpower[i]));
// Leistungsdaten2 Ende
// Autoszenen speichern
	  inprogress.filename.Caption:=_('Schreibe Datei... Autoszenen');
  	inprogress.Refresh;
    Count:=length(mainform.Autoszenen);
	  Filestream.WriteBuffer(Count,sizeof(Count));
    for i:=0 to Count-1 do
    begin
   	  Filestream.WriteBuffer(mainform.Autoszenen[i].ID,sizeof(mainform.Autoszenen[i].ID));
   	  Filestream.WriteBuffer(mainform.Autoszenen[i].Name,sizeof(mainform.Autoszenen[i].Name));
   	  Filestream.WriteBuffer(mainform.Autoszenen[i].Beschreibung,sizeof(mainform.Autoszenen[i].Beschreibung));
   	  Filestream.WriteBuffer(mainform.Autoszenen[i].fadetime,sizeof(mainform.Autoszenen[i].fadetime));
   	  Filestream.WriteBuffer(mainform.Autoszenen[i].R,sizeof(mainform.Autoszenen[i].R));
   	  Filestream.WriteBuffer(mainform.Autoszenen[i].G,sizeof(mainform.Autoszenen[i].G));
   	  Filestream.WriteBuffer(mainform.Autoszenen[i].B,sizeof(mainform.Autoszenen[i].B));
   	  Filestream.WriteBuffer(mainform.Autoszenen[i].A,sizeof(mainform.Autoszenen[i].A));
   	  Filestream.WriteBuffer(mainform.Autoszenen[i].W,sizeof(mainform.Autoszenen[i].W));
   	  Filestream.WriteBuffer(mainform.Autoszenen[i].accuracy,sizeof(mainform.Autoszenen[i].accuracy));
   	  Filestream.WriteBuffer(mainform.Autoszenen[i].helligkeit,sizeof(mainform.Autoszenen[i].helligkeit));
   	  Filestream.WriteBuffer(mainform.Autoszenen[i].Category,sizeof(mainform.Autoszenen[i].Category));
    end;
// Ende Autoszenen

 	  Filestream.WriteBuffer(textbuchform.TextBuchFile,sizeof(textbuchform.TextBuchFile));

    count:=length(SendValueOfSelectedDevicesToMidi);
 	  Filestream.WriteBuffer(count,sizeof(count));
    for i:=0 to count-1 do
    begin
      Filestream.WriteBuffer(SendValueOfSelectedDevicesToMidi[i].MSG,sizeof(SendValueOfSelectedDevicesToMidi[i].MSG));
      Filestream.WriteBuffer(SendValueOfSelectedDevicesToMidi[i].Data1,sizeof(SendValueOfSelectedDevicesToMidi[i].Data1));
      Filestream.WriteBuffer(SendValueOfSelectedDevicesToMidi[i].UseData2,sizeof(SendValueOfSelectedDevicesToMidi[i].UseData2));
    end;

// Submaster (neu) speichern
	  inprogress.filename.Caption:=_('Schreibe Datei... Submaster');
  	inprogress.Refresh;
    count:=length(Submasterbank);
    FileStream.WriteBuffer(count,sizeof(count));
    for i:=0 to count-1 do
    begin
      FileStream.WriteBuffer(Submasterbank[i].BankName, sizeof(Submasterbank[i].BankName));
      for j:=1 to 16 do
      begin
        FileStream.WriteBuffer(Submasterbank[i].SubmasterName[j], sizeof(Submasterbank[i].SubmasterName[j]));
        FileStream.WriteBuffer(Submasterbank[i].UseScene[j], sizeof(Submasterbank[i].UseScene[j]));
        FileStream.WriteBuffer(Submasterbank[i].SubmasterScene[j], sizeof(Submasterbank[i].SubmasterScene[j]));

        count2:=length(Submasterbank[i].Submasterdevices[j]);
        FileStream.WriteBuffer(count2,sizeof(count2));
        for k:=0 to count2-1 do
        begin
          FileStream.WriteBuffer(Submasterbank[i].Submasterdevices[j][k].ID,sizeof(Submasterbank[i].Submasterdevices[j][k].ID));
          count3:=length(Submasterbank[i].Submasterdevices[j][k].ChanActive);
          FileStream.WriteBuffer(count3,sizeof(count3));
          for l:=0 to count3-1 do
          begin
            FileStream.WriteBuffer(Submasterbank[i].Submasterdevices[j][k].ChanActive[l],sizeof(Submasterbank[i].Submasterdevices[j][k].ChanActive[l]));;
            FileStream.WriteBuffer(Submasterbank[i].Submasterdevices[j][k].ChanValue[l],sizeof(Submasterbank[i].Submasterdevices[j][k].ChanValue[l]));;
            FileStream.WriteBuffer(Submasterbank[i].Submasterdevices[j][k].ChanDelay[l],sizeof(Submasterbank[i].Submasterdevices[j][k].ChanDelay[l]));;
          end;
        end;                             

        FileStream.WriteBuffer(Submasterbank[i].UseBefehl[j], sizeof(Submasterbank[i].UseBefehl[j]));

        Filestream.WriteBuffer(Submasterbank[i].Befehl[j].ID,sizeof(Submasterbank[i].Befehl[j].ID));
        Filestream.WriteBuffer(Submasterbank[i].Befehl[j].Typ,sizeof(Submasterbank[i].Befehl[j].Typ));
        Filestream.WriteBuffer(Submasterbank[i].Befehl[j].OnValue,sizeof(Submasterbank[i].Befehl[j].OnValue));
        Filestream.WriteBuffer(Submasterbank[i].Befehl[j].SwitchValue,sizeof(Submasterbank[i].Befehl[j].SwitchValue));
        Filestream.WriteBuffer(Submasterbank[i].Befehl[j].InvertSwitchValue,sizeof(Submasterbank[i].Befehl[j].InvertSwitchValue));
        Filestream.WriteBuffer(Submasterbank[i].Befehl[j].OffValue,sizeof(Submasterbank[i].Befehl[j].OffValue));
        Filestream.WriteBuffer(Submasterbank[i].Befehl[j].ScaleValue,sizeof(Submasterbank[i].Befehl[j].ScaleValue));
        Count2:=length(Submasterbank[i].Befehl[j].ArgInteger);
        Filestream.WriteBuffer(Count2,sizeof(Count2));
        for k:=0 to Count2-1 do
          Filestream.WriteBuffer(Submasterbank[i].Befehl[j].ArgInteger[k],sizeof(Submasterbank[i].Befehl[j].ArgInteger[k]));
        Count2:=length(Submasterbank[i].Befehl[j].ArgString);
        Filestream.WriteBuffer(Count2,sizeof(Count2));
        for k:=0 to Count2-1 do
          Filestream.WriteBuffer(Submasterbank[i].Befehl[j].ArgString[k],sizeof(Submasterbank[i].Befehl[j].ArgString[k]));
        Count2:=length(Submasterbank[i].Befehl[j].ArgGUID);
        Filestream.WriteBuffer(Count2,sizeof(Count2));
        for k:=0 to Count2-1 do
          Filestream.WriteBuffer(Submasterbank[i].Befehl[j].ArgGUID[k],sizeof(Submasterbank[i].Befehl[j].ArgGUID[k]));
      end;
    end;
// Submaster Ende

// Cue-Liste speichern
	  inprogress.filename.Caption:=_('Schreibe Datei... Cueliste');
  	inprogress.Refresh;

    count:=length(Cuelistbank);
    FileStream.WriteBuffer(count,sizeof(count));
    for i:=0 to count-1 do
    begin
      FileStream.WriteBuffer(Cuelistbank[i].BankName,sizeof(Cuelistbank[i].BankName));

      count2:=length(Cuelistbank[i].cuelistbankitems);
      FileStream.WriteBuffer(count2,sizeof(count2));
      for j:=0 to count2-1 do
      begin
        FileStream.WriteBuffer(Cuelistbank[i].cuelistbankitems[j].ID,sizeof(Cuelistbank[i].cuelistbankitems[j].ID));
        count3:=sizeof(Cuelistbank[i].cuelistbankitems[j].OwnDescription);
        FileStream.WriteBuffer(count3,sizeof(count3));
        FileStream.WriteBuffer(Cuelistbank[i].cuelistbankitems[j].OwnDescription,sizeof(Cuelistbank[i].cuelistbankitems[j].OwnDescription));
        FileStream.WriteBuffer(Cuelistbank[i].cuelistbankitems[j].Typ,sizeof(Cuelistbank[i].cuelistbankitems[j].Typ));
        FileStream.WriteBuffer(Cuelistbank[i].cuelistbankitems[j].UseFadetime,sizeof(Cuelistbank[i].cuelistbankitems[j].UseFadetime));
        FileStream.WriteBuffer(Cuelistbank[i].cuelistbankitems[j].Fadetime,sizeof(Cuelistbank[i].cuelistbankitems[j].Fadetime));
        FileStream.WriteBuffer(Cuelistbank[i].cuelistbankitems[j].LiveTime,sizeof(Cuelistbank[i].cuelistbankitems[j].LiveTime));
        FileStream.WriteBuffer(Cuelistbank[i].cuelistbankitems[j].StopCueIfTimeOver,sizeof(Cuelistbank[i].cuelistbankitems[j].StopCueIfTimeOver));
      end;
    end;
// Cue-Liste Ende

// Timecodeplayer-Liste speichern
	  inprogress.filename.Caption:=_('Schreibe Datei... Timecodeplayer');
  	inprogress.Refresh;

    count:=length(TimeCodePlayerBank);
    FileStream.WriteBuffer(count,sizeof(count));
    for i:=0 to count-1 do
    begin
      FileStream.WriteBuffer(TimeCodePlayerBank[i].BankName,sizeof(TimeCodePlayerBank[i].BankName));
      count2:=length(TimeCodePlayerBank[i].TimeCodePlayerBankItems);
      FileStream.WriteBuffer(count2,sizeof(count2));
      for j:=0 to count2-1 do
      begin
        FileStream.WriteBuffer(TimeCodePlayerBank[i].TimeCodePlayerBankItems[j],sizeof(TimeCodePlayerBank[i].TimeCodePlayerBankItems[j]));
        FileStream.WriteBuffer(TimeCodePlayerBank[i].Time[j],sizeof(TimeCodePlayerBank[i].Time[j]));
        FileStream.WriteBuffer(TimeCodePlayerBank[i].Frame[j],sizeof(TimeCodePlayerBank[i].Frame[j]));
      end;
    end;
// Timecodeplayer-Liste Ende

// IR FB speichern
	  inprogress.filename.Caption:=_('Schreibe Datei... IR Fernbedienung');
  	inprogress.Refresh;

    count:=length(mainform.IREvent);
    FileStream.WriteBuffer(count,sizeof(count));
    for i:=0 to length(mainform.IREvent)-1 do
    begin
      FileStream.WriteBuffer(mainform.IREvent[i].id,sizeof(mainform.IREvent[i].id));
      FileStream.WriteBuffer(mainform.IREvent[i].fernbedienung,sizeof(mainform.IREvent[i].fernbedienung));
      FileStream.WriteBuffer(mainform.IREvent[i].taste,sizeof(mainform.IREvent[i].taste));
      FileStream.WriteBuffer(mainform.IREvent[i].taste_raw,sizeof(mainform.IREvent[i].taste_raw));
    end;
// IR FB Ende

// MediaCenter Szenen speichern
	  inprogress.filename.Caption:=_('Schreibe Datei... MediaCenter Szenen');
  	inprogress.Refresh;
    Count:=length(mainform.MediaCenterSzenen);
	  Filestream.WriteBuffer(Count,sizeof(Count));
    for i:=0 to Count-1 do
    begin
   	  Filestream.WriteBuffer(mainform.MediaCenterSzenen[i].ID,sizeof(mainform.MediaCenterSzenen[i].ID));
   	  Filestream.WriteBuffer(mainform.MediaCenterSzenen[i].Name,sizeof(mainform.MediaCenterSzenen[i].Name));
   	  Filestream.WriteBuffer(mainform.MediaCenterSzenen[i].Beschreibung,sizeof(mainform.MediaCenterSzenen[i].Beschreibung));
   	  Filestream.WriteBuffer(mainform.MediaCenterSzenen[i].Adresse,sizeof(mainform.MediaCenterSzenen[i].Adresse));
   	  Filestream.WriteBuffer(mainform.MediaCenterSzenen[i].Port,sizeof(mainform.MediaCenterSzenen[i].Port));
   	  Filestream.WriteBuffer(mainform.MediaCenterSzenen[i].Befehl,sizeof(mainform.MediaCenterSzenen[i].Befehl));
   	  Filestream.WriteBuffer(mainform.MediaCenterSzenen[i].Data1,sizeof(mainform.MediaCenterSzenen[i].Data1));
   	  Filestream.WriteBuffer(mainform.MediaCenterSzenen[i].Data2,sizeof(mainform.MediaCenterSzenen[i].Data2));
   	  Filestream.WriteBuffer(mainform.MediaCenterSzenen[i].Text,sizeof(mainform.MediaCenterSzenen[i].Text));
   	  Filestream.WriteBuffer(mainform.MediaCenterSzenen[i].Category,sizeof(mainform.MediaCenterSzenen[i].Category));
    end;
// Ende MediaCenter Szenen

// Plugin Szenen speichern
	  inprogress.filename.Caption:=_('Schreibe Datei... Pluginszenen');
  	inprogress.Refresh;
    Count:=length(mainform.PluginSzenen);
	  Filestream.WriteBuffer(Count,sizeof(Count));
    for i:=0 to Count-1 do
    begin
   	  Filestream.WriteBuffer(mainform.PluginSzenen[i].ID,sizeof(mainform.PluginSzenen[i].ID));
   	  Filestream.WriteBuffer(mainform.PluginSzenen[i].Name,sizeof(mainform.PluginSzenen[i].Name));
   	  Filestream.WriteBuffer(mainform.PluginSzenen[i].Category,sizeof(mainform.PluginSzenen[i].Category));
    end;
// Ende Plugin Szenen
// FFTDataIn speichern
    for i:=0 to 31 do
    begin
      Filestream.WriteBuffer(mainform.FFTDataIn[i].Active,sizeof(mainform.FFTDataIn[i].Active));
      Filestream.WriteBuffer(mainform.FFTDataIn[i].Channel,sizeof(mainform.FFTDataIn[i].Channel));
      Filestream.WriteBuffer(mainform.FFTDataIn[i].Faktor,sizeof(mainform.FFTDataIn[i].Faktor));
    end;
// Ende FFTDataIn speichern
// BeatImpuls speichern
    Filestream.WriteBuffer(mainform.BeatImpuls.Active,sizeof(mainform.BeatImpuls.Active));
    Filestream.WriteBuffer(mainform.BeatImpuls.Channel,sizeof(mainform.BeatImpuls.Channel));
    Filestream.WriteBuffer(mainform.BeatImpuls.OnValue,sizeof(mainform.BeatImpuls.OnValue));
    Filestream.WriteBuffer(mainform.BeatImpuls.OffValue,sizeof(mainform.BeatImpuls.OffValue));
    Filestream.WriteBuffer(mainform.BeatImpuls.SceneOnBeatLost,sizeof(mainform.BeatImpuls.SceneOnBeatLost));
    Filestream.WriteBuffer(mainform.BeatImpuls.SceneOnBeatStart,sizeof(mainform.BeatImpuls.SceneOnBeatStart));
    Filestream.WriteBuffer(mainform.BeatImpuls.Timeout,sizeof(mainform.BeatImpuls.Timeout));
    Filestream.WriteBuffer(mainform.BeatImpuls.SendVolumeToDataIn,sizeof(mainform.BeatImpuls.SendVolumeToDataIn));
    Filestream.WriteBuffer(mainform.BeatImpuls.SendVolumeToDataInChannel,sizeof(mainform.BeatImpuls.SendVolumeToDataInChannel));
// Ende BeatImpuls speichern
// Geräteselektionen speichern
    Count:=length(DeviceSelectedIDs);
    Filestream.WriteBuffer(Count,sizeof(Count));
    for i:=0 to length(DeviceSelectedIDs)-1 do
    begin
      Count2:=length(DeviceSelectedIDs[i]);
      Filestream.WriteBuffer(Count2,sizeof(Count2));

      FileStream.WriteBuffer(DeviceSelectedIDsName[i], sizeof(DeviceSelectedIDsName[i]));

      for j:=0 to length(DeviceSelectedIDs[i])-1 do
        FileStream.WriteBuffer(DeviceSelectedIDs[i][j], sizeof(DeviceSelectedIDs[i][j]));
    end;
// Geräteselektionen speichern Ende
// Ambilight speichern
  Count:=length(ambilights);
  Filestream.WriteBuffer(Count,sizeof(Count));
  for i:=0 to Count-1 do
  begin
    Count2:=length(ambilights[i]);
    Filestream.WriteBuffer(Count2,sizeof(Count2));
    for j:=0 to Count2-1 do
      Filestream.WriteBuffer(ambilights[i][j],sizeof(ambilights[i][j]));
  end;
// Ambilight speichern Ende
// PartyMuckenModul speichern
  Count:=length(pmmlights);
  Filestream.WriteBuffer(Count,sizeof(Count));
  for i:=0 to Count-1 do
    Filestream.WriteBuffer(pmmlights[i],sizeof(pmmlights[i]));

  Count:=length(PartyMuckenModul);
  Filestream.WriteBuffer(Count,sizeof(Count));
  for i:=0 to Count-1 do
  begin
    Filestream.WriteBuffer(PartyMuckenModul[i].Name,sizeof(PartyMuckenModul[i].Name));
    Filestream.WriteBuffer(PartyMuckenModul[i].ControlMode,sizeof(PartyMuckenModul[i].ControlMode));
    Filestream.WriteBuffer(PartyMuckenModul[i].UsePanTilt,sizeof(PartyMuckenModul[i].UsePanTilt));
    Filestream.WriteBuffer(PartyMuckenModul[i].UseRandom,sizeof(PartyMuckenModul[i].UseRandom));
    Filestream.WriteBuffer(PartyMuckenModul[i].MaxFadetime,sizeof(PartyMuckenModul[i].MaxFadetime));
    Filestream.WriteBuffer(PartyMuckenModul[i].MaxPanTiltTime,sizeof(PartyMuckenModul[i].MaxPanTiltTime));
    Filestream.WriteBuffer(PartyMuckenModul[i].MaxDelayTime,sizeof(PartyMuckenModul[i].MaxDelayTime));
    Filestream.WriteBuffer(PartyMuckenModul[i].UseRed,sizeof(PartyMuckenModul[i].UseRed));
    Filestream.WriteBuffer(PartyMuckenModul[i].UseGreen,sizeof(PartyMuckenModul[i].UseGreen));
    Filestream.WriteBuffer(PartyMuckenModul[i].UseBlue,sizeof(PartyMuckenModul[i].UseBlue));
    Filestream.WriteBuffer(PartyMuckenModul[i].UseAmber,sizeof(PartyMuckenModul[i].UseAmber));
    Filestream.WriteBuffer(PartyMuckenModul[i].UseWhite,sizeof(PartyMuckenModul[i].UseWhite));
    Filestream.WriteBuffer(PartyMuckenModul[i].MaxRed,sizeof(PartyMuckenModul[i].MaxRed));
    Filestream.WriteBuffer(PartyMuckenModul[i].MaxGreen,sizeof(PartyMuckenModul[i].MaxGreen));
    Filestream.WriteBuffer(PartyMuckenModul[i].MaxBlue,sizeof(PartyMuckenModul[i].MaxBlue));
    Filestream.WriteBuffer(PartyMuckenModul[i].MaxAmber,sizeof(PartyMuckenModul[i].MaxAmber));
    Filestream.WriteBuffer(PartyMuckenModul[i].MaxWhite,sizeof(PartyMuckenModul[i].MaxWhite));
    Filestream.WriteBuffer(PartyMuckenModul[i].AllowMixing,sizeof(PartyMuckenModul[i].AllowMixing));
    Filestream.WriteBuffer(PartyMuckenModul[i].NoBlackDevices,sizeof(PartyMuckenModul[i].NoBlackDevices));
    Filestream.WriteBuffer(PartyMuckenModul[i].UseRGB,sizeof(PartyMuckenModul[i].UseRGB));
    Filestream.WriteBuffer(PartyMuckenModul[i].UseAW,sizeof(PartyMuckenModul[i].UseAW));
    Filestream.WriteBuffer(PartyMuckenModul[i].UseUV,sizeof(PartyMuckenModul[i].UseUV));
    Filestream.WriteBuffer(PartyMuckenModul[i].UseDimmer,sizeof(PartyMuckenModul[i].UseDimmer));
    Filestream.WriteBuffer(PartyMuckenModul[i].UseColor12,sizeof(PartyMuckenModul[i].UseColor12));
    Filestream.WriteBuffer(PartyMuckenModul[i].MaxLuminance,sizeof(PartyMuckenModul[i].MaxLuminance));
    Filestream.WriteBuffer(PartyMuckenModul[i].MinLuminance,sizeof(PartyMuckenModul[i].MinLuminance));
  end;
// PartyMuckenModul speichern Ende
// PresetSzenen speichern
  inprogress.filename.Caption:=_('Schreibe Datei... Preset-Szenen');
  inprogress.Refresh;
  Count:=length(mainform.PresetScenes);
  Filestream.WriteBuffer(Count,sizeof(Count));
  for i:=0 to Count-1 do
  begin
    Filestream.WriteBuffer(mainform.PresetScenes[i].ID,sizeof(mainform.PresetScenes[i].ID));
    Filestream.WriteBuffer(mainform.PresetScenes[i].Name,sizeof(mainform.PresetScenes[i].Name));
    Filestream.WriteBuffer(mainform.PresetScenes[i].Beschreibung,sizeof(mainform.PresetScenes[i].Beschreibung));
    Filestream.WriteBuffer(mainform.PresetScenes[i].Category,sizeof(mainform.PresetScenes[i].Category));

    count2:=length(mainform.PresetScenes[i].Devices);
    Filestream.WriteBuffer(count2,sizeof(count2));
    for k:=0 to count2-1 do
      Filestream.WriteBuffer(mainform.PresetScenes[i].Devices[k],sizeof(mainform.PresetScenes[i].Devices[k]));

    Filestream.WriteBuffer(mainform.PresetScenes[i].Color,sizeof(mainform.PresetScenes[i].Color));
    Filestream.WriteBuffer(mainform.PresetScenes[i].Shutter,sizeof(mainform.PresetScenes[i].Shutter));
    Filestream.WriteBuffer(mainform.PresetScenes[i].Dimmer,sizeof(mainform.PresetScenes[i].Dimmer));
    Filestream.WriteBuffer(mainform.PresetScenes[i].Iris,sizeof(mainform.PresetScenes[i].Iris));
    Filestream.WriteBuffer(mainform.PresetScenes[i].Focus,sizeof(mainform.PresetScenes[i].Focus));
    Filestream.WriteBuffer(mainform.PresetScenes[i].PrismaRot,sizeof(mainform.PresetScenes[i].PrismaRot));
    Filestream.WriteBuffer(mainform.PresetScenes[i].PrismaEnabled,sizeof(mainform.PresetScenes[i].PrismaEnabled));
    Filestream.WriteBuffer(mainform.PresetScenes[i].Strobe,sizeof(mainform.PresetScenes[i].Strobe));
    Filestream.WriteBuffer(mainform.PresetScenes[i].Pan,sizeof(mainform.PresetScenes[i].Pan));
    Filestream.WriteBuffer(mainform.PresetScenes[i].Tilt,sizeof(mainform.PresetScenes[i].Tilt));
    Filestream.WriteBuffer(mainform.PresetScenes[i].PanFine,sizeof(mainform.PresetScenes[i].PanFine));
    Filestream.WriteBuffer(mainform.PresetScenes[i].TiltFine,sizeof(mainform.PresetScenes[i].TiltFine));
    Filestream.WriteBuffer(mainform.PresetScenes[i].Gobo,sizeof(mainform.PresetScenes[i].Gobo));
    Filestream.WriteBuffer(mainform.PresetScenes[i].GoboRot1,sizeof(mainform.PresetScenes[i].GoboRot1));
    Filestream.WriteBuffer(mainform.PresetScenes[i].GoboRot2,sizeof(mainform.PresetScenes[i].GoboRot2));
  end;
// Ende Presets
// NodeControl speichern
  inprogress.filename.Caption:=_('Schreibe Datei... Knotensteuerung');
  inprogress.Refresh;
  Count:=length(mainform.NodeControlSets);
  Filestream.WriteBuffer(Count,sizeof(Count));
  for i:=0 to Count-1 do
  begin
    Filestream.WriteBuffer(mainform.NodeControlSets[i].ID,sizeof(mainform.NodeControlSets[i].ID));
    Filestream.WriteBuffer(mainform.NodeControlSets[i].Name,sizeof(mainform.NodeControlSets[i].Name));
    Filestream.WriteBuffer(mainform.NodeControlSets[i].stretching,sizeof(mainform.NodeControlSets[i].stretching));
    Filestream.WriteBuffer(mainform.NodeControlSets[i].contrast,sizeof(mainform.NodeControlSets[i].contrast));
    Filestream.WriteBuffer(mainform.NodeControlSets[i].fadetime,sizeof(mainform.NodeControlSets[i].fadetime));
    Filestream.WriteBuffer(mainform.NodeControlSets[i].ChangeRGB,sizeof(mainform.NodeControlSets[i].ChangeRGB));
    Filestream.WriteBuffer(mainform.NodeControlSets[i].ChangeA,sizeof(mainform.NodeControlSets[i].ChangeA));
    Filestream.WriteBuffer(mainform.NodeControlSets[i].ChangeW,sizeof(mainform.NodeControlSets[i].ChangeW));
    Filestream.WriteBuffer(mainform.NodeControlSets[i].ChangeDimmer,sizeof(mainform.NodeControlSets[i].ChangeDimmer));
    Filestream.WriteBuffer(mainform.NodeControlSets[i].StageViewScaling,sizeof(mainform.NodeControlSets[i].StageViewScaling));

    count2:=length(mainform.NodeControlSets[i].NodeControlNodes);
    Filestream.WriteBuffer(count2,sizeof(count2));
    for k:=0 to count2-1 do
    begin
      Filestream.WriteBuffer(mainform.NodeControlSets[i].NodeControlNodes[k].ID,sizeof(mainform.NodeControlSets[i].NodeControlNodes[k].ID));
      Filestream.WriteBuffer(mainform.NodeControlSets[i].NodeControlNodes[k].Name,sizeof(mainform.NodeControlSets[i].NodeControlNodes[k].Name));
      Filestream.WriteBuffer(mainform.NodeControlSets[i].NodeControlNodes[k].X,sizeof(mainform.NodeControlSets[i].NodeControlNodes[k].X));
      Filestream.WriteBuffer(mainform.NodeControlSets[i].NodeControlNodes[k].Y,sizeof(mainform.NodeControlSets[i].NodeControlNodes[k].Y));
      Filestream.WriteBuffer(mainform.NodeControlSets[i].NodeControlNodes[k].Z,sizeof(mainform.NodeControlSets[i].NodeControlNodes[k].Z));
      Filestream.WriteBuffer(mainform.NodeControlSets[i].NodeControlNodes[k].R,sizeof(mainform.NodeControlSets[i].NodeControlNodes[k].R));
      Filestream.WriteBuffer(mainform.NodeControlSets[i].NodeControlNodes[k].G,sizeof(mainform.NodeControlSets[i].NodeControlNodes[k].G));
      Filestream.WriteBuffer(mainform.NodeControlSets[i].NodeControlNodes[k].B,sizeof(mainform.NodeControlSets[i].NodeControlNodes[k].B));
      Filestream.WriteBuffer(mainform.NodeControlSets[i].NodeControlNodes[k].A,sizeof(mainform.NodeControlSets[i].NodeControlNodes[k].A));
      Filestream.WriteBuffer(mainform.NodeControlSets[i].NodeControlNodes[k].W,sizeof(mainform.NodeControlSets[i].NodeControlNodes[k].W));
      Filestream.WriteBuffer(mainform.NodeControlSets[i].NodeControlNodes[k].Dimmer,sizeof(mainform.NodeControlSets[i].NodeControlNodes[k].Dimmer));
      Filestream.WriteBuffer(mainform.NodeControlSets[i].NodeControlNodes[k].UseRGB,sizeof(mainform.NodeControlSets[i].NodeControlNodes[k].UseRGB));
      Filestream.WriteBuffer(mainform.NodeControlSets[i].NodeControlNodes[k].UseA,sizeof(mainform.NodeControlSets[i].NodeControlNodes[k].UseA));
      Filestream.WriteBuffer(mainform.NodeControlSets[i].NodeControlNodes[k].UseW,sizeof(mainform.NodeControlSets[i].NodeControlNodes[k].UseW));
      Filestream.WriteBuffer(mainform.NodeControlSets[i].NodeControlNodes[k].UseDimmer,sizeof(mainform.NodeControlSets[i].NodeControlNodes[k].UseDimmer));
    end;
  end;
// Ende NodeControl
// XTouchControl speichern
  inprogress.filename.Caption:=_('Schreibe Datei... XTouchControl');
  inprogress.Refresh;
  Count:=length(mainform.XTouchPCDDevicesOrGroups);
  Filestream.WriteBuffer(Count,sizeof(Count));
  for i:=0 to Count-1 do
  begin
    Filestream.WriteBuffer(mainform.XTouchPCDDevicesOrGroups[i].ID,sizeof(mainform.XTouchPCDDevicesOrGroups[i].ID));
  end;
  Count:=length(XTouchBefehle);
  Filestream.WriteBuffer(Count,sizeof(Count));
  for i:=0 to Count-1 do
  begin
    for j:=0 to 17 do // 8 Faders + Masterfader, 8x Dials + JogDial
    begin
      Filestream.WriteBuffer(XTouchBefehle[i][j].Typ,sizeof(XTouchBefehle[i][j].Typ));
      Filestream.WriteBuffer(XTouchBefehle[i][j].OnValue,sizeof(XTouchBefehle[i][j].OnValue));
      Filestream.WriteBuffer(XTouchBefehle[i][j].SwitchValue,sizeof(XTouchBefehle[i][j].SwitchValue));
      Filestream.WriteBuffer(XTouchBefehle[i][j].InvertSwitchValue,sizeof(XTouchBefehle[i][j].InvertSwitchValue));
      Filestream.WriteBuffer(XTouchBefehle[i][j].OffValue,sizeof(XTouchBefehle[i][j].OffValue));
      Filestream.WriteBuffer(XTouchBefehle[i][j].ScaleValue,sizeof(XTouchBefehle[i][j].ScaleValue));
      Count2:=length(XTouchBefehle[i][j].ArgInteger);
      Filestream.WriteBuffer(Count2,sizeof(Count2));
      for k:=0 to Count2-1 do
        Filestream.WriteBuffer(XTouchBefehle[i][j].ArgInteger[k],sizeof(XTouchBefehle[i][j].ArgInteger[k]));
      Count2:=length(XTouchBefehle[i][j].ArgString);
      Filestream.WriteBuffer(Count2,sizeof(Count2));
      for k:=0 to Count2-1 do
        Filestream.WriteBuffer(XTouchBefehle[i][j].ArgString[k],sizeof(XTouchBefehle[i][j].ArgString[k]));
      Count2:=length(XTouchBefehle[i][j].ArgGUID);
      Filestream.WriteBuffer(Count2,sizeof(Count2));
      for k:=0 to Count2-1 do
        Filestream.WriteBuffer(XTouchBefehle[i][j].ArgGUID[k],sizeof(XTouchBefehle[i][j].ArgGUID[k]));
    end;
  end;
// Ende XTouchControl
// CodeSzenen speichern
  inprogress.filename.Caption:=_('Schreibe Datei... Code-Szenen');
  inprogress.Refresh;
  Count:=length(mainform.CodeScenes);
  Filestream.WriteBuffer(Count,sizeof(Count));
  for i:=0 to Count-1 do
  begin
    Filestream.WriteBuffer(mainform.CodeScenes[i].ID,sizeof(mainform.CodeScenes[i].ID));
    Filestream.WriteBuffer(mainform.CodeScenes[i].Name,sizeof(mainform.CodeScenes[i].Name));
    Filestream.WriteBuffer(mainform.CodeScenes[i].Beschreibung,sizeof(mainform.CodeScenes[i].Beschreibung));
    Filestream.WriteBuffer(mainform.CodeScenes[i].Category,sizeof(mainform.CodeScenes[i].Category));
    Count2:=length(mainform.CodeScenes[i].Code);
    Filestream.WriteBuffer(Count2,sizeof(Count2));
    Filestream.WriteBuffer(Pointer(mainform.CodeScenes[i].Code)^,length(mainform.CodeScenes[i].Code));
  end;
// Ende CodeScenes
// StreamDeck speichern
  inprogress.filename.Caption:=_('Schreibe Datei... StreamDeck');
  inprogress.Refresh;
  Count:=length(mainform.ElgatoStreamDeckArray);
  Filestream.WriteBuffer(Count,sizeof(Count));
  for i:=0 to Count-1 do
  begin
    Filestream.WriteBuffer(mainform.ElgatoStreamDeckArray[i].Serial,sizeof(mainform.ElgatoStreamDeckArray[i].Serial));
    Filestream.WriteBuffer(mainform.ElgatoStreamDeckArray[i].ButtonCount,sizeof(mainform.ElgatoStreamDeckArray[i].ButtonCount));
    Filestream.WriteBuffer(mainform.ElgatoStreamDeckArray[i].Brightness,sizeof(mainform.ElgatoStreamDeckArray[i].Brightness));
    Filestream.WriteBuffer(mainform.ElgatoStreamDeckArray[i].UseAutoModeOnLastButton,sizeof(mainform.ElgatoStreamDeckArray[i].UseAutoModeOnLastButton));
    for j:=0 to 31 do
    begin
      Filestream.WriteBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].ButtonType,sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].ButtonType));
      Filestream.WriteBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].KontrollpanelX,sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].KontrollpanelX));
      Filestream.WriteBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].KontrollpanelY,sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].KontrollpanelY));
      Filestream.WriteBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].DeviceOrGroupID,sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].DeviceOrGroupID));
      Filestream.WriteBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].DataInChannel,sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].DataInChannel));
      Filestream.WriteBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].UseHoldToChange,sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].UseHoldToChange));
      Filestream.WriteBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].Increment,sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].Increment));

      Filestream.WriteBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.Typ,sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.Typ));
      Filestream.WriteBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.OnValue,sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.OnValue));
      Filestream.WriteBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.SwitchValue,sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.SwitchValue));
      Filestream.WriteBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.InvertSwitchValue,sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.InvertSwitchValue));
      Filestream.WriteBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.OffValue,sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.OffValue));
      Filestream.WriteBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.ScaleValue,sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.ScaleValue));
      Count2:=length(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.ArgInteger);
      Filestream.WriteBuffer(Count2,sizeof(Count2));
      for k:=0 to Count2-1 do
        Filestream.WriteBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.ArgInteger[k],sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.ArgInteger[k]));
      Count2:=length(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.ArgString);
      Filestream.WriteBuffer(Count2,sizeof(Count2));
      for k:=0 to Count2-1 do
        Filestream.WriteBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.ArgString[k],sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.ArgString[k]));
      Count2:=length(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.ArgGUID);
      Filestream.WriteBuffer(Count2,sizeof(Count2));
      for k:=0 to Count2-1 do
        Filestream.WriteBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.ArgGUID[k],sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.ArgGUID[k]));
    end;
  end;
// Ende StreamDeck

  inprogress.filename.Caption:=_('Schreibe Datei...');
  inprogress.Refresh;
  FileStream.Free;

  if (not fastsave) then
  begin
    fastsaved:=false;
  end;

  if (not fastsaved) and ((projectfilepath+projectfilename)<>(userdirectory+'ProjectTemp\Projekt')) then
  begin
    inprogress.filename.Caption:='';
    inprogress.Label1.Caption:='';
    inprogress.ProgressBar1.Position:=80;
    AutosaveProgress.Position:=80;
    inprogress.ProgressBar2.Position:=0;
    inprogress.Label1.Refresh;
    inprogress.Refresh;


    if FileExists(projectfilepath+projectfilename) then
    begin
      inprogress.filename.Caption:=_('Erstelle Backup-Datei "')+'~Backup of '+projectfilename+'" ...';
      inprogress.Refresh;

      // Alte Backupdatei löschen, falls vorhanden
      if FileExists(projectfilepath+'~Backup of '+projectfilename) then
        DeleteFile(projectfilepath+'~Backup of '+projectfilename);
      // Alte Projektdatei umbennenen
      renamefile(projectfilepath+projectfilename,projectfilepath+'~Backup of '+projectfilename);
    end;

    inprogress.filename.Caption:=_('Komprimiere Projektdatei...');
    inprogress.ProgressBar1.Position:=90;
    AutosaveProgress.Position:=90;
    inprogress.Refresh;

//        filesinprojectdirectory:=0;
    filesinprojectdirectory:=CountFiles(userdirectory+'ProjectTemp\','*.*');
    inprogress.ProgressBar2.Max:=filesinprojectdirectory;
    inprogress.Label1.Caption:=_('Datei (1/')+inttostr(filesinprojectdirectory)+')';
    inprogress.ProgressBar2.Position:=0;

    Compress.CompressDirectory(userdirectory+'ProjectTemp\',true,projectfilepath+projectfilename);

    // SETFILESUMMARYINFORMATIONS
    SetFileSummaryInfo(projectfilepath+projectfilename,FmtID_SummaryInformation,PID_TITLE,copy(projectfilename,0,length(projectfilename)-8));
    SetFileSummaryInfo(projectfilepath+projectfilename,FmtID_SummaryInformation,PID_SUBJECT,'Beleuchtungstechnik');
    SetFileSummaryInfo(projectfilepath+projectfilename,FmtID_SummaryInformation,PID_AUTHOR,JvComputerInfoEx1.Identification.LocalUserName);
    SetFileSummaryInfo(projectfilepath+projectfilename,FmtID_SummaryInformation,PID_COMMENTS,'Insgesamt: '+inttostr(filesinprojectdirectory)+' Dateien im Projekt. Gespeichert mit '+GetFileVersionBuild(paramstr(0)));
    SetFileSummaryInfo(projectfilepath+projectfilename,FmtID_SummaryInformation,PID_APPNAME,'PC_DIMMER');
    SetFileSummaryInfo(projectfilepath+projectfilename,FmtID_SummaryInformation,PID_CREATE_DTM,DateToStr(now)+' '+TimeToStr(now));
    SetFileSummaryInfo(projectfilepath+projectfilename,FmtID_SummaryInformation,PID_REVNUMBER,GetFileVersion(paramstr(0)));
    SetFileSummaryInfo(projectfilepath+projectfilename,FmtID_SummaryInformation,PID_PAGECOUNT,inttostr(filesinprojectdirectory));

    SetFileSummaryInfo(projectfilepath+projectfilename,FMTID_MediaFileSummaryInformation,PIDMSI_SOURCE,'http://www.pcdimmer.de');
    SetFileSummaryInfo(projectfilepath+projectfilename,FMTID_MediaFileSummaryInformation,PIDMSI_COPYRIGHT,'Christian Nöding');

    SetFileSummaryInfo(projectfilepath+projectfilename,FMTID_DocSummaryInformation,PID_COMPANY,'PHOENIXstudios');
    //MSIFILEINFO
  end;

  if not saveonclosing then
    inprogress.Hide;
  AutosaveProgress.Visible:=false;
  inprogress.Label1.Caption:='';
  inprogress.Label2.caption:='';
  inprogress.ProgressBar2.Position:=0;
  result:=true;
end;

function TMainform.Openproject(openfile:string; OnlyProject:boolean):boolean;
  type
  TOldEinfacheszene = record
    ID : TGUID;
    Name : string[255];
    Beschreibung : string[255];
    einblendzeit : Cardinal;
    kanal : array[1..chan] of byte;
    kanalaktiv : array[1..chan] of boolean;
  end;
var
  i,j,k,l,m,effektanzahl,laenge, Count, Count2, Count3, Count4:integer;
  b:byte;
  filename,openfilename,openfilepath:string;
  openerror:boolean;
  scan:boolean;
  LReg:TPCDRegistry;
  text:string[30];
  Key:Word;
  ShiftNumber:integer;
  Shift:TShiftState;
  tempchannel_pre425:TBewegungsszenenDeviceChannel_pre425;
  showownmessageform:boolean;
  bildname, bildpfad:string;
  temp:word;
  OldEinfacheszene:TOldEinfacheszene;
  DummyByte:Byte;
begin
  if not UserAccessGranted(2) then exit;

  scan:=false;
  openerror:=false;
  Autobackuptimer.Enabled:=false;

  if not OnlyProject then
  begin
    filename:=openfile;
    Openfilepath:=ExtractFilepath(filename);
    Openfilename:=ExtractFilename(filename);

    project_file:=filename;
    project_folder:=userdirectory+'ProjectTemp\';
  end;

  BASS_StreamFree(audioeffektplayerform._chan[0]);
  BASS_StreamFree(audioeffektplayerform._chan[1]);
  BASS_StreamFree(audioeffektplayerform._chan[2]);
  BASS_StreamFree(audioeffektplayerform._chan[3]);
  audioeffektplayerform._chan[0]:=0;
  audioeffektplayerform._chan[1]:=0;
  audioeffektplayerform._chan[2]:=0;
  audioeffektplayerform._chan[3]:=0;

//  BASS_Free;
//  BASS_Init(sounddevice+1, BASSDLLFREQUENZ, BASS_DEVICE_SPEAKERS, Handle, nil);

  // Einstellungen resetten
  kontrollpanel.MSGNew;
  effektsequenzer.NewFile;
  geraetesteuerung.NewFile;
  submasterform.NewFile;
  grafischebuehnenansicht.NewPanel;
  TimeCodePlayerForm.NewFile;
  cuelistform.MSGNew;
  winlircform.MSGNew;
  nodecontrolform.MSGNew;
  textbuchform.MSGNew;
  joystickform.MSGNew;
  beatform.MSGNew;
  xtouchcontrolform.MSGNew;
  elgatostreamdeckform.MSGNew;

  if not OnlyProject then
  begin
    if (filename<>(userdirectory+'ProjectTemp\Projekt')) then
    begin
      // Projektverzeichnis reinigen
      DeleteDirectory(userdirectory+'ProjectTemp');
      CreateDir(userdirectory+'ProjectTemp');
      CreateDir(userdirectory+'ProjectTemp\Kontrollpanel');

      sleep(250);

      if (copy(Openfilename,length(Openfilename)-6,7)<>'pcdproj') then
        ShowMessage(_('Achtung: Sie versuchen eine Datei als Projekt zu öffnen, die nicht die Endung "pcdproj" besitzt!'));

      try
        filesinprojectdirectory:=strtoint(copy(GetFileSummaryInfo(Openfilepath+Openfilename),12,pos(' Dateien',GetFileSummaryInfo(Openfilepath+Openfilename))-12));
        if filesinprojectdirectory<1 then
          filesinprojectdirectory:=1;
      except
        filesinprojectdirectory:=1;
      end;

      if not startingup then
      begin
  //      ShowMessage('Informationen über aktuelle Projektdatei:'+#13#10#13#10+GetFileSummaryInfo(Openfilepath+Openfilename));
        inprogress.ProgressBar2.Max:=filesinprojectdirectory;
        inprogress.Label1.Caption:=_('Datei (1/')+inttostr(filesinprojectdirectory)+')';
        inprogress.ProgressBar2.Position:=0;
      end;

      //Containerdatei entpacken
      try
        Compress.DecompressFile(Openfilepath+Openfilename,userdirectory+'ProjectTemp\',true,true);
      except
        inprogress.Hide;
        CopyFile(PChar(Openfilepath+Openfilename),PChar(userdirectory+'ProjectTemp\Projekt'),false);
      end;
    end else
    begin
      fastsaved:=true;
    end;
  end;

	if not startingup then
  begin
    inprogress.ProgressBar1.Max:=100;
    inprogress.Caption:=_('Lade Projekt...');
   	inprogress.label8.Caption:=_(' Öffne Datei... ');
		application.processmessages;
		inprogress.Show;
		inprogress.filename.Caption:='';
		inprogress.ProgressBar1.Position:=25;
	  inprogress.Refresh;
  end;

  if not OnlyProject then
  begin
    if not startingup then
    begin
      inprogress.filename.Caption:=_('Sende Öffnen-Befehl...Plugins');
      inprogress.ProgressBar1.Position:=38;
      inprogress.Refresh;
    end else
    begin
      SplashCaptioninfo(_('Sende Öffnen-Befehl...Plugins'));
      SplashProgress(1, 81, 100);
      RefreshSplashText;
    end;
    SendMSG(MSG_OPEN,userdirectory+'ProjectTemp\',0);
  end;

  // Den Plugins genügend Zeit geben
//  Application.ProcessMessages;
//  sleep(250);

  //Projekt laden
  // hier aus Datei in Records schreiben
	if not startingup then
  begin
	  inprogress.filename.Caption:=_('Lese Daten ein...');
	 	inprogress.Refresh;
	  inprogress.ProgressBar1.Position:=50;
  end;

  try
    if fileexists(userdirectory+'ProjectTemp\Projekt') then
      FileStream:=TFileStream.Create(userdirectory+'ProjectTemp\Projekt',fmOpenRead)
    else
     	FileStream:=TFileStream.Create(userdirectory+'ProjectTemp\'+Openfilename,fmOpenRead);

    // Projekt-Header öffnen
  	if not startingup then
    begin
  	  inprogress.filename.Caption:=_('Lese Daten ein... Projekt-Header');
  	 	inprogress.Refresh;
    end else
    begin
      SplashCaptioninfo(_('Lese Daten ein...Projekt-Header'));
      RefreshSplashText;
    end;

    FileStream.ReadBuffer(projektprogrammversion,256);
    FileStream.ReadBuffer(projektdatum,256);
    FileStream.ReadBuffer(projektuhrzeit,256);
    FileStream.ReadBuffer(lastchan,sizeof(lastchan));
    FileStream.ReadBuffer(LastChan,sizeof(LastChan));
    FileStream.ReadBuffer(projekttitel,256);
    FileStream.ReadBuffer(projektversion,256);
    FileStream.ReadBuffer(projektbearbeiter,256);
    FileStream.ReadBuffer(projektspeicheranzahl,256);
    projektprogrammversionint:=strtoint(projektprogrammversion);

    setlength(data.ch,lastchan+1);
    setlength(data.names,lastchan+1);
    setlength(data.sdirect,lastchan+1);
    setlength(data.combine,lastchan+1);

    setlength(faderpanelform.faderselected, lastchan);
    setlength(faderpanelform.faderselectedalt, lastchan);
    setlength(faderpanelform.faderselectedshift, lastchan);

    // einzelne Projektversionen entsprechend laden

    if pos('.',projektprogrammversion)>0 then
    begin
      if (projektprogrammversion[1]='4') and (projektprogrammversion[3]='0') and ((projektprogrammversion[5]='0') or (projektprogrammversion[5]='1')) then
        projektprogrammversion:='400'
    end;

    // Version vor 4.x
    if projektprogrammversionint<400 then
    begin
      DebugAdd('FILE: Project Version: '+projektprogrammversion+' edited on '+projektdatum+' '+projektuhrzeit);
      FileStream.Free;
      openerror:=true;
      ownmessageform.captionlbl.Caption:=_('Projektdatei zurückgewiesen');
      ownmessageform.descriptionlbl.Caption:=_('Die Projektdatei ist veraltet');
      ownmessageform.meldung.Clear;
      ownmessageform.meldung.Lines.Add(_('Aufgrund großer Änderungen am Projektformat können die bisherigen Projekte leider nicht weiter verwendet werden. Zum Teil können Programmteile über die jeweilige Speicherfunktion exportiert und reimportiert werden.'));
      ownmessageform.meldung.Lines.Add('');
      ownmessageform.meldung.Lines.Add(_('Projektversion: ')+projektprogrammversion);
      ownmessageform.meldung.Lines.Add(_('Datum: ')+projektdatum);
      ownmessageform.meldung.Lines.Add(_('Uhrzeit: ')+projektuhrzeit);
      ownmessageform.ClientHeight:=209;
      ownmessageform.ClientWidth:=550;
      ownmessageform.CancelBtn.Visible:=false;
      ownmessageform.caption:=_('Projektdatei zurückgewiesen');
      ownmessageform.showmodal;
      // Projektverzeichnis reinigen
      DeleteDirectory(userdirectory+'ProjectTemp');
      CreateDir(userdirectory+'ProjectTemp');
    	CreateDir(userdirectory+'ProjectTemp\Kontrollpanel');
      exit;
    end;

    // Hinweise zu neueren Projekten, als diese Programmversion
    if projektprogrammversionint>actualprojectversion then
    begin
      ownmessageform.captionlbl.Caption:=_('Projekt einer neueren Programmversion');
      ownmessageform.descriptionlbl.Caption:=_('Das Projekt wurde mit einer neueren PC_DIMMER Version gespeichert.');
      ownmessageform.meldung.Clear;
      ownmessageform.meldung.Lines.Add(_('Die zu ladende Projektdatei wurde mit einer neueren PC_DIMMER-Version gespeichert und kann mit der aktuellen Version nicht fehlerfrei geöffnet werden.'));
      ownmessageform.meldung.Lines.Add('');
      ownmessageform.meldung.Lines.Add(_('Bitte laden Sie sich eine aktuelle Version des PC_DIMMERs von der Seite http://www.pcdimmer.de herunter.'));
      ownmessageform.meldung.Lines.Add('');
      ownmessageform.meldung.Lines.Add('');
      ownmessageform.meldung.Lines.Add(_('Projektversion: ')+projektprogrammversion);
      ownmessageform.meldung.Lines.Add(_('Projektdatum: ')+projektdatum);
      ownmessageform.meldung.Lines.Add(_('Projektzeit: ')+projektuhrzeit);
      ownmessageform.ClientHeight:=275;
      ownmessageform.ClientWidth:=550;
      ownmessageform.CancelBtn.Visible:=false;
      ownmessageform.caption:=_('Hinweis...');
      ownmessageform.showmodal;
      // Projektverzeichnis reinigen
      DeleteDirectory(userdirectory+'ProjectTemp');
      CreateDir(userdirectory+'ProjectTemp');
    	CreateDir(userdirectory+'ProjectTemp\Kontrollpanel');
      exit;
    end;

    // Hinweise zu älteren Projekten
    if projektprogrammversionint<actualprojectversion then
    begin
      ownmessageform.captionlbl.Caption:=_('Projekt einer früheren Programmversion');
      ownmessageform.descriptionlbl.Caption:=_('Das Projekt wurde mit einer älteren PC_DIMMER Version gespeichert.');
      ownmessageform.meldung.Clear;
      ownmessageform.meldung.Lines.Add(_('Die zu ladende Projektdatei wurde mit einer älteren PC_DIMMER-Version gespeichert. Die Projektdatei wird beim nächsten Speichervorgang automatisch konvertiert und als neue Version abgespeichert.'));
      ownmessageform.meldung.Lines.Add('');
      ownmessageform.meldung.Lines.Add(_('Nach der Konvertierung kann das Projekt nicht mehr in einer älteren Version des PC_DIMMERs geladen werden. Möchten Sie parallel eine ältere PC_DIMMER-Version benutzen,'+' sollten Sie eine Sicherungskopie (normale Dateikopie, nicht über die Speicherfunktion!) des Projektes anfertigen.'));
      ownmessageform.meldung.Lines.Add('');
      ownmessageform.meldung.Lines.Add('');
      ownmessageform.meldung.Lines.Add(_('Projektversion: ')+projektprogrammversion+_(' (wird bei nächster Speicherung konvertiert zu Projektversion ')+inttostr(actualprojectversion)+')');
      ownmessageform.meldung.Lines.Add(_('Projektdatum: ')+projektdatum);
      ownmessageform.meldung.Lines.Add(_('Projektzeit: ')+projektuhrzeit);
      ownmessageform.ClientHeight:=275;
      ownmessageform.ClientWidth:=550;
      ownmessageform.CancelBtn.Visible:=false;
      ownmessageform.caption:=_('Hinweis...');
      showownmessageform:=true;

    end;

    // ab 4.0.0.0 (aktuelle Version)
    if (projektprogrammversionint>=400) then
    begin
      DebugAdd('FILE: Project Version: '+projektprogrammversion+' edited on '+projektdatum+' '+projektuhrzeit);
  		//Effektaudio laden
    	if not startingup then
      begin
    	  inprogress.filename.Caption:=_('Lese Daten ein... Audioeffektplayer');
    	 	inprogress.Refresh;
      end else
      begin
        SplashCaptioninfo(_('Lese Daten ein...Audioeffektplayer'));
        RefreshSplashText;
      end;
      //Länge der Arrays als erstes auslesen
      FileStream.ReadBuffer(laenge,sizeof(laenge));
      // nun alle Array einzeln nacheinander lesen
      setlength(Effektaudio_record,laenge);
  		if laenge>0 then
      for i:=0 to laenge-1 do
      begin
  			Filestream.ReadBuffer(Effektaudio_record[i].audiodatei,sizeof(Effektaudio_record[i].audiodatei));
  			Filestream.ReadBuffer(Effektaudio_record[i].audiopfad,sizeof(Effektaudio_record[i].audiopfad));
        // Einzelne Layer und Effekte laden
        Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layeranzahl,sizeof(Effektaudio_record[i].effektaudiodatei.layeranzahl));
        for j:=1 to maxaudioeffektlayers do
        begin
          // Effektanzahl herausfinden
          FileStream.ReadBuffer(effektanzahl,sizeof(effektanzahl));
  				audioeffektplayerform.maxaudioeffekte[j]:=effektanzahl;
          // Effektarraygrößen festlegen
          setlength(Effektaudio_record[i].effektaudiodatei.layer[j].effekt,effektanzahl);
          // Effektarray laden
          for k:=0 to effektanzahl-1 do
          begin
	          Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].ID,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].ID));
            if projektprogrammversionint>=402 then
   	          Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Name,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Name));
            if projektprogrammversionint>=406 then
   	        begin
   	          Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Beschreibung,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Beschreibung));
              Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].StopScene,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].StopScene));
            end;
	          Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].audioeffektposition,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].audioeffektposition));
	          Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].UseIDScene,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].UseIDScene));
	          Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].fadetime,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].fadetime));
	          Filestream.ReadBuffer(Count,sizeof(Count));
            setlength(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices,Count);
            for l:=0 to Count-1 do
            begin
    	        Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ID,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ID));
  	          Filestream.ReadBuffer(Count2,sizeof(Count2));
              setlength(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanActive,Count2);
              setlength(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanValue,Count2);
              setlength(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanActiveRandom,Count2);
              setlength(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanValueRandom,Count2);
              setlength(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanDelay,Count2);
              setlength(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanFadetime,Count2);
              for m:=0 to Count2-1 do
              begin
  	            Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanActive[m],sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanActive[m]));
  	            Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanValue[m],sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanValue[m]));
                if projektprogrammversionint>=433 then
    	          begin
                  Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanActiveRandom[m],sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanActiveRandom[m]));
    	            Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanValueRandom[m],sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanValueRandom[m]));
                end;
                if projektprogrammversionint>=408 then
                begin
    	            Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanDelay[m],sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanDelay[m]));
    	            Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanFadetime[m],sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanFadetime[m]));
                end else
                begin
                  Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanDelay[m]:=0;
                  Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanFadetime[m]:=-1;
                end;
              end;
            end;
            if projektprogrammversionint>=430 then
            begin
              Filestream.ReadBuffer(Count,sizeof(Count));
              setlength(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle,Count);
              setlength(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte,Count);
              for l:=0 to Count-1 do
              begin
                Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].ID,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].ID));
                Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].Typ,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].Typ));
                Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].Name,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].Name));
                Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].Beschreibung,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].Beschreibung));
                Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].OnValue,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].OnValue));
                if projektprogrammversionint>=456 then
                  Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].SwitchValue,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].SwitchValue))
                else
                  Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].SwitchValue:=Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].OnValue;
                if projektprogrammversionint>=462 then
                  Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].InvertSwitchValue,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].InvertSwitchValue));
                Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].OffValue,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].OffValue));
                if projektprogrammversionint>=457 then
                  Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].ScaleValue,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].ScaleValue));

                Filestream.ReadBuffer(Count2,sizeof(Count2));
                setlength(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].ArgInteger, Count2);
                for m:=0 to Count2-1 do
                  Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].ArgInteger[m],sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].ArgInteger[m]));
                Filestream.ReadBuffer(Count2,sizeof(Count2));
                setlength(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].ArgString, Count2);
                for m:=0 to Count2-1 do
                  Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].ArgString[m],sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].ArgString[m]));
                Filestream.ReadBuffer(Count2,sizeof(Count2));
                setlength(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].ArgGUID, Count2);
                for m:=0 to Count2-1 do
                  Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].ArgGUID[m],sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehle[l].ArgGUID[m]));


                Filestream.ReadBuffer(Count2,sizeof(Count2));
                setlength(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanActive, Count2);
                setlength(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanValue, Count2);
                setlength(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanActiveRandom, Count2);
                setlength(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanValueRandom, Count2);
                setlength(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanDelay, Count2);
                setlength(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanFadetime, Count2);
                for m:=0 to Count2-1 do
                begin
                  Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanActive[m],sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanActive[m]));
                  Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanValue[m],sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanValue[m]));
                  Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanActiveRandom[m],sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanActiveRandom[m]));
                  Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanValueRandom[m],sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanValueRandom[m]));
                  Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanDelay[m],sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanDelay[m]));
                  Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanFadetime[m],sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Befehlswerte[l].ChanFadetime[m]));
                end;
              end;
            end;
          end;
          Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layer[j].layeractive,sizeof(Effektaudio_record[i].effektaudiodatei.layer[j].layeractive));
        end;
  			Filestream.ReadBuffer(Effektaudio_record[i].waveform,sizeof(Effektaudio_record[i].waveform));
        Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.repeatjump,sizeof(Effektaudio_record[i].effektaudiodatei.repeatjump));
        Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.repeatdestination,sizeof(Effektaudio_record[i].effektaudiodatei.repeatdestination));
        Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.repeatactive,sizeof(Effektaudio_record[i].effektaudiodatei.repeatactive));
        Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.volume,sizeof(Effektaudio_record[i].effektaudiodatei.volume));
        if projektprogrammversionint>=405 then
          Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.videoseeking,sizeof(Effektaudio_record[i].effektaudiodatei.videoseeking));
        if projektprogrammversionint>=406 then
        begin
          Filestream.ReadBuffer(Effektaudio_record[i].effektaudiodatei.layername,sizeof(Effektaudio_record[i].effektaudiodatei.layername));
        end else
        begin
          for m:=1 to maxaudioeffektlayers do
            Effektaudio_record[i].effektaudiodatei.layername[m]:='Layer '+inttostr(m);
        end;
      end;

      // Bugfix für Fehlerhafte Array-Länge bei Gruppeneinträgen in Direktszenen von Audioeffektplayerdaten von alten Projekten
      for i:=0 to length(Effektaudio_record)-1 do
      begin
        for j:=1 to maxaudioeffektlayers do
        begin
          for k:=0 to length(Effektaudio_record[i].effektaudiodatei.layer[j].effekt)-1 do
          begin
          for l:=0 to length(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices)-1 do
          begin
            if geraetesteuerung.GetGroupPositionInGroupArray(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ID)>-1 then
            begin
              setlength(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanActive, length(mainform.DeviceChannelNames));
              setlength(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanActiveRandom, length(mainform.DeviceChannelNames));
              setlength(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanValue, length(mainform.DeviceChannelNames));
              setlength(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanValueRandom, length(mainform.DeviceChannelNames));
              setlength(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanDelay, length(mainform.DeviceChannelNames));
              setlength(Effektaudio_record[i].effektaudiodatei.layer[j].effekt[k].Devices[l].ChanFadetime, length(mainform.DeviceChannelNames));
            end;
          end;
        end;
      end;
    end;
  // Effektaudio fertig
  // Lese Projekteinstellungen
	if not startingup then
  begin
	  inprogress.filename.Caption:=_('Lese Daten ein... Projekteinstellungen');
	 	inprogress.Refresh;
  end else
  begin
    SplashCaptioninfo(_('Lese Daten ein...Projekteinstellungen'));
    RefreshSplashText;
  end;

      Filestream.ReadBuffer(Count,sizeof(Count));
      setlength(data.ch,Count);
      for i:=0 to Count-1 do
        Filestream.ReadBuffer(data.ch[i],sizeof(data.ch[i]));
      Filestream.ReadBuffer(Count,sizeof(Count));
      setlength(data.names,Count);
      for i:=0 to Count-1 do
        Filestream.ReadBuffer(data.names[i],sizeof(data.names[i]));
      Filestream.ReadBuffer(Count,sizeof(Count));
      setlength(data.sdirect,Count);
      for i:=0 to Count-1 do
        Filestream.ReadBuffer(data.sdirect[i],sizeof(data.sdirect[i]));
      Filestream.ReadBuffer(Count,sizeof(Count));
      setlength(data.combine,Count);
      for i:=0 to Count-1 do
        Filestream.ReadBuffer(data.combine[i],sizeof(data.combine[i]));
      Filestream.ReadBuffer(data.page,sizeof(data.page));
      Filestream.ReadBuffer(data.Shortcutnames,sizeof(data.Shortcutnames));
  // Projekteinstellungen fertig

  // Kanalmin/maxwerte
  if projektprogrammversionint>=416 then
  begin
    Filestream.ReadBuffer(Count,sizeof(Count));

    if projektprogrammversionint>=435 then
    begin
      for i:=1 to Count do
      begin
        Filestream.ReadBuffer(channel_minvalue[i],sizeof(channel_minvalue[i]));
        Filestream.ReadBuffer(channel_maxvalue[i],sizeof(channel_maxvalue[i]));
      end;
    end else
    begin
      for i:=1 to Count do
      begin
        Filestream.ReadBuffer(temp,sizeof(temp));
        channel_minvalue[i]:=temp;
        Filestream.ReadBuffer(temp,sizeof(temp));
        channel_maxvalue[i]:=temp;
      end;
    end;
  end;

  // Lese Figurendaten
	if not startingup then
  begin
	  inprogress.filename.Caption:=_('Lese Daten ein... Figuren');
    inprogress.ProgressBar1.Position:=53;
	 	inprogress.Refresh;
  end else
  begin
    SplashCaptioninfo(_('Lese Daten ein...Figuren'));
    SplashProgress(1, 82, 100);
    RefreshSplashText;
  end;

  Filestream.ReadBuffer(Count,sizeof(Count));
  setlength(Figuren,Count);
  for i:=0 to Count-1 do
  begin
    Filestream.ReadBuffer(Figuren[i].ID,sizeof(Figuren[i].ID));
    Filestream.ReadBuffer(Figuren[i].name,sizeof(Figuren[i].name));
    Filestream.ReadBuffer(Figuren[i].invertpan,sizeof(Figuren[i].invertpan));
    Filestream.ReadBuffer(Figuren[i].inverttilt,sizeof(Figuren[i].inverttilt));
    Filestream.ReadBuffer(Count2,sizeof(Count2));
    setlength(Figuren[i].posx,Count2);
    setlength(Figuren[i].posy,Count2);
    for k:=0 to Count2-1 do
    begin
      Filestream.ReadBuffer(Figuren[i].posx[k],sizeof(Figuren[i].posx[k]));
      Filestream.ReadBuffer(Figuren[i].posy[k],sizeof(Figuren[i].posy[k]));
    end;
    Filestream.ReadBuffer(Figuren[i].gesamtlaenge,sizeof(Figuren[i].gesamtlaenge));
  end;
  // Ende Figurendaten
  // Einfache-, Bewegungs- und Audioszenen, sowie Befehle öffnen
	if not startingup then
  begin
	  inprogress.filename.Caption:=_('Lese Daten ein... Szenen');
	 	inprogress.Refresh;
  end else
  begin
    SplashCaptioninfo(_('Lese Daten ein...Szenen'));
    RefreshSplashText;
  end;

  Filestream.ReadBuffer(Count,sizeof(Count));
  setlength(Einfacheszenen,Count);

  if projektprogrammversionint<439 then
  begin
    for i:=0 to Count-1 do
    begin
      Filestream.ReadBuffer(OldEinfacheszene,sizeof(OldEinfacheszene));
      Einfacheszenen[i].ID:=OldEinfacheszene.ID;
      Einfacheszenen[i].Name:=OldEinfacheszene.Name;
      Einfacheszenen[i].Beschreibung:=OldEinfacheszene.Beschreibung;
      Einfacheszenen[i].einblendzeit:=OldEinfacheszene.einblendzeit;
      for j:=1 to chan do
      begin
        Einfacheszenen[i].kanal[j]:=OldEinfacheszene.kanal[j];
        Einfacheszenen[i].kanalaktiv[j]:=OldEinfacheszene.kanalaktiv[j];
      end;
    end;
  end else
  begin
    for i:=0 to Count-1 do
    begin
      Filestream.ReadBuffer(Einfacheszenen[i].ID,sizeof(Einfacheszenen[i].ID));
      Filestream.ReadBuffer(Einfacheszenen[i].Name,sizeof(Einfacheszenen[i].Name));
      Filestream.ReadBuffer(Einfacheszenen[i].Beschreibung,sizeof(Einfacheszenen[i].Beschreibung));
      Filestream.ReadBuffer(Einfacheszenen[i].einblendzeit,sizeof(Einfacheszenen[i].einblendzeit));
      Filestream.ReadBuffer(Einfacheszenen[i].kanal,sizeof(Einfacheszenen[i].kanal));
      Filestream.ReadBuffer(Einfacheszenen[i].kanalaktiv,sizeof(Einfacheszenen[i].kanalaktiv));
      Filestream.ReadBuffer(Einfacheszenen[i].Category,sizeof(Einfacheszenen[i].Category));
    end;
  end;
  Filestream.ReadBuffer(Count,sizeof(Count));
  setlength(Audioszenen,Count);
  setlength(AudioszenenCHAN,Count);

  if projektprogrammversionint>=411 then
  begin
    for i:=0 to Count-1 do
    begin
      Filestream.ReadBuffer(Audioszenen[i].ID,sizeof(Audioszenen[i].ID));
      Filestream.ReadBuffer(Audioszenen[i].Name,sizeof(Audioszenen[i].Name));
      Filestream.ReadBuffer(Audioszenen[i].Beschreibung,sizeof(Audioszenen[i].Beschreibung));
      Filestream.ReadBuffer(Audioszenen[i].Datei,sizeof(Audioszenen[i].Datei));
      Filestream.ReadBuffer(Audioszenen[i].Dauer,sizeof(Audioszenen[i].Dauer));
      Filestream.ReadBuffer(Audioszenen[i].Volume,sizeof(Audioszenen[i].Volume));
      Filestream.ReadBuffer(Audioszenen[i].FadeinTime,sizeof(Audioszenen[i].FadeinTime));
      Filestream.ReadBuffer(Audioszenen[i].FadeoutTime,sizeof(Audioszenen[i].FadeoutTime));
      if projektprogrammversionint>=432 then
      begin
        Filestream.ReadBuffer(Audioszenen[i].matrix,sizeof(Audioszenen[i].matrix));
        Filestream.ReadBuffer(Audioszenen[i].Kanalsettings,sizeof(Audioszenen[i].Kanalsettings));
      end else
      begin
        Audioszenen[i].matrix[0][0]:=1;
        Audioszenen[i].matrix[0][1]:=0;
        Audioszenen[i].matrix[0][2]:=0;
        Audioszenen[i].matrix[0][3]:=0;
        Audioszenen[i].matrix[0][4]:=0;
        Audioszenen[i].matrix[0][5]:=0;
        Audioszenen[i].matrix[0][6]:=0;
        Audioszenen[i].matrix[0][7]:=0;
        Audioszenen[i].matrix[1][0]:=0;
        Audioszenen[i].matrix[1][1]:=0;
        Audioszenen[i].matrix[1][2]:=1;
        Audioszenen[i].matrix[1][3]:=0;
        Audioszenen[i].matrix[1][4]:=0;
        Audioszenen[i].matrix[1][5]:=0;
        Audioszenen[i].matrix[1][6]:=0;
        Audioszenen[i].matrix[1][7]:=0;
        Audioszenen[i].Kanalsettings[0]:=0;
        Audioszenen[i].Kanalsettings[1]:=0;
        Audioszenen[i].Kanalsettings[2]:=0;
        Audioszenen[i].Kanalsettings[3]:=0;
        Audioszenen[i].Kanalsettings[4]:=0;
        Audioszenen[i].Kanalsettings[5]:=0;
        Audioszenen[i].Kanalsettings[6]:=0;
        Audioszenen[i].Kanalsettings[7]:=0;
      end;
      if projektprogrammversionint>=439 then
        Filestream.ReadBuffer(Audioszenen[i].Category,sizeof(Audioszenen[i].Category));
    end;
  end else
  begin
    for i:=0 to Count-1 do
    begin
      Filestream.ReadBuffer(AudioszeneOld,sizeof(AudioszeneOld));

      Audioszenen[i].ID:=AudioszeneOld.ID;
      Audioszenen[i].Name:=AudioszeneOld.Name;
      Audioszenen[i].Beschreibung:=AudioszeneOld.Beschreibung;
      Audioszenen[i].Datei:=AudioszeneOld.Datei;
      Audioszenen[i].Dauer:=AudioszeneOld.Dauer;
      Audioszenen[i].Volume:=1;
      Audioszenen[i].FadeinTime:=0;
      Audioszenen[i].FadeoutTime:=0;

      Audioszenen[i].matrix[0][0]:=1;
      Audioszenen[i].matrix[0][1]:=0;
      Audioszenen[i].matrix[0][2]:=0;
      Audioszenen[i].matrix[0][3]:=0;
      Audioszenen[i].matrix[0][4]:=0;
      Audioszenen[i].matrix[0][5]:=0;
      Audioszenen[i].matrix[0][6]:=0;
      Audioszenen[i].matrix[0][7]:=0;
      Audioszenen[i].matrix[1][0]:=0;
      Audioszenen[i].matrix[1][1]:=0;
      Audioszenen[i].matrix[1][2]:=1;
      Audioszenen[i].matrix[1][3]:=0;
      Audioszenen[i].matrix[1][4]:=0;
      Audioszenen[i].matrix[1][5]:=0;
      Audioszenen[i].matrix[1][6]:=0;
      Audioszenen[i].matrix[1][7]:=0;
      Audioszenen[i].Kanalsettings[0]:=0;
      Audioszenen[i].Kanalsettings[1]:=0;
      Audioszenen[i].Kanalsettings[2]:=0;
      Audioszenen[i].Kanalsettings[3]:=0;
      Audioszenen[i].Kanalsettings[4]:=0;
      Audioszenen[i].Kanalsettings[5]:=0;
      Audioszenen[i].Kanalsettings[6]:=0;
      Audioszenen[i].Kanalsettings[7]:=0;
    end;
  end;

  Filestream.ReadBuffer(Count,sizeof(Count));
  setlength(Bewegungsszenen,Count);
  setlength(BewegungsszenenZeit,Count);
  setlength(BewegungsszenenAktiv,Count);
  for i:=0 to Count-1 do
  begin
    Filestream.ReadBuffer(Bewegungsszenen[i].ID,sizeof(Bewegungsszenen[i].ID));
    Filestream.ReadBuffer(Bewegungsszenen[i].Name,sizeof(Bewegungsszenen[i].Name));
    Filestream.ReadBuffer(Bewegungsszenen[i].Beschreibung,sizeof(Bewegungsszenen[i].Beschreibung));
    if projektprogrammversionint>=428 then
      Filestream.ReadBuffer(Bewegungsszenen[i].IsBeatControlled,sizeof(Bewegungsszenen[i].IsBeatControlled));
    Filestream.ReadBuffer(Bewegungsszenen[i].figur,sizeof(Bewegungsszenen[i].figur));
    Filestream.ReadBuffer(Bewegungsszenen[i].dauer,sizeof(Bewegungsszenen[i].dauer));
    if projektprogrammversionint>=417 then
      Filestream.ReadBuffer(Bewegungsszenen[i].DontFade,sizeof(Bewegungsszenen[i].DontFade));
    Filestream.ReadBuffer(Bewegungsszenen[i].repeats,sizeof(Bewegungsszenen[i].repeats));
    Filestream.ReadBuffer(Bewegungsszenen[i].identischespurgeschwidigkeit,sizeof(Bewegungsszenen[i].identischespurgeschwidigkeit));
    Filestream.ReadBuffer(Bewegungsszenen[i].startpositionrelativ,sizeof(Bewegungsszenen[i].startpositionrelativ));
    if projektprogrammversionint>=439 then
      Filestream.ReadBuffer(Bewegungsszenen[i].Category,sizeof(Bewegungsszenen[i].Category));

    Filestream.ReadBuffer(Count2,sizeof(Count2));
    setlength(Bewegungsszenen[i].Devices,Count2);
    setlength(BewegungsszenenZeit[i],Count2);
    setlength(BewegungsszenenAktiv[i].Zeit,Count2);
    setlength(BewegungsszenenAktiv[i].Repeats,Count2);
    setlength(BewegungsszenenAktiv[i].Position,Count2);
    for j:=0 to Count2-1 do
    begin
      Filestream.ReadBuffer(Bewegungsszenen[i].Devices[j].ID,sizeof(Bewegungsszenen[i].Devices[j].ID));

      Filestream.ReadBuffer(Count3,sizeof(Count3));
      setlength(Bewegungsszenen[i].Devices[j].DeviceChannel,Count3);
      setlength(Bewegungsszenen[i].Devices[j].Szenen,Count3);
      setlength(BewegungsszenenZeit[i][j],Count3);
      setlength(BewegungsszenenAktiv[i].Zeit[j],Count3);
      setlength(BewegungsszenenAktiv[i].Repeats[j],Count3);
      setlength(BewegungsszenenAktiv[i].Position[j],Count3);
      for k:=0 to Count3-1 do
      begin
        if projektprogrammversionint>=425 then
          Filestream.ReadBuffer(Bewegungsszenen[i].Devices[j].DeviceChannel[k],sizeof(Bewegungsszenen[i].Devices[j].DeviceChannel[k]))
        else
        begin
          Filestream.ReadBuffer(tempchannel_pre425,sizeof(tempchannel_pre425));
          Bewegungsszenen[i].Devices[j].DeviceChannel[k].ChanActive:=tempchannel_pre425.ChanActive;
          Bewegungsszenen[i].Devices[j].DeviceChannel[k].invertx:=tempchannel_pre425.invertx;
          Bewegungsszenen[i].Devices[j].DeviceChannel[k].inverty:=tempchannel_pre425.inverty;
          Bewegungsszenen[i].Devices[j].DeviceChannel[k].mittelpunktx:=tempchannel_pre425.mittelpunktx;
          Bewegungsszenen[i].Devices[j].DeviceChannel[k].mittelpunkty:=tempchannel_pre425.mittelpunkty;
          Bewegungsszenen[i].Devices[j].DeviceChannel[k].scalex:=tempchannel_pre425.scalex;
          Bewegungsszenen[i].Devices[j].DeviceChannel[k].scaley:=tempchannel_pre425.scaley;
          Bewegungsszenen[i].Devices[j].DeviceChannel[k].x:=tempchannel_pre425.x;
          Bewegungsszenen[i].Devices[j].DeviceChannel[k].y:=tempchannel_pre425.y;
          Bewegungsszenen[i].Devices[j].DeviceChannel[k].mixXY:=tempchannel_pre425.mixXY;
          Bewegungsszenen[i].Devices[j].DeviceChannel[k].offset:=tempchannel_pre425.offset;
          Bewegungsszenen[i].Devices[j].DeviceChannel[k].delay:=0;
        end;


        Filestream.ReadBuffer(Count4,sizeof(Count4));
        setlength(Bewegungsszenen[i].Devices[j].Szenen[k],Count4);
        for l:=0 to Count4-1 do
        begin
          Filestream.ReadBuffer(Bewegungsszenen[i].Devices[j].Szenen[k][l],sizeof(Bewegungsszenen[i].Devices[j].Szenen[k][l]));
        end;
      end;
    end;
  end;

  if projektprogrammversionint>=418 then
  begin
    Filestream.ReadBuffer(Count,sizeof(Count));
    setlength(Befehle2,Count);
    for i:=0 to Count-1 do
    begin
      Filestream.ReadBuffer(Befehle2[i].ID,sizeof(Befehle2[i].ID));
      Filestream.ReadBuffer(Befehle2[i].Typ,sizeof(Befehle2[i].Typ));
      Filestream.ReadBuffer(Befehle2[i].Name,sizeof(Befehle2[i].Name));
      Filestream.ReadBuffer(Befehle2[i].Beschreibung,sizeof(Befehle2[i].Beschreibung));
      Filestream.ReadBuffer(Befehle2[i].OnValue,sizeof(Befehle2[i].OnValue));
      if projektprogrammversionint>=456 then
        Filestream.ReadBuffer(Befehle2[i].SwitchValue,sizeof(Befehle2[i].SwitchValue))
      else
        Befehle2[i].SwitchValue:=Befehle2[i].OnValue;
      if projektprogrammversionint>=462 then
        Filestream.ReadBuffer(Befehle2[i].InvertSwitchValue,sizeof(Befehle2[i].InvertSwitchValue));
      Filestream.ReadBuffer(Befehle2[i].OffValue,sizeof(Befehle2[i].OffValue));
      if projektprogrammversionint>=457 then
        Filestream.ReadBuffer(Befehle2[i].ScaleValue,sizeof(Befehle2[i].ScaleValue));

      if projektprogrammversionint>=438 then
        Filestream.ReadBuffer(Befehle2[i].RunOnProjectLoad,sizeof(Befehle2[i].RunOnProjectLoad));
      if projektprogrammversionint>=439 then
        Filestream.ReadBuffer(Befehle2[i].Category,sizeof(Befehle2[i].Category));

      Filestream.ReadBuffer(Count2,sizeof(Count2));
      setlength(Befehle2[i].ArgInteger,Count2);
      for j:=0 to Count2-1 do
      begin
        Filestream.ReadBuffer(Befehle2[i].ArgInteger[j],sizeof(Befehle2[i].ArgInteger[j]));
      end;
      Filestream.ReadBuffer(Count2,sizeof(Count2));
      setlength(Befehle2[i].ArgString,Count2);
      for j:=0 to Count2-1 do
      begin
        Filestream.ReadBuffer(Befehle2[i].ArgString[j],sizeof(Befehle2[i].ArgString[j]));
      end;
      Filestream.ReadBuffer(Count2,sizeof(Count2));
      setlength(Befehle2[i].ArgGUID,Count2);
      for j:=0 to Count2-1 do
      begin
        Filestream.ReadBuffer(Befehle2[i].ArgGUID[j],sizeof(Befehle2[i].ArgGUID[j]));
      end;
    end;
  end else
  begin
    // Nur aus Kompatibilitätsgründen
    Filestream.ReadBuffer(Count,sizeof(Count));
    setlength(OldBefehle,Count);
    for i:=0 to Count-1 do
    begin
      Filestream.ReadBuffer(OldBefehle[i],sizeof(OldBefehle[i]));
    end;
    ConvertBefehlToBefehl2;
  end;

  Filestream.ReadBuffer(Count,sizeof(Count));
  setlength(Kompositionsszenen,Count);
  for i:=0 to Count-1 do
  begin
    Filestream.ReadBuffer(Kompositionsszenen[i].ID,sizeof(Kompositionsszenen[i].ID));
    Filestream.ReadBuffer(Kompositionsszenen[i].Name,sizeof(Kompositionsszenen[i].Name));
    Filestream.ReadBuffer(Kompositionsszenen[i].Beschreibung,sizeof(Kompositionsszenen[i].Beschreibung));
    if projektprogrammversionint>=439 then
      Filestream.ReadBuffer(Kompositionsszenen[i].Category,sizeof(Kompositionsszenen[i].Category));

    Filestream.ReadBuffer(Count2, sizeof(Count2));
    setlength(Kompositionsszenen[i].IDs,Count2);
    setlength(Kompositionsszenen[i].StopScene,Count2);
    for j:=0 to Count2-1 do
    begin
      Filestream.ReadBuffer(Kompositionsszenen[i].IDs[j],sizeof(Kompositionsszenen[i].IDs[j]));
      if projektprogrammversionint>=454 then
        Filestream.ReadBuffer(Kompositionsszenen[i].StopScene[j],sizeof(Kompositionsszenen[i].StopScene[j]));
    end;
  end;

  FileStream.ReadBuffer(Count,sizeof(Count));
  Setlength(SzenenablaufArray,Count);
  for i:=0 to Count-1 do
  begin
    Filestream.ReadBuffer(text,sizeof(text));
    FileStream.ReadBuffer(Count2,sizeof(Count2));
    Setlength(SzenenablaufArray[i],Count2);
    for j:=0 to Count2-1 do
      FileStream.ReadBuffer(SzenenablaufArray[i][j],sizeof(SzenenablaufArray[i][j]));
  end;
  // Ende Szenenöffnen

    // Timeline öffnen
	if not startingup then
  begin
	  inprogress.filename.Caption:=_('Lese Daten ein... Timeline');
	 	inprogress.Refresh;
  end else
  begin
    SplashCaptioninfo(_('Lese Daten ein...Timeline'));
    RefreshSplashText;
  end;

  Filestream.ReadBuffer(Count,sizeof(Count));
  setlength(Effekttimeline,Count);
  for i:=0 to Count-1 do
  begin
    Filestream.ReadBuffer(Effekttimeline[i].name,sizeof(Effekttimeline[i].name));
    Filestream.ReadBuffer(Count2,sizeof(Count2));
    setlength(Effekttimeline[i].value,Count2);
    for j:=0 to Count2-1 do
      Filestream.ReadBuffer(Effekttimeline[i].value[j],sizeof(Effekttimeline[i].value[j]));
    Filestream.ReadBuffer(Effekttimeline[i].checked,sizeof(Effekttimeline[i].checked));
    Filestream.ReadBuffer(Effekttimeline[i].steps,sizeof(Effekttimeline[i].steps));
    Filestream.ReadBuffer(Effekttimeline[i].blendzeit,sizeof(Effekttimeline[i].blendzeit));
    Filestream.ReadBuffer(Effekttimeline[i].blitzfunktion,sizeof(Effekttimeline[i].blitzfunktion));
    Filestream.ReadBuffer(Effekttimeline[i].blitzzeit,sizeof(Effekttimeline[i].blitzzeit));
    Filestream.ReadBuffer(Effekttimeline[i].pendeln,sizeof(Effekttimeline[i].pendeln));
    Filestream.ReadBuffer(Effekttimeline[i].zufall,sizeof(Effekttimeline[i].zufall));
  end;
  // Ende Timeline öffnen
  // Skripttimer öffnen
	if not startingup then
  begin
	  inprogress.filename.Caption:=_('Lese Daten ein... Skripttimer');
	 	inprogress.Refresh;
  end else
  begin
    SplashCaptioninfo(_('Lese Daten ein...Skripttimer'));
    RefreshSplashText;
  end;

  Filestream.ReadBuffer(Count,sizeof(Count));
  setlength(AblaufTimer,Count);
  for i:=0 to Count-1 do
  begin
    Filestream.ReadBuffer(AblaufTimer[i].Aktiviert,sizeof(AblaufTimer[i].Aktiviert));
    Filestream.ReadBuffer(AblaufTimer[i].Name,sizeof(AblaufTimer[i].Name));
    Filestream.ReadBuffer(AblaufTimer[i].Beschreibung,sizeof(AblaufTimer[i].Beschreibung));
    Filestream.ReadBuffer(AblaufTimer[i].Datum,sizeof(AblaufTimer[i].Datum));
    Filestream.ReadBuffer(AblaufTimer[i].Uhrzeit,sizeof(AblaufTimer[i].Uhrzeit));
    Filestream.ReadBuffer(AblaufTimer[i].TimerTyp,sizeof(AblaufTimer[i].TimerTyp));
    Filestream.ReadBuffer(AblaufTimer[i].Skriptdatei,sizeof(AblaufTimer[i].Skriptdatei));
    Filestream.ReadBuffer(AblaufTimer[i].LoadTyp,sizeof(AblaufTimer[i].LoadTyp));
    Filestream.ReadBuffer(AblaufTimer[i].LoadID,sizeof(AblaufTimer[i].LoadID));
    if projektprogrammversionint>=482 then
    begin
      Filestream.ReadBuffer(AblaufTimer[i].Weekday,sizeof(AblaufTimer[i].Weekday));
    end else
    begin
      AblaufTimer[i].Weekday[1]:=true;
      AblaufTimer[i].Weekday[2]:=true;
      AblaufTimer[i].Weekday[3]:=true;
      AblaufTimer[i].Weekday[4]:=true;
      AblaufTimer[i].Weekday[5]:=true;
      AblaufTimer[i].Weekday[6]:=true;
      AblaufTimer[i].Weekday[7]:=true;
    end;
  end;
  // Ende Skripttimer öffnen
  // Hotkeys öffnen
	if not startingup then
  begin
	  inprogress.filename.Caption:=_('Lese Daten ein... Hotkeys');
    inprogress.ProgressBar1.Position:=56;
	 	inprogress.Refresh;
  end else
  begin
    SplashCaptioninfo(_('Lese Daten ein...Hotkeys'));
    SplashProgress(1, 83, 100);
    RefreshSplashText;
  end;
  ShortCutChecker.Enabled:=false;
  sleep(100);

  if projektprogrammversionint>=418 then
  begin
    Filestream.ReadBuffer(Count,sizeof(Count));
    setlength(TastencodeArray,Count);
    setlength(TastencodePressedArray,Count);
    for i:=0 to Count-1 do
    begin
      Filestream.ReadBuffer(TastencodeArray[i].ID,sizeof(TastencodeArray[i].ID));
      Filestream.ReadBuffer(TastencodeArray[i].active,sizeof(TastencodeArray[i].active));
      Filestream.ReadBuffer(TastencodeArray[i].Hotkey,sizeof(TastencodeArray[i].Hotkey));
      Filestream.ReadBuffer(TastencodeArray[i].Global,sizeof(TastencodeArray[i].Global));
      Filestream.ReadBuffer(TastencodeArray[i].Repeated,sizeof(TastencodeArray[i].Repeated));
      Filestream.ReadBuffer(TastencodeArray[i].UseKeyUp,sizeof(TastencodeArray[i].UseKeyUp));

      if projektprogrammversionint>=421 then
      begin
        Filestream.ReadBuffer(TastencodeArray[i].KeyDownValue,sizeof(TastencodeArray[i].KeyDownValue));
        Filestream.ReadBuffer(TastencodeArray[i].KeyUpValue,sizeof(TastencodeArray[i].KeyUpValue));
      end else
      begin
        TastencodeArray[i].KeyDownValue:=255;
        TastencodeArray[i].KeyUpValue:=0;
      end;

      Filestream.ReadBuffer(TastencodeArray[i].Befehl.Typ,sizeof(TastencodeArray[i].Befehl.Typ));
      Filestream.ReadBuffer(TastencodeArray[i].Befehl.OnValue,sizeof(TastencodeArray[i].Befehl.OnValue));
      if projektprogrammversionint>=456 then
        Filestream.ReadBuffer(TastencodeArray[i].Befehl.SwitchValue,sizeof(TastencodeArray[i].Befehl.SwitchValue))
      else
        TastencodeArray[i].Befehl.SwitchValue:=TastencodeArray[i].Befehl.OnValue;
      if projektprogrammversionint>=462 then
        Filestream.ReadBuffer(TastencodeArray[i].Befehl.InvertSwitchValue,sizeof(TastencodeArray[i].Befehl.InvertSwitchValue));
      Filestream.ReadBuffer(TastencodeArray[i].Befehl.OffValue,sizeof(TastencodeArray[i].Befehl.OffValue));
      if projektprogrammversionint>=457 then
        Filestream.ReadBuffer(TastencodeArray[i].Befehl.ScaleValue,sizeof(TastencodeArray[i].Befehl.ScaleValue));
      Filestream.ReadBuffer(Count2,sizeof(Count2));
      setlength(TastencodeArray[i].Befehl.ArgInteger,Count2);
      for j:=0 to Count2-1 do
        Filestream.ReadBuffer(TastencodeArray[i].Befehl.ArgInteger[j],sizeof(TastencodeArray[i].Befehl.ArgInteger[j]));
      Filestream.ReadBuffer(Count2,sizeof(Count2));
      setlength(TastencodeArray[i].Befehl.ArgString,Count2);
      for j:=0 to Count2-1 do
        Filestream.ReadBuffer(TastencodeArray[i].Befehl.ArgString[j],sizeof(TastencodeArray[i].Befehl.ArgString[j]));
      Filestream.ReadBuffer(Count2,sizeof(Count2));
      setlength(TastencodeArray[i].Befehl.ArgGUID,Count2);
      for j:=0 to Count2-1 do
        Filestream.ReadBuffer(TastencodeArray[i].Befehl.ArgGUID[j],sizeof(TastencodeArray[i].Befehl.ArgGUID[j]));
    end;
  end else
  begin
    Filestream.ReadBuffer(Count,sizeof(Count));
    setlength(OldTastencodeArray,Count);
    setlength(TastencodePressedArray,Count);
    for i:=0 to Count-1 do
      Filestream.ReadBuffer(OldTastencodeArray[i],sizeof(OldTastencodeArray[i]));

    ConvertHotkeysToHotkeys2;
  end;

  if EnableHotKeys then
  begin
    for i:=0 to length(TastencodeArray)-1 do
    begin
      ShortCutToKey(TastencodeArray[i].Hotkey,Key,Shift);
      ShiftNumber:=0;
      if Shift=[ssAlt] then
        ShiftNumber:=1
      else if Shift=[ssCtrl] then
        ShiftNumber:=ShiftNumber+2
      else if Shift=[ssShift] then
      begin
        ShiftNumber:=ShiftNumber+4;
      end;
    end;
  end;

  ShortCutChecker.Enabled:=true;
  // Ende Hotkey laden
  // Nebelmaschineneinstellungen laden
    if not startingup then
    begin
      inprogress.filename.Caption:=_('Lese Daten ein... Nebelmaschine');
      inprogress.Refresh;
    end else
    begin
      SplashCaptioninfo(_('Lese Daten ein...Nebelmaschine'));
      RefreshSplashText;
    end;
    Filestream.ReadBuffer(fogtimer,sizeof(fogtimer));

      // Geräte öffnen
    if not startingup then
    begin
      inprogress.filename.Caption:=_('Lese Daten ein... Geräte');
      inprogress.Refresh;
    end else
    begin
      SplashCaptioninfo(_('Lese Daten ein...Geräte'));
      RefreshSplashText;
    end;

	  Filestream.ReadBuffer(Count,sizeof(Count));
    setlength(mainform.Devices,Count);
    setlength(mainform.DeviceSelected,Count);
    for i:=0 to Count-1 do
    begin
   	  Filestream.ReadBuffer(mainform.Devices[i].ID,sizeof(mainform.Devices[i].ID));
   	  Filestream.ReadBuffer(mainform.Devices[i].Name,sizeof(mainform.Devices[i].Name));
   	  Filestream.ReadBuffer(mainform.Devices[i].DeviceName,sizeof(mainform.Devices[i].DeviceName));
   	  Filestream.ReadBuffer(mainform.Devices[i].Beschreibung,sizeof(mainform.Devices[i].Beschreibung));
   	  Filestream.ReadBuffer(mainform.Devices[i].Vendor,sizeof(mainform.Devices[i].Vendor));
   	  Filestream.ReadBuffer(mainform.Devices[i].Bildadresse,sizeof(mainform.Devices[i].Bildadresse));
   	  Filestream.ReadBuffer(mainform.Devices[i].Startaddress,sizeof(mainform.Devices[i].Startaddress));
   	  Filestream.ReadBuffer(mainform.Devices[i].MaxChan,sizeof(mainform.Devices[i].MaxChan));
   	  Filestream.ReadBuffer(mainform.Devices[i].invertpan,sizeof(mainform.Devices[i].invertpan));
   	  Filestream.ReadBuffer(mainform.Devices[i].inverttilt,sizeof(mainform.Devices[i].inverttilt));
      if (projektprogrammversionint>=401) then
     	  Filestream.ReadBuffer(mainform.Devices[i].typeofscannercalibration,sizeof(mainform.Devices[i].typeofscannercalibration));
      if (projektprogrammversionint>=401) and (projektprogrammversionint<407) then
      begin
     	  Filestream.ReadBuffer(mainform.Devices[i].CalibrationpointA,sizeof(mainform.Devices[i].CalibrationpointA));
     	  Filestream.ReadBuffer(mainform.Devices[i].CalibrationpointB,sizeof(mainform.Devices[i].CalibrationpointB));
     	  Filestream.ReadBuffer(mainform.Devices[i].CalibrationpointC,sizeof(mainform.Devices[i].CalibrationpointC));
     	  Filestream.ReadBuffer(mainform.Devices[i].CalibrationpointD,sizeof(mainform.Devices[i].CalibrationpointD));
        mainform.Devices[i].ScannerCalibrations[2].Name:=_('Konv. Kalibrierung');
        mainform.Devices[i].ScannerCalibrations[2].PointA:=mainform.Devices[i].CalibrationpointA;
        mainform.Devices[i].ScannerCalibrations[2].PointB:=mainform.Devices[i].CalibrationpointB;
        mainform.Devices[i].ScannerCalibrations[2].PointC:=mainform.Devices[i].CalibrationpointC;
        mainform.Devices[i].ScannerCalibrations[2].PointD:=mainform.Devices[i].CalibrationpointD;
      end;
      if (projektprogrammversionint>=402) and (projektprogrammversionint<407) then
      begin
     	  Filestream.ReadBuffer(mainform.Devices[i].CalibrationpointAsync,sizeof(mainform.Devices[i].CalibrationpointAsync));
     	  Filestream.ReadBuffer(mainform.Devices[i].CalibrationpointBsync,sizeof(mainform.Devices[i].CalibrationpointBsync));
     	  Filestream.ReadBuffer(mainform.Devices[i].CalibrationpointCsync,sizeof(mainform.Devices[i].CalibrationpointCsync));
     	  Filestream.ReadBuffer(mainform.Devices[i].CalibrationpointDsync,sizeof(mainform.Devices[i].CalibrationpointDsync));
        mainform.Devices[i].ScannerCalibrations[16].Name:=_('Konv. Verfolgerkalib.');
        mainform.Devices[i].ScannerCalibrations[16].PointA:=mainform.Devices[i].CalibrationpointA;
        mainform.Devices[i].ScannerCalibrations[16].PointB:=mainform.Devices[i].CalibrationpointB;
        mainform.Devices[i].ScannerCalibrations[16].PointC:=mainform.Devices[i].CalibrationpointC;
        mainform.Devices[i].ScannerCalibrations[16].PointD:=mainform.Devices[i].CalibrationpointD;
      end;

      if projektprogrammversionint>=407 then
      begin
        Filestream.ReadBuffer(Count2,sizeof(Count2));
        for j:=0 to Count2-1 do
   	      Filestream.ReadBuffer(mainform.Devices[i].ScannerCalibrations[j],sizeof(mainform.Devices[i].ScannerCalibrations[j]));
      end;
      // Bühnenansichtdarstellung
   	  Filestream.ReadBuffer(mainform.Devices[i].ShowInStageView,sizeof(mainform.Devices[i].ShowInStageView));
      Filestream.ReadBuffer(mainform.Devices[i].color,sizeof(mainform.Devices[i].color));
   	  Filestream.ReadBuffer(mainform.Devices[i].picturesize,sizeof(mainform.Devices[i].picturesize));

      if projektprogrammversionint<=433 then
      begin
        mainform.Devices[i].picturesize:=mainform.Devices[i].picturesize*16;
      end;

      if projektprogrammversionint>=480 then
     	  Filestream.ReadBuffer(mainform.Devices[i].pictureangle,sizeof(mainform.Devices[i].pictureangle))
      else
     	begin
        Filestream.ReadBuffer(b,sizeof(b));
        case b of
          0: mainform.Devices[i].pictureangle:=0;
          1: mainform.Devices[i].pictureangle:=90;
          2: mainform.Devices[i].pictureangle:=180;
          3: mainform.Devices[i].pictureangle:=270;
        end;
      end;
   	  Filestream.ReadBuffer(mainform.Devices[i].picturefliphor,sizeof(mainform.Devices[i].picturefliphor));
   	  Filestream.ReadBuffer(mainform.Devices[i].pictureflipver,sizeof(mainform.Devices[i].pictureflipver));
   	  Filestream.ReadBuffer(mainform.Devices[i].pictureispng,sizeof(mainform.Devices[i].pictureispng));

   	  Filestream.ReadBuffer(Count2,sizeof(Count2));
      setlength(mainform.Devices[i].top,Count2);
      setlength(mainform.Devices[i].left,Count2);
      setlength(mainform.Devices[i].bank,Count2);
      setlength(mainform.Devices[i].selected,Count2);
      setlength(mainform.Devices[i].OldPos,Count2);
      for j:=0 to Count2-1 do
      begin
     	  Filestream.ReadBuffer(mainform.Devices[i].top[j],sizeof(mainform.Devices[i].top[j]));
     	  Filestream.ReadBuffer(mainform.Devices[i].left[j],sizeof(mainform.Devices[i].left[j]));
        if projektprogrammversionint>=422 then
       	  Filestream.ReadBuffer(mainform.Devices[i].bank[j],sizeof(mainform.Devices[i].bank[j]));
      end;
   	  Filestream.ReadBuffer(mainform.Devices[i].hasDimmer,sizeof(mainform.Devices[i].hasDIMMER));
      if projektprogrammversionint>=481 then
        Filestream.ReadBuffer(mainform.Devices[i].hasShutter,sizeof(mainform.Devices[i].hasShutter));
      if projektprogrammversionint>=464 then
     	  Filestream.ReadBuffer(mainform.Devices[i].hasVirtualRGBAWDimmer,sizeof(mainform.Devices[i].hasVirtualRGBAWDIMMER));
   	  Filestream.ReadBuffer(mainform.Devices[i].hasRGB,sizeof(mainform.Devices[i].hasRGB));
      if projektprogrammversionint>=468 then
     	  Filestream.ReadBuffer(mainform.Devices[i].hasCMY,sizeof(mainform.Devices[i].hasCMY));
      if projektprogrammversionint>=463 then
     	begin
        Filestream.ReadBuffer(mainform.Devices[i].hasAmber,sizeof(mainform.Devices[i].hasAmber));
        Filestream.ReadBuffer(mainform.Devices[i].hasWhite,sizeof(mainform.Devices[i].hasWhite));
        if projektprogrammversionint>=476 then
          Filestream.ReadBuffer(mainform.Devices[i].hasUV,sizeof(mainform.Devices[i].hasUV));
        if projektprogrammversionint>=477 then
          Filestream.ReadBuffer(mainform.Devices[i].hasFog,sizeof(mainform.Devices[i].hasFog));
     	  Filestream.ReadBuffer(mainform.Devices[i].UseAmberMixing,sizeof(mainform.Devices[i].UseAmberMixing));
     	  Filestream.ReadBuffer(mainform.Devices[i].AmberMixingCompensateRG,sizeof(mainform.Devices[i].AmberMixingCompensateRG));
     	  Filestream.ReadBuffer(mainform.Devices[i].AmberMixingCompensateBlue,sizeof(mainform.Devices[i].AmberMixingCompensateBlue));
     	  Filestream.ReadBuffer(mainform.Devices[i].AmberRatioR,sizeof(mainform.Devices[i].AmberRatioR));
     	  Filestream.ReadBuffer(mainform.Devices[i].AmberRatioG,sizeof(mainform.Devices[i].AmberRatioG));
   	  end;
      Filestream.ReadBuffer(mainform.Devices[i].hasPANTILT,sizeof(mainform.Devices[i].hasPANTILT));
   	  Filestream.ReadBuffer(mainform.Devices[i].hasColor,sizeof(mainform.Devices[i].hasColor));
      if projektprogrammversionint>=450 then
      begin
        Filestream.ReadBuffer(mainform.Devices[i].hasColor2,sizeof(mainform.Devices[i].hasColor2));
        Filestream.ReadBuffer(mainform.Devices[i].hasGobo,sizeof(mainform.Devices[i].hasGobo));
        Filestream.ReadBuffer(mainform.Devices[i].hasGobo2,sizeof(mainform.Devices[i].hasGobo2));
      end;

   	  Filestream.ReadBuffer(Count2,sizeof(Count2));
      setlength(mainform.Devices[i].colors,Count2);
      setlength(mainform.Devices[i].colorlevels,Count2);
      setlength(mainform.Devices[i].colorendlevels,Count2);
      setlength(mainform.Devices[i].colornames,Count2);
      for j:=0 to Count2-1 do
     	begin
        Filestream.ReadBuffer(mainform.Devices[i].colors[j],sizeof(mainform.Devices[i].colors[j]));
        Filestream.ReadBuffer(mainform.Devices[i].colorlevels[j],sizeof(mainform.Devices[i].colorlevels[j]));
        if projektprogrammversionint>=440 then
          Filestream.ReadBuffer(mainform.Devices[i].colorendlevels[j],sizeof(mainform.Devices[i].colorendlevels[j]))
        else
          mainform.Devices[i].colorendlevels[j]:=mainform.Devices[i].colorlevels[j];
        Filestream.ReadBuffer(mainform.Devices[i].colornames[j],sizeof(mainform.Devices[i].colornames[j]));
      end;
      Filestream.ReadBuffer(mainform.Devices[i].colortolerance,sizeof(mainform.Devices[i].colortolerance));
   	  Filestream.ReadBuffer(mainform.Devices[i].autoscening,sizeof(mainform.Devices[i].autoscening));

      if projektprogrammversionint>=449 then
      begin
        Filestream.ReadBuffer(Count2,sizeof(Count2));
        setlength(mainform.Devices[i].colors2, Count2);
        setlength(mainform.Devices[i].colorlevels2, Count2);
        setlength(mainform.Devices[i].colorendlevels2, Count2);
        setlength(mainform.Devices[i].colornames2, Count2);
        for j:=0 to Count2-1 do
        begin
          Filestream.ReadBuffer(mainform.Devices[i].colors2[j],sizeof(mainform.Devices[i].colors2[j]));
          Filestream.ReadBuffer(mainform.Devices[i].colorlevels2[j],sizeof(mainform.Devices[i].colorlevels2[j]));
          Filestream.ReadBuffer(mainform.Devices[i].colorendlevels2[j],sizeof(mainform.Devices[i].colorendlevels2[j]));
          Filestream.ReadBuffer(mainform.Devices[i].colornames2[j],sizeof(mainform.Devices[i].colornames2[j]));
        end;
        Filestream.ReadBuffer(Count2,sizeof(Count2));
        setlength(mainform.Devices[i].gobos,Count2);
        setlength(mainform.Devices[i].gobolevels,Count2);
        setlength(mainform.Devices[i].goboendlevels,Count2);
        setlength(mainform.Devices[i].gobonames,Count2);
        setlength(mainform.Devices[i].bestgobos,Count2);
        for j:=0 to Count2-1 do
        begin
          Filestream.ReadBuffer(mainform.Devices[i].gobos[j],sizeof(mainform.Devices[i].gobos[j]));
          Filestream.ReadBuffer(mainform.Devices[i].gobolevels[j],sizeof(mainform.Devices[i].gobolevels[j]));
          Filestream.ReadBuffer(mainform.Devices[i].goboendlevels[j],sizeof(mainform.Devices[i].goboendlevels[j]));
          Filestream.ReadBuffer(mainform.Devices[i].gobonames[j],sizeof(mainform.Devices[i].gobonames[j]));
          if projektprogrammversionint<452 then
            Filestream.ReadBuffer(DummyByte,sizeof(DummyByte))
          else
          begin
            Filestream.ReadBuffer(Count3,sizeof(Count3));
            setlength(mainform.Devices[i].bestgobos[j], Count3);
            for k:=0 to length(mainform.Devices[i].bestgobos[j])-1 do
            begin
              Filestream.ReadBuffer(mainform.Devices[i].bestgobos[j][k].GoboName,sizeof(mainform.Devices[i].bestgobos[j][k].GoboName));
              Filestream.ReadBuffer(mainform.Devices[i].bestgobos[j][k].Percent,sizeof(mainform.Devices[i].bestgobos[j][k].Percent));
            end;
          end;
          geraetesteuerung.AddGobo(mainform.Devices[i].gobos[j]);
        end;
        Filestream.ReadBuffer(Count2,sizeof(Count2));
        setlength(mainform.Devices[i].gobos2,Count2);
        setlength(mainform.Devices[i].gobolevels2,Count2);
        setlength(mainform.Devices[i].goboendlevels2,Count2);
        setlength(mainform.Devices[i].gobonames2,Count2);
        setlength(mainform.Devices[i].bestgobos2,Count2);
        for j:=0 to Count2-1 do
        begin
          Filestream.ReadBuffer(mainform.Devices[i].gobos2[j],sizeof(mainform.Devices[i].gobos2[j]));
          Filestream.ReadBuffer(mainform.Devices[i].gobolevels2[j],sizeof(mainform.Devices[i].gobolevels2[j]));
          Filestream.ReadBuffer(mainform.Devices[i].goboendlevels2[j],sizeof(mainform.Devices[i].goboendlevels2[j]));
          Filestream.ReadBuffer(mainform.Devices[i].gobonames2[j],sizeof(mainform.Devices[i].gobonames2[j]));
          if projektprogrammversionint<452 then
            Filestream.ReadBuffer(DummyByte,sizeof(DummyByte))
          else
          begin
            Filestream.ReadBuffer(Count3,sizeof(Count3));
            setlength(mainform.Devices[i].bestgobos2[j], Count3);
            for k:=0 to length(mainform.Devices[i].bestgobos2[j])-1 do
            begin
              Filestream.ReadBuffer(mainform.Devices[i].bestgobos2[j][k].GoboName,sizeof(mainform.Devices[i].bestgobos2[j][k].GoboName));
              Filestream.ReadBuffer(mainform.Devices[i].bestgobos2[j][k].Percent,sizeof(mainform.Devices[i].bestgobos2[j][k].Percent));
            end;
          end;
          geraetesteuerung.AddGobo(mainform.Devices[i].gobos2[j]);
        end;
      end;

      if projektprogrammversionint>=460 then
      begin
        Filestream.ReadBuffer(mainform.Devices[i].ShutterOpenValue,sizeof(mainform.Devices[i].ShutterOpenValue));
        Filestream.ReadBuffer(mainform.Devices[i].ShutterCloseValue,sizeof(mainform.Devices[i].ShutterCloseValue));
        Filestream.ReadBuffer(mainform.Devices[i].ShutterChannel,sizeof(mainform.Devices[i].ShutterChannel));
        Filestream.ReadBuffer(mainform.Devices[i].StrobeOffValue,sizeof(mainform.Devices[i].StrobeOffValue));
        Filestream.ReadBuffer(mainform.Devices[i].StrobeMinValue,sizeof(mainform.Devices[i].StrobeMinValue));
        Filestream.ReadBuffer(mainform.Devices[i].StrobeMaxValue,sizeof(mainform.Devices[i].StrobeMaxValue));
        Filestream.ReadBuffer(mainform.Devices[i].StrobeChannel,sizeof(mainform.Devices[i].StrobeChannel));
        Filestream.ReadBuffer(mainform.Devices[i].DimmerOffValue,sizeof(mainform.Devices[i].DimmerOffValue));
        Filestream.ReadBuffer(mainform.Devices[i].DimmerMaxValue,sizeof(mainform.Devices[i].DimmerMaxValue));
        if projektprogrammversionint>=477 then
        begin
          Filestream.ReadBuffer(mainform.Devices[i].FogOffValue,sizeof(mainform.Devices[i].FogOffValue));
          Filestream.ReadBuffer(mainform.Devices[i].FogMaxValue,sizeof(mainform.Devices[i].FogMaxValue));
        end;
        Filestream.ReadBuffer(mainform.Devices[i].Gobo1RotLeftminValue,sizeof(mainform.Devices[i].Gobo1RotLeftminValue));
        Filestream.ReadBuffer(mainform.Devices[i].Gobo1RotLeftValue,sizeof(mainform.Devices[i].Gobo1RotLeftValue));
        Filestream.ReadBuffer(mainform.Devices[i].Gobo1RotOffValue,sizeof(mainform.Devices[i].Gobo1RotOffValue));
        Filestream.ReadBuffer(mainform.Devices[i].Gobo1RotRightminValue,sizeof(mainform.Devices[i].Gobo1RotRightminValue));
        Filestream.ReadBuffer(mainform.Devices[i].Gobo1RotRightValue,sizeof(mainform.Devices[i].Gobo1RotRightValue));
        Filestream.ReadBuffer(mainform.Devices[i].Gobo1RotChannel,sizeof(mainform.Devices[i].Gobo1RotChannel));
        Filestream.ReadBuffer(mainform.Devices[i].Gobo2RotLeftminValue,sizeof(mainform.Devices[i].Gobo2RotLeftminValue));
        Filestream.ReadBuffer(mainform.Devices[i].Gobo2RotLeftValue,sizeof(mainform.Devices[i].Gobo2RotLeftValue));
        Filestream.ReadBuffer(mainform.Devices[i].Gobo2RotOffValue,sizeof(mainform.Devices[i].Gobo2RotOffValue));
        Filestream.ReadBuffer(mainform.Devices[i].Gobo2RotRightminValue,sizeof(mainform.Devices[i].Gobo2RotRightminValue));
        Filestream.ReadBuffer(mainform.Devices[i].Gobo2RotRightValue,sizeof(mainform.Devices[i].Gobo2RotRightValue));
        Filestream.ReadBuffer(mainform.Devices[i].Gobo2RotChannel,sizeof(mainform.Devices[i].Gobo2RotChannel));

        if projektprogrammversionint>=461 then
        begin
          Filestream.ReadBuffer(mainform.Devices[i].PrismaSingleValue,sizeof(mainform.Devices[i].PrismaSingleValue));
          Filestream.ReadBuffer(mainform.Devices[i].PrismaTripleValue,sizeof(mainform.Devices[i].PrismaTripleValue));
          Filestream.ReadBuffer(mainform.Devices[i].PrismaRotOffValue,sizeof(mainform.Devices[i].PrismaRotOffValue));
          Filestream.ReadBuffer(mainform.Devices[i].PrismaRotLeftminValue,sizeof(mainform.Devices[i].PrismaRotLeftminValue));
          Filestream.ReadBuffer(mainform.Devices[i].PrismaRotLeftmaxValue,sizeof(mainform.Devices[i].PrismaRotLeftmaxValue));
          Filestream.ReadBuffer(mainform.Devices[i].PrismaRotRightminValue,sizeof(mainform.Devices[i].PrismaRotRightminValue));
          Filestream.ReadBuffer(mainform.Devices[i].PrismaRotRightmaxValue,sizeof(mainform.Devices[i].PrismaRotRightmaxValue));
          Filestream.ReadBuffer(mainform.Devices[i].PrismaRotChannel,sizeof(mainform.Devices[i].PrismaRotChannel));
          Filestream.ReadBuffer(mainform.Devices[i].IrisCloseValue,sizeof(mainform.Devices[i].IrisCloseValue));
          Filestream.ReadBuffer(mainform.Devices[i].IrisOpenValue,sizeof(mainform.Devices[i].IrisOpenValue));
          Filestream.ReadBuffer(mainform.Devices[i].IrisMinValue,sizeof(mainform.Devices[i].IrisMinValue));
          Filestream.ReadBuffer(mainform.Devices[i].IrisMaxValue,sizeof(mainform.Devices[i].IrisMaxValue));
        end;
      end else
      begin
        mainform.Devices[i].ShutterOpenValue:=255;
        mainform.Devices[i].ShutterCloseValue:=0;
        mainform.Devices[i].ShutterChannel:='SHUTTER';
        mainform.Devices[i].StrobeOffValue:=0;
        mainform.Devices[i].StrobeMinValue:=0;
        mainform.Devices[i].StrobeMaxValue:=0;
        mainform.Devices[i].StrobeChannel:='NOTDEFINED';
        mainform.Devices[i].DimmerOffValue:=0;
        mainform.Devices[i].DimmerMaxValue:=255;
        mainform.Devices[i].FogOffValue:=0;
        mainform.Devices[i].FogMaxValue:=255;
        mainform.Devices[i].Gobo1RotLeftminValue:=0;
        mainform.Devices[i].Gobo1RotLeftValue:=0;
        mainform.Devices[i].Gobo1RotOffValue:=127;
        mainform.Devices[i].Gobo1RotRightminValue:=255;
        mainform.Devices[i].Gobo1RotRightValue:=255;
        mainform.Devices[i].Gobo1RotChannel:='GOBO1ROT';
        mainform.Devices[i].Gobo2RotLeftminValue:=0;
        mainform.Devices[i].Gobo2RotLeftValue:=0;
        mainform.Devices[i].Gobo2RotOffValue:=127;
        mainform.Devices[i].Gobo2RotRightminValue:=255;
        mainform.Devices[i].Gobo2RotRightValue:=255;
        mainform.Devices[i].Gobo2RotChannel:='GOBO2ROT';

        mainform.Devices[i].PrismaSingleValue:=0;
        mainform.Devices[i].PrismaTripleValue:=127;
        mainform.Devices[i].PrismaRotOffValue:=127;
        mainform.Devices[i].PrismaRotLeftminValue:=0;
        mainform.Devices[i].PrismaRotLeftmaxValue:=126;
        mainform.Devices[i].PrismaRotRightminValue:=128;
        mainform.Devices[i].PrismaRotRightmaxValue:=255;
        mainform.Devices[i].PrismaRotChannel:='PRISMAROT';
        mainform.Devices[i].IrisCloseValue:=0;
        mainform.Devices[i].IrisOpenValue:=255;
        mainform.Devices[i].IrisMinValue:=0;
        mainform.Devices[i].IrisMaxValue:=255;
      end;

      if projektprogrammversionint>=426 then
      begin
        Filestream.ReadBuffer(mainform.Devices[i].UseChannelBasedPower,sizeof(mainform.Devices[i].UseChannelBasedPower));
        if projektprogrammversionint<475 then
          Filestream.ReadBuffer(mainform.Devices[i].AlwaysOn,sizeof(mainform.Devices[i].AlwaysOn));
        Filestream.ReadBuffer(mainform.Devices[i].ChannelForPower,sizeof(mainform.Devices[i].ChannelForPower));
        Filestream.ReadBuffer(mainform.Devices[i].Power,sizeof(mainform.Devices[i].Power));
        Filestream.ReadBuffer(mainform.Devices[i].Phase,sizeof(mainform.Devices[i].Phase));
        if projektprogrammversionint>=475 then
        begin
          Filestream.ReadBuffer(mainform.Devices[i].CalcPowerAboveValue,sizeof(mainform.Devices[i].CalcPowerAboveValue));
          Filestream.ReadBuffer(mainform.Devices[i].ContinuousPower,sizeof(mainform.Devices[i].ContinuousPower));
          Filestream.ReadBuffer(mainform.Devices[i].UseFullPowerOnChannelvalue,sizeof(mainform.Devices[i].UseFullPowerOnChannelvalue));
        end else
        begin
          mainform.Devices[i].CalcPowerAboveValue:=0;
          mainform.Devices[i].UseFullPowerOnChannelvalue:=false;
          if mainform.Devices[i].AlwaysOn then
          begin
            mainform.Devices[i].ContinuousPower:=mainform.Devices[i].Power;
            mainform.Devices[i].Power:=0;
            mainform.Devices[i].UseChannelBasedPower:=false;
          end else
            mainform.Devices[i].ContinuousPower:=0;
        end;
        if projektprogrammversionint>=479 then
        begin
          Filestream.ReadBuffer(mainform.Devices[i].MatrixDeviceLevel,sizeof(mainform.Devices[i].MatrixDeviceLevel));
          Filestream.ReadBuffer(mainform.Devices[i].MatrixMainDeviceID,sizeof(mainform.Devices[i].MatrixMainDeviceID));
          Filestream.ReadBuffer(mainform.Devices[i].MatrixOrderType,sizeof(mainform.Devices[i].MatrixOrderType));
          Filestream.ReadBuffer(mainform.Devices[i].MatrixXCount,sizeof(mainform.Devices[i].MatrixXCount));
          Filestream.ReadBuffer(mainform.Devices[i].MatrixYCount,sizeof(mainform.Devices[i].MatrixYCount));
          Filestream.ReadBuffer(mainform.Devices[i].MatrixXPosition,sizeof(mainform.Devices[i].MatrixXPosition));
          Filestream.ReadBuffer(mainform.Devices[i].MatrixYPosition,sizeof(mainform.Devices[i].MatrixYPosition));
        end;
      end;

  	  Filestream.ReadBuffer(Count2,sizeof(Count2));
      setlength(mainform.Devices[i].KanalMinValue,Count2);
      setlength(mainform.Devices[i].KanalMaxValue,Count2);
      setlength(mainform.Devices[i].kanaltyp,Count2);
      setlength(mainform.Devices[i].kanalname,Count2);
      setlength(mainform.Devices[i].kanalfade,Count2);
      setlength(mainform.Devices[i].kanaldimmcurve,Count2);
      setlength(mainform.Devices[i].kanalabsolutedimmcurve,Count2);
      for j:=0 to Count2-1 do
      begin
     	  Filestream.ReadBuffer(mainform.Devices[i].KanalMinValue[j],sizeof(mainform.Devices[i].KanalMinValue[j]));
     	  Filestream.ReadBuffer(mainform.Devices[i].KanalMaxValue[j],sizeof(mainform.Devices[i].KanalMaxValue[j]));
     	  Filestream.ReadBuffer(mainform.Devices[i].kanaltyp[j],sizeof(mainform.Devices[i].kanaltyp[j]));
     	  Filestream.ReadBuffer(mainform.Devices[i].kanalname[j],sizeof(mainform.Devices[i].kanalname[j]));
        if projektprogrammversionint>=403 then
       	  Filestream.ReadBuffer(mainform.Devices[i].kanalfade[j],sizeof(mainform.Devices[i].kanalfade[j]));
     	  Filestream.ReadBuffer(mainform.Devices[i].kanaldimmcurve[j],sizeof(mainform.Devices[i].kanaldimmcurve[j]));
     	  Filestream.ReadBuffer(mainform.Devices[i].kanalabsolutedimmcurve[j],sizeof(mainform.Devices[i].kanalabsolutedimmcurve[j]));
        channel_dimmcurve[mainform.Devices[i].Startaddress+j]:=mainform.Devices[i].kanaldimmcurve[j];
        channel_absolutedimmcurve[mainform.Devices[i].Startaddress+j]:=mainform.Devices[i].kanalabsolutedimmcurve[j];
      end;
    end;
      // Ende Geräte
    // Presets öffnen
    if not startingup then
    begin
      inprogress.filename.Caption:=_('Lese Daten ein... Presets');
      inprogress.Refresh;
    end else
    begin
      SplashCaptioninfo(_('Lese Daten ein...Presets'));
      RefreshSplashText;
    end;

	  Filestream.ReadBuffer(Count,sizeof(Count));
    setlength(mainform.DevicePresets,Count);
    for i:=0 to Count-1 do
    begin
   	  Filestream.ReadBuffer(mainform.DevicePresets[i].ID,sizeof(mainform.DevicePresets[i].ID));
   	  Filestream.ReadBuffer(mainform.DevicePresets[i].Name,sizeof(mainform.DevicePresets[i].Name));
   	  Filestream.ReadBuffer(mainform.DevicePresets[i].Beschreibung,sizeof(mainform.DevicePresets[i].Beschreibung));
      if projektprogrammversionint>=439 then
        Filestream.ReadBuffer(DevicePresets[i].Category,sizeof(DevicePresets[i].Category));

   	  Filestream.ReadBuffer(count2,sizeof(count2));
      setlength(mainform.DevicePresets[i].ChanTyp,count2);
      setlength(mainform.DevicePresets[i].ChanValue,count2);
      setlength(mainform.DevicePresets[i].ChanActive,count2);
      for k:=0 to count2-1 do
      begin
     	  Filestream.ReadBuffer(mainform.DevicePresets[i].ChanTyp[k],sizeof(mainform.DevicePresets[i].ChanTyp[k]));
     	  Filestream.ReadBuffer(mainform.DevicePresets[i].ChanValue[k],sizeof(mainform.DevicePresets[i].ChanValue[k]));
     	  Filestream.ReadBuffer(mainform.DevicePresets[i].ChanActive[k],sizeof(mainform.DevicePresets[i].ChanActive[k]));
      end;

      if projektprogrammversionint>=462 then
      begin
        Filestream.ReadBuffer(mainform.DevicePresets[i].UseNewInterface,sizeof(mainform.DevicePresets[i].UseNewInterface));
        Filestream.ReadBuffer(mainform.DevicePresets[i].Color,sizeof(mainform.DevicePresets[i].Color));
        Filestream.ReadBuffer(mainform.DevicePresets[i].Shutter,sizeof(mainform.DevicePresets[i].Shutter));
        Filestream.ReadBuffer(mainform.DevicePresets[i].Dimmer,sizeof(mainform.DevicePresets[i].Dimmer));
        Filestream.ReadBuffer(mainform.DevicePresets[i].Iris,sizeof(mainform.DevicePresets[i].Iris));
        Filestream.ReadBuffer(mainform.DevicePresets[i].Focus,sizeof(mainform.DevicePresets[i].Focus));
        Filestream.ReadBuffer(mainform.DevicePresets[i].PrismaRot,sizeof(mainform.DevicePresets[i].PrismaRot));
        Filestream.ReadBuffer(mainform.DevicePresets[i].PrismaEnabled,sizeof(mainform.DevicePresets[i].PrismaEnabled));
        Filestream.ReadBuffer(mainform.DevicePresets[i].Strobe,sizeof(mainform.DevicePresets[i].Strobe));
        Filestream.ReadBuffer(mainform.DevicePresets[i].Pan,sizeof(mainform.DevicePresets[i].Pan));
        Filestream.ReadBuffer(mainform.DevicePresets[i].Tilt,sizeof(mainform.DevicePresets[i].Tilt));
        Filestream.ReadBuffer(mainform.DevicePresets[i].PanFine,sizeof(mainform.DevicePresets[i].PanFine));
        Filestream.ReadBuffer(mainform.DevicePresets[i].TiltFine,sizeof(mainform.DevicePresets[i].TiltFine));
        Filestream.ReadBuffer(mainform.DevicePresets[i].Gobo,sizeof(mainform.DevicePresets[i].Gobo));
        Filestream.ReadBuffer(mainform.DevicePresets[i].GoboRot1,sizeof(mainform.DevicePresets[i].GoboRot1));
        Filestream.ReadBuffer(mainform.DevicePresets[i].GoboRot2,sizeof(mainform.DevicePresets[i].GoboRot2));
      end else
      begin
        mainform.DevicePresets[i].UseNewInterface:=false;
      end;
    end;
// Ende Presets
// Geräteszenen öffnen
	if not startingup then
  begin
	  inprogress.filename.Caption:=_('Lese Daten ein... Geräteszenen');
    inprogress.ProgressBar1.Position:=59;
	 	inprogress.Refresh;
  end else
  begin
    SplashCaptioninfo(_('Lese Daten ein...Geräteszenen'));
    SplashProgress(1, 84, 100);
    RefreshSplashText;
  end;

   	  Filestream.ReadBuffer(Count,sizeof(Count));
      setlength(DeviceScenes,Count);
      for i:=0 to length(DeviceScenes)-1 do
    	begin
        Filestream.ReadBuffer(DeviceScenes[i].ID,sizeof(DeviceScenes[i].ID));
        Filestream.ReadBuffer(DeviceScenes[i].Name,sizeof(DeviceScenes[i].Name));
        Filestream.ReadBuffer(DeviceScenes[i].Beschreibung,sizeof(DeviceScenes[i].Beschreibung));
        Filestream.ReadBuffer(DeviceScenes[i].Fadetime,sizeof(DeviceScenes[i].Fadetime));
        if projektprogrammversionint>=439 then
          Filestream.ReadBuffer(DeviceScenes[i].Category,sizeof(DeviceScenes[i].Category));

     	  Filestream.ReadBuffer(Count2,sizeof(Count2));
        setlength(DeviceScenes[i].Devices,Count2);
        for j:=0 to Count2-1 do
        begin
          // einzelne Geräte der aktuellen Szene durchlaufen
          Filestream.ReadBuffer(DeviceScenes[i].Devices[j].ID,sizeof(DeviceScenes[i].Devices[j].ID));
       	  Filestream.ReadBuffer(Count3,sizeof(Count3));
          setlength(DeviceScenes[i].Devices[j].ChanActive,Count3);
          for k:=0 to Count3-1 do
            Filestream.ReadBuffer(DeviceScenes[i].Devices[j].ChanActive[k],sizeof(DeviceScenes[i].Devices[j].ChanActive[k]));

       	  Filestream.ReadBuffer(Count3,sizeof(Count3));
          setlength(DeviceScenes[i].Devices[j].ChanValue,Count3);
          for k:=0 to Count3-1 do
            Filestream.ReadBuffer(DeviceScenes[i].Devices[j].ChanValue[k],sizeof(DeviceScenes[i].Devices[j].ChanValue[k]));

          if projektprogrammversionint>=433 then
          begin
            Filestream.ReadBuffer(Count3,sizeof(Count3));
            setlength(DeviceScenes[i].Devices[j].ChanActiveRandom,Count3);
            for k:=0 to Count3-1 do
              Filestream.ReadBuffer(DeviceScenes[i].Devices[j].ChanActiveRandom[k],sizeof(DeviceScenes[i].Devices[j].ChanActiveRandom[k]));

            Filestream.ReadBuffer(Count3,sizeof(Count3));
            setlength(DeviceScenes[i].Devices[j].ChanValueRandom,Count3);
            for k:=0 to Count3-1 do
              Filestream.ReadBuffer(DeviceScenes[i].Devices[j].ChanValueRandom[k],sizeof(DeviceScenes[i].Devices[j].ChanValueRandom[k]));
          end else
          begin
            setlength(DeviceScenes[i].Devices[j].ChanActiveRandom,Count3);
            setlength(DeviceScenes[i].Devices[j].ChanValueRandom,Count3);
          end;

          if projektprogrammversionint>=408 then
         	begin
            Filestream.ReadBuffer(Count3,sizeof(Count3));
            setlength(DeviceScenes[i].Devices[j].ChanDelay,Count3);
            for k:=0 to Count3-1 do
              Filestream.ReadBuffer(DeviceScenes[i].Devices[j].ChanDelay[k],sizeof(DeviceScenes[i].Devices[j].ChanDelay[k]));

         	  Filestream.ReadBuffer(Count3,sizeof(Count3));
            setlength(DeviceScenes[i].Devices[j].ChanFadetime,Count3);
            for k:=0 to Count3-1 do
              Filestream.ReadBuffer(DeviceScenes[i].Devices[j].ChanFadetime[k],sizeof(DeviceScenes[i].Devices[j].ChanFadetime[k]));
          end else
          begin
            setlength(DeviceScenes[i].Devices[j].ChanDelay,Count3);
            setlength(DeviceScenes[i].Devices[j].ChanFadetime,Count3);
            for k:=0 to Count3-1 do
              DeviceScenes[i].Devices[j].ChanDelay[k]:=0;
            for k:=0 to Count3-1 do
              DeviceScenes[i].Devices[j].ChanFadetime[k]:=-1;
          end;
        end;
        if projektprogrammversionint>=430 then
        begin
          Filestream.ReadBuffer(Count,sizeof(Count));
          setlength(DeviceScenes[i].Befehle, Count);
          setlength(DeviceScenes[i].Befehlswerte, Count);
          for l:=0 to Count-1 do
          begin
            Filestream.ReadBuffer(DeviceScenes[i].Befehle[l].ID,sizeof(DeviceScenes[i].Befehle[l].ID));
            Filestream.ReadBuffer(DeviceScenes[i].Befehle[l].Typ,sizeof(DeviceScenes[i].Befehle[l].Typ));
            Filestream.ReadBuffer(DeviceScenes[i].Befehle[l].Name,sizeof(DeviceScenes[i].Befehle[l].Name));
            Filestream.ReadBuffer(DeviceScenes[i].Befehle[l].Beschreibung,sizeof(DeviceScenes[i].Befehle[l].Beschreibung));
            Filestream.ReadBuffer(DeviceScenes[i].Befehle[l].OnValue,sizeof(DeviceScenes[i].Befehle[l].OnValue));
            if projektprogrammversionint>=456 then
              Filestream.ReadBuffer(DeviceScenes[i].Befehle[l].SwitchValue,sizeof(DeviceScenes[i].Befehle[l].SwitchValue))
            else
              DeviceScenes[i].Befehle[l].SwitchValue:=DeviceScenes[i].Befehle[l].OnValue;
            if projektprogrammversionint>=462 then
              Filestream.ReadBuffer(DeviceScenes[i].Befehle[l].InvertSwitchValue,sizeof(DeviceScenes[i].Befehle[l].InvertSwitchValue));
            Filestream.ReadBuffer(DeviceScenes[i].Befehle[l].OffValue,sizeof(DeviceScenes[i].Befehle[l].OffValue));
            if projektprogrammversionint>=457 then
              Filestream.ReadBuffer(DeviceScenes[i].Befehle[l].ScaleValue,sizeof(DeviceScenes[i].Befehle[l].ScaleValue));

            Filestream.ReadBuffer(Count2,sizeof(Count2));
            setlength(DeviceScenes[i].Befehle[l].ArgInteger, Count2);
            for m:=0 to Count2-1 do
              Filestream.ReadBuffer(DeviceScenes[i].Befehle[l].ArgInteger[m],sizeof(DeviceScenes[i].Befehle[l].ArgInteger[m]));
            Filestream.ReadBuffer(Count2,sizeof(Count2));
            setlength(DeviceScenes[i].Befehle[l].ArgString, Count2);
            for m:=0 to Count2-1 do
              Filestream.ReadBuffer(DeviceScenes[i].Befehle[l].ArgString[m],sizeof(DeviceScenes[i].Befehle[l].ArgString[m]));
            Filestream.ReadBuffer(Count2,sizeof(Count2));
            setlength(DeviceScenes[i].Befehle[l].ArgGUID, Count2);
            for m:=0 to Count2-1 do
              Filestream.ReadBuffer(DeviceScenes[i].Befehle[l].ArgGUID[m],sizeof(DeviceScenes[i].Befehle[l].ArgGUID[m]));


            Filestream.ReadBuffer(Count2,sizeof(Count2));
            setlength(DeviceScenes[i].Befehlswerte[l].ChanActive, Count2);
            setlength(DeviceScenes[i].Befehlswerte[l].ChanValue, Count2);
            setlength(DeviceScenes[i].Befehlswerte[l].ChanActiveRandom, Count2);
            setlength(DeviceScenes[i].Befehlswerte[l].ChanValueRandom, Count2);
            setlength(DeviceScenes[i].Befehlswerte[l].ChanDelay, Count2);
            setlength(DeviceScenes[i].Befehlswerte[l].ChanFadetime, Count2);
            for m:=0 to Count2-1 do
            begin
              Filestream.ReadBuffer(DeviceScenes[i].Befehlswerte[l].ChanActive[m],sizeof(DeviceScenes[i].Befehlswerte[l].ChanActive[m]));
              Filestream.ReadBuffer(DeviceScenes[i].Befehlswerte[l].ChanValue[m],sizeof(DeviceScenes[i].Befehlswerte[l].ChanValue[m]));
              Filestream.ReadBuffer(DeviceScenes[i].Befehlswerte[l].ChanActiveRandom[m],sizeof(DeviceScenes[i].Befehlswerte[l].ChanActiveRandom[m]));
              Filestream.ReadBuffer(DeviceScenes[i].Befehlswerte[l].ChanValueRandom[m],sizeof(DeviceScenes[i].Befehlswerte[l].ChanValueRandom[m]));
              Filestream.ReadBuffer(DeviceScenes[i].Befehlswerte[l].ChanDelay[m],sizeof(DeviceScenes[i].Befehlswerte[l].ChanDelay[m]));
              Filestream.ReadBuffer(DeviceScenes[i].Befehlswerte[l].ChanFadetime[m],sizeof(DeviceScenes[i].Befehlswerte[l].ChanFadetime[m]));
            end;
          end;
        end;
      end;
// Ende Geräteszenen
// Gruppen öffnen
  if not startingup then
  begin
	  inprogress.filename.Caption:=_('Lese Daten... Gerätegruppen');
  	inprogress.Refresh;
  end else
  begin
    SplashCaptioninfo(_('Lese Daten ein...Gerätegruppen'));
    RefreshSplashText;
  end;
	  Filestream.ReadBuffer(Count,sizeof(Count));
    setlength(mainform.DeviceGroups,Count);
    for i:=0 to Count-1 do
    begin
      if projektprogrammversionint>=425 then
     	  Filestream.ReadBuffer(mainform.DeviceGroups[i].Active,sizeof(mainform.DeviceGroups[i].Active))
      else
        mainform.DeviceGroups[i].Active:=true;
   	  Filestream.ReadBuffer(mainform.DeviceGroups[i].ID,sizeof(mainform.DeviceGroups[i].ID));
   	  Filestream.ReadBuffer(mainform.DeviceGroups[i].Name,sizeof(mainform.DeviceGroups[i].Name));
   	  Filestream.ReadBuffer(mainform.DeviceGroups[i].Beschreibung,sizeof(mainform.DeviceGroups[i].Beschreibung));
  	  Filestream.ReadBuffer(Count2,sizeof(Count2));
      setlength(mainform.DeviceGroups[i].IDs,Count2);
      setlength(mainform.DeviceGroups[i].IDActive,Count2);
      setlength(mainform.DeviceGroups[i].Delays,Count2);
      for k:=0 to length(mainform.DeviceGroups[i].IDs)-1 do
      begin
     	  Filestream.ReadBuffer(mainform.DeviceGroups[i].IDs[k],sizeof(mainform.DeviceGroups[i].IDs[k]));
        if projektprogrammversionint>=425 then
       	  Filestream.ReadBuffer(mainform.DeviceGroups[i].IDActive[k],sizeof(mainform.DeviceGroups[i].IDActive[k]))
        else
       	  mainform.DeviceGroups[i].IDActive[k]:=true;
        if projektprogrammversionint>=409 then
       	  Filestream.ReadBuffer(mainform.DeviceGroups[i].Delays[k],sizeof(mainform.DeviceGroups[i].Delays[k]));
      end;
      if projektprogrammversionint>=409 then
     	begin
        Filestream.ReadBuffer(mainform.DeviceGroups[i].MasterDevice,sizeof(mainform.DeviceGroups[i].MasterDevice));
    	  Filestream.ReadBuffer(mainform.DeviceGroups[i].UseMaster,sizeof(mainform.DeviceGroups[i].UseMaster));
    	  Filestream.ReadBuffer(mainform.DeviceGroups[i].FanMode,sizeof(mainform.DeviceGroups[i].FanMode));
        if projektprogrammversionint>=410 then
       	begin
      	  Filestream.ReadBuffer(mainform.DeviceGroups[i].FanMorph,sizeof(mainform.DeviceGroups[i].FanMorph));
        end;
    	  Filestream.ReadBuffer(mainform.DeviceGroups[i].Delay,sizeof(mainform.DeviceGroups[i].Delay));
      end;
      setlength(mainform.DeviceGroups[i].HasChanType,length(DeviceChannelNames));
      geraetesteuerung.CheckDeviceGroupIntersection(i, mainform.DeviceGroups[i].HasChanType);
    end;
// Ende Gruppen
// Softpatch öffnen
	if not startingup then
  begin
	  inprogress.filename.Caption:=_('Lese Daten ein... Softpatch');
  	inprogress.Refresh;
  end else
  begin
    SplashCaptioninfo(_('Lese Daten ein...Softpatch'));
    RefreshSplashText;
  end;
    Filestream.ReadBuffer(Count,sizeof(Count));
    setlength(softpatch,Count);
    for i:=0 to Count-1 do
    begin
   	  Filestream.ReadBuffer(mainform.softpatch[i].Channel,sizeof(mainform.softpatch[i].Channel));
      Filestream.ReadBuffer(Count2,sizeof(Count2));
      setlength(softpatch[i].RouteToInputChan,Count2);
      for k:=0 to Count2-1 do
      begin
     	  Filestream.ReadBuffer(mainform.softpatch[i].RouteToInputChan[k],sizeof(mainform.softpatch[i].RouteToInputChan[k]));
      end;
    end;

    if projektprogrammversionint>=414 then
    begin
      Filestream.ReadBuffer(Count,sizeof(Count));
      setlength(softpatch2,Count);
      for i:=0 to Count-1 do
      begin
        Filestream.ReadBuffer(mainform.softpatch2[i].Channel2,sizeof(mainform.softpatch2[i].Channel2));
        Filestream.ReadBuffer(Count2,sizeof(Count2));
        setlength(mainform.softpatch2[i].RouteToPC_DIMMERChan,Count2);
        for k:=0 to Count2-1 do
        begin
          Filestream.ReadBuffer(mainform.softpatch2[i].RouteToPC_DIMMERChan[k],sizeof(mainform.softpatch2[i].RouteToPC_DIMMERChan[k]));
        end;
      end;
    end else
    begin
      setlength(softpatch2,0);
    end;
// Ende Softpatch
// Effekte Öffnen
	if not startingup then
  begin
	  inprogress.filename.Caption:=_('Lese Daten ein... Effekte');
	 	inprogress.Refresh;
  end else
  begin
    SplashCaptioninfo(_('Lese Daten ein... Effekte'));
    RefreshSplashText;
  end;
  
    Filestream.ReadBuffer(Count, sizeof(Count));
    setlength(Effektsequenzereffekte, Count);
    setlength(AktuellerEffekt, Count);
    for i:=0 to Count-1 do
    begin
      Filestream.ReadBuffer(Effektsequenzereffekte[i].ID,sizeof(Effektsequenzereffekte[i].ID));
      Filestream.ReadBuffer(Effektsequenzereffekte[i].Name,sizeof(Effektsequenzereffekte[i].Name));
      Filestream.ReadBuffer(Effektsequenzereffekte[i].Beschreibung,sizeof(Effektsequenzereffekte[i].Beschreibung));
      if projektprogrammversionint>=431 then
        Filestream.ReadBuffer(Effektsequenzereffekte[i].TabPosition,sizeof(Effektsequenzereffekte[i].TabPosition));
      Filestream.ReadBuffer(Effektsequenzereffekte[i].AnzahlderDurchlaufe,sizeof(Effektsequenzereffekte[i].AnzahlderDurchlaufe));
      Filestream.ReadBuffer(Effektsequenzereffekte[i].modus,sizeof(Effektsequenzereffekte[i].modus));
      Filestream.ReadBuffer(Effektsequenzereffekte[i].Repeating,sizeof(Effektsequenzereffekte[i].Repeating));
      Filestream.ReadBuffer(Effektsequenzereffekte[i].intensitaet,sizeof(Effektsequenzereffekte[i].intensitaet));
      Filestream.ReadBuffer(Effektsequenzereffekte[i].speed,sizeof(Effektsequenzereffekte[i].speed));
      Filestream.ReadBuffer(Effektsequenzereffekte[i].startwithstepone,sizeof(Effektsequenzereffekte[i].startwithstepone));
      if projektprogrammversionint>=442 then
        Filestream.ReadBuffer(Effektsequenzereffekte[i].blackoutonstop,sizeof(Effektsequenzereffekte[i].blackoutonstop));
      if projektprogrammversionint>=465 then
      begin
        Filestream.ReadBuffer(Effektsequenzereffekte[i].Startscene,sizeof(Effektsequenzereffekte[i].Startscene));
        Filestream.ReadBuffer(Effektsequenzereffekte[i].Stopscene,sizeof(Effektsequenzereffekte[i].Stopscene));
      end;

      Filestream.ReadBuffer(Count2, sizeof(Count2));
      setlength(Effektsequenzereffekte[i].effektschritte,Count2);
      for k:=0 to Count2-1 do
      begin
        Filestream.ReadBuffer(Count3, sizeof(Count3));
        setlength(Effektsequenzereffekte[i].effektschritte[k].IDs,Count3);
        for l:=0 to Count3-1 do
          Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].IDs[l],sizeof(Effektsequenzereffekte[i].effektschritte[k].IDs[l]));
        Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].Typ,sizeof(Effektsequenzereffekte[i].effektschritte[k].Typ));
        Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].Name,sizeof(Effektsequenzereffekte[i].effektschritte[k].Name));
        Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].Beschreibung,sizeof(Effektsequenzereffekte[i].effektschritte[k].Beschreibung));
        Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].einblendzeit,sizeof(Effektsequenzereffekte[i].effektschritte[k].einblendzeit));
        Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].wartezeit,sizeof(Effektsequenzereffekte[i].effektschritte[k].wartezeit));
        Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].AnzahlBeats,sizeof(Effektsequenzereffekte[i].effektschritte[k].ANzahlBeats));
        Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].DeactivateLastScene,sizeof(Effektsequenzereffekte[i].effektschritte[k].DeactivateLastScene));

        Filestream.ReadBuffer(Count3,sizeof(Count3));
        setlength(Effektsequenzereffekte[i].effektschritte[k].Devices,Count3);
        for l:=0 to Count3-1 do
        begin
          Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ID,sizeof(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ID));
          Filestream.ReadBuffer(Count4,sizeof(Count4));
          setlength(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanActive,Count4);
          setlength(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanValue,Count4);
          setlength(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanActiveRandom,Count4);
          setlength(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanValueRandom,Count4);
          setlength(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanDelay,Count4);
          setlength(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanFadetime,Count4);
          for m:=0 to Count4-1 do
          begin
            Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanActive[m],sizeof(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanActive[m]));
            Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanValue[m],sizeof(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanValue[m]));
            if projektprogrammversionint>=433 then
            begin
              Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanActiveRandom[m],sizeof(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanActiveRandom[m]));
              Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanValueRandom[m],sizeof(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanValueRandom[m]));
            end;
            if projektprogrammversionint>=408 then
           	begin
              Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanDelay[m],sizeof(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanDelay[m]));
              Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanFadetime[m],sizeof(Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanFadetime[m]));
            end else
            begin
              Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanDelay[m]:=0;
              Effektsequenzereffekte[i].effektschritte[k].Devices[l].ChanFadetime[m]:=-1;
            end;
          end;
        end;
        if projektprogrammversionint>=430 then
        begin
          Filestream.ReadBuffer(Count3,sizeof(Count3));
          setlength(Effektsequenzereffekte[i].effektschritte[k].Befehle, Count3);
          setlength(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte, Count3);
          for l:=0 to Count3-1 do
          begin
            Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].ID,sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].ID));
            Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].Typ,sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].Typ));
            Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].Name,sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].Name));
            Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].Beschreibung,sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].Beschreibung));
            Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].OnValue,sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].OnValue));
            if projektprogrammversionint>=456 then
              Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].SwitchValue,sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].SwitchValue))
            else
              Effektsequenzereffekte[i].effektschritte[k].Befehle[l].SwitchValue:=Effektsequenzereffekte[i].effektschritte[k].Befehle[l].OnValue;
            if projektprogrammversionint>=462 then
              Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].InvertSwitchValue,sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].InvertSwitchValue));
            Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].OffValue,sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].OffValue));
            if projektprogrammversionint>=457 then
              Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].ScaleValue,sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].ScaleValue));

            Filestream.ReadBuffer(Count4,sizeof(Count4));
            setlength(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].ArgInteger, Count4);
            for m:=0 to Count4-1 do
              Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].ArgInteger[m],sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].ArgInteger[m]));
            Filestream.ReadBuffer(Count4,sizeof(Count4));
            setlength(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].ArgString, Count4);
            for m:=0 to Count4-1 do
              Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].ArgString[m],sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].ArgString[m]));
            Filestream.ReadBuffer(Count4,sizeof(Count4));
            setlength(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].ArgGUID, Count4);
            for m:=0 to Count4-1 do
              Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].ArgGUID[m],sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehle[l].ArgGUID[m]));


            Filestream.ReadBuffer(Count4,sizeof(Count4));
            setlength(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanActive, Count4);
            setlength(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanValue, Count4);
            setlength(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanActiveRandom, Count4);
            setlength(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanValueRandom, Count4);
            setlength(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanDelay, Count4);
            setlength(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanFadetime, Count4);
            for m:=0 to Count4-1 do
            begin
              Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanActive[m],sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanActive[m]));
              Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanValue[m],sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanValue[m]));
              Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanActiveRandom[m],sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanActiveRandom[m]));
              Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanValueRandom[m],sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanValueRandom[m]));
              Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanDelay[m],sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanDelay[m]));
              Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanFadetime[m],sizeof(Effektsequenzereffekte[i].effektschritte[k].Befehlswerte[l].ChanFadetime[m]));
            end;
          end;
        end;
        Filestream.ReadBuffer(Effektsequenzereffekte[i].effektschritte[k].ActivateTimecontrol,sizeof(Effektsequenzereffekte[i].effektschritte[k].ActivateTimecontrol));
      end;
    end;
    if projektprogrammversionint>=437 then
    begin
      Filestream.ReadBuffer(Count,sizeof(Count));
      setlength(EffektsequenzerTabs,Count);
      for i:=0 to Count-1 do
        Filestream.ReadBuffer(EffektsequenzerTabs[i],sizeof(EffektsequenzerTabs[i]));

      if length(EffektsequenzerTabs)=0 then
        setlength(EffektsequenzerTabs,1);
    end;

  // Bugfix für Fehlerhafte Array-Länge bei Gruppeneinträgen in Direktszenen von Effektschritten von alten Projekten
  for i:=0 to length(Effektsequenzereffekte)-1 do
  begin
    for j:=0 to length(Effektsequenzereffekte[i].Effektschritte)-1 do
    begin
      for k:=0 to length(Effektsequenzereffekte[i].Effektschritte[j].Devices)-1 do
      begin
        if geraetesteuerung.GetGroupPositionInGroupArray(Effektsequenzereffekte[i].Effektschritte[j].Devices[k].ID)>-1 then
        begin
          setlength(Effektsequenzereffekte[i].Effektschritte[j].Devices[k].ChanActive, length(mainform.DeviceChannelNames));
          setlength(Effektsequenzereffekte[i].Effektschritte[j].Devices[k].ChanActiveRandom, length(mainform.DeviceChannelNames));
          setlength(Effektsequenzereffekte[i].Effektschritte[j].Devices[k].ChanValue, length(mainform.DeviceChannelNames));
          setlength(Effektsequenzereffekte[i].Effektschritte[j].Devices[k].ChanValueRandom, length(mainform.DeviceChannelNames));
          setlength(Effektsequenzereffekte[i].Effektschritte[j].Devices[k].ChanDelay, length(mainform.DeviceChannelNames));
          setlength(Effektsequenzereffekte[i].Effektschritte[j].Devices[k].ChanFadetime, length(mainform.DeviceChannelNames));
        end;
      end;
    end;
  end;
// Ende Effekte Öffnen
// Bühnenansicht öffnen
	if not startingup then
  begin
	  inprogress.filename.Caption:=_('Lese Daten ein... Bühnenansicht');
    inprogress.ProgressBar1.Position:=62;
	 	inprogress.Refresh;
  end else
  begin
    SplashCaptioninfo(_('Lese Daten ein... Bühnenansicht'));
    SplashProgress(1, 85, 100);
    RefreshSplashText;
  end;

    FileStream.ReadBuffer(mainform.buehnenansichtsetup,sizeof(mainform.buehnenansichtsetup));
    if projektprogrammversionint<424 then
    begin
      setlength(buehnenansicht_background, 1);
      buehnenansicht_background[0]:=buehnenansichtsetup.Buehnenansicht_background;
    end;

    if projektprogrammversionint>=422 then
    begin
      FileStream.ReadBuffer(count,sizeof(count));

      setlength(buehnenansicht_background, count);

      grafischebuehnenansicht.BankSelect.Clear;
      grafischebuehnenansicht.BankCopy.Clear;
      for i:=0 to count-1 do
      begin
        FileStream.ReadBuffer(text, sizeof(text));

        if projektprogrammversionint>=424 then
          FileStream.ReadBuffer(buehnenansicht_background[i], sizeof(buehnenansicht_background[i]));
        grafischebuehnenansicht.BankSelect.Items.Add(text);
        grafischebuehnenansicht.BankCopy.Items.Add(text);
      end;
      mainform.BankSelect.Items:=grafischebuehnenansicht.BankSelect.Items;
      mainform.BankSelect.Itemindex:=grafischebuehnenansicht.BankSelect.Itemindex;
      mainform.BankCopy.Items:=grafischebuehnenansicht.BankCopy.Items;
      mainform.BankCopy.Itemindex:=grafischebuehnenansicht.BankCopy.Itemindex;
    end;

    FileStream.ReadBuffer(count,sizeof(count));
		setlength(mainform.buehnenansichtdevices,count);
    for i:=0 to count-1 do
    begin
    	FileStream.ReadBuffer(mainform.buehnenansichtdevices[i].channel,sizeof(mainform.buehnenansichtdevices[i].channel));
    	FileStream.ReadBuffer(mainform.buehnenansichtdevices[i].color,sizeof(mainform.buehnenansichtdevices[i].color));
    	FileStream.ReadBuffer(mainform.buehnenansichtdevices[i].picture,sizeof(mainform.buehnenansichtdevices[i].picture));

      // Bildadresse aktualisieren
      mainform.buehnenansichtdevices[i].picture:=SearchFileBeneathProject(mainform.buehnenansichtdevices[i].picture);

      FileStream.ReadBuffer(mainform.buehnenansichtdevices[i].picturesize,sizeof(mainform.buehnenansichtdevices[i].picturesize));
      if projektprogrammversionint<=433 then
        mainform.buehnenansichtdevices[i].picturesize:=mainform.buehnenansichtdevices[i].picturesize*16;

      if projektprogrammversionint>=480 then
        FileStream.ReadBuffer(mainform.buehnenansichtdevices[i].pictureangle,sizeof(mainform.buehnenansichtdevices[i].pictureangle))
      else
      begin
        FileStream.ReadBuffer(b,sizeof(b));
        case b of
          0: mainform.buehnenansichtdevices[i].pictureangle:=0;
          1: mainform.buehnenansichtdevices[i].pictureangle:=90;
          2: mainform.buehnenansichtdevices[i].pictureangle:=180;
          3: mainform.buehnenansichtdevices[i].pictureangle:=270;
        end;
      end;
      FileStream.ReadBuffer(mainform.buehnenansichtdevices[i].picturefliphor,sizeof(mainform.buehnenansichtdevices[i].picturefliphor));
      FileStream.ReadBuffer(mainform.buehnenansichtdevices[i].pictureflipver,sizeof(mainform.buehnenansichtdevices[i].pictureflipver));
      FileStream.ReadBuffer(mainform.buehnenansichtdevices[i].pictureispng,sizeof(mainform.buehnenansichtdevices[i].pictureispng));
    	FileStream.ReadBuffer(mainform.buehnenansichtdevices[i].top,sizeof(mainform.buehnenansichtdevices[i].top));
    	FileStream.ReadBuffer(mainform.buehnenansichtdevices[i].left,sizeof(mainform.buehnenansichtdevices[i].left));
      if projektprogrammversionint>=422 then
      	FileStream.ReadBuffer(mainform.buehnenansichtdevices[i].bank,sizeof(mainform.buehnenansichtdevices[i].bank));
    end;
// Ende Bühnenansicht
// Submaster (alt - nur zur Kompatibilität) öffnen
    FileStream.ReadBuffer(count,sizeof(count));
    setlength(mainform.Submasterfader,count);
    for i:=0 to count-1 do
    begin
    	FileStream.ReadBuffer(mainform.Submasterfader[i],sizeof(mainform.Submasterfader[i]));
    end;
// Submaster Ende
// Desktopproperties öffnen
	if not startingup then
  begin
	  inprogress.filename.Caption:=_('Lese Daten ein... Desktopeinstellungen');
	 	inprogress.Refresh;
  end else
  begin
    SplashCaptioninfo(_('Lese Daten ein... Desktopeinstellungen'));
    RefreshSplashText;
  end;

  for i:=1 to 9 do
  begin
    FileStream.ReadBuffer(desktopproperties[i].name,sizeof(desktopproperties[i].name));
    FileStream.ReadBuffer(desktopproperties[i].maintop,sizeof(desktopproperties[i].maintop));
    FileStream.ReadBuffer(desktopproperties[i].mainleft,sizeof(desktopproperties[i].mainleft));
    FileStream.ReadBuffer(desktopproperties[i].mainheight,sizeof(desktopproperties[i].mainheight));
    FileStream.ReadBuffer(desktopproperties[i].mainwidth,sizeof(desktopproperties[i].mainwidth));
    FileStream.ReadBuffer(Count,sizeof(Count));
    setlength(desktopproperties[i].top,Count);
    setlength(desktopproperties[i].left,Count);
    setlength(desktopproperties[i].height,Count);
    setlength(desktopproperties[i].width,Count);
    setlength(desktopproperties[i].visible,Count);
    for k:=0 to Count-1 do
    begin
      FileStream.ReadBuffer(desktopproperties[i].top[k],sizeof(desktopproperties[i].top[k]));
      FileStream.ReadBuffer(desktopproperties[i].left[k],sizeof(desktopproperties[i].left[k]));
      FileStream.ReadBuffer(desktopproperties[i].height[k],sizeof(desktopproperties[i].height[k]));
      FileStream.ReadBuffer(desktopproperties[i].width[k],sizeof(desktopproperties[i].width[k]));
      FileStream.ReadBuffer(desktopproperties[i].visible[k],sizeof(desktopproperties[i].visible[k]));
    end;
  end;
// Desktopproperties Ende
// Joystickeinstellungen öffnen
	if not startingup then
  begin
	  inprogress.filename.Caption:=_('Lese Daten ein... Joystickeinstellungen');
	 	inprogress.Refresh;
  end else
  begin
    SplashCaptioninfo(_('Lese Daten ein... Joystickeinstellungen'));
    RefreshSplashText;
  end;
  if projektprogrammversionint>=418 then
  begin
    for i:=0 to length(JoystickEvents)-1 do
    begin
      Filestream.ReadBuffer(JoystickEvents[i].ID,sizeof(JoystickEvents[i].ID));
      Filestream.ReadBuffer(JoystickEvents[i].UseEvent,sizeof(JoystickEvents[i].UseEvent));
      Filestream.ReadBuffer(JoystickEvents[i].positionrelativ,sizeof(JoystickEvents[i].positionrelativ));
      if projektprogrammversionint>=429 then
        Filestream.ReadBuffer(JoystickEvents[i].invert,sizeof(JoystickEvents[i].invert));
      Filestream.ReadBuffer(JoystickEvents[i].deaktivierterbereich,sizeof(JoystickEvents[i].deaktivierterbereich));
      Filestream.ReadBuffer(JoystickEvents[i].beschleunigung,sizeof(JoystickEvents[i].beschleunigung));
      Filestream.ReadBuffer(JoystickEvents[i].offset,sizeof(JoystickEvents[i].offset));
      if projektprogrammversionint>=466 then
        Filestream.ReadBuffer(JoystickEvents[i].PermanentUpdate,sizeof(JoystickEvents[i].PermanentUpdate));

      Filestream.ReadBuffer(JoystickEvents[i].Befehl.Typ,sizeof(JoystickEvents[i].Befehl.Typ));
      Filestream.ReadBuffer(JoystickEvents[i].Befehl.OnValue,sizeof(JoystickEvents[i].Befehl.OnValue));
      if projektprogrammversionint>=456 then
        Filestream.ReadBuffer(JoystickEvents[i].Befehl.SwitchValue,sizeof(JoystickEvents[i].Befehl.SwitchValue))
      else
        JoystickEvents[i].Befehl.SwitchValue:=JoystickEvents[i].Befehl.OnValue;
      if projektprogrammversionint>=462 then
        Filestream.ReadBuffer(JoystickEvents[i].Befehl.InvertSwitchValue,sizeof(JoystickEvents[i].Befehl.InvertSwitchValue));
      Filestream.ReadBuffer(JoystickEvents[i].Befehl.OffValue,sizeof(JoystickEvents[i].Befehl.OffValue));
      if projektprogrammversionint>=457 then
        Filestream.ReadBuffer(JoystickEvents[i].Befehl.ScaleValue,sizeof(JoystickEvents[i].Befehl.ScaleValue));
      Filestream.ReadBuffer(Count2,sizeof(Count2));
      setlength(JoystickEvents[i].Befehl.ArgInteger,Count2);
      for j:=0 to Count2-1 do
        Filestream.ReadBuffer(JoystickEvents[i].Befehl.ArgInteger[j],sizeof(JoystickEvents[i].Befehl.ArgInteger[j]));
      Filestream.ReadBuffer(Count2,sizeof(Count2));
      setlength(JoystickEvents[i].Befehl.ArgString,Count2);
      for j:=0 to Count2-1 do
        Filestream.ReadBuffer(JoystickEvents[i].Befehl.ArgString[j],sizeof(JoystickEvents[i].Befehl.ArgString[j]));
      Filestream.ReadBuffer(Count2,sizeof(Count2));
      setlength(JoystickEvents[i].Befehl.ArgGUID,Count2);
      for j:=0 to Count2-1 do
        Filestream.ReadBuffer(JoystickEvents[i].Befehl.ArgGUID[j],sizeof(JoystickEvents[i].Befehl.ArgGUID[j]));
    end;

    // falls Version vor 466
    if projektprogrammversionint<466 then
    begin
      // Joystickoptionen anpassen
      JoystickEvents[0].UseEvent:=true;
      JoystickEvents[0].positionrelativ:=false;
      JoystickEvents[0].invert:=false;
      JoystickEvents[0].deaktivierterbereich:=0;
      JoystickEvents[0].beschleunigung:=2000;
      setlength(JoystickEvents[0].Befehl.ArgInteger,2);
      JoystickEvents[0].Befehl.ArgInteger[0]:=0; // PAN
      JoystickEvents[0].Befehl.ArgInteger[1]:=1000; // Faktor 1
      JoystickEvents[0].Befehl.Typ:=Befehlssystem[5].Steuerung[21].GUID;
      JoystickEvents[0].Befehl.OnValue:=255;
      JoystickEvents[0].Befehl.SwitchValue:=0;
      JoystickEvents[0].Befehl.OffValue:=0;
      JoystickEvents[0].PermanentUpdate:=true;

      JoystickEvents[1].UseEvent:=true;
      JoystickEvents[1].positionrelativ:=false;
      JoystickEvents[1].invert:=false;
      JoystickEvents[1].deaktivierterbereich:=0;
      JoystickEvents[1].beschleunigung:=2000;
      setlength(JoystickEvents[1].Befehl.ArgInteger,2);
      JoystickEvents[1].Befehl.ArgInteger[0]:=1; // TILT
      JoystickEvents[1].Befehl.ArgInteger[1]:=1000; // Faktor 1
      JoystickEvents[1].Befehl.Typ:=Befehlssystem[5].Steuerung[21].GUID;
      JoystickEvents[1].Befehl.OnValue:=255;
      JoystickEvents[1].Befehl.SwitchValue:=0;
      JoystickEvents[1].Befehl.OffValue:=0;
      JoystickEvents[1].PermanentUpdate:=true;
    end;
  end else
  begin
    for i:=0 to length(OldJoystickEvents)-1 do
    begin
      FileStream.ReadBuffer(OldJoystickEvents[i],sizeof(OldJoystickEvents[i]));
    end;
    ConvertJoystickToJoystick2;
  end;
// Joystickeinstellungen Ende
// Kontrollpanel öffnen
	if not startingup then
  begin
	  inprogress.filename.Caption:=_('Lese Daten ein... Kontrollpanel');
	 	inprogress.Refresh;
  end else
  begin
    SplashCaptioninfo(_('Lese Daten ein... Kontrollpanel'));
    RefreshSplashText;
  end;

    Filestream.ReadBuffer(kontrollpanelrecord,sizeof(kontrollpanelrecord));

    for i:=0 to length(kontrollpanelbuttons)-1 do
    for j:=0 to length(kontrollpanelbuttons[i])-1 do
    begin
      kontrollpanelbuttons[i][j].PNG.Free;
      kontrollpanelbuttons[i][j].PNG:=nil;
    end;

    if projektprogrammversionint>=435 then
    begin
      Filestream.ReadBuffer(Count,sizeof(Count));
      setlength(kontrollpanelbuttons,Count);
      Filestream.ReadBuffer(Count,sizeof(Count));
      for i:=0 to length(kontrollpanelbuttons)-1 do
        setlength(kontrollpanelbuttons[i],Count);

      kontrollpanel.zeilen.value:=length(kontrollpanelbuttons);
      if length(kontrollpanelbuttons)>0 then
        kontrollpanel.spalten.value:=length(kontrollpanelbuttons[0]);

      for i:=0 to length(kontrollpanelbuttons)-1 do
      for j:=0 to length(kontrollpanelbuttons[i])-1 do
      begin
        Filestream.ReadBuffer(kontrollpanelbuttons[i][j].ID,sizeof(kontrollpanelbuttons[i][j].ID));
        Filestream.ReadBuffer(kontrollpanelbuttons[i][j].Name,sizeof(kontrollpanelbuttons[i][j].Name));
        Filestream.ReadBuffer(kontrollpanelbuttons[i][j].Color,sizeof(kontrollpanelbuttons[i][j].Color));
        Filestream.ReadBuffer(kontrollpanelbuttons[i][j].Typ,sizeof(kontrollpanelbuttons[i][j].Typ));
        Filestream.ReadBuffer(kontrollpanelbuttons[i][j].Shortcut,sizeof(kontrollpanelbuttons[i][j].Shortcut));
        Filestream.ReadBuffer(kontrollpanelbuttons[i][j].Picture,sizeof(kontrollpanelbuttons[i][j].Picture));

        // Bildadresse aktualisieren
        kontrollpanelbuttons[i][j].Picture:=SearchFileBeneathProject(kontrollpanelbuttons[i][j].Picture);

        if not Assigned(kontrollpanelbuttons[i][j].PNG) then
          kontrollpanelbuttons[i][j].PNG:=TPNGObject.Create;
        if FileExists(kontrollpanelbuttons[i][j].Picture) then
          kontrollpanelbuttons[i][j].PNG.LoadFromFile(kontrollpanelbuttons[i][j].Picture);
        kontrollpanelbuttons[i][j].Visible:=true;
      end;
    end else
    begin
      count:=kontrollpanelrecord.zeilenanzahl+1;
      count2:=kontrollpanelrecord.spaltenanzahl+1;
      kontrollpanel.zeilen.value:=count;
      kontrollpanel.spalten.value:=count2;

      for i:=0 to length(kontrollpanelbuttons)-1 do
      for j:=0 to length(kontrollpanelbuttons[i])-1 do
      begin
        kontrollpanelbuttons[i][j].PNG.Free;
        kontrollpanelbuttons[i][j].PNG:=nil;
      end;

      setlength(kontrollpanelbuttons,count);
      for i:=0 to length(kontrollpanelbuttons)-1 do
      begin
        setlength(kontrollpanelbuttons[i], count2);
        for j:=0 to length(kontrollpanelbuttons[i])-1 do
        begin
          kontrollpanelbuttons[i][j].ID:=kontrollpanelrecord.ID[i][j];
          kontrollpanelbuttons[i][j].Name:=kontrollpanelrecord.buttonname[i][j];
          kontrollpanelbuttons[i][j].Color:=kontrollpanelrecord.buttonfarbe[i][j];
          kontrollpanelbuttons[i][j].Typ:=kontrollpanelrecord.buttontyp[i][j];
          kontrollpanelbuttons[i][j].TypName:='';
          kontrollpanelbuttons[i][j].Time:='-';
          kontrollpanelbuttons[i][j].Shortcut:=kontrollpanelrecord.buttonshortcut[i][j];
          kontrollpanelbuttons[i][j].Picture:='';

          if not Assigned(kontrollpanelbuttons[i][j].PNG) then
            kontrollpanelbuttons[i][j].PNG:=TPNGObject.Create;
          kontrollpanelbuttons[i][j].Visible:=true;

          // Picture
        end;
      end;
    end;
// Kontrollpanel ende
// MIDI-IN Event öffnen
	if not startingup then
  begin
	  inprogress.filename.Caption:=_('Lese Daten ein... MIDI Einstellungen');
    inprogress.ProgressBar1.Position:=65;
	 	inprogress.Refresh;
  end else
  begin
    SplashCaptioninfo(_('Lese Daten ein... MIDI Einstellungen'));
    SplashProgress(1, 86, 100);
    RefreshSplashText;
  end;

  if projektprogrammversionint>=418 then
  begin
    Filestream.ReadBuffer(Count,sizeof(Count));
    setlength(MidiEventArray,Count);
    for i:=0 to Count-1 do
    begin
      Filestream.ReadBuffer(MidiEventArray[i].ID,sizeof(MidiEventArray[i].ID));
      Filestream.ReadBuffer(MidiEventArray[i].MIDIMessage,sizeof(MidiEventArray[i].MIDIMessage));
      Filestream.ReadBuffer(MidiEventArray[i].MIDIData1,sizeof(MidiEventArray[i].MIDIData1));
      Filestream.ReadBuffer(MidiEventArray[i].MIDIData2,sizeof(MidiEventArray[i].MIDIData2));

      Filestream.ReadBuffer(MidiEventArray[i].Befehl.Typ,sizeof(MidiEventArray[i].Befehl.Typ));
      if projektprogrammversionint>=478 then
      begin
        Filestream.ReadBuffer(MidiEventArray[i].Befehl.Name,sizeof(MidiEventArray[i].Befehl.Name));
        Filestream.ReadBuffer(MidiEventArray[i].Befehl.Beschreibung,sizeof(MidiEventArray[i].Befehl.Beschreibung));
      end;
      Filestream.ReadBuffer(MidiEventArray[i].Befehl.OnValue,sizeof(MidiEventArray[i].Befehl.OnValue));
      if projektprogrammversionint>=456 then
        Filestream.ReadBuffer(MidiEventArray[i].Befehl.SwitchValue,sizeof(MidiEventArray[i].Befehl.SwitchValue))
      else
        MidiEventArray[i].Befehl.SwitchValue:=MidiEventArray[i].Befehl.OnValue;
      if projektprogrammversionint>=462 then
        Filestream.ReadBuffer(MidiEventArray[i].Befehl.InvertSwitchValue,sizeof(MidiEventArray[i].Befehl.InvertSwitchValue));
      Filestream.ReadBuffer(MidiEventArray[i].Befehl.OffValue,sizeof(MidiEventArray[i].Befehl.OffValue));
      if projektprogrammversionint>=457 then
        Filestream.ReadBuffer(MidiEventArray[i].Befehl.ScaleValue,sizeof(MidiEventArray[i].Befehl.ScaleValue));
      Filestream.ReadBuffer(Count2,sizeof(Count2));
      setlength(MidiEventArray[i].Befehl.ArgInteger,Count2);
      for j:=0 to Count2-1 do
        Filestream.ReadBuffer(MidiEventArray[i].Befehl.ArgInteger[j],sizeof(MidiEventArray[i].Befehl.ArgInteger[j]));
      Filestream.ReadBuffer(Count2,sizeof(Count2));
      setlength(MidiEventArray[i].Befehl.ArgString,Count2);
      for j:=0 to Count2-1 do
        Filestream.ReadBuffer(MidiEventArray[i].Befehl.ArgString[j],sizeof(MidiEventArray[i].Befehl.ArgString[j]));
      Filestream.ReadBuffer(Count2,sizeof(Count2));
      setlength(MidiEventArray[i].Befehl.ArgGUID,Count2);
      for j:=0 to Count2-1 do
        Filestream.ReadBuffer(MidiEventArray[i].Befehl.ArgGUID[j],sizeof(MidiEventArray[i].Befehl.ArgGUID[j]));

      Filestream.ReadBuffer(MidiEventArray[i].Data1orData2,sizeof(MidiEventArray[i].Data1orData2));
      Filestream.ReadBuffer(MidiEventArray[i].UseMidiBacktrack,sizeof(MidiEventArray[i].UseMidiBacktrack))
    end;
  end else
  begin
    Filestream.ReadBuffer(Count,sizeof(Count));
    setlength(MidiEventArray,Count);
    for i:=0 to Count-1 do
    begin
      Filestream.ReadBuffer(MidiEventArray[i].MIDIMessage,sizeof(MidiEventArray[i].MIDIMessage));
      Filestream.ReadBuffer(MidiEventArray[i].MIDIData1,sizeof(MidiEventArray[i].MIDIData1));
      Filestream.ReadBuffer(MidiEventArray[i].MIDIData2,sizeof(MidiEventArray[i].MIDIData2));
      Filestream.ReadBuffer(MidiEventArray[i].Typ,sizeof(MidiEventArray[i].Typ));
      if projektprogrammversionint>=404 then
      begin
        Filestream.ReadBuffer(MidiEventArray[i].Wert1,sizeof(MidiEventArray[i].Wert1));
        Filestream.ReadBuffer(MidiEventArray[i].Wert2,sizeof(MidiEventArray[i].Wert2));
      end else
      begin
        Filestream.ReadBuffer(MidiEventArray[i].Wert1,sizeof(Word));
        Filestream.ReadBuffer(MidiEventArray[i].Wert2,sizeof(Word));
      end;
      Filestream.ReadBuffer(MidiEventArray[i].Data1orData2,sizeof(MidiEventArray[i].Data1orData2));
      Filestream.ReadBuffer(MidiEventArray[i].Arg3,sizeof(MidiEventArray[i].Arg3));
      if projektprogrammversionint>=415 then
        Filestream.ReadBuffer(MidiEventArray[i].UseMidiBacktrack,sizeof(MidiEventArray[i].UseMidiBacktrack))
      else
        MidiEventArray[i].UseMidiBacktrack:=true;

      ConvertMidiToMidi2;
    end;
  end;
// MIDI-IN Event Ende
// Data-IN Event öffnen
	if not startingup then
  begin
	  inprogress.filename.Caption:=_('Lese Daten ein... DataIn Einstellungen');
	 	inprogress.Refresh;
  end else
  begin
    SplashCaptioninfo(_('Lese Daten ein... DataIn Einstellungen'));
    RefreshSplashText;
  end;

  if projektprogrammversionint>=418 then
  begin
    Filestream.ReadBuffer(Count,sizeof(Count));
    setlength(DatainEventArray,Count);
    for i:=0 to Count-1 do
    begin
      Filestream.ReadBuffer(DatainEventArray[i].ID,sizeof(DatainEventArray[i].ID));
      Filestream.ReadBuffer(DatainEventArray[i].Channel,sizeof(DatainEventArray[i].Channel));
      Filestream.ReadBuffer(DatainEventArray[i].Value,sizeof(DatainEventArray[i].Value));

      Filestream.ReadBuffer(DatainEventArray[i].Befehl.Typ,sizeof(DatainEventArray[i].Befehl.Typ));
      if projektprogrammversionint>=478 then
      begin
        Filestream.ReadBuffer(DatainEventArray[i].Befehl.Name,sizeof(DatainEventArray[i].Befehl.Name));
        Filestream.ReadBuffer(DatainEventArray[i].Befehl.Beschreibung,sizeof(DatainEventArray[i].Befehl.Beschreibung));
      end;
      Filestream.ReadBuffer(DatainEventArray[i].Befehl.OnValue,sizeof(DatainEventArray[i].Befehl.OnValue));
      if projektprogrammversionint>=456 then
        Filestream.ReadBuffer(DatainEventArray[i].Befehl.SwitchValue,sizeof(DatainEventArray[i].Befehl.SwitchValue))
      else
        DatainEventArray[i].Befehl.SwitchValue:=DatainEventArray[i].Befehl.OnValue;
      if projektprogrammversionint>=462 then
        Filestream.ReadBuffer(DatainEventArray[i].Befehl.InvertSwitchValue,sizeof(DatainEventArray[i].Befehl.InvertSwitchValue));
      Filestream.ReadBuffer(DatainEventArray[i].Befehl.OffValue,sizeof(DatainEventArray[i].Befehl.OffValue));
      if projektprogrammversionint>=457 then
        Filestream.ReadBuffer(DatainEventArray[i].Befehl.ScaleValue,sizeof(DatainEventArray[i].Befehl.ScaleValue));
      Filestream.ReadBuffer(Count2,sizeof(Count2));
      setlength(DatainEventArray[i].Befehl.ArgInteger,Count2);
      for j:=0 to Count2-1 do
        Filestream.ReadBuffer(DatainEventArray[i].Befehl.ArgInteger[j],sizeof(DatainEventArray[i].Befehl.ArgInteger[j]));
      Filestream.ReadBuffer(Count2,sizeof(Count2));
      setlength(DatainEventArray[i].Befehl.ArgString,Count2);
      for j:=0 to Count2-1 do
        Filestream.ReadBuffer(DatainEventArray[i].Befehl.ArgString[j],sizeof(DatainEventArray[i].Befehl.ArgString[j]));
      Filestream.ReadBuffer(Count2,sizeof(Count2));
      setlength(DatainEventArray[i].Befehl.ArgGUID,Count2);
      for j:=0 to Count2-1 do
        Filestream.ReadBuffer(DatainEventArray[i].Befehl.ArgGUID[j],sizeof(DatainEventArray[i].Befehl.ArgGUID[j]));
    end;
  end else
  begin
    Filestream.ReadBuffer(Count,sizeof(Count));
    setlength(DataInEventArray,Count);
    for i:=0 to Count-1 do
    begin
      Filestream.ReadBuffer(DataInEventArray[i].Channel,sizeof(DataInEventArray[i].Channel));
      Filestream.ReadBuffer(DataInEventArray[i].Value,sizeof(DataInEventArray[i].Value));
      Filestream.ReadBuffer(DataInEventArray[i].Typ,sizeof(DataInEventArray[i].Typ));
      if projektprogrammversionint>=404 then
      begin
        Filestream.ReadBuffer(DataInEventArray[i].Wert1,sizeof(DataInEventArray[i].Wert1));
        Filestream.ReadBuffer(DataInEventArray[i].Wert2,sizeof(DataInEventArray[i].Wert2));
      end else
      begin
        Filestream.ReadBuffer(DataInEventArray[i].Wert1,sizeof(Word));
        Filestream.ReadBuffer(DataInEventArray[i].Wert2,sizeof(Word));
      end;
      Filestream.ReadBuffer(DataInEventArray[i].Arg3,sizeof(DataInEventArray[i].Arg3));
    end;
    ConvertDataInToDataIn2;
  end;
// Data-IN Event Ende
// Leistungsdaten öffnen
	if not startingup then
  begin
	  inprogress.filename.Caption:=_('Lese Daten ein... Leistungssteuerung');
	 	inprogress.Refresh;
  end else
  begin
    SplashCaptioninfo(_('Lese Daten ein... Leistungssteuerung'));
    RefreshSplashText;
  end;
  Filestream.ReadBuffer(leistungsdaten.ampere,sizeof(leistungsdaten.ampere));
  Filestream.ReadBuffer(leistungsdaten.usesinus,sizeof(leistungsdaten.usesinus));
  Filestream.ReadBuffer(Count,sizeof(Count));
  setlength(leistungsdaten.channel,Count);
  setlength(leistungsdaten.phase,Count);
  setlength(leistungsdaten.leistung,Count);
  setlength(leistungsdaten.deactivatechannelonoverload,Count);
{
  setlength(leistungssteuerung.pL1array,Count);
  setlength(leistungssteuerung.pL2array,Count);
  setlength(leistungssteuerung.pL3array,Count);
  setlength(leistungssteuerung.pL4array,Count);
}
  for i:=0 to Count-1 do
  begin
    Filestream.ReadBuffer(leistungsdaten.channel[i],sizeof(leistungsdaten.channel[i]));
    Filestream.ReadBuffer(leistungsdaten.phase[i],sizeof(leistungsdaten.phase[i]));
    Filestream.ReadBuffer(leistungsdaten.leistung[i],sizeof(leistungsdaten.leistung[i]));
    Filestream.ReadBuffer(leistungsdaten.deactivatechannelonoverload[i],sizeof(leistungsdaten.deactivatechannelonoverload[i]));
  end;
// Leistungsdaten Ende
// Leistungsdaten2 öffnen
  if projektprogrammversionint>=453 then
  begin
    for i:=0 to 11 do
      Filestream.ReadBuffer(leistungssteuerungform2.maxpower[i],sizeof(leistungssteuerungform2.maxpower[i]));
  end else if projektprogrammversionint>=426 then
  begin
    for i:=0 to 5 do
      Filestream.ReadBuffer(leistungssteuerungform2.maxpower[i],sizeof(leistungssteuerungform2.maxpower[i]));
    for i:=6 to 11 do
      leistungssteuerungform2.maxpower[i]:=3680;
  end;
// Leistungsdaten2 Ende
// Autoszenen öffnen
	if not startingup then
  begin
	  inprogress.filename.Caption:=_('Lese Daten ein... Automatikszenen');
	 	inprogress.Refresh;
  end else
  begin
    SplashCaptioninfo(_('Lese Daten ein... Automatikszenen'));
    RefreshSplashText;
  end;

	  Filestream.ReadBuffer(Count,sizeof(Count));
    setlength(mainform.Autoszenen,Count);
    for i:=0 to Count-1 do
    begin
   	  Filestream.ReadBuffer(mainform.Autoszenen[i].ID,sizeof(mainform.Autoszenen[i].ID));
   	  Filestream.ReadBuffer(mainform.Autoszenen[i].Name,sizeof(mainform.Autoszenen[i].Name));
   	  Filestream.ReadBuffer(mainform.Autoszenen[i].Beschreibung,sizeof(mainform.Autoszenen[i].Beschreibung));
   	  Filestream.ReadBuffer(mainform.Autoszenen[i].fadetime,sizeof(mainform.Autoszenen[i].fadetime));
   	  Filestream.ReadBuffer(mainform.Autoszenen[i].R,sizeof(mainform.Autoszenen[i].R));
   	  Filestream.ReadBuffer(mainform.Autoszenen[i].G,sizeof(mainform.Autoszenen[i].G));
   	  Filestream.ReadBuffer(mainform.Autoszenen[i].B,sizeof(mainform.Autoszenen[i].B));
      if projektprogrammversionint>=483 then
      begin
     	  Filestream.ReadBuffer(mainform.Autoszenen[i].A,sizeof(mainform.Autoszenen[i].A));
     	  Filestream.ReadBuffer(mainform.Autoszenen[i].W,sizeof(mainform.Autoszenen[i].W));
   	  end else
      begin
        mainform.Autoszenen[i].A:=-1;
        mainform.Autoszenen[i].W:=-1;
      end;
      Filestream.ReadBuffer(mainform.Autoszenen[i].accuracy,sizeof(mainform.Autoszenen[i].accuracy));
   	  Filestream.ReadBuffer(mainform.Autoszenen[i].helligkeit,sizeof(mainform.Autoszenen[i].helligkeit));
      if projektprogrammversionint>=439 then
        Filestream.ReadBuffer(Autoszenen[i].Category,sizeof(Autoszenen[i].Category));
    end;
// Ende Autoszenen
// Textbuch
	if not startingup then
  begin
	  inprogress.filename.Caption:=_('Lese Daten ein... Textbuch');
    inprogress.ProgressBar1.Position:=68;
	 	inprogress.Refresh;
  end else
  begin
    SplashCaptioninfo(_('Lese Daten ein... Textbuch'));
    SplashProgress(1, 87, 100);
    RefreshSplashText;
  end;

  if projektprogrammversionint>=411 then
  begin
    Filestream.ReadBuffer(textbuchform.TextBuchFile,sizeof(textbuchform.TextBuchFile));
  end;
// Ende Textbuch
// MIDI-DirectSending
	if not startingup then
  begin
	  inprogress.filename.Caption:=_('Lese Daten ein... MIDI-Informationen');
	 	inprogress.Refresh;
  end else
  begin
    SplashCaptioninfo(_('Lese Daten ein... MIDI-Informationen'));
    RefreshSplashText;
  end;

  if projektprogrammversionint>=412 then
  begin
    Filestream.ReadBuffer(count,sizeof(count));
    setlength(SendValueOfSelectedDevicesToMidi,Count);
    for i:=0 to count-1 do
    begin
      Filestream.ReadBuffer(SendValueOfSelectedDevicesToMidi[i].MSG,sizeof(SendValueOfSelectedDevicesToMidi[i].MSG));
      Filestream.ReadBuffer(SendValueOfSelectedDevicesToMidi[i].Data1,sizeof(SendValueOfSelectedDevicesToMidi[i].Data1));
      Filestream.ReadBuffer(SendValueOfSelectedDevicesToMidi[i].UseData2,sizeof(SendValueOfSelectedDevicesToMidi[i].UseData2));
    end;
// Ende MIDI-DirectSending
  end else
  begin
    setlength(SendValueOfSelectedDevicesToMidi,0);
  end;

  if projektprogrammversionint>=412 then
  begin
// Submaster
    if not startingup then
    begin
      inprogress.filename.Caption:=_('Lese Daten ein... Submaster');
      inprogress.Refresh;
    end else
    begin
      SplashCaptioninfo(_('Lese Daten ein... Submaster'));
      RefreshSplashText;
    end;

    FileStream.ReadBuffer(count,sizeof(count));
    setlength(Submasterbank,count);
    for i:=0 to count-1 do
    begin
      FileStream.ReadBuffer(Submasterbank[i].BankName, sizeof(Submasterbank[i].BankName));
      if projektprogrammversionint<451 then
      begin
        FileStream.ReadBuffer(Submasterbank[i].SubmasterName, sizeof(Submasterbank[i].SubmasterName));
        if projektprogrammversionint>=447 then
        begin
          FileStream.ReadBuffer(Submasterbank[i].UseScene, sizeof(Submasterbank[i].UseScene));
          FileStream.ReadBuffer(Submasterbank[i].SubmasterScene, sizeof(Submasterbank[i].SubmasterScene));
        end;
      end;

      for j:=1 to 16 do
      begin
        if projektprogrammversionint>=451 then
        begin
          FileStream.ReadBuffer(Submasterbank[i].SubmasterName[j], sizeof(Submasterbank[i].SubmasterName[j]));
          FileStream.ReadBuffer(Submasterbank[i].UseScene[j], sizeof(Submasterbank[i].UseScene[j]));
          FileStream.ReadBuffer(Submasterbank[i].SubmasterScene[j], sizeof(Submasterbank[i].SubmasterScene[j]));
        end;

        FileStream.ReadBuffer(count2,sizeof(count2));
        if count2=-1 then count2:=0; // hier gab es mal Probleme mit dem Laden von Submastern - keine Ahnung warum, aber count2 war nach dem lesen =-1
        setlength(Submasterbank[i].Submasterdevices[j],count2);
        for k:=0 to count2-1 do
        begin
          FileStream.ReadBuffer(Submasterbank[i].Submasterdevices[j][k].ID,sizeof(Submasterbank[i].Submasterdevices[j][k].ID));
          FileStream.ReadBuffer(count3,sizeof(count3));

          setlength(Submasterbank[i].Submasterdevices[j][k].ChanActive,count3);
          setlength(Submasterbank[i].Submasterdevices[j][k].ChanValue,count3);
          setlength(Submasterbank[i].Submasterdevices[j][k].ChanDelay,count3);
          for l:=0 to count3-1 do
          begin
            FileStream.ReadBuffer(Submasterbank[i].Submasterdevices[j][k].ChanActive[l],sizeof(Submasterbank[i].Submasterdevices[j][k].ChanActive[l]));;
            if projektprogrammversionint>=413 then
            begin
              FileStream.ReadBuffer(Submasterbank[i].Submasterdevices[j][k].ChanValue[l],sizeof(Submasterbank[i].Submasterdevices[j][k].ChanValue[l]));;
              FileStream.ReadBuffer(Submasterbank[i].Submasterdevices[j][k].ChanDelay[l],sizeof(Submasterbank[i].Submasterdevices[j][k].ChanDelay[l]));;
            end else
            begin
              Submasterbank[i].Submasterdevices[j][k].ChanValue[l]:=maxres;
              Submasterbank[i].Submasterdevices[j][k].ChanDelay[l]:=-1;
            end;
          end;
        end;

        if projektprogrammversionint>=427 then
        begin
          FileStream.ReadBuffer(Submasterbank[i].UseBefehl[j], sizeof(Submasterbank[i].UseBefehl[j]));
          Filestream.ReadBuffer(Submasterbank[i].Befehl[j].ID,sizeof(Submasterbank[i].Befehl[j].ID));
          Filestream.ReadBuffer(Submasterbank[i].Befehl[j].Typ,sizeof(Submasterbank[i].Befehl[j].Typ));
          Filestream.ReadBuffer(Submasterbank[i].Befehl[j].OnValue,sizeof(Submasterbank[i].Befehl[j].OnValue));
          if projektprogrammversionint>=456 then
            Filestream.ReadBuffer(Submasterbank[i].Befehl[j].SwitchValue,sizeof(Submasterbank[i].Befehl[j].SwitchValue))
          else
            Submasterbank[i].Befehl[j].SwitchValue:=Submasterbank[i].Befehl[j].OnValue;
          if projektprogrammversionint>=462 then
            Filestream.ReadBuffer(Submasterbank[i].Befehl[j].InvertSwitchValue,sizeof(Submasterbank[i].Befehl[j].InvertSwitchValue));
          Filestream.ReadBuffer(Submasterbank[i].Befehl[j].OffValue,sizeof(Submasterbank[i].Befehl[j].OffValue));
          if projektprogrammversionint>=457 then
            Filestream.ReadBuffer(Submasterbank[i].Befehl[j].ScaleValue,sizeof(Submasterbank[i].Befehl[j].ScaleValue));

          Filestream.ReadBuffer(Count2,sizeof(Count2));
          setlength(Submasterbank[i].Befehl[j].ArgInteger,Count2);
          for k:=0 to Count2-1 do
            Filestream.ReadBuffer(Submasterbank[i].Befehl[j].ArgInteger[k],sizeof(Submasterbank[i].Befehl[j].ArgInteger[k]));
          Filestream.ReadBuffer(Count2,sizeof(Count2));
          setlength(Submasterbank[i].Befehl[j].ArgString,Count2);
          for k:=0 to Count2-1 do
            Filestream.ReadBuffer(Submasterbank[i].Befehl[j].ArgString[k],sizeof(Submasterbank[i].Befehl[j].ArgString[k]));
          Filestream.ReadBuffer(Count2,sizeof(Count2));
          setlength(Submasterbank[i].Befehl[j].ArgGUID,Count2);
          for k:=0 to Count2-1 do
            Filestream.ReadBuffer(Submasterbank[i].Befehl[j].ArgGUID[k],sizeof(Submasterbank[i].Befehl[j].ArgGUID[k]));
        end else
        begin
          // allen älteren Submastern entsprechend IDs für die Befehle verpassen
          Submasterbank[i].UseBefehl[j]:=false;
          CreateGUID(Submasterbank[i].Befehl[j].ID);
        end;
      end;
    end;

    // Bugfix für Fehlerhafte Array-Länge bei Gruppeneinträgen in Submaster von alten Projekten
    for i:=0 to length(Submasterbank)-1 do
    begin
      for j:=1 to 16 do
      for k:=0 to length(Submasterbank[i].Submasterdevices[j])-1 do
      begin
        if geraetesteuerung.GetGroupPositionInGroupArray(Submasterbank[i].Submasterdevices[j][k].ID)>-1 then
        begin
          setlength(Submasterbank[i].Submasterdevices[j][k].ChanActive, length(mainform.DeviceChannelNames));
          setlength(Submasterbank[i].Submasterdevices[j][k].ChanValue, length(mainform.DeviceChannelNames));
          setlength(Submasterbank[i].Submasterdevices[j][k].ChanDelay, length(mainform.DeviceChannelNames));
        end;
      end;
    end;

// Ende Submaster
  end; // Projektversion 4.12

  if projektprogrammversionint>=412 then
  begin
    if not startingup then
    begin
      inprogress.filename.Caption:=_('Lese Daten ein... Cue-Liste');
      inprogress.Refresh;
    end else
    begin
      SplashCaptioninfo(_('Lese Daten ein... Cue-Liste'));
      RefreshSplashText;
    end;

    FileStream.ReadBuffer(count,sizeof(count));
    setlength(Cuelistbank,count);
    for i:=0 to count-1 do
    begin
      FileStream.ReadBuffer(Cuelistbank[i].BankName,sizeof(Cuelistbank[i].BankName));

      FileStream.ReadBuffer(count2,sizeof(count2));
      setlength(Cuelistbank[i].cuelistbankitems,count2);
      for j:=0 to count2-1 do
      begin
        FileStream.ReadBuffer(Cuelistbank[i].cuelistbankitems[j].ID,sizeof(Cuelistbank[i].cuelistbankitems[j].ID));
        if projektprogrammversionint>=436 then
        begin
          FileStream.ReadBuffer(count3,sizeof(count3));

          if projektprogrammversionint<441 then
          begin
            FileStream.Position:=FileStream.Position+count3;
            Cuelistbank[i].cuelistbankitems[j].OwnDescription:='';
          end else
          begin
            FileStream.ReadBuffer(Cuelistbank[i].cuelistbankitems[j].OwnDescription,sizeof(Cuelistbank[i].cuelistbankitems[j].OwnDescription));
          end;
          
          FileStream.ReadBuffer(Cuelistbank[i].cuelistbankitems[j].Typ,sizeof(Cuelistbank[i].cuelistbankitems[j].Typ));

          if projektprogrammversionint>=439 then
          begin
            FileStream.ReadBuffer(Cuelistbank[i].cuelistbankitems[j].UseFadetime,sizeof(Cuelistbank[i].cuelistbankitems[j].UseFadetime));
            FileStream.ReadBuffer(Cuelistbank[i].cuelistbankitems[j].Fadetime,sizeof(Cuelistbank[i].cuelistbankitems[j].Fadetime));
          end else
          begin
            Cuelistbank[i].cuelistbankitems[j].UseFadetime:=false;
            Cuelistbank[i].cuelistbankitems[j].Fadetime:=0;
          end;
          if projektprogrammversionint>=455 then
          begin
            FileStream.ReadBuffer(Cuelistbank[i].cuelistbankitems[j].LiveTime,sizeof(Cuelistbank[i].cuelistbankitems[j].LiveTime));
            FileStream.ReadBuffer(Cuelistbank[i].cuelistbankitems[j].StopCueIfTimeOver,sizeof(Cuelistbank[i].cuelistbankitems[j].StopCueIfTimeOver));
          end else
          begin
            Cuelistbank[i].cuelistbankitems[j].LiveTime:=-1;
            Cuelistbank[i].cuelistbankitems[j].StopCueIfTimeOver:=false;
          end;
        end else
        begin
          Cuelistbank[i].cuelistbankitems[j].OwnDescription:='';
          Cuelistbank[i].cuelistbankitems[j].Typ:=GetSceneType(Cuelistbank[i].cuelistbankitems[j].ID);
          Cuelistbank[i].cuelistbankitems[j].UseFadetime:=false;
          Cuelistbank[i].cuelistbankitems[j].Fadetime:=0;
          Cuelistbank[i].cuelistbankitems[j].LiveTime:=-1;
          Cuelistbank[i].cuelistbankitems[j].StopCueIfTimeOver:=false;
        end;
      end;
    end;
  end; // Projektversion 4.12

  if projektprogrammversionint>=419 then
  begin
    // Timecodeplayer-Liste laden
    if not startingup then
    begin
      inprogress.filename.Caption:=_('Lese Daten ein... Timecodeplayer');
      inprogress.Refresh;
    end else
    begin
      SplashCaptioninfo(_('Lese Daten ein... Timecodeplayer'));
      RefreshSplashText;
    end;

    FileStream.ReadBuffer(count,sizeof(count));
    setlength(TimeCodePlayerBank,count);
    for i:=0 to count-1 do
    begin
      FileStream.ReadBuffer(TimeCodePlayerBank[i].BankName,sizeof(TimeCodePlayerBank[i].BankName));
      FileStream.ReadBuffer(count2,sizeof(count2));
      setlength(TimeCodePlayerBank[i].TimeCodePlayerBankItems,count2);
      setlength(TimeCodePlayerBank[i].Time,count2);
      setlength(TimeCodePlayerBank[i].Frame,count2);
      for j:=0 to count2-1 do
      begin
        FileStream.ReadBuffer(TimeCodePlayerBank[i].TimeCodePlayerBankItems[j],sizeof(TimeCodePlayerBank[i].TimeCodePlayerBankItems[j]));
        FileStream.ReadBuffer(TimeCodePlayerBank[i].Time[j],sizeof(TimeCodePlayerBank[i].Time[j]));
        FileStream.ReadBuffer(TimeCodePlayerBank[i].Frame[j],sizeof(TimeCodePlayerBank[i].Frame[j]));
      end;
    end;
    // Timecodeplayer-Liste Ende
  end;

  if projektprogrammversionint>=420 then
  begin
    // IR FB laden
    if not startingup then
    begin
      inprogress.filename.Caption:=_('Lese Daten ein... IR Fernbedienung');
      inprogress.Refresh;
    end else
    begin
      SplashCaptioninfo(_('Lese Daten ein... IR Fernbedienung'));
      RefreshSplashText;
    end;

    FileStream.ReadBuffer(count,sizeof(count));
    setlength(mainform.IREvent,count);
    for i:=0 to length(mainform.IREvent)-1 do
    begin
      FileStream.ReadBuffer(mainform.IREvent[i].id,sizeof(mainform.IREvent[i].id));
      FileStream.ReadBuffer(mainform.IREvent[i].fernbedienung,sizeof(mainform.IREvent[i].fernbedienung));
      FileStream.ReadBuffer(mainform.IREvent[i].taste,sizeof(mainform.IREvent[i].taste));
      FileStream.ReadBuffer(mainform.IREvent[i].taste_raw,sizeof(mainform.IREvent[i].taste_raw));
    end;
    // IR FB Ende
  end;

  if projektprogrammversionint>=423 then
  begin
// MediaCenter Szenen laden
    if not startingup then
    begin
  	  inprogress.filename.Caption:=_('Lese Daten ein... MediaCenter Szenen');
    	inprogress.Refresh;
    end else
    begin
      SplashCaptioninfo(_('Lese Daten ein... MediaCenter Szenen'));
      RefreshSplashText;
    end;

	  Filestream.ReadBuffer(Count,sizeof(Count));
    setlength(mainform.MediaCenterSzenen,Count);
    for i:=0 to Count-1 do
    begin
   	  Filestream.ReadBuffer(mainform.MediaCenterSzenen[i].ID,sizeof(mainform.MediaCenterSzenen[i].ID));
   	  Filestream.ReadBuffer(mainform.MediaCenterSzenen[i].Name,sizeof(mainform.MediaCenterSzenen[i].Name));
   	  Filestream.ReadBuffer(mainform.MediaCenterSzenen[i].Beschreibung,sizeof(mainform.MediaCenterSzenen[i].Beschreibung));
   	  Filestream.ReadBuffer(mainform.MediaCenterSzenen[i].Adresse,sizeof(mainform.MediaCenterSzenen[i].Adresse));
   	  Filestream.ReadBuffer(mainform.MediaCenterSzenen[i].Port,sizeof(mainform.MediaCenterSzenen[i].Port));
   	  Filestream.ReadBuffer(mainform.MediaCenterSzenen[i].Befehl,sizeof(mainform.MediaCenterSzenen[i].Befehl));
   	  Filestream.ReadBuffer(mainform.MediaCenterSzenen[i].Data1,sizeof(mainform.MediaCenterSzenen[i].Data1));
   	  Filestream.ReadBuffer(mainform.MediaCenterSzenen[i].Data2,sizeof(mainform.MediaCenterSzenen[i].Data2));
   	  Filestream.ReadBuffer(mainform.MediaCenterSzenen[i].Text,sizeof(mainform.MediaCenterSzenen[i].Text));
      if projektprogrammversionint>=439 then
        Filestream.ReadBuffer(MediaCenterSzenen[i].Category,sizeof(MediaCenterSzenen[i].Category));
    end;
// Ende MediaCenter laden
  end;
  if projektprogrammversionint>=443 then
  begin
// Plugin Szenen laden
    if not startingup then
    begin
  	  inprogress.filename.Caption:=_('Lese Daten ein... Pluginszenen');
    	inprogress.Refresh;
    end else
    begin
      SplashCaptioninfo(_('Lese Daten ein... Pluginszenen'));
      RefreshSplashText;
    end;

	  Filestream.ReadBuffer(Count,sizeof(Count));
    setlength(mainform.PluginSzenen,Count);
    for i:=0 to Count-1 do
    begin
   	  Filestream.ReadBuffer(mainform.PluginSzenen[i].ID,sizeof(mainform.PluginSzenen[i].ID));
   	  Filestream.ReadBuffer(mainform.PluginSzenen[i].Name,sizeof(mainform.PluginSzenen[i].Name));
      Filestream.ReadBuffer(mainform.PluginSzenen[i].Category,sizeof(mainform.PluginSzenen[i].Category));
    end;
// Ende Plugin laden
// FFTDataIn laden
    if projektprogrammversionint>=444 then
    begin
      for i:=0 to 31 do
      begin
        Filestream.ReadBuffer(mainform.FFTDataIn[i].Active,sizeof(mainform.FFTDataIn[i].Active));
        Filestream.ReadBuffer(mainform.FFTDataIn[i].Channel,sizeof(mainform.FFTDataIn[i].Channel));
        Filestream.ReadBuffer(mainform.FFTDataIn[i].Faktor,sizeof(mainform.FFTDataIn[i].Faktor));
      end;
    end else
    begin
      for i:=0 to 31 do
      begin
        mainform.FFTDataIn[i].Active:=false;
        mainform.FFTDataIn[i].Channel:=1;
        mainform.FFTDataIn[i].Faktor:=255;
      end;
    end;
// Ende FFTDataIn
// BeatImpuls laden
    if projektprogrammversionint>=445 then
    begin
      Filestream.ReadBuffer(mainform.BeatImpuls.Active,sizeof(mainform.BeatImpuls.Active));
      Filestream.ReadBuffer(mainform.BeatImpuls.Channel,sizeof(mainform.BeatImpuls.Channel));
      Filestream.ReadBuffer(mainform.BeatImpuls.OnValue,sizeof(mainform.BeatImpuls.OnValue));
      Filestream.ReadBuffer(mainform.BeatImpuls.OffValue,sizeof(mainform.BeatImpuls.OffValue));
      if projektprogrammversionint>=474 then
      begin
        Filestream.ReadBuffer(mainform.BeatImpuls.SceneOnBeatLost,sizeof(mainform.BeatImpuls.SceneOnBeatLost));
        Filestream.ReadBuffer(mainform.BeatImpuls.SceneOnBeatStart,sizeof(mainform.BeatImpuls.SceneOnBeatStart));
        Filestream.ReadBuffer(mainform.BeatImpuls.Timeout,sizeof(mainform.BeatImpuls.Timeout));
      end else
      begin
        BeatImpuls.SceneOnBeatLost:=StringToGUID('{00000000-0000-0000-0000-000000000000}');
        BeatImpuls.SceneOnBeatStart:=StringToGUID('{00000000-0000-0000-0000-000000000000}');
        BeatImpuls.Timeout:=5;
      end;
      if projektprogrammversionint>=484 then
      begin
        Filestream.ReadBuffer(mainform.BeatImpuls.SendVolumeToDataIn,sizeof(mainform.BeatImpuls.SendVolumeToDataIn));
        Filestream.ReadBuffer(mainform.BeatImpuls.SendVolumeToDataInChannel,sizeof(mainform.BeatImpuls.SendVolumeToDataInChannel));
      end;
    end else
    begin
      BeatImpuls.Active:=false;
      BeatImpuls.Channel:=400;
      BeatImpuls.OnValue:=255;
      BeatImpuls.OffValue:=0;
      BeatImpuls.SceneOnBeatLost:=StringToGUID('{00000000-0000-0000-0000-000000000000}');
      BeatImpuls.SceneOnBeatStart:=StringToGUID('{00000000-0000-0000-0000-000000000000}');
      BeatImpuls.Timeout:=5;
      BeatImpuls.SendVolumeToDataIn:=false;
      BeatImpuls.SendVolumeToDataInChannel:=401;
    end;
// Ende BeatImpuls
// Geräteselektionen laden
    if projektprogrammversionint>=446 then
    begin
      Filestream.ReadBuffer(Count,sizeof(Count));
      setlength(DeviceSelectedIDs,Count);
      setlength(DeviceSelectedIDsName, Count);
      for i:=0 to length(DeviceSelectedIDs)-1 do
      begin
        Filestream.ReadBuffer(Count2,sizeof(Count2));
        setlength(DeviceSelectedIDs[i],Count2);

        FileStream.ReadBuffer(DeviceSelectedIDsName[i], sizeof(DeviceSelectedIDsName[i]));

        for j:=0 to length(DeviceSelectedIDs[i])-1 do
          FileStream.ReadBuffer(DeviceSelectedIDs[i][j], sizeof(DeviceSelectedIDs[i][j]));
      end;
    end;
// Geräteselektionen laden Ende
  end;
  if projektprogrammversionint>=458 then
  begin
// Ambilight laden
    Filestream.ReadBuffer(Count,sizeof(Count));
    setlength(ambilights,Count);
    for i:=0 to Count-1 do
    begin
      Filestream.ReadBuffer(Count2,sizeof(Count2));
      setlength(ambilights[i],Count2);
      for j:=0 to Count2-1 do
        Filestream.ReadBuffer(ambilights[i][j],sizeof(ambilights[i][j]));
    end;
// Ambilight laden Ende
  end;
  if projektprogrammversionint>=459 then
  begin
// PartyMuckenModul laden
    Filestream.ReadBuffer(Count,sizeof(Count));
    setlength(pmmlights, Count);
    for i:=0 to Count-1 do
      Filestream.ReadBuffer(pmmlights[i],sizeof(pmmlights[i]));

    Filestream.ReadBuffer(Count,sizeof(Count));
    setlength(PartyMuckenModul, Count);
    for i:=0 to Count-1 do
    begin
      Filestream.ReadBuffer(PartyMuckenModul[i].Name,sizeof(PartyMuckenModul[i].Name));
      Filestream.ReadBuffer(PartyMuckenModul[i].ControlMode,sizeof(PartyMuckenModul[i].ControlMode));
      Filestream.ReadBuffer(PartyMuckenModul[i].UsePanTilt,sizeof(PartyMuckenModul[i].UsePanTilt));
      Filestream.ReadBuffer(PartyMuckenModul[i].UseRandom,sizeof(PartyMuckenModul[i].UseRandom));
      Filestream.ReadBuffer(PartyMuckenModul[i].MaxFadetime,sizeof(PartyMuckenModul[i].MaxFadetime));
      Filestream.ReadBuffer(PartyMuckenModul[i].MaxPanTiltTime,sizeof(PartyMuckenModul[i].MaxPanTiltTime));
      Filestream.ReadBuffer(PartyMuckenModul[i].MaxDelayTime,sizeof(PartyMuckenModul[i].MaxDelayTime));
      Filestream.ReadBuffer(PartyMuckenModul[i].UseRed,sizeof(PartyMuckenModul[i].UseRed));
      Filestream.ReadBuffer(PartyMuckenModul[i].UseGreen,sizeof(PartyMuckenModul[i].UseGreen));
      Filestream.ReadBuffer(PartyMuckenModul[i].UseBlue,sizeof(PartyMuckenModul[i].UseBlue));
      if projektprogrammversionint>=476 then
      begin
        Filestream.ReadBuffer(PartyMuckenModul[i].UseAmber,sizeof(PartyMuckenModul[i].UseAmber));
        Filestream.ReadBuffer(PartyMuckenModul[i].UseWhite,sizeof(PartyMuckenModul[i].UseWhite));
      end;
      Filestream.ReadBuffer(PartyMuckenModul[i].MaxRed,sizeof(PartyMuckenModul[i].MaxRed));
      Filestream.ReadBuffer(PartyMuckenModul[i].MaxGreen,sizeof(PartyMuckenModul[i].MaxGreen));
      Filestream.ReadBuffer(PartyMuckenModul[i].MaxBlue,sizeof(PartyMuckenModul[i].MaxBlue));
      if projektprogrammversionint>=476 then
      begin
        Filestream.ReadBuffer(PartyMuckenModul[i].MaxAmber,sizeof(PartyMuckenModul[i].MaxAmber));
        Filestream.ReadBuffer(PartyMuckenModul[i].MaxWhite,sizeof(PartyMuckenModul[i].MaxWhite));
      end;
      Filestream.ReadBuffer(PartyMuckenModul[i].AllowMixing,sizeof(PartyMuckenModul[i].AllowMixing));
      Filestream.ReadBuffer(PartyMuckenModul[i].NoBlackDevices,sizeof(PartyMuckenModul[i].NoBlackDevices));
      Filestream.ReadBuffer(PartyMuckenModul[i].UseRGB,sizeof(PartyMuckenModul[i].UseRGB));
      if projektprogrammversionint>=476 then
      begin
        Filestream.ReadBuffer(PartyMuckenModul[i].UseAW,sizeof(PartyMuckenModul[i].UseAW));
        Filestream.ReadBuffer(PartyMuckenModul[i].UseUV,sizeof(PartyMuckenModul[i].UseUV));
      end;
      Filestream.ReadBuffer(PartyMuckenModul[i].UseDimmer,sizeof(PartyMuckenModul[i].UseDimmer));
      Filestream.ReadBuffer(PartyMuckenModul[i].UseColor12,sizeof(PartyMuckenModul[i].UseColor12));
      Filestream.ReadBuffer(PartyMuckenModul[i].MaxLuminance,sizeof(PartyMuckenModul[i].MaxLuminance));
      Filestream.ReadBuffer(PartyMuckenModul[i].MinLuminance,sizeof(PartyMuckenModul[i].MinLuminance));
    end;
// PartyMuckenModul laden Ende
    if projektprogrammversionint>=467 then
    begin
      // PresetSzenen öffnen
      if not startingup then
      begin
        inprogress.filename.Caption:=_('Lese Daten ein... Preset-Szenen');
        inprogress.Refresh;
      end else
      begin
        SplashCaptioninfo(_('Lese Daten ein...Preset-Szenen'));
        RefreshSplashText;
      end;

      Filestream.ReadBuffer(Count,sizeof(Count));
      setlength(mainform.PresetScenes,Count);
      for i:=0 to Count-1 do
      begin
        Filestream.ReadBuffer(mainform.PresetScenes[i].ID,sizeof(mainform.PresetScenes[i].ID));
        Filestream.ReadBuffer(mainform.PresetScenes[i].Name,sizeof(mainform.PresetScenes[i].Name));
        Filestream.ReadBuffer(mainform.PresetScenes[i].Beschreibung,sizeof(mainform.PresetScenes[i].Beschreibung));
        Filestream.ReadBuffer(PresetScenes[i].Category,sizeof(PresetScenes[i].Category));

        Filestream.ReadBuffer(count2,sizeof(count2));
        setlength(mainform.PresetScenes[i].Devices,count2);
        for k:=0 to count2-1 do
          Filestream.ReadBuffer(mainform.PresetScenes[i].Devices[k],sizeof(mainform.PresetScenes[i].Devices[k]));

        Filestream.ReadBuffer(mainform.PresetScenes[i].Color,sizeof(mainform.PresetScenes[i].Color));
        Filestream.ReadBuffer(mainform.PresetScenes[i].Shutter,sizeof(mainform.PresetScenes[i].Shutter));
        Filestream.ReadBuffer(mainform.PresetScenes[i].Dimmer,sizeof(mainform.PresetScenes[i].Dimmer));
        Filestream.ReadBuffer(mainform.PresetScenes[i].Iris,sizeof(mainform.PresetScenes[i].Iris));
        Filestream.ReadBuffer(mainform.PresetScenes[i].Focus,sizeof(mainform.PresetScenes[i].Focus));
        Filestream.ReadBuffer(mainform.PresetScenes[i].PrismaRot,sizeof(mainform.PresetScenes[i].PrismaRot));
        Filestream.ReadBuffer(mainform.PresetScenes[i].PrismaEnabled,sizeof(mainform.PresetScenes[i].PrismaEnabled));
        Filestream.ReadBuffer(mainform.PresetScenes[i].Strobe,sizeof(mainform.PresetScenes[i].Strobe));
        Filestream.ReadBuffer(mainform.PresetScenes[i].Pan,sizeof(mainform.PresetScenes[i].Pan));
        Filestream.ReadBuffer(mainform.PresetScenes[i].Tilt,sizeof(mainform.PresetScenes[i].Tilt));
        Filestream.ReadBuffer(mainform.PresetScenes[i].PanFine,sizeof(mainform.PresetScenes[i].PanFine));
        Filestream.ReadBuffer(mainform.PresetScenes[i].TiltFine,sizeof(mainform.PresetScenes[i].TiltFine));
        Filestream.ReadBuffer(mainform.PresetScenes[i].Gobo,sizeof(mainform.PresetScenes[i].Gobo));
        Filestream.ReadBuffer(mainform.PresetScenes[i].GoboRot1,sizeof(mainform.PresetScenes[i].GoboRot1));
        Filestream.ReadBuffer(mainform.PresetScenes[i].GoboRot2,sizeof(mainform.PresetScenes[i].GoboRot2));
      end;
    end;
// Ende Preset-Szenen
// NodeControl laden
    if projektprogrammversionint>=470 then
    begin
      if not startingup then
      begin
        inprogress.filename.Caption:=_('Lese Daten ein... Knotensteuerung');
        inprogress.Refresh;
      end else
      begin
        SplashCaptioninfo(_('Lese Daten ein...Knotensteuerung'));
        RefreshSplashText;
      end;

  	  Filestream.ReadBuffer(Count,sizeof(Count));
      setlength(mainform.NodeControlSets, Count);
      for i:=0 to Count-1 do
      begin
     	  Filestream.ReadBuffer(mainform.NodeControlSets[i].ID,sizeof(mainform.NodeControlSets[i].ID));
     	  Filestream.ReadBuffer(mainform.NodeControlSets[i].Name,sizeof(mainform.NodeControlSets[i].Name));
     	  Filestream.ReadBuffer(mainform.NodeControlSets[i].stretching,sizeof(mainform.NodeControlSets[i].stretching));
     	  Filestream.ReadBuffer(mainform.NodeControlSets[i].contrast,sizeof(mainform.NodeControlSets[i].contrast));
     	  Filestream.ReadBuffer(mainform.NodeControlSets[i].fadetime,sizeof(mainform.NodeControlSets[i].fadetime));
   	    Filestream.ReadBuffer(mainform.NodeControlSets[i].ChangeRGB,sizeof(mainform.NodeControlSets[i].ChangeRGB));
   	    Filestream.ReadBuffer(mainform.NodeControlSets[i].ChangeA,sizeof(mainform.NodeControlSets[i].ChangeA));
     	  Filestream.ReadBuffer(mainform.NodeControlSets[i].ChangeW,sizeof(mainform.NodeControlSets[i].ChangeW));
     	  Filestream.ReadBuffer(mainform.NodeControlSets[i].ChangeDimmer,sizeof(mainform.NodeControlSets[i].ChangeDimmer));
     	  Filestream.ReadBuffer(mainform.NodeControlSets[i].StageViewScaling,sizeof(mainform.NodeControlSets[i].StageViewScaling));

     	  Filestream.ReadBuffer(count2,sizeof(count2));
        setlength(mainform.NodeControlSets[i].NodeControlNodes, count2);
        for k:=0 to count2-1 do
       	begin
          if projektprogrammversionint>=473 then
            Filestream.ReadBuffer(mainform.NodeControlSets[i].NodeControlNodes[k].ID,sizeof(mainform.NodeControlSets[i].NodeControlNodes[k].ID))
          else
            CreateGUID(mainform.NodeControlSets[i].NodeControlNodes[k].ID);
          Filestream.ReadBuffer(mainform.NodeControlSets[i].NodeControlNodes[k].Name,sizeof(mainform.NodeControlSets[i].NodeControlNodes[k].Name));
          Filestream.ReadBuffer(mainform.NodeControlSets[i].NodeControlNodes[k].X,sizeof(mainform.NodeControlSets[i].NodeControlNodes[k].X));
          Filestream.ReadBuffer(mainform.NodeControlSets[i].NodeControlNodes[k].Y,sizeof(mainform.NodeControlSets[i].NodeControlNodes[k].Y));
          Filestream.ReadBuffer(mainform.NodeControlSets[i].NodeControlNodes[k].Z,sizeof(mainform.NodeControlSets[i].NodeControlNodes[k].Z));
          Filestream.ReadBuffer(mainform.NodeControlSets[i].NodeControlNodes[k].R,sizeof(mainform.NodeControlSets[i].NodeControlNodes[k].R));
          Filestream.ReadBuffer(mainform.NodeControlSets[i].NodeControlNodes[k].G,sizeof(mainform.NodeControlSets[i].NodeControlNodes[k].G));
          Filestream.ReadBuffer(mainform.NodeControlSets[i].NodeControlNodes[k].B,sizeof(mainform.NodeControlSets[i].NodeControlNodes[k].B));
          Filestream.ReadBuffer(mainform.NodeControlSets[i].NodeControlNodes[k].A,sizeof(mainform.NodeControlSets[i].NodeControlNodes[k].A));
          Filestream.ReadBuffer(mainform.NodeControlSets[i].NodeControlNodes[k].W,sizeof(mainform.NodeControlSets[i].NodeControlNodes[k].W));
          Filestream.ReadBuffer(mainform.NodeControlSets[i].NodeControlNodes[k].Dimmer,sizeof(mainform.NodeControlSets[i].NodeControlNodes[k].Dimmer));
          Filestream.ReadBuffer(mainform.NodeControlSets[i].NodeControlNodes[k].UseRGB,sizeof(mainform.NodeControlSets[i].NodeControlNodes[k].UseRGB));
          Filestream.ReadBuffer(mainform.NodeControlSets[i].NodeControlNodes[k].UseA,sizeof(mainform.NodeControlSets[i].NodeControlNodes[k].UseA));
          Filestream.ReadBuffer(mainform.NodeControlSets[i].NodeControlNodes[k].UseW,sizeof(mainform.NodeControlSets[i].NodeControlNodes[k].UseW));
          Filestream.ReadBuffer(mainform.NodeControlSets[i].NodeControlNodes[k].UseDimmer,sizeof(mainform.NodeControlSets[i].NodeControlNodes[k].UseDimmer));
        end;
      end;
    end;
// Ende NodeControl
// XTouchControl laden
    if projektprogrammversionint>=485 then
    begin
      if not startingup then
      begin
        inprogress.filename.Caption:=_('Lese Daten ein... XTouchControl');
        inprogress.Refresh;
      end else
      begin
        SplashCaptioninfo(_('Lese Daten ein...XTouchControl'));
        RefreshSplashText;
      end;

      Filestream.ReadBuffer(Count,sizeof(Count));
      setlength(mainform.XTouchPCDDevicesOrGroups, Count);
      for i:=0 to Count-1 do
      begin
        Filestream.ReadBuffer(mainform.XTouchPCDDevicesOrGroups[i].ID,sizeof(mainform.XTouchPCDDevicesOrGroups[i].ID));
      end;
      if projektprogrammversionint>=490 then
      begin
        Filestream.ReadBuffer(Count,sizeof(Count));
        setlength(XTouchBefehle, Count);
        if length(XTouchBefehle)<length(XTouchDevices) then
          setlength(XTouchBefehle, length(XTouchDevices));
        for i:=0 to Count-1 do
        begin
          for j:=0 to 17 do
          begin
            Filestream.ReadBuffer(XTouchBefehle[i][j].Typ,sizeof(XTouchBefehle[i][j].Typ));
            Filestream.ReadBuffer(XTouchBefehle[i][j].OnValue,sizeof(XTouchBefehle[i][j].OnValue));
            Filestream.ReadBuffer(XTouchBefehle[i][j].SwitchValue,sizeof(XTouchBefehle[i][j].SwitchValue));
            Filestream.ReadBuffer(XTouchBefehle[i][j].InvertSwitchValue,sizeof(XTouchBefehle[i][j].InvertSwitchValue));
            Filestream.ReadBuffer(XTouchBefehle[i][j].OffValue,sizeof(XTouchBefehle[i][j].OffValue));
            Filestream.ReadBuffer(XTouchBefehle[i][j].ScaleValue,sizeof(XTouchBefehle[i][j].ScaleValue));
            Filestream.ReadBuffer(Count2,sizeof(Count2));
            setlength(XTouchBefehle[i][j].ArgInteger,Count2);
            for k:=0 to Count2-1 do
              Filestream.ReadBuffer(XTouchBefehle[i][j].ArgInteger[k],sizeof(XTouchBefehle[i][j].ArgInteger[k]));
            Filestream.ReadBuffer(Count2,sizeof(Count2));
            setlength(XTouchBefehle[i][j].ArgString,Count2);
            for k:=0 to Count2-1 do
              Filestream.ReadBuffer(XTouchBefehle[i][j].ArgString[k],sizeof(XTouchBefehle[i][j].ArgString[k]));
            Filestream.ReadBuffer(Count2,sizeof(Count2));
            setlength(XTouchBefehle[i][j].ArgGUID,Count2);
            for k:=0 to Count2-1 do
              Filestream.ReadBuffer(XTouchBefehle[i][j].ArgGUID[k],sizeof(XTouchBefehle[i][j].ArgGUID[k]));
          end;
        end;
      end;
    end;
// Ende XTouchControl
// CodeScene laden
    if projektprogrammversionint>=491 then
    begin
      if not startingup then
      begin
        inprogress.filename.Caption:=_('Lese Daten ein... Code-Szenen');
        inprogress.Refresh;
      end else
      begin
        SplashCaptioninfo(_('Lese Daten ein...Code-Szenen'));
        RefreshSplashText;
      end;

      Filestream.ReadBuffer(Count,sizeof(Count));
      setlength(mainform.CodeScenes,Count);
      for i:=0 to Count-1 do
      begin
        Filestream.ReadBuffer(mainform.CodeScenes[i].ID,sizeof(mainform.CodeScenes[i].ID));
        Filestream.ReadBuffer(mainform.CodeScenes[i].Name,sizeof(mainform.CodeScenes[i].Name));
        Filestream.ReadBuffer(mainform.CodeScenes[i].Beschreibung,sizeof(mainform.CodeScenes[i].Beschreibung));
        Filestream.ReadBuffer(mainform.CodeScenes[i].Category,sizeof(mainform.CodeScenes[i].Category));
        Filestream.ReadBuffer(Count2,sizeof(Count2));
        setlength(mainform.CodeScenes[i].Code,Count2);
        Filestream.ReadBuffer(Pointer(mainform.CodeScenes[i].Code)^, Count2);
      end;
    end;
// Ende CodeScene
// StreamDeck laden
    if projektprogrammversionint>=491 then
    begin
      if not startingup then
      begin
        inprogress.filename.Caption:=_('Lese Daten ein... StreamDeck');
        inprogress.Refresh;
      end else
      begin
        SplashCaptioninfo(_('Lese Daten ein...StreamDeck'));
        RefreshSplashText;
      end;

      Filestream.ReadBuffer(Count,sizeof(Count));
      setlength(mainform.ElgatoStreamDeckArray,Count);
      for i:=0 to Count-1 do
      begin
        Filestream.ReadBuffer(mainform.ElgatoStreamDeckArray[i].Serial,sizeof(mainform.ElgatoStreamDeckArray[i].Serial));
        Filestream.ReadBuffer(mainform.ElgatoStreamDeckArray[i].ButtonCount,sizeof(mainform.ElgatoStreamDeckArray[i].ButtonCount));
        Filestream.ReadBuffer(mainform.ElgatoStreamDeckArray[i].Brightness,sizeof(mainform.ElgatoStreamDeckArray[i].Brightness));
        Filestream.ReadBuffer(mainform.ElgatoStreamDeckArray[i].UseAutoModeOnLastButton,sizeof(mainform.ElgatoStreamDeckArray[i].UseAutoModeOnLastButton));
        for j:=0 to 31 do
        begin
          Filestream.ReadBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].ButtonType,sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].ButtonType));
          Filestream.ReadBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].KontrollpanelX,sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].KontrollpanelX));
          Filestream.ReadBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].KontrollpanelY,sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].KontrollpanelY));
          Filestream.ReadBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].DeviceOrGroupID,sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].DeviceOrGroupID));
          Filestream.ReadBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].DataInChannel,sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].DataInChannel));
          Filestream.ReadBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].UseHoldToChange,sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].UseHoldToChange));
          Filestream.ReadBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].Increment,sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].Increment));

          Filestream.ReadBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.Typ,sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.Typ));
          Filestream.ReadBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.OnValue,sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.OnValue));
          Filestream.ReadBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.SwitchValue,sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.SwitchValue));
          Filestream.ReadBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.InvertSwitchValue,sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.InvertSwitchValue));
          Filestream.ReadBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.OffValue,sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.OffValue));
          Filestream.ReadBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.ScaleValue,sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.ScaleValue));
          Filestream.ReadBuffer(Count2,sizeof(Count2));
          setlength(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.ArgInteger,Count2);
          for k:=0 to Count2-1 do
            Filestream.ReadBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.ArgInteger[k],sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.ArgInteger[k]));
          Filestream.ReadBuffer(Count2,sizeof(Count2));
          setlength(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.ArgString,Count2);
          for k:=0 to Count2-1 do
            Filestream.ReadBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.ArgString[k],sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.ArgString[k]));
          Filestream.ReadBuffer(Count2,sizeof(Count2));
          setlength(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.ArgGUID,Count2);
          for k:=0 to Count2-1 do
            Filestream.ReadBuffer(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.ArgGUID[k],sizeof(mainform.ElgatoStreamDeckArray[i].Buttons[j].Befehl.ArgGUID[k]));
        end;
      end;
    end;
// Ende StreamDeck
  end;

	if not startingup then
  begin
	  inprogress.filename.Caption:=_('Lese Daten ein... Fertig.');
    inprogress.ProgressBar1.Position:=71;
	 	inprogress.Refresh;
  end else
  begin
    SplashCaptioninfo(_('Lese Daten ein...Fertig.'));
    SplashProgress(1, 88, 100);
    SplashAddText(_('Lese Daten ein...'));
    RefreshSplashText;
  end;
      FileStream.Free;
      // Ende von aktueller Version
    end else
    begin
      FileStream.Free;
      openerror:=true;
//      MessageDlg('Die Projektdatei ist in einem alten Format. Bitte nutzen Sie die Projektkonvertierung, um das Projekt in die neue Version zu konvertieren.'+#10+#10+'Projektversion: '+projektprogrammversion+#10+'Datum: '+projektdatum+#10+'Uhrzeit: '+projektuhrzeit, mtError, [mbOk], 0);
      ownmessageform.captionlbl.Caption:=_('Fehler in Projektdatei');
      ownmessageform.descriptionlbl.Caption:=_('Die Projektdatei ist veraltet');
      ownmessageform.meldung.Clear;
      ownmessageform.meldung.Lines.Add(_('Die Projektdatei ist in einem alten Format. Bitte nutzen Sie die Projektkonvertierung, um das Projekt in die neue Version zu konvertieren.'));
      ownmessageform.meldung.Lines.Add('');
      ownmessageform.meldung.Lines.Add(_('Projektversion: ')+projektprogrammversion);
      ownmessageform.meldung.Lines.Add(_('Datum: ')+projektdatum);
      ownmessageform.meldung.Lines.Add(_('Uhrzeit: ')+projektuhrzeit);
      ownmessageform.meldung.Lines.Add('');
      ownmessageform.meldung.Lines.Add(_('Letzte Meldung: ')+inprogress.filename.Caption);
      ownmessageform.ClientHeight:=220;
      ownmessageform.ClientWidth:=550;
      ownmessageform.CancelBtn.Visible:=false;
      ownmessageform.caption:=_('Fehler in Projektdatei');
      ownmessageform.showmodal;
      // Projektverzeichnis reinigen
      DeleteDirectory(userdirectory+'ProjectTemp');
      CreateDir(userdirectory+'ProjectTemp');
    	CreateDir(userdirectory+'ProjectTemp\Kontrollpanel');
    end;
  except
    FileStream.Free;
//    MessageDlg('Die Projektdatei ist möglicherweise beschädigt, oder in einem falschen Format!'+#10+#10+'Projektversion: '+projektprogrammversion+#10+'Datum: '+projektdatum+#10+'Uhrzeit: '+projektuhrzeit+#10+#10+'Letzte Meldung: '+inprogress.filename.Caption, mtError, [mbOk], 0);

    ownmessageform.captionlbl.Caption:=_('Fehler in Projektdatei');
    ownmessageform.descriptionlbl.Caption:=_('Projektdatei konnte aufgrund eines Fehlers nicht geöffnet werden...');
    ownmessageform.meldung.Clear;
    ownmessageform.meldung.Lines.Add(_('Die Projektdatei ist möglicherweise beschädigt, oder in einem falschen Format! Senden Sie das Projekt bitte an das PC_DIMMER-Team.'));
    ownmessageform.meldung.Lines.Add('');
    ownmessageform.meldung.Lines.Add(_('Projektversion: ')+projektprogrammversion);
    ownmessageform.meldung.Lines.Add(_('Datum: ')+projektdatum);
    ownmessageform.meldung.Lines.Add(_('Uhrzeit: ')+projektuhrzeit);
    ownmessageform.meldung.Lines.Add('');
    ownmessageform.meldung.Lines.Add(_('Letzte Meldung: ')+inprogress.filename.Caption);
    ownmessageform.ClientHeight:=220;
    ownmessageform.ClientWidth:=550;
    ownmessageform.CancelBtn.Visible:=false;
    ownmessageform.caption:=_('Fehler in Projektdatei');
    ownmessageform.showmodal;

    openerror:=true;
    DebugAdd('FILE: Loading PC_DIMMER-Project failed - bad file!');
    // Projektverzeichnis reinigen
    DeleteDirectory(userdirectory+'ProjectTemp');
    CreateDir(userdirectory+'ProjectTemp');
  	CreateDir(userdirectory+'ProjectTemp\Kontrollpanel');
  end;

  // Bugfix für Fehlerhafte Array-Länge bei Gruppeneinträgen in Geräteszenen von alten Projekten
  for i:=0 to length(devicescenes)-1 do
  begin
    for j:=0 to length(devicescenes[i].Devices)-1 do
    begin
      if geraetesteuerung.GetGroupPositionInGroupArray(devicescenes[i].devices[j].ID)>-1 then
      begin
        setlength(devicescenes[i].Devices[j].ChanActive, length(mainform.DeviceChannelNames));
        setlength(devicescenes[i].Devices[j].ChanActiveRandom, length(mainform.DeviceChannelNames));
        setlength(devicescenes[i].Devices[j].ChanValue, length(mainform.DeviceChannelNames));
        setlength(devicescenes[i].Devices[j].ChanValueRandom, length(mainform.DeviceChannelNames));
        setlength(devicescenes[i].Devices[j].ChanDelay, length(mainform.DeviceChannelNames));
        setlength(devicescenes[i].Devices[j].ChanFadetime, length(mainform.DeviceChannelNames));
      end;
    end;
  end;

  for i:=0 to length(data.ch)-1 do
    data.ch[i]:=maxres;

  // Der Anwendung genügend Zeit geben
//  Application.ProcessMessages;
//  sleep(250);

  refreshmidi;
  refreshdatain;

  if openerror=true then
  begin
    project_file:='';
    // Projektverzeichnis reinigen
    DeleteDirectory(userdirectory+'ProjectTemp');
    CreateDir(userdirectory+'ProjectTemp');
  	CreateDir(userdirectory+'ProjectTemp\Kontrollpanel');
  end;

  if openerror=false then
  begin
    if not startingup then
    begin
      inprogress.filename.Caption:=_('Sende Öffnen-Befehl...Kontrollpanel');
      inprogress.ProgressBar1.Position:=75;
      inprogress.Refresh;
    end else
    begin
      SplashCaptioninfo(_('Sende Öffnen-Befehl... Kontrollpanel'));
      SplashProgress(1, 89, 100);
      RefreshSplashText;
    end;
    kontrollpanel.MSGOpen(nil);
    if not startingup then
    begin
      inprogress.filename.Caption:=_('Sende Öffnen-Befehl...Effektsequenzer');
      inprogress.ProgressBar1.Position:=78;
      inprogress.Refresh;
    end else
    begin
      SplashCaptioninfo(_('Sende Öffnen-Befehl... Effektsequenzer'));
      SplashProgress(1, 90, 100);
      RefreshSplashText;
    end;
    effektsequenzer.MSGopen;
    if not startingup then
    begin
      inprogress.filename.Caption:=_('Sende Öffnen-Befehl...Beattool');
      inprogress.Refresh;
    end else
    begin
      SplashCaptioninfo(_('Sende Öffnen-Befehl... Beattool'));
      RefreshSplashText;
    end;
    beatform.MSGopen;
    if not startingup then
    begin
      inprogress.filename.Caption:=_('Sende Öffnen-Befehl...Gerätesteuerung');
      inprogress.Refresh;
    end else
    begin
      SplashCaptioninfo(_('Sende Öffnen-Befehl... Gerätesteuerung'));
      RefreshSplashText;
    end;
    geraetesteuerung.RefreshDeviceControl;
    groupeditorform.GroupListChanged;
    if not startingup then
    begin
      inprogress.filename.Caption:=_('Sende Öffnen-Befehl...Submaster');
      inprogress.ProgressBar1.Position:=81;
      inprogress.Refresh;
    end else
    begin
      SplashCaptioninfo(_('Sende Öffnen-Befehl... Submaster'));
      SplashProgress(1, 91, 100);
      RefreshSplashText;
    end;
    submasterform.msgopen;
    if not startingup then
    begin
      inprogress.filename.Caption:=_('Sende Öffnen-Befehl...Grafische Bühnenansicht');
      inprogress.Refresh;
    end else
    begin
      SplashCaptioninfo(_('Sende Öffnen-Befehl... Bühnenansicht'));
      RefreshSplashText;
    end;
    grafischebuehnenansicht.MSGOpen;
    if not startingup then
    begin
      inprogress.filename.Caption:=_('Sende Öffnen-Befehl...Audioeffektplayer');
      inprogress.Refresh;
    end else
    begin
      SplashCaptioninfo(_('Sende Öffnen-Befehl... Audioeffektplayer'));
      RefreshSplashText;
    end;
    if not startingup then
    begin
      inprogress.filename.Caption:=_('Sende Öffnen-Befehl...Textbuch');
      inprogress.ProgressBar1.Position:=87;
      inprogress.Refresh;
    end else
    begin
      SplashCaptioninfo(_('Sende Öffnen-Befehl... Textbuch'));
      SplashProgress(1, 92, 100);
      RefreshSplashText;
    end;
    Textbuchform.MSGOpen(textbuchform.TextbuchFile);

    if not startingup then
    begin
      inprogress.filename.Caption:=_('Sende Öffnen-Befehl...Cue-List');
      inprogress.Refresh;
    end else
    begin
      SplashCaptioninfo(_('Sende Öffnen-Befehl... Cue-List'));
      RefreshSplashText;
    end;
    Cuelistform.MSGOpen;

    if not startingup then
    begin
      inprogress.filename.Caption:=_('Sende Öffnen-Befehl...Timecodeplayer');
      inprogress.Refresh;
    end else
    begin
      SplashCaptioninfo(_('Sende Öffnen-Befehl... Timecodeplayer'));
      RefreshSplashText;
    end;
    timecodeplayerform.MSGOpen;

    if not startingup then
    begin
      inprogress.filename.Caption:=_('Sende Öffnen-Befehl...IR Steuerung');
      inprogress.Refresh;
    end else
    begin
      SplashCaptioninfo(_('Sende Öffnen-Befehl... IR Steuerung'));
      RefreshSplashText;
    end;
    winlircform.RefreshStringGrid;

    // Ambilight aktualisieren
    if ambilightform.Showing then
      ambilightform.RefreshListboxes;

    // PartyMuckenModul aktualisieren
    pmmform.RefreshListboxes;

    if not startingup then
    begin
      inprogress.filename.Caption:=_('Sende Öffnen-Befehl...Knotensteuerung');
      inprogress.Refresh;
    end else
    begin
      SplashCaptioninfo(_('Sende Öffnen-Befehl... Knotensteuerung'));
      RefreshSplashText;
    end;
    nodecontrolform.MSGOpen;

    if not startingup then
    begin
      inprogress.filename.Caption:=_('Sende Öffnen-Befehl...XTouchControl');
      inprogress.Refresh;
    end else
    begin
      SplashCaptioninfo(_('Sende Öffnen-Befehl... XTouchControl'));
      RefreshSplashText;
    end;
    xtouchcontrolform.MSGOpen;

    if not startingup then
    begin
      inprogress.filename.Caption:=_('Sende Öffnen-Befehl...StreamDeckControl');
      inprogress.Refresh;
    end else
    begin
      SplashCaptioninfo(_('Sende Öffnen-Befehl... StreamDeckControl'));
      RefreshSplashText;
    end;
    elgatostreamdeckform.MSGOpen;

    if not startingup then
    begin
      inprogress.filename.Caption:=_('Aktualisiere Hauptprogramm');
      inprogress.ProgressBar1.Position:=90;
      inprogress.Refresh;
    end else
    begin
      SplashCaptioninfo(_('Aktualisiere Hauptprogramm'));
      SplashAddText(_('Sende Öffnen-Befehl...'));
      SplashProgress(1, 93, 100);
      RefreshSplashText;
    end;
    if FileExists(autoload_project_file) then
    begin
      Openfilename:=ExtractFileName(autoload_project_file);
      Openfilepath:=ExtractFilePath(autoload_project_file);
      project_file:=autoload_project_file;
      autoload_project_file:='';
    end;
    if Openfilepath+Openfilename=userdirectory+'ProjectTemp\Projekt' then
      mainform.Caption:=maincaption+_(' - [Nicht gespeichertes Projekt]')
    else
      mainform.Caption:=maincaption+' - ['+Openfilename+']';

    if szenenverwaltung_formarray[0].Showing then
      szenenverwaltung_formarray[0].FormShow(nil);

    // OpenHistory aktualisieren
    AddToOpenHistory(Openfilepath+Openfilename);

    audioeffektplayerform.audioeffektfilenamebox.Clear;
    if laenge>0 then
    for i:=0 to laenge-1 do
    begin
      if not FileExists(Effektaudio_record[i].audiopfad+Effektaudio_record[i].audiodatei) then
        if pos('\ProjectTemp\',Effektaudio_record[i].audiopfad)>0 then
          Effektaudio_record[i].audiopfad:=userdirectory+copy(Effektaudio_record[i].audiopfad,pos('ProjectTemp\',Effektaudio_record[i].audiopfad),length(Effektaudio_record[i].audiopfad));

      if FileExists(mainform.Effektaudio_record[i].audiopfad+mainform.Effektaudio_record[i].audiodatei) then
      begin
        audioeffektplayerform.audioeffektfilenamebox.Items.Add(inttostr(i+1)+' - '+mainform.Effektaudio_record[i].audiodatei);
      end else
      if FileExists(mainform.project_folder+mainform.Effektaudio_record[i].audiodatei) then
      begin
        mainform.Effektaudio_record[i].audiopfad:=mainform.project_folder;
        audioeffektplayerform.audioeffektfilenamebox.Items.Add(inttostr(i+1)+' - '+mainform.Effektaudio_record[i].audiodatei);
      end else
      if (i>0) and FileExists(mainform.Effektaudio_record[i-1].audiopfad+mainform.Effektaudio_record[i].audiodatei) then
      begin
        mainform.Effektaudio_record[i].audiopfad:=mainform.Effektaudio_record[i-1].audiopfad;
        audioeffektplayerform.audioeffektfilenamebox.Items.Add(inttostr(i+1)+' - '+mainform.Effektaudio_record[i].audiodatei);
      end else
      begin
        if messagedlg(_('Die Audiodatei "')+Effektaudio_record[i].audiopfad+Effektaudio_record[i].audiodatei+_('" wurde nicht gefunden. Möchten Sie jetzt danach suchen?'),mtConfirmation,
          [mbYes,mbNo],0)=mrYes then
          begin
            OpenDialog.Filter:=_('Audiodateien (*.wav;*.mp3)|*.wav;*.mp3|All files (*.*)|*.*');
            OpenDialog.Title:=_('Audiodatei öffnen');
            opendialog.FileName:='';
            if project_folder<>'' then opendialog.InitialDir:=project_folder;
            if OpenDialog.Execute then
            begin
              Effektaudio_record[i].audiopfad:=ExtractFilePath(OpenDialog.FileName);
              Effektaudio_record[i].audiodatei:=ExtractFileName(OpenDialog.FileName);
              audioeffektplayerform.audioeffektfilenamebox.Items.Add(inttostr(i+1)+' - '+ExtractFileName(OpenDialog.FileName));
              scan:=true;
            end;
          end else audioeffektplayerform.audioeffektfilenamebox.Items.Add(inttostr(i+1)+' - '+Effektaudio_record[i].audiodatei);
      end;
    end;
    audioeffektplayerform.audioeffektfilenamebox.items.Add(_('Neue Audiodatei...'));
    audioeffektplayerform.audioeffektfilenamebox.ItemIndex:=0;
    if (audioeffektplayerform.audioeffektfilenamebox.Items.Count>1) then
    begin
      audioeffektplayerform.Button20.Enabled:=true;
      audioeffektplayerform.button21.Enabled:=true;
    end else
    begin
      audioeffektplayerform.Button18.Enabled:=false;
//    	audioeffektplayerform.Button20.Enabled:=false;
      audioeffektplayerform.button21.Enabled:=false;
    end;
    audioeffektplayerform.audioeffektfilenameboxChange(nil);

    if scan then
    begin
      TScanThread.create(audioeffektplayerform._decodechan);
    end;

    audioeffektplayerform._stereowaveform:=audioeffektplayerform.checkbox9.Checked;

    schedulerform.skripttimer_listbox.Clear;
    for i:=0 to length(Ablauftimer)-1 do
    begin
      case Ablauftimer[i].LoadTyp of
        0..1:
        begin
          case Ablauftimer[i].TimerTyp of
            0, 100, 200: schedulerform.skripttimer_listbox.ItemIndex:=schedulerform.skripttimer_listbox.Items.Add(_('<EINMALIG>    ')+Ablauftimer[i].Datum+' '+Ablauftimer[i].Uhrzeit+' : '+Ablauftimer[i].Name);
            1, 101, 201: schedulerform.skripttimer_listbox.ItemIndex:=schedulerform.skripttimer_listbox.Items.Add(_('<TÄGLICH>     ')+'-          '+Ablauftimer[i].Uhrzeit+' : '+Ablauftimer[i].Name);
            2, 102, 202: schedulerform.skripttimer_listbox.ItemIndex:=schedulerform.skripttimer_listbox.Items.Add(_('<WÖCHENTLICH> ')+Wochentag(StrToDate(Ablauftimer[i].Datum))+' '+Ablauftimer[i].Uhrzeit+' : '+Ablauftimer[i].Name);
            3, 103, 203: schedulerform.skripttimer_listbox.ItemIndex:=schedulerform.skripttimer_listbox.Items.Add(_('<MONATLICH>   ')+_('jeden')+' '+copy(Ablauftimer[i].Datum,0,2)+'.  '+Ablauftimer[i].Uhrzeit+' : '+Ablauftimer[i].Name);
            4, 104, 204: schedulerform.skripttimer_listbox.ItemIndex:=schedulerform.skripttimer_listbox.Items.Add(_('<JÄHRLICH>    ')+copy(Ablauftimer[i].Datum,0,6)+'     '+Ablauftimer[i].Uhrzeit+' : '+Ablauftimer[i].Name);
          end;
        end;
        2:
        begin
          case Ablauftimer[i].TimerTyp of
            0, 100, 200: schedulerform.skripttimer_listbox.ItemIndex:=schedulerform.skripttimer_listbox.Items.Add(_('<EINMALIG>    ')+Ablauftimer[i].Datum+' '+Ablauftimer[i].Uhrzeit+' : '+ExtractFileName(Ablauftimer[i].Skriptdatei));
            1, 101, 201: schedulerform.skripttimer_listbox.ItemIndex:=schedulerform.skripttimer_listbox.Items.Add(_('<TÄGLICH>     ')+'-          '+Ablauftimer[i].Uhrzeit+' : '+ExtractFileName(Ablauftimer[i].Skriptdatei));
            2, 102, 202: schedulerform.skripttimer_listbox.ItemIndex:=schedulerform.skripttimer_listbox.Items.Add(_('<WÖCHENTLICH> ')+Wochentag(StrToDate(Ablauftimer[i].Datum))+' '+Ablauftimer[i].Uhrzeit+' : '+ExtractFileName(Ablauftimer[i].Skriptdatei));
            3, 103, 203: schedulerform.skripttimer_listbox.ItemIndex:=schedulerform.skripttimer_listbox.Items.Add(_('<MONATLICH>   ')+_('jeden')+' '+copy(Ablauftimer[i].Datum,0,2)+'.  '+Ablauftimer[i].Uhrzeit+' : '+ExtractFileName(Ablauftimer[i].Skriptdatei));
            4, 104, 204: schedulerform.skripttimer_listbox.ItemIndex:=schedulerform.skripttimer_listbox.Items.Add(_('<JÄHRLICH>    ')+copy(Ablauftimer[i].Datum,0,6)+'     '+Ablauftimer[i].Uhrzeit+' : '+ExtractFileName(Ablauftimer[i].Skriptdatei));
          end;
        end;
      end;
    end;

    sidebarselectform.ListBox1.Items.Clear;
    for i:=0 to length(DeviceSelectedIDsName)-1 do
    begin
      sidebarselectform.ListBox1.Items.Add(DeviceSelectedIDsName[i]);
    end;

    pluginsaktualisieren(nil);

    result:=true;
    DebugAdd('FILE: Loaded PC_DIMMER-Project successful...');
  end else
  begin
    // Fehler beim Laden
    result:=false;
  end;

  // Projektgeräte mit Dateien abgleichen
  if projektprogrammversionint<477 then
  begin
    if not startingup then
    begin
      inprogress.filename.Caption:=_('Synchronisiere Gerätedateien...');
      inprogress.Refresh;
    end else
    begin
      SplashCaptioninfo(_('Synchronisiere Gerätedateien...'));
      RefreshSplashText;
    end;

    DebugAdd('DDF: Synchronizing project-ddfs with file-ddfs...');
    if length(geraetesteuerung.DevicePrototyp)<=0 then
      geraetesteuerung.LoadDDFfiles;

    // DDFs komplett neu laden
    for i:=0 to length(devices)-1 do
      DeviceSelected[i]:=true;
    geraetesteuerung.GertemitGertedateiabgleichen1Click(nil);
    for i:=0 to length(devices)-1 do
      DeviceSelected[i]:=false;
    DebugAdd('DDF: Synchronizing ddfs completed.');
  end;

  // Initialisierungsfunktion ausführen
  for i:=0 to length(devices)-1 do
  begin
    for j:=0 to length(geraetesteuerung.DevicePrototyp)-1 do
    begin
      if devices[i].DeviceName=geraetesteuerung.deviceprototyp[j].DeviceName then
      begin
        XML.Xml.LoadFromFile(mainform.pcdimmerdirectory+'\Devices\'+geraetesteuerung.deviceprototyp[j].ddffilename);
        for k:=0 to XML.Xml.Root.Items.Count-1 do
        begin // <device>
          if XML.XML.Root.Items[k].Name='initvalues' then
          begin
            for l:=0 to Devices[i].MaxChan-1 do
            begin
              if XML.XML.Root.Items[k].Properties.IntValue(inttostr(l))>-1 then
                senddata(Devices[i].startaddress+l,maxres-XML.XML.Root.Items[k].Properties.IntValue(inttostr(l)),maxres-XML.XML.Root.Items[k].Properties.IntValue(inttostr(l)),0);
              if XML.XML.Root.Items[k].Properties.IntValue('ch'+inttostr(l))>-1 then
                senddata(Devices[i].startaddress+l,maxres-XML.XML.Root.Items[k].Properties.IntValue('ch'+inttostr(l)),maxres-XML.XML.Root.Items[k].Properties.IntValue('ch'+inttostr(l)),0);
            end;
            break;
          end;
        end;
        break;
      end;
    end;
  end;

  // Befehle ausführen, sofern gewünscht
  for i:=0 to length(Befehle2)-1 do
  begin
    if Befehle2[i].RunOnProjectLoad then
      StartBefehl(Befehle2[i].ID);
  end;

  // Code-Szenen initialisieren
  if not startingup then
  begin
    inprogress.filename.Caption:=_('Initialisiere Code-Szenen');
    inprogress.Refresh;
  end else
  begin
    SplashCaptioninfo(_('Initialisiere Code-Szenen'));
    RefreshSplashText;
  end;
  for i:=0 to length(codescenes)-1 do
  begin
    InitCodeScene(codescenes[i].ID);
  end;


  if not startingup then
  begin
    inprogress.filename.Caption:=_('Fertig');
    inprogress.Refresh;
  end else
  begin
    SplashCaptioninfo(_('Fertig'));
    RefreshSplashText;
  end;

  if not startingup then
	  inprogress.Hide;

  if showownmessageform then
  begin
    ownmessageform.NonModal:=true;
    ownmessageform.show;
    ownmessageform.Refresh;
  end;

  Autobackuptimer.Enabled:=enabled;
end;

procedure TMainform.input_number_minus(var pos:integer; var s:string);
var
  i:integer;
begin
  i:=1;
  while i<=length(s) do
    begin
      if (s[i]<'-') or (s[i]>'9') then
        begin delete(s,i,1); dec(pos); end
      else
        inc(i);
    end;
end;

function TMainform.MyMessageDlg(const Msg: string; DlgType : TMsgDlgType;
                     Buttons : TMsgDlgButtons; Captions: array of string) : Integer;
var
  aMsgDlg : TForm;
  CaptionIndex,
  i : integer;
  dlgButton : TButton;  // uses stdctrls
begin
  // Dlg erzeugen
  aMsgDlg := CreateMessageDialog(Msg, DlgType, buttons);
  CaptionIndex := 0;
  // alle Objekte des Dialoges testen
  for i := 0 to aMsgDlg.ComponentCount - 1 do begin
    // wenn es ein Button ist, dann...
    if (aMsgDlg.Components[i] is TButton) then begin
      dlgButton := TButton(aMsgDlg.Components[i]);
      if CaptionIndex > High(Captions) then Break;
      // Beschriftung entsprechend Captions-array ändern
      dlgButton.Caption := Captions[CaptionIndex];
      Inc(CaptionIndex);
    end;
  end;
//  aMsgDlg.PopupParent := Self;
  Result := aMsgDlg.ShowModal;
end;

procedure TMainform.PCDimmeranzeigen1Click(Sender: TObject);
begin
  if Mainform.Showing then
  begin
    Application.Minimize;
    MainForm.Visible:=false;
  end else
  begin
    Application.Restore;
    MainForm.Visible:=true;
  end;
end;

procedure TMainform.ZuSystrayminimieren1Click(Sender: TObject);
begin
  if Mainform.Showing then
  begin
    Application.Minimize;
    MainForm.Visible:=false;
  end;
end;

procedure TMainform.Uhrzeit_TimerTimer(Sender: TObject);
var
  autolockrealtime, autologoutrealtime:integer;
begin
  if smallwindowstyle and (not mainpanel.Visible) then
    SmallWindowRibbonBtnClick(nil);
  if smallwindowstyle and (mainform.ClientHeight<>(dxRibbon1.ClientHeight+dxRibbonStatusBar1.ClientHeight+mainpanel.ClientHeight)) then
    mainform.ClientHeight:=dxRibbon1.ClientHeight+dxRibbonStatusBar1.ClientHeight+mainpanel.ClientHeight; //dxRibbon1.Height=147

  DimmerkernelChangesPerSecond:=round(DimmerkernelChanges/0.99);
  DimmerkernelChanges:=0;

  MIDIInPacketsFreq:=round(MIDIInPackets/0.99);
  MIDIOutPacketsFreq:=round(MIDIOutPackets/0.99);
  DataInPacketsFreq:=round(DataInPackets/0.99);
  DMXOutPacketsFreq:=round(DMXOutPackets/0.99);
  MIDIInPackets:=0;
  MIDIOutPackets:=0;
  DataInPackets:=0;
  DMXOutPackets:=0;

  schedulerform.skripttimer_time.Caption:=TimeToStr(Time);
  schedulerform.skripttimer_date.Caption:=DateToStr(Date);
  if not skripttimer_offline then
  begin
    if (skripttimer_todo>0) then
      dxRibbonStatusBar1.Panels[5].Text:=_('Scheduler: Warten... (Noch ')+inttostr(skripttimer_todo)+')'
    else
      dxRibbonStatusBar1.Panels[5].Text:=_('Scheduler im Leerlauf...');
  end else
  begin
    dxRibbonStatusBar1.Panels[5].Text:=_('Scheduler: Deaktiviert');
  end;

  if IsBlackoutMode then
  begin
    BlackoutRibbonBtn.Down:=false;
  end else
  begin
    BlackoutRibbonBtn.Down:=true;
  end;

  if audioeffektplayerform<>nil then
  if audioeffektplayerform.RecordModus1.Checked then
  begin
    dxRibbonStatusBar1.Panels[4].Text:='Recording';
    statusbar_imagegreen.Visible:=false;
    statusbar_imageyellow.Visible:=false;
    statusbar_imagered.Visible:=true;
  end else
  begin
    if BASS_ChannelIsActive(audioeffektplayerform._chan[0]) = BASS_ACTIVE_PLAYING then
    begin
    	dxRibbonStatusBar1.Panels[4].Text:='Playing';
      statusbar_imagegreen.Visible:=true;
      statusbar_imageyellow.Visible:=false;
      statusbar_imagered.Visible:=false;
    end else
    begin
    	dxRibbonStatusBar1.Panels[4].Text:='Paused';
      statusbar_imagegreen.Visible:=false;
      statusbar_imageyellow.Visible:=true;
      statusbar_imagered.Visible:=false;
    end;
  end;

  if killsplash and (splashscreenvalue=1) then
  begin
    Splash.Free;
    killsplash:=false;
  end;

  if gotosystray then
  begin
    Application.Minimize;
    MainForm.Visible:=false;
    gotosystray:=false;
  end;

{
  if BeginValueBackups then
    CreateValueBackup;
}

  if (autolocktime>0) then
  begin
    case autolocktime of
      1: autolockrealtime:=1;
      2: autolockrealtime:=2;
      3: autolockrealtime:=5;
      4: autolockrealtime:=10;
      5: autolockrealtime:=15;
      6: autolockrealtime:=30;
      7: autolockrealtime:=60;
      else
        autolockrealtime:=120;
    end;

    if ((autolocktimecounter/59.4)>autolockrealtime) then
    begin
      autolocktimecounter:=0;
      lockedform.itsmylife:=autolockcode;
      lockedform.showmodal;
    end;

    autolocktimecounter:=autolocktimecounter+1;
  end;

  if (autologouttime>0) then
  begin
    case autologouttime of
      1: autologoutrealtime:=1;
      2: autologoutrealtime:=2;
      3: autologoutrealtime:=5;
      4: autologoutrealtime:=10;
      5: autologoutrealtime:=15;
      6: autologoutrealtime:=30;
      7: autologoutrealtime:=60;
      else
        autologoutrealtime:=120;
    end;

    if ((autologouttimecounter/59.4)>autologoutrealtime) then
    begin
      autologouttimecounter:=0;

      // switch to Visitor-Access-Level
      ChangeUser(false, _('Besucher'), 4);
    end;

    autologouttimecounter:=autologouttimecounter+1;
  end;
end;

procedure TMainform.pluginsaktualisieren(Sender: TObject);
var
  i,k:integer;
  value:byte;
begin
  for i:=1 to lastchan do
  begin
    // Werte des aktuellen Kanals an Plugin-DLL senden
    // Strings für Plugins nullterminieren
    datanames:=data.names[i]+#0;

    value:=maxres-data.ch[i];
//    value:=round(((100-masterform.dimmerMaster.Position)/100)*value);

    for k:=0 to length(ProgramPlugins)-1 do
    begin
      if (@ProgramPlugins[k].SendData<>nil) then
      begin
        ProgramPlugins[k].SendData(i,value,value,0,@datanames);
      end;
    end;
	end;
end;

function TMainform.AudioInBufferFilled(Buffer: PAnsiChar;
  var Size: Integer): Boolean;
Var
  SP    : ^SmallInt;
  i, N,  v  : Integer;
  xMin, xMax : Integer;

begin
  N := Size Div 2;
  SP := Pointer(Buffer);
  xMin := SP^;
  xMax := xMin;

  For i := 0 to N-1 Do
     Begin
       v := SP^; Inc(SP);
       If (xMin > v) Then xMin := v;
       If (xMax < v) Then xMax := v;
     End;

  If (AudioMin > xMin) Then AudioMin := xMin;
  If (AudioMax < xMax) Then AudioMax := xMax;

  AudioTempMax := xMax;
  If (Abs(xMin) > xMax) Then AudioTempMax := Abs(xMin);
  Result := TRUE;
end;

procedure TMainform.Optotimer_oldTimer(Sender: TObject);
begin
  if pcdimmerresetting then exit;
  if not BeatEnabled then exit;

  // Beatdarstellung vom Temposlider
//  SetLedState(ktCapsLock, einoderaus);  // CapsLock on
//  SetLedState(ktNumLock, einoderaus);  // NumLock on
//  SetLedState(ktScrollLock, einoderaus);  // ScrollLock on

  BeatTime:=BeatTime+1;
  if BeatTime>BeatInterval then
  begin
    BeatTime:=0;
    ExecuteBeat(nil);
  end;
end;

procedure TMainform.GNULizenz1Click(Sender: TObject);
begin
  if gnulicense=nil then
    gnulicense:=Tgnulicense.Create(gnulicense);

  gnulicense.Memo1.Lines.LoadFromFile(pcdimmerdirectory+'\gpl.txt');
  gnulicense.Caption:='GNU General Public License';
  gnulicense.Label1.Caption:='Please read the license agreement below in its entirely. It describes the only conditions under which you may redistribute and';
  gnulicense.Label2.Caption:='modify the PHOENIXstudios PC_DIMMER, and that this program comes with no warranty.';
  //gnulicense.PopupParent := Self;
  gnulicense.ShowModal;
end;

procedure TMainform.Changelog1Click(Sender: TObject);
begin
  if gnulicense=nil then
    gnulicense:=Tgnulicense.Create(gnulicense);

  gnulicense.Memo1.Lines.LoadFromFile(pcdimmerdirectory+'\revhist.txt');
  gnulicense.Caption:=_('PC_DIMMER Change log...');
  gnulicense.Label1.Caption:=_('PHOENIXstudios PC_DIMMER');
  gnulicense.Label2.Caption:=_('Keep looking on http://www.pcdimmer.de for updates');
  //gnulicense.PopupParent := Self;
  gnulicense.ShowModal;
end;

procedure TMainform.Debugger1Click(Sender: TObject);
var
	i:integer;
begin
  if protocolbox=nil then
    protocolbox:=Tprotocolbox.create(protocolbox);

  with protocolbox do
  begin
	  errorsoccured:=false;
		debuglistbox.Items.LoadFromFile(userdirectory+'\PC_DIMMER.log');
		debuglistbox.ItemIndex:=debuglistbox.Items.Count-1;
		for i:=0 to debuglistbox.Count-1 do
	  begin
			if (pos('- OK',debuglistbox.Items[i])<>0) then
	    begin
	    	debuglistbox.Items.Objects[i]:=TObject(clGreen);
			end;
			if (pos('WARNING',debuglistbox.Items[i])<>0) or (pos('Warning',debuglistbox.Items[i])<>0) then
	    begin
	    	debuglistbox.Items.Objects[i]:=TObject($000080FF);
			end;
	    if (pos('ERROR',debuglistbox.Items[i])<>0) or (pos('Error',debuglistbox.Items[i])<>0) then
	    begin
	    	debuglistbox.Items.Objects[i]:=TObject(clRed);
	      errorsoccured:=true;
	    end;
	    if (pos('MESSAGE',debuglistbox.Items[i])<>0) or (pos('Message',debuglistbox.Items[i])<>0) then
	    begin
	    	debuglistbox.Items.Objects[i]:=TObject(clYellow);
	    end;
	  end;
		ShowModal;
  end;
end;

procedure TMainform.FormCloseQuery(Sender: TObject; var CanClose: Boolean);
var
  text:string;
begin
  if not UserAccessGranted(2) then
  begin
    CanClose:=false;
    exit;
  end;

  if (QuitWithoutConfirmation=false) then
  begin
    if messagedlg(_('PC_DIMMER jetzt beenden?'),mtConfirmation,[mbYes,mbNo],0) <> mrYes then
    begin
    	canclose:=false;
    end else
    begin
      if (length(project_file)>0) and (project_file<>userdirectory+'ProjectTemp\Projekt') then
      begin
        if fastsaved then
          text:=_('Bislang wurde das Projekt nur per "Fastsave" gespeichert. Die Projektdatei wurde noch nicht aktualisiert.'+#10#13+'Sämtliche Änderungen könnten durch einen Klick auf "Neues Projekt" oder das Laden eines anderen Projektes gelöscht werden.'+#10#13+#10#13+'Möchten Sie die Projektdatei nun aktualisieren?'+#10#13#10#13+'Datei: "')+ExtractFileName(project_file)+'"'+#10#13+'Titel: '+projekttitel+#10#13+'Bearbeiter: '+projektbearbeiter
        else
          text:=_('Möchten Sie das aktuelle Projekt vor dem Beenden speichern?')+#10#13#10#13+'Datei: "'+ExtractFileName(project_file)+'"'+#10#13+'Titel: '+projekttitel+#10#13+'Bearbeiter: '+projektbearbeiter;

        case mymessagedlg(text,mtConfirmation,[mbYes,mbNo,mbRetry,mbCancel],[_('&Ja'),_('&Nein'),_('&Fastsave'),_('&Abbrechen')]) of
//    		  case messagedlg(text,mtConfirmation,[mbYes,mbNo,mbCancel],0) of
            mrYes: begin saveonclosing:=true; saveproject(true,false,false); end;
            mrNo: ;
            mrCancel: begin saveonclosing:=true; saveproject(true,true,false);end;
            mrRetry: canclose:=false;
{
          case mymessagedlg(text,mtConfirmation,[mbYes,mbNo,mbCancel],[_('&Ja'),_('&Nein'),_('&Abbrechen')]) of
              mrYes: begin saveonclosing:=true; saveproject(true,false,false); end;
              mrNo: ;
              mrCancel: canclose:=false;
          end;
}
        end;
      end else
      begin
        project_file:='';
        if fastsaved then
          text:=_('Bislang wurde das Projekt nur per "Fastsave" gespeichert. Es wurde noch keine externe Projektdatei erzeugt.'+#10#13+'Sämtliche Daten könnten derzeit durch einen Klick auf "Neues Projekt" oder das Laden eines anderen Projektes gelöscht werden.'+#10#13+#10#13+'Möchten Sie das Projekt nun in eine Projektdatei speichern?')
        else
          text:=_('Möchten Sie das aktuelle Projekt vor dem Beenden speichern?');
        case mymessagedlg(text,mtConfirmation,[mbYes,mbNo,mbRetry,mbCancel],[_('&Ja'),_('&Nein'),_('&Fastsave'),_('&Abbrechen')]) of
//     		  case messagedlg(text,mtConfirmation,[mbYes,mbNo,mbCancel],0) of
            mrYes: begin saveonclosing:=true; saveproject(false,false,false); end;
            mrNo: ;
            mrCancel: begin saveonclosing:=true; saveproject(true,true,false); end;
            mrRetry: canclose:=false;
        end;
{
        case mymessagedlg(text,mtConfirmation,[mbYes,mbNo,mbCancel],[_('&Ja'),_('&Nein'),_('&Abbrechen')]) of
            mrYes: begin saveonclosing:=true; saveproject(false,false,false); end;
            mrNo: ;
            mrCancel: canclose:=false;
        end;
}
      end;
    end;
  end else
  begin
	// Exit PC_DIMMER without request or message
  end;
end;

procedure TMainform.poweroffswitch_on_offClick(Sender: TObject);
begin
  if not UserAccessGranted(1) then exit;

  if powerbutton1.PowerOffEnable then
  begin
    PowerRibbonBtn.Down:=false;
    powerbutton1.PowerOffEnable:=false;
//    messagedlg('Der Ein-/Aus-Schalter am Computergehäuse ist jetzt deaktiviert.'+#13#10#13#10+'Beim kurzen(!) Drücken auf diesen Schalter wird Windows bei Computern mit ATX-Netzteil NICHT heruntergefahren.',mtInformation,[mbOK],0)
    ownmessageform.captionlbl.Caption:=_('Ein-/Ausschalter deaktiviert');
    ownmessageform.descriptionlbl.Caption:='';
    ownmessageform.meldung.Clear;
    ownmessageform.meldung.Lines.Add(_('Der Ein-/Aus-Schalter am Computergehäuse ist jetzt deaktiviert.'));
    ownmessageform.meldung.Lines.Add('');
    ownmessageform.meldung.Lines.Add(_('Beim kurzen(!) Drücken auf diesen Schalter wird Windows bei Computern mit ATX-Netzteil NICHT heruntergefahren.'));
    ownmessageform.ClientHeight:=209;
    ownmessageform.ClientWidth:=377;
    ownmessageform.meldung.Width:=ownmessageform.ClientWidth-16;
    ownmessageform.CancelBtn.Visible:=false;
    ownmessageform.caption:=_('Ein-/Ausschalter deaktiviert');
    ownmessageform.showmodal;
  end
  else
  begin
    PowerRibbonBtn.Down:=true;
    powerbutton1.PowerOffEnable:=true;
//    messagedlg('Der Ein-/Aus-Schalter am Computergehäuse ist wieder aktiviert.'+#13#10#13#10+'Durch Drücken dieser Taste wird Windows jetzt wieder heruntergefahren.',mtInformation,[mbOK],0)
    ownmessageform.captionlbl.Caption:=_('Ein-/Ausschalter aktiviert');
    ownmessageform.descriptionlbl.Caption:='';
    ownmessageform.meldung.Clear;
    ownmessageform.meldung.Lines.Add(_('Der Ein-/Aus-Schalter am Computergehäuse ist wieder aktiviert.'));
    ownmessageform.meldung.Lines.Add('');
    ownmessageform.meldung.Lines.Add(_('Durch Drücken dieser Taste wird Windows jetzt wieder heruntergefahren.'));
    ownmessageform.ClientHeight:=209;
    ownmessageform.ClientWidth:=377;
    ownmessageform.CancelBtn.Visible:=false;
    ownmessageform.caption:=_('Ein/-Ausschalter aktiviert');
    ownmessageform.showmodal;
  end;
end;

procedure TMainform.Optionen1Click(Sender: TObject);
var
  i:integer;
  BassInfo: BASS_INFO;
  channel_0_position:Int64;
  playing:boolean;
  oldsounddevicespeakers:integer;
  BassDeviceInfo:BASS_DEVICEINFO;
begin
  if not UserAccessGranted(1) then exit;

  Optionenbox.Notebook1.PageIndex:=0;

  oldsounddevicespeakers:=sounddevicespeakers;

// Werte in den Optionendialog schreiben
  Optionenbox.startupwitholdscene_checkbox.Checked:=startupwitholdscene;
  Optionenbox.switchofflightsatshutdown.Checked:=switchofflightsatshutdown;
  Optionenbox.scrolllockled_checkbox.Checked:=flashscrolllockled;
  Optionenbox.powerswitch_checkbox.Checked:=powerswitchoff;
  Optionenbox.lastchan.position:=lastchan;
  Optionenbox.lastchan_edit.Text:=inttostr(lastchan);
  Optionenbox.askforsaveproject_checkbox.Checked:=askforsaveproject;
  Optionenbox.levelanzeigeoptionen.ItemIndex:=levelanzeigeoptionen;
  Optionenbox.deactivateoutputdllsonclose.Checked:=deactivateoutputdllsonclose;
  Optionenbox.deactivateinputdllsonclose.Checked:=deactivateinputdllsonclose;
  Optionenbox.prioritaet.Position:=mainpriority;
  Optionenbox.showlastplugins_checkbox.Checked:=showlastplugins;
  Optionenbox.showaccuwarnings.Checked:=showakkuwarnings;
  Optionenbox.Blendoutformscheckbox.Checked:=blendoutforms;
  Optionenbox.RadioGroup1.ItemIndex:=errorhandlingmode;
  Optionenbox.Autosavetrackbar.Position:=autobackupcountermax;
  Optionenbox.AutosavetrackbarChange(nil);
  Optionenbox.maxautobackupfilesedit.Value:=maxautobackupfiles;
  Optionenbox.HTTPServerPasswordCheckbox.Checked:=FHTTPServer.UsePassword;
  Optionenbox.HTTPServerPassword.Text:= FHTTPServer.Password;
  Optionenbox.MQTTBrokerIP.Text:=mqtt.Host;
  Optionenbox.MQTTBrokerPort.Value:=mqtt.Port;
  Optionenbox.MQTTBrokerUser.Text:=mqtt.Username;
  Optionenbox.MQTTBrokerPassword.Text:=mqtt.Password;
  Optionenbox.mbs_onlineCheckbox.Checked:=MBS_Online;
  Optionenbox.mbs_MSGonEdit.text:=inttostr(MBS_MSGon);
  Optionenbox.mbs_MSGoffEdit.text:=inttostr(MBS_MSGoff);
  Optionenbox.mbs_Data1onEdit.text:=inttostr(MBS_Data1on);
  Optionenbox.mbs_Data1offEdit.text:=inttostr(MBS_Data1off);
  Optionenbox.mbs_Data2onEdit.text:=inttostr(MBS_Data2on);
  Optionenbox.mbs_Data2offEdit.text:=inttostr(MBS_Data2off);
  Optionenbox.mevpdir.text := mevp.MEVPDLLPath;
  OptionenBox.MevpUseThread.Checked := mevp.UseThread;
  OptionenBox.GroupBox15.Enabled := mevp.UseThread;
  OptionenBox.MevpThreadPriority.Position := ThreadPriorityToInt(mevp.ThreadPriority);
  Optionenbox.autolocktime.ItemIndex:=autolocktime;
  Optionenbox.autolockcode.Text:=autolockcode;
  Optionenbox.terminalportedit.value:=terminalport;
  Optionenbox.mediacenterportedit.value:=mediacenterport;
  Optionenbox.CheckUpdatesOnStartup.Checked := CheckUpdatesOnStartup;
  Optionenbox.midibacktrackintervaledit.value:=MidiCallbackTimer.Interval;
  Optionenbox.dimmerkernelresolutionedit.Value:=MinDimmerkernelResolution;
  Optionenbox.dimmerkernelresolutioncheck.Checked:=DimmerkernelResolutionAutoset;
  Optionenbox.QuitWithoutConfirmation.Checked:=QuitWithoutConfirmation;
  Optionenbox.autologouttime.ItemIndex:=autologouttime;
  Optionenbox.startupuseredit.Items.Clear;
  for i:=0 to length(UserAccounts)-1 do
  begin
    Optionenbox.startupuseredit.Items.Add(UserAccounts[i].Name);
  end;
  Optionenbox.startupuseredit.text:=StartupUser;
  Optionenbox.autoambercheckbox.checked:=UseAutoAmberCalculation;

  Optionenbox.rfr_main.Value:=rfr_main;
  Optionenbox.rfr_aep.Value:=rfr_aep;
  Optionenbox.rfr_buehnenansicht.Value:=rfr_buehnenansicht;
  Optionenbox.rfr_cuelist.Value:=rfr_cuelist;
  Optionenbox.rfr_faderpanel.Value:=rfr_faderpanel;
  Optionenbox.rfr_kanaluebersicht.Value:=rfr_kanaluebersicht;
  Optionenbox.rfr_kontrollpanel.Value:=rfr_kontrollpanel;
  Optionenbox.rfr_kontrollpanelcheckforactive.Value:=rfr_kontrollpanelcheckforactive;
  Optionenbox.rfr_submaster.Value:=rfr_submaster;

// Werte für Soundausgabe
  i:=1;
  Optionenbox.sounddevices.clear;
  while (BASS_GetDeviceInfo(i, BassDeviceInfo)) do
  begin
    Optionenbox.sounddevices.Items.Add(BassDeviceInfo.name);
    i := i + 1;
  end;
  if Optionenbox.sounddevices.Items.Count>0 then
  	Optionenbox.sounddevices.ItemIndex:=sounddevice;
  Optionenbox.frontspeaker.checked:=(sounddevicespeakers and 1)=1;
  Optionenbox.rearspeaker.checked:=(sounddevicespeakers and 2)=2;
  Optionenbox.centerlfespeaker.checked:=(sounddevicespeakers and 4)=4;
  Optionenbox.backsurroundspeaker.checked:=(sounddevicespeakers and 8)=8;

  BASS_GetInfo(BassInfo);

  if BassInfo.speakers<8 then
    Optionenbox.backsurroundspeaker.enabled:=false;
  if BassInfo.speakers<6 then
    Optionenbox.centerlfespeaker.enabled:=false;
  if BassInfo.speakers<4 then
    Optionenbox.rearspeaker.enabled:=false;
  if BassInfo.speakers<2 then
    Optionenbox.frontspeaker.enabled:=false;

// Werte für Plugins
  Optionenbox.Plugingrid.RowCount:=length(OutputPlugins);

  for i:=0 to length(OutputPlugins)-1 do
  begin
    Optionenbox.Plugingrid.Cells[1,i]:=OutputPlugins[i].Name;
    Optionenbox.Plugingrid.Cells[2,i]:=OutputPlugins[i].Version;

    if (OutputPlugins[i].Startaddress=0) and (OutputPlugins[i].Stopaddress=0) then
    begin
      OutputPlugins[i].Startaddress:=1;
      OutputPlugins[i].Stopaddress:=512;
    end;

    Optionenbox.Plugingrid.Cells[3,i]:=inttostr(OutputPlugins[i].Startaddress);
    Optionenbox.Plugingrid.Cells[4,i]:=inttostr(OutputPlugins[i].Stopaddress);
    Optionenbox.Plugingrid.Cells[5,i]:=OutputPlugins[i].Filename;
  end;

// Ende von Werte schreiben
  Optionenbox.Plugingrid.Refresh;

//#########################
  Optionenbox.showmodal;
//#########################

// Werte aus Optionendialog lesen
  lastchan:=Optionenbox.lastchan.Position;
  setlength(data.ch,lastchan+1);
  setlength(data.names,lastchan+1);
  setlength(data.sdirect,lastchan+1);
  setlength(data.combine,lastchan+1);

  setlength(faderpanelform.faderselected, lastchan);
  setlength(faderpanelform.faderselectedalt, lastchan);
  setlength(faderpanelform.faderselectedshift, lastchan);

  if faderpanelform.Showing then
  begin
    faderpanelform.ScrollBar1.Max:=lastchan-15;
    faderpanelform.ScrollBar1.Position:=1;
  end;

  startupwitholdscene:=Optionenbox.startupwitholdscene_checkbox.Checked;
  switchofflightsatshutdown:=Optionenbox.switchofflightsatshutdown.Checked;
  powerswitchoff:=Optionenbox.powerswitch_checkbox.Checked;
  lastchan:=optionenbox.lastchan.position;
  askforsaveproject:=Optionenbox.askforsaveproject_checkbox.Checked;
  levelanzeigeoptionen:=Optionenbox.levelanzeigeoptionen.ItemIndex;
  deactivateoutputdllsonclose:=Optionenbox.deactivateoutputdllsonclose.Checked;
  deactivateinputdllsonclose:=Optionenbox.deactivateinputdllsonclose.Checked;
  mainpriority:=Optionenbox.prioritaet.Position;
  showlastplugins:=Optionenbox.showlastplugins_checkbox.Checked;
  flashscrolllockled:=Optionenbox.scrolllockled_checkbox.checked;
  showakkuwarnings:=Optionenbox.showaccuwarnings.Checked;
  blendoutforms:=Optionenbox.blendoutformscheckbox.Checked;
  errorhandlingmode:=Optionenbox.RadioGroup1.ItemIndex;
  maxautobackupfiles:=round(Optionenbox.maxautobackupfilesedit.Value);
  autobackupcountermax:=Optionenbox.Autosavetrackbar.Position;
  Autobackupcounter:=0;
  Autobackuptimer.Enabled:=Autobackupcountermax>0;
  FHTTPServer.UsePassword := Optionenbox.HTTPServerPasswordCheckbox.Checked;
  FHTTPServer.Password := Optionenbox.HTTPServerPassword.Text;
  mqtt.Host:=Optionenbox.MQTTBrokerIP.Text;
  mqtt.Port:=round(Optionenbox.MQTTBrokerPort.Value);
  mqtt.Username:=Optionenbox.MQTTBrokerUser.Text;
  mqtt.Password:=Optionenbox.MQTTBrokerPassword.Text;
  MBS_Online:=Optionenbox.mbs_onlineCheckbox.Checked;
  MBS_MSGon:=strtoint(Optionenbox.mbs_MSGonEdit.text);
  MBS_MSGoff:=strtoint(Optionenbox.mbs_MSGoffEdit.text);
  MBS_Data1on:=strtoint(Optionenbox.mbs_Data1onEdit.text);
  MBS_Data1off:=strtoint(Optionenbox.mbs_Data1offEdit.text);
  MBS_Data2on:=strtoint(Optionenbox.mbs_Data2onEdit.text);
  MBS_Data2off:=strtoint(Optionenbox.mbs_Data2offEdit.text);
  mevp.MEVPDLLPath := Optionenbox.mevpdir.Text;
  mevp.UseThread := OptionenBox.MevpUseThread.Checked;
  mevp.ThreadPriority := IntToThreadPriority(OptionenBox.MevpThreadPriority.Position);
  autolocktime:=Optionenbox.autolocktime.ItemIndex;
  autolocktimecounter:=0;
  autolockcode:=Optionenbox.autolockcode.Text;
  terminalport:=round(Optionenbox.terminalportedit.value);
  mediacenterport:=round(Optionenbox.mediacenterportedit.value);
  CheckUpdatesOnStartup := Optionenbox.CheckUpdatesOnStartup.Checked;
  MidiCallbackTimer.Interval:=round(Optionenbox.midibacktrackintervaledit.value);
  MinDimmerkernelResolution:=round(Optionenbox.dimmerkernelresolutionedit.Value);
  DimmerkernelResolution:=MinDimmerkernelResolution;
  DimmerkernelResolutionAutoset:=Optionenbox.dimmerkernelresolutioncheck.Checked;
  AutoFader.Interval:=DimmerkernelResolution;
  QuitWithoutConfirmation:=Optionenbox.QuitWithoutConfirmation.Checked;
  autologouttime:=Optionenbox.autologouttime.ItemIndex;
  StartupUser:=Optionenbox.startupuseredit.text;
  UseAutoAmberCalculation:=Optionenbox.autoambercheckbox.checked;

  rfr_main:=round(Optionenbox.rfr_main.Value);
  rfr_aep:=round(Optionenbox.rfr_aep.Value);
  rfr_buehnenansicht:=round(Optionenbox.rfr_buehnenansicht.Value);
  rfr_cuelist:=round(Optionenbox.rfr_cuelist.Value);
  rfr_faderpanel:=round(Optionenbox.rfr_faderpanel.Value);
  rfr_kanaluebersicht:=round(Optionenbox.rfr_kanaluebersicht.Value);
  rfr_kontrollpanel:=round(Optionenbox.rfr_kontrollpanel.Value);
  rfr_kontrollpanelcheckforactive:=round(Optionenbox.rfr_kontrollpanelcheckforactive.Value);
  rfr_submaster:=round(Optionenbox.rfr_submaster.Value);

// Werte für Sounddevice auslesen
  sounddevicespeakers:=0;
  if Optionenbox.frontspeaker.checked then sounddevicespeakers:=sounddevicespeakers or 1;
  if Optionenbox.rearspeaker.checked then sounddevicespeakers:=sounddevicespeakers or 2;
  if Optionenbox.centerlfespeaker.checked then sounddevicespeakers:=sounddevicespeakers or 4;
  if Optionenbox.backsurroundspeaker.checked then sounddevicespeakers:=sounddevicespeakers or 8;

  channel_0_position:=BASS_ChannelGetPosition(audioeffektplayerform._chan[0], BASS_POS_BYTE);
  playing:=(BASS_ChannelIsActive(audioeffektplayerform._chan[0])=1);

  if ((sounddevice<>Optionenbox.sounddevices.ItemIndex) or (oldsounddevicespeakers<>sounddevicespeakers)) then
  begin
    BASS_ChannelPause(audioeffektplayerform._chan[0]);
    BASS_ChannelPause(audioeffektplayerform._chan[1]);
    BASS_ChannelPause(audioeffektplayerform._chan[2]);
    BASS_ChannelPause(audioeffektplayerform._chan[3]);

    BASS_Free;
    BASS_Init(Optionenbox.sounddevices.ItemIndex+1, BASSDLLFREQUENZ, BASS_DEVICE_SPEAKERS, Handle, nil);

    audioeffektplayerform._chan[0] := BASS_StreamCreateFile(false, PChar(audioeffektplayerform.effektaudioeffektefilename), 0, 0, BASS_SPEAKER_FRONT);
    audioeffektplayerform._chan[1] := BASS_StreamCreateFile(false, PChar(audioeffektplayerform.effektaudioeffektefilename), 0, 0, BASS_SPEAKER_REAR);
    audioeffektplayerform._chan[2] := BASS_StreamCreateFile(false, PChar(audioeffektplayerform.effektaudioeffektefilename), 0, 0, BASS_SPEAKER_CENLFE);
    audioeffektplayerform._chan[3] := BASS_StreamCreateFile(false, PChar(audioeffektplayerform.effektaudioeffektefilename), 0, 0, BASS_SPEAKER_REAR2);

    BASS_ChannelSetPosition(audioeffektplayerform._chan[0],channel_0_position, BASS_POS_BYTE);
    BASS_ChannelSetPosition(audioeffektplayerform._chan[1],BASS_ChannelGetPosition(audioeffektplayerform._chan[0], BASS_POS_BYTE), BASS_POS_BYTE);
    BASS_ChannelSetPosition(audioeffektplayerform._chan[2],BASS_ChannelGetPosition(audioeffektplayerform._chan[0], BASS_POS_BYTE), BASS_POS_BYTE);
    BASS_ChannelSetPosition(audioeffektplayerform._chan[3],BASS_ChannelGetPosition(audioeffektplayerform._chan[0], BASS_POS_BYTE), BASS_POS_BYTE);

    if playing then
    begin
      if (sounddevicespeakers and 1)=1 then BASS_SetVolume(100) else BASS_SetVolume(0);
      BASS_ChannelPlay(audioeffektplayerform._chan[0], False);
      if (sounddevicespeakers and 2)=2 then BASS_ChannelPlay(audioeffektplayerform._chan[1], False);
      if (sounddevicespeakers and 4)=4 then BASS_ChannelPlay(audioeffektplayerform._chan[2], False);
      if (sounddevicespeakers and 8)=8 then BASS_ChannelPlay(audioeffektplayerform._chan[3], False);
    end;
  end;
  sounddevice:=Optionenbox.sounddevices.ItemIndex;

// Werte für Plugins auslesen
  for i:=0 to length(OutputPlugins)-1 do
  begin
    OutputPlugins[i].Startaddress:=strtoint(Optionenbox.Plugingrid.Cells[3,i]);
    OutputPlugins[i].Stopaddress:=strtoint(Optionenbox.Plugingrid.Cells[4,i]);
  end;

// Ende von Auslesen der Werte

  BASS_GetInfo(BassInfo);

  DebugAdd('SETUP: Writing values into registry...');
// Werte in Registry schreiben
  WriteSettingsToRegistry;
 	DebugAddToLine(' - OK');
end;

procedure TMainform.ToolButton12Click(Sender: TObject);
begin
  if blenddown=nil then
    blenddown:=Tblenddown.Create(blenddown);

  with blenddown do
  begin
    if not blenddown.Showing then
    begin
      BrightnessEditRibbon.Visible:=ivAlways;
      screenfaded:=false;
      blendfadein.Enabled:=true;
      blendfadeout.Enabled:=false;
      Left:=0;
      Top:=0;
      Width:=screen.Width;
      Height:=screen.Height;
      BlenddownRibbonBtn.Down:=true;
      Show;
      blenddown.endalphablendvalue:=255-strtoint(brightnesseditribbon.text);
    end else
    begin
      brightnessEditRibbon.Visible:=ivNever;
      blendfadeout.Enabled:=true;
      blendfadein.Enabled:=false;
      BlenddownRibbonBtn.Down:=false;
    end;
  end;
end;

procedure TMainform.brightness_barChange(Sender: TObject);
begin
  brightnessEditRibbon.Hint:=_('Bildschirmhelligkeit: ')+inttostr(round(((strtoint(brightnesseditribbon.text))/255)*100))+'%';
  if blenddown.Showing then
    blenddown.AlphaBlendValue:=255-strtoint(brightnesseditribbon.text)
  else
    blenddown.endalphablendvalue:=255-strtoint(brightnesseditribbon.text);
end;

procedure TMainform.brightness_barContextPopup(Sender: TObject;
  MousePos: TPoint; var Handled: Boolean);
begin
  brightnesseditribbon.text:='128';
end;

procedure TMainform.ToolButton1Click(Sender: TObject);
var
	choice:integer;
begin
  choice:=messagedlg(_('Aktuelles Projekt speichern?'),mtConfirmation,
     [mbYes,mbNo,mbCancel],0);
  if choice=6 then begin if saveproject(false,false,false) then NewProject; end;
  if choice=7 then NewProject;
  if choice=2 then begin end;
end;

procedure TMainform.ToolButton4Click(Sender: TObject);
begin
  if (project_file=userdirectory+'ProjectTemp\Projekt') then
  begin
    saveproject(false,false,false);
    exit;
  end else
  begin
    if askforsaveproject then
      if (length(project_file)>0) then
      begin
        case messagedlg('Aktuelles Projekt in Datei "'+project_file+'" speichern?',mtConfirmation,
           [mbYes,mbNo,mbCancel],0) of
    	    mrYes: saveproject(true,false,false);
      	  mrNo: saveproject(false,false,false);
    		end;
      end else
      begin
        saveproject(false,false,false)
      end
    else
    begin
      if length(project_file)>0 then
      	saveproject(true,false,false)
      else
      	saveproject(false,false,false);
    end;
  end;
end;

procedure TMainform.ToolButton3Click(Sender: TObject);
begin
  opendialog.Title:=_('PC_DIMMER Projekt öffnen...');
  opendialog.Filter:=_('PC_DIMMER Projekt (*.pcdproj)|*.pcdproj|*.*|*.*');
  opendialog.FileName:='';
  opendialog.DefaultExt:='*.pcdproj';
  if project_folder<>'' then opendialog.InitialDir:=project_folder;
  if opendialog.execute then
    openproject(opendialog.filename, false);
end;

procedure TMainform.openhistory1Click(Sender: TObject);
var
  i:integer;
begin
  for i:=1 to 5 do
  begin
    if (Sender=TdxBarButton(FindComponent('openhistory'+inttostr(i)+'ribbon'))) then
    begin
    	if FileExists(data.openhistory[i-1]) then
	      openproject(data.openhistory[i-1], false)
      else
      begin
      	ShowMessage(_('Die Datei "')+data.openhistory[i-1]+_('" ist nicht mehr verfügbar!'));
  			data.openhistory[i-1]:='';
        TdxBarButton(FindComponent('openhistory'+inttostr(i)+'ribbon')).Visible:=ivNever;
      end;
    end;
  end;
end;

procedure TMainform.Projektspeichern1Click(Sender: TObject);
begin
  saveproject(false,false,false);
end;

procedure TMainform.BlackoutClick(Sender: TObject);
var
  i:integer;
begin
  if not UserAccessGranted(2) then exit;

  if IsBlackoutMode then
  begin
    BlackoutRibbonBtn.Down:=true;

    IsBlackoutMode:=false;
    for i:=0 to length(devices)-1 do
    begin
      if devices[i].hasDimmer then
      begin
        geraetesteuerung.set_dimmer(devices[i].ID,channelvalue_blackout[i],2500);
      end else if devices[i].hasRGB or devices[i].hasCMY then
      begin
        geraetesteuerung.set_channel(devices[i].ID,'R',geraetesteuerung.get_channel(devices[i].ID,'R'),channelvalue_blackoutR[i],2500);
        geraetesteuerung.set_channel(devices[i].ID,'G',geraetesteuerung.get_channel(devices[i].ID,'G'),channelvalue_blackoutG[i],2500);
        geraetesteuerung.set_channel(devices[i].ID,'B',geraetesteuerung.get_channel(devices[i].ID,'B'),channelvalue_blackoutB[i],2500);

        geraetesteuerung.set_channel(devices[i].ID,'C',geraetesteuerung.get_channel(devices[i].ID,'C'),channelvalue_blackoutR[i],2500);
        geraetesteuerung.set_channel(devices[i].ID,'M',geraetesteuerung.get_channel(devices[i].ID,'M'),channelvalue_blackoutG[i],2500);
        geraetesteuerung.set_channel(devices[i].ID,'Y',geraetesteuerung.get_channel(devices[i].ID,'Y'),channelvalue_blackoutB[i],2500);

        if devices[i].hasAmber then
          geraetesteuerung.set_channel(devices[i].ID,'A',geraetesteuerung.get_channel(devices[i].ID,'A'),channelvalue_blackoutA[i],2500);
        if devices[i].hasWhite then
          geraetesteuerung.set_channel(devices[i].ID,'W',geraetesteuerung.get_channel(devices[i].ID,'W'),channelvalue_blackoutW[i],2500);
        if devices[i].hasUV then
          geraetesteuerung.set_channel(devices[i].ID,'UV',geraetesteuerung.get_channel(devices[i].ID,'UV'),channelvalue_blackoutUV[i],2500);
      end else
      begin
        // letzte Möglichkeit: Shutter
        geraetesteuerung.set_shutter(devices[i].ID, channelvalue_blackout[i], 0);
      end;
    end;
  end else
  begin
    BlackoutRibbonBtn.Down:=false;

    setlength(channelvalue_blackout,length(devices));
    setlength(channelvalue_blackoutR,length(devices));
    setlength(channelvalue_blackoutG,length(devices));
    setlength(channelvalue_blackoutB,length(devices));
    setlength(channelvalue_blackoutC,length(devices));
    setlength(channelvalue_blackoutM,length(devices));
    setlength(channelvalue_blackoutY,length(devices));
    setlength(channelvalue_blackoutA,length(devices));
    setlength(channelvalue_blackoutW,length(devices));
    setlength(channelvalue_blackoutUV,length(devices));
    for i:=0 to length(devices)-1 do
    begin
      if devices[i].hasDimmer then
      begin
        channelvalue_blackout[i]:=geraetesteuerung.get_dimmer(devices[i].ID);
        geraetesteuerung.set_dimmer(devices[i].ID,0,0,0);
      end else if devices[i].hasRGB or devices[i].hasCMY then
      begin
        channelvalue_blackoutR[i]:=geraetesteuerung.get_channel(devices[i].ID,'R');
        geraetesteuerung.set_channel(devices[i].ID,'R',0,0,0);
        channelvalue_blackoutG[i]:=geraetesteuerung.get_channel(devices[i].ID,'G');
        geraetesteuerung.set_channel(devices[i].ID,'G',0,0,0);
        channelvalue_blackoutB[i]:=geraetesteuerung.get_channel(devices[i].ID,'B');
        geraetesteuerung.set_channel(devices[i].ID,'B',0,0,0);

        channelvalue_blackoutC[i]:=geraetesteuerung.get_channel(devices[i].ID,'C');
        geraetesteuerung.set_channel(devices[i].ID,'C',0,0,0);
        channelvalue_blackoutM[i]:=geraetesteuerung.get_channel(devices[i].ID,'M');
        geraetesteuerung.set_channel(devices[i].ID,'M',0,0,0);
        channelvalue_blackoutY[i]:=geraetesteuerung.get_channel(devices[i].ID,'Y');
        geraetesteuerung.set_channel(devices[i].ID,'Y',0,0,0);

        channelvalue_blackoutA[i]:=geraetesteuerung.get_channel(devices[i].ID,'A');
        geraetesteuerung.set_channel(devices[i].ID,'A',0,0,0);
        channelvalue_blackoutW[i]:=geraetesteuerung.get_channel(devices[i].ID,'W');
        geraetesteuerung.set_channel(devices[i].ID,'W',0,0,0);
        channelvalue_blackoutUV[i]:=geraetesteuerung.get_channel(devices[i].ID,'UV');
        geraetesteuerung.set_channel(devices[i].ID,'UV',0,0,0);
      end else
      begin
        // letzte Möglichkeit: Shutter
        channelvalue_blackout[i]:=geraetesteuerung.get_shutter(devices[i].ID);
        geraetesteuerung.set_shutter(devices[i].ID,0,0);
      end;
    end;
    IsBlackoutMode:=true;
  end;
end;

procedure TMainform.ErrorPop(str:string);
begin
  if str = '' then
    Showmessage('Error code: '+inttostr(BASS_ErrorGetCode()))
  else
    Showmessage(str);
end;

procedure TMainform.PCDIMMERForum1Click(Sender: TObject);
begin
  ShellExecute(Handle, 'open', PChar('http://forum.pcdimmer.de'), nil, nil, SW_SHOW);
end;

procedure TMainform.Homepage1Click(Sender: TObject);
begin
  ShellExecute(Handle, 'open', PChar('http://www.pcdimmer.de'), nil, nil, SW_SHOW);
end;

// Hier kommen die Threads
//------------------------------------------------------------------------------

{ HelperThread }

constructor THelperThread.Create();
begin
  inherited create(false);
  Priority := tpIdle;
  FreeOnTerminate := true;
end;

procedure THelperThread.Execute;
var
  DeviceIndex, ButtonIndex, w:Word;
  TxBuffer: array of byte;
  HidReportA:TReportA;
  HidReportB:TReportB;
  HidReportC:TReportC;
  WrittenPayloadBytes, RemainingPayloadBytes, PacketCounter:Cardinal;
  BytesWritten:DWORD;
  PID:Word;
begin
  inherited;

  repeat
    try
      // Transmit Data to Elgato StreamDeck
      for DeviceIndex:=0 to length(elgatostreamdeckform.TotalPayloadBuffer)-1 do
      begin
        if (DeviceIndex<length(mainform.ElgatoStreamDeckArray)) and mainform.ElgatoStreamDeckArray[DeviceIndex].Online and (DeviceIndex<length(elgatostreamdeckform.TotalPayloadBuffer)) then
        for ButtonIndex:=0 to length(elgatostreamdeckform.TotalPayloadBuffer[DeviceIndex])-1 do
        begin
          if elgatostreamdeckform.TotalPayloadBuffer_ReadyToSend[DeviceIndex][ButtonIndex] then
          begin
            // reset ReadyToSend_Flag
            elgatostreamdeckform.TotalPayloadBuffer_ReadyToSend[DeviceIndex][ButtonIndex]:=false;

            // now transmit the byte-array to Stream Deck Device
            WrittenPayloadBytes:=0;
            RemainingPayloadBytes:=length(elgatostreamdeckform.TotalPayloadBuffer[DeviceIndex][ButtonIndex]);
            PacketCounter:=0;

            PID:=mainform.ElgatoStreamDeckArray[DeviceIndex].HidDevice.Attributes.ProductID;

            {
            StreamDeck Orig, PID 0060, CmdSet v1, BMP, 72x72 Pixel, Header 16 Byte, Image Pagesize 8191 Byte, FeatureReportSize 17 Byte // maybe 7819 instead of 8191
            -----------------
            StreamDeck Mini, PID 0063, CmdSet v1, BMP, 80x80 Pixel, Header 16 Byte, Image Pagesize 1024 Byte, FeatureReportSize 17 Byte
            =================
            StreamDeck V2,   PID 006D, CmdSet v2, JPG, 72x72 Pixel, Header 8 Byte, Image Pagesize 1024 Byte, FeatureReportSize 32 Byte
            StreamDeck MK2,  PID 0080, CmdSet v2, JPG, 72x72 Pixel, Header 8 Byte, Image Pagesize 1024 Byte, FeatureReportSize 32 Byte
            StreamDeck XL,   PID 006C, CmdSet v2, JPG, 96x96 Pixel, Header 8 Byte, Image Pagesize 1024 Byte, FeatureReportSize 32 Byte
            }

            if (PID=$0060) then
            begin
              // StreamDeck Orig

              {
                Set Key image:
                  00 = static 02 (identifier)
                  01 = static 01 (cmd to set image)
                  02 = PageID + 1
                  03 = 0x00
                  04 = 0x00 = not the last message, 0x01 = last message
                  05 = hex-value of button-id + 1
                  06..15 = 0x00
              }

              setlength(TxBuffer, 8191);
              repeat
                if RemainingPayloadBytes>8175 then // 8191 Bytes minus 16 Bytes of Header
                begin
                  // not the last message
                  TxBuffer[0]:=$02; // identifier
                  TxBuffer[1]:=$01; // cmd to set image
                  TxBuffer[2]:=PacketCounter; // PageID
                  TxBuffer[3]:=$00; // has to be 0
                  TxBuffer[4]:=$00; // 0x00 = not the last message, 0x01 = last message
                  TxBuffer[5]:=ButtonIndex+1;

                  // copy 8175 bytes of PayloadBuffer
                  for w:=0 to 8174 do
                  begin
                    TxBuffer[16+w]:=elgatostreamdeckform.TotalPayloadBuffer[DeviceIndex][ButtonIndex][WrittenPayloadBytes+w];
                  end;

                  for w:=0 to 15 do
                    HidReportA.Header[w]:=TxBuffer[w];
                  for w:=0 to 8174 do
                    HidReportA.Data[w]:=TxBuffer[16+w];
                  mainform.ElgatoStreamDeckArray[DeviceIndex].HidDevice.WriteFile(HidReportA, mainform.ElgatoStreamDeckArray[DeviceIndex].HidDevice.Caps.OutputReportByteLength, BytesWritten);
                  WrittenPayloadBytes:=WrittenPayloadBytes+8175;
                  RemainingPayloadBytes:=RemainingPayloadBytes-8175;
                  PacketCounter:=PacketCounter+1;
                end else
                begin
                  // data fits into single message / last message
                  TxBuffer[0]:=$02; // identifier
                  TxBuffer[1]:=$01; // cmd to set image
                  TxBuffer[2]:=PacketCounter; // PageID
                  TxBuffer[3]:=$00; // has to be 0
                  TxBuffer[4]:=$01; // 0x00 = not the last message, 0x01 = last message
                  TxBuffer[5]:=ButtonIndex+1;

                  // copy remaining bytes of PayloadBuffer
                  for w:=0 to RemainingPayloadBytes-1 do
                  begin
                    TxBuffer[16+w]:=elgatostreamdeckform.TotalPayloadBuffer[DeviceIndex][ButtonIndex][WrittenPayloadBytes+w];
                  end;
                  // fill remaining bytes with zeros
                  for w:=RemainingPayloadBytes to 8174 do
                  begin
                    TxBuffer[w]:=0;
                  end;

                  for w:=0 to 15 do
                    HidReportA.Header[w]:=TxBuffer[w];
                  for w:=0 to 8174 do
                    HidReportA.Data[w]:=TxBuffer[16+w];
                  mainform.ElgatoStreamDeckArray[DeviceIndex].HidDevice.WriteFile(HidReportA, mainform.ElgatoStreamDeckArray[DeviceIndex].HidDevice.Caps.OutputReportByteLength, BytesWritten);
                  RemainingPayloadBytes:=0;
                  PacketCounter:=PacketCounter+1;
                end;
              until RemainingPayloadBytes=0;
            end else if (PID=$0063) then
            begin
              // StreamDeck Mini

              {
                Set Key image:
                  00 = static 02 (identifier)
                  01 = static 01 (cmd to set image)
                  02 = PageID + 1
                  03 = 0x00
                  04 = 0x00 = not the last message, 0x01 = last message
                  05 = hex-value of button-id + 1
                  06..15 = 0x00
              }

              setlength(TxBuffer, 1024);
              repeat
                if RemainingPayloadBytes>1008 then // 1024 Bytes minus 16 Bytes of Header
                begin
                  // not the last message
                  TxBuffer[0]:=$02; // identifier
                  TxBuffer[1]:=$01; // cmd to set image
                  TxBuffer[2]:=PacketCounter; // PageID
                  TxBuffer[3]:=$00; // has to be 0
                  TxBuffer[4]:=$00; // 0x00 = not the last message, 0x01 = last message
                  TxBuffer[5]:=ButtonIndex+1;

                  // copy 1008 bytes of PayloadBuffer
                  for w:=0 to 1007 do
                  begin
                    TxBuffer[16+w]:=elgatostreamdeckform.TotalPayloadBuffer[DeviceIndex][ButtonIndex][WrittenPayloadBytes+w];
                  end;

                  for w:=0 to 15 do
                    HidReportB.Header[w]:=TxBuffer[w];
                  for w:=0 to 1007 do
                    HidReportB.Data[w]:=TxBuffer[16+w];
                  mainform.ElgatoStreamDeckArray[DeviceIndex].HidDevice.WriteFile(HidReportB, mainform.ElgatoStreamDeckArray[DeviceIndex].HidDevice.Caps.OutputReportByteLength, BytesWritten);
                  WrittenPayloadBytes:=WrittenPayloadBytes+1008;
                  RemainingPayloadBytes:=RemainingPayloadBytes-1008;
                  PacketCounter:=PacketCounter+1;
                end else
                begin
                  // data fits into single message / last message
                  TxBuffer[0]:=$02; // identifier
                  TxBuffer[1]:=$01; // cmd to set image
                  TxBuffer[2]:=PacketCounter; // PageID
                  TxBuffer[3]:=$00; // has to be 0
                  TxBuffer[4]:=$01; // 0x00 = not the last message, 0x01 = last message
                  TxBuffer[5]:=ButtonIndex+1;

                  // copy remaining bytes of PayloadBuffer
                  for w:=0 to RemainingPayloadBytes-1 do
                  begin
                    TxBuffer[16+w]:=elgatostreamdeckform.TotalPayloadBuffer[DeviceIndex][ButtonIndex][WrittenPayloadBytes+w];
                  end;
                  // fill remaining bytes with zeros
                  for w:=RemainingPayloadBytes to 1007 do
                  begin
                    TxBuffer[w]:=0;
                  end;

                  for w:=0 to 15 do
                    HidReportB.Header[w]:=TxBuffer[w];
                  for w:=0 to 1007 do
                    HidReportB.Data[w]:=TxBuffer[16+w];
                  mainform.ElgatoStreamDeckArray[DeviceIndex].HidDevice.WriteFile(HidReportB, mainform.ElgatoStreamDeckArray[DeviceIndex].HidDevice.Caps.OutputReportByteLength, BytesWritten);
                  RemainingPayloadBytes:=0;
                  PacketCounter:=PacketCounter+1;
                end;
              until RemainingPayloadBytes=0;
            end else if (PID=$006D) or (PID=$006C) or (PID=$0080) then
            begin
              // StreamDeck XL, V2, MK2
              setlength(TxBuffer, 1024);
              TxBuffer[0]:=$02; // identifier
              TxBuffer[1]:=$07; // cmd to set image
              TxBuffer[2]:=ButtonIndex; // hex-value of button-id
              //TxBuffer[3]:=$00; // 0x00 = not the last message, 0x01 = last message
              //TxBuffer[4]:=$F8; // 16-bit little-endian value of length: f803 -> 0x03f8 = 1016
              //TxBuffer[5]:=$03;
              //TxBuffer[6]:=$00; // 16-bit little-endian value of the zero-based iteration, if the image is split
              //TxBuffer[7]:=$00;
              repeat
                if RemainingPayloadBytes>1016 then // 1024 Bytes minus 8 Bytes of Header
                begin
                  // not the last message
                  TxBuffer[3]:=$00; // 0x00 = not the last message, 0x01 = last message
                  TxBuffer[4]:=$F8; // 16-bit little-endian value of length: f803 -> 0x03f8 = 1016 bytes
                  TxBuffer[5]:=$03;
                  TxBuffer[6]:=PacketCounter AND 255;
                  TxBuffer[7]:=(PacketCounter shr 8);

                  // copy 1016 bytes of PayloadBuffer
                  for w:=0 to 1015 do
                  begin
                    TxBuffer[8+w]:=elgatostreamdeckform.TotalPayloadBuffer[DeviceIndex][ButtonIndex][WrittenPayloadBytes+w];
                  end;

                  for w:=0 to 7 do
                    HidReportC.Header[w]:=TxBuffer[w];
                  for w:=0 to 1015 do
                    HidReportC.Data[w]:=TxBuffer[8+w];
                  mainform.ElgatoStreamDeckArray[DeviceIndex].HidDevice.WriteFile(HidReportC, mainform.ElgatoStreamDeckArray[DeviceIndex].HidDevice.Caps.OutputReportByteLength, BytesWritten);
                  WrittenPayloadBytes:=WrittenPayloadBytes+1016;
                  RemainingPayloadBytes:=RemainingPayloadBytes-1016;
                  PacketCounter:=PacketCounter+1;
                end else
                begin
                  // data fits into single message / last message
                  TxBuffer[3]:=$01; // 0x00 = not the last message, 0x01 = last message
                  TxBuffer[4]:=RemainingPayloadBytes AND 255; // 16-bit little-endian value of length: f803 -> 0x03f8 = 1016
                  TxBuffer[5]:=(RemainingPayloadBytes shr 8);
                  TxBuffer[6]:=PacketCounter AND 255;
                  TxBuffer[7]:=(PacketCounter shr 8);

                  // copy remaining bytes of PayloadBuffer
                  for w:=0 to RemainingPayloadBytes-1 do
                  begin
                    TxBuffer[8+w]:=elgatostreamdeckform.TotalPayloadBuffer[DeviceIndex][ButtonIndex][WrittenPayloadBytes+w];
                  end;
                  // fill remaining bytes with zeros
                  for w:=RemainingPayloadBytes to 1015 do
                  begin
                    TxBuffer[w]:=0;
                  end;

                  for w:=0 to 7 do
                    HidReportC.Header[w]:=TxBuffer[w];
                  for w:=0 to 1015 do
                    HidReportC.Data[w]:=TxBuffer[8+w];
                  mainform.ElgatoStreamDeckArray[DeviceIndex].HidDevice.WriteFile(HidReportC, mainform.ElgatoStreamDeckArray[DeviceIndex].HidDevice.Caps.OutputReportByteLength, BytesWritten);
                  RemainingPayloadBytes:=0;
                  PacketCounter:=PacketCounter+1;
                end;
              until RemainingPayloadBytes=0;
            end
          end;
        end;
      end;
    except
      // something went wrong with the StreamDeck...
    end;
    // End of Elgato StreamDeck

    sleep(50);
  until mainform._killthreads;

  Terminate;
end;

{ TScanThread }

//constructor TScanThread.Create(decoder: HSTREAM; ScanEvent:TScanEvent);
constructor TScanThread.Create(decoder: HSTREAM);
begin
  inherited create(false);
  Priority := tpNormal;
  FreeOnTerminate := true;
  FDecoder := decoder;
end;

procedure TScanThread.Execute;
begin
  inherited;
  try
    audioeffektplayerform.ScanPeaks(FDecoder);
  except
  end;
  Terminate;
end;

//-------------------------------------------------

constructor TAccuThread.Create(AccuEvent:TAccuEvent);
begin
  inherited create(false);
  FAccuEvent:=AccuEvent;
  Priority := tpIdle;
  FreeOnTerminate := true;
end;

function GetPowerStatus(var HasBattery: Boolean; var LoadStatusString: String;
  var LoadstatusPercent: Integer): DWORD;
var
  SystemPowerStatus: TSystemPowerStatus;
  Text:string;
begin
  SetLastError(0);
  if GetSystemPowerStatus(SystemPowerStatus) then
    with SystemPowerStatus do
    begin
      HasBattery := ACLineStatus = 0;
      // Ladezustand der Batterie
      if (BatteryFlag = 255) then
        LoadStatusString := _('Unbekannter Status')
      else if (BatteryFlag and 128 = 128) then
        LoadStatusString := _('Es existiert kein Akku')
      else
      begin
        case (BatteryFlag and (1 or 2 or 4)) of
          1: Text := _('Hoher Ladezustand');
          2: Text := _('Niedriger Ladezustand');
          4: Text := _('Kritischer Ladezustand');
        else
          LoadStatusString := _('Unbekannter Ladezustand')
        end;
        if (BatteryFlag and 8 = 8) then
          LoadStatusString := Text + _(' - Akku wird geladen')
        else
          LoadStatusString:=text;
      end;
      // Ladezustand in Prozent
      if (BatteryLifePercent <> 255) then
        LoadstatusPercent := BatteryLifePercent
      else
        LoadstatusPercent := -1;
  end;
  Result := GetLastError;
end;

procedure Tmainform.GetAccuLevel;
var
  text:string;
  hasbattery:boolean;
  percent:integer;
begin
  repeat
    if mainform._killaccu then
      Exit;

    GetPowerStatus(hasbattery,text,percent);
    mainform.akkulevel:=percent;

    sleep(3000);
    if mainform._killaccu then
      Exit;

    if (text=_('Es existiert kein Akku')) or (percent<0) then
    begin
      mainform.akkulevel:=-1;
      mainform._killaccu:=true;
    end;

    if mainform.JvComputerInfoEx1.APM.LineStatus=alsOnline then
      mainform.netzbetrieb:=true
    else
      mainform.netzbetrieb:=false;

    sleep(1000);
  until mainform._killaccu;
end;

procedure TAccuThread.Execute;
begin
  inherited;
  try
    mainform.GetAccuLevel;
  except
  end;
  Terminate;
end;

//-------------------------------------------------

function GetTime(): Double;
{$WRITEABLECONST ON}
const
  bInitialized:   BOOL = FALSE;
  qwTicksPerSec:  Int64 = 0;
  qwTime:         Int64 = 0;
{$WRITEABLECONST OFF}
begin
  if not bInitialized then begin
    QueryPerformanceFrequency(qwTicksPerSec);
    bInitialized := TRUE;
  end;
  QueryPerformanceCounter(Int64(qwTime));
  Result := qwTime / qwTicksPerSec;
end;

// Hier kommt der Dimmerkernel
procedure ExecuteDimmerkernelEvent;
var
  i,j,k,tempvalue,tempvalue1,tempvalue2:integer;
  actualvalue,startvalue,endvalue,inkrement:integer;
  volume:single;
  dTime1, dTime2: Double;
begin
  if mainform.pcdimmerresetting then exit;

  with mainform do
  begin
//    dTime1:=0;
//    if MeasureKernelLaufzeit then
    begin
      dTime1 := GetTime();
    end;

    if length(DimmerKernelChannelArray)>0 then
    for i:=length(DimmerKernelChannelArray)-1 downto 0 do
    if i<length(DimmerKernelChannelArray) then
    begin
      pDimmerKernelChannel:=DimmerKernelChannelArray[i];
      if pDimmerKernelChannel<>nil then
      if not (pDimmerKernelChannel.DeleteChannel) then
      begin
        if (pDimmerKernelChannel.channel_delay>0) then
        begin
          // Delay noch vorhanden, also um einen Punkt dekrementieren
          if (pDimmerKernelChannel.channel_delay<DimmerkernelResolution) then
            pDimmerKernelChannel.channel_delay:=0
          else
            pDimmerKernelChannel.channel_delay:=pDimmerKernelChannel.channel_delay-DimmerkernelResolution;
        end else
        begin
          // Delay ist um. Jetzt Paket verarbeiten
          case pDimmerKernelChannel.ChannelType of
            0: // Normaler Lichtkanal
            begin
              if not pDimmerKernelChannel.DontSetValues then
              begin
                // Kanal ist das erste Mal an der Reihe (nach Ablauf des Delay oder bei Delay=0)
                pDimmerKernelChannel.DontSetValues:=true;

                // Zunächst alle anderen Dimmerkanäle mit gleicher Adresse zum Löschen freigeben, sofern sie bereits dimmen
                for j:=length(DimmerKernelChannelArray)-1 downto 0 do
                begin
                  pDimmerKernelChannel2:=DimmerKernelChannelArray[j];
                  if (pDimmerKernelChannel2.channel=pDimmerKernelChannel.channel) and not (pDimmerKernelChannel2=pDimmerKernelChannel) and not (pDimmerKernelChannel2.channel_delay>0) then
                  begin
                    // Delay ist vorbei, Kanal hat gleiche Adresse und ist nicht identisch mit gleich auszuführendem. Also kann gelöscht werden.
                    channel_endvalue[pDimmerKernelChannel2.channel]:=channel_value[pDimmerKernelChannel2.channel];
                    pDimmerKernelChannel2.DeleteChannel:=true;
                  end;
                end;
                // Nun die neuen Dimmerwerte setzen
                if pDimmerKernelChannel.IsPanTiltChannel and (pDimmerKernelChannel.FineChannel>0) then
                  channel_value_highresolution[pDimmerKernelChannel.channel]:=channel_value[pDimmerKernelChannel.channel]*257+channel_value[pDimmerKernelChannel.FineChannel]
                else
                  channel_value_highresolution[pDimmerKernelChannel.channel]:=channel_value[pDimmerKernelChannel.channel]*257;
                channel_endvalue[pDimmerKernelChannel.channel]:=pDimmerKernelChannel.channel_endvalue;
                if pDimmerKernelChannel.IsPanTiltChannel and (pDimmerKernelChannel.FineChannel>0) then
                  pDimmerKernelChannel.channel_steps := round(Abs((channel_value[pDimmerKernelChannel.channel]*257)+channel_value[pDimmerKernelChannel.FineChannel] - (pDimmerKernelChannel.channel_endvalue*257)))
                else
                  pDimmerKernelChannel.channel_steps := round(Abs((channel_value[pDimmerKernelChannel.channel]*257) - (pDimmerKernelChannel.channel_endvalue*257)));

                if pDimmerKernelChannel.IsDelayedChan then
                begin
                  if pDimmerKernelChannel.SetStartvalue then
                  begin
                    Senddata(pDimmerKernelChannel.channel, maxres-pDimmerKernelChannel.channel_startvalue, maxres-pDimmerKernelChannel.channel_startvalue, 0, 0);
                    Senddata(pDimmerKernelChannel.channel, maxres-pDimmerKernelChannel.channel_startvalue, maxres-pDimmerKernelChannel.channel_endvalue,pDimmerKernelChannel.channel_fadetime);
                  end else
                  begin
                    pDimmerKernelChannel.channel_startvalue:=channel_value[pDimmerKernelChannel.channel];
                    Senddata(pDimmerKernelChannel.channel,-1,maxres-pDimmerKernelChannel.channel_endvalue,pDimmerKernelChannel.channel_fadetime);
                  end;

                  // da in der oberen Zeile ein neues Dimmerkernelobjekt erstellt wird, kann dieses hier gelöscht werden
                  pDimmerKernelChannel.DeleteChannel:=true;
                end;
              end;

              if not pDimmerKernelChannel.DeleteChannel then
              if (pDimmerKernelChannel.channel_fadetime=0) then
              begin
                // Fadetime=0
                channel_value_highresolution[pDimmerKernelChannel.channel]:=pDimmerKernelChannel.channel_endvalue*257;
                channel_value[pDimmerKernelChannel.channel]:=pDimmerKernelChannel.channel_endvalue;
                channel_endvalue[pDimmerKernelChannel.channel]:=pDimmerKernelChannel.channel_endvalue;

                data.ch[pDimmerKernelChannel.channel]:=maxres-channel_value[pDimmerKernelChannel.channel];

                tempvalue1:=pDimmerKernelChannel.channel;
                tempvalue2:=channel_value[pDimmerKernelChannel.channel];
                SendMSG(MSG_ACTUALCHANNELVALUE,tempvalue1,tempvalue2);
                pDimmerKernelChannel.DeleteChannel:=true;
              end else if (pDimmerKernelChannel.channel_fadetime>0) then
              begin
                // Fadetime>0
                if (trunc(channel_value_highresolution[pDimmerKernelChannel.channel]/257)<channel_endvalue[pDimmerKernelChannel.channel]) and ((pDimmerKernelChannel.FadeDirection=255) or (pDimmerKernelChannel.FadeDirection=0)) then
                begin
                  // Nach oben Dimmen
                  pDimmerKernelChannel.FadeDirection:=255;
                  channel_value_highresolution[pDimmerKernelChannel.channel]:=channel_value_highresolution[pDimmerKernelChannel.channel]+(pDimmerKernelChannel.channel_steps/(pDimmerKernelChannel.channel_fadetime div DimmerKernelResolution));//+1;
                  if channel_value_highresolution[pDimmerKernelChannel.channel]>65535 then
                    channel_value_highresolution[pDimmerKernelChannel.channel]:=65535;
                  if channel_value_highresolution[pDimmerKernelChannel.channel]<0 then
                    channel_value_highresolution[pDimmerKernelChannel.channel]:=0;
                  actualvalue:=trunc(channel_value_highresolution[pDimmerKernelChannel.channel]/257);
                  startvalue:=pDimmerKernelChannel.channel_startvalue;
                  endvalue:=channel_endvalue[pDimmerKernelChannel.channel];
                end else if (trunc(channel_value_highresolution[pDimmerKernelChannel.channel]/257)>channel_endvalue[pDimmerKernelChannel.channel]) and ((pDimmerKernelChannel.FadeDirection=128) or (pDimmerKernelChannel.FadeDirection=0)) then
                begin
                  // Nach unten Dimmen
                  pDimmerKernelChannel.FadeDirection:=128;
                  channel_value_highresolution[pDimmerKernelChannel.channel]:=channel_value_highresolution[pDimmerKernelChannel.channel]-(pDimmerKernelChannel.channel_steps/(pDimmerKernelChannel.channel_fadetime div DimmerKernelResolution));//-1;
                  if channel_value_highresolution[pDimmerKernelChannel.channel]>65535 then
                    channel_value_highresolution[pDimmerKernelChannel.channel]:=65535;
                  if channel_value_highresolution[pDimmerKernelChannel.channel]<0 then
                    channel_value_highresolution[pDimmerKernelChannel.channel]:=0;
                  actualvalue:=trunc(channel_value_highresolution[pDimmerKernelChannel.channel]/257);
                  startvalue:=channel_endvalue[pDimmerKernelChannel.channel];
                  endvalue:=pDimmerKernelChannel.channel_startvalue;
                end else
                begin
                  pDimmerKernelChannel.DeleteChannel:=true;
                  if channel_value_highresolution[pDimmerKernelChannel.channel]>65535 then
                    channel_value_highresolution[pDimmerKernelChannel.channel]:=65535;
                  if channel_value_highresolution[pDimmerKernelChannel.channel]<0 then
                    channel_value_highresolution[pDimmerKernelChannel.channel]:=0;
                  actualvalue:=trunc(channel_value_highresolution[pDimmerKernelChannel.channel]/257);
                  startvalue:=channel_endvalue[pDimmerKernelChannel.channel];
                  endvalue:=pDimmerKernelChannel.channel_startvalue;
                end;

                //  Viertel-Sinus
                //  sin((x/150)*(pi/2))*150+64-64*sin((x/150)*(pi/2))
                //  sin((actualvalue/endvalue)*(pi/2))*endvalue+startvalue-startvalue*sin((actualvalue/endvalue)*(pi/2))
                //  Viertel-Sinus Invertiert
                //  (150-(sin(((150-x)/150)*(pi/2))*150))+(64-64*(1-(sin(((150-x)/150)*(pi/2)))));
                //  (endvalue-(sin(((endvalue-actualvalue)/endvalue)*(pi/2))*endvalue))+(startvalue-startvalue*(1-(sin(((endvalue-actualvalue)/endvalue)*(pi/2)))));
                //  Halber Cosinus
                //  ((cos((( 150-x)/150)*pi)+1)/2)*150+64-64*((cos(((150-x)/150)*pi)+1)/2);
                //  ((cos(((endvalue-actualvalue)/endvalue)*pi)+1)/2)*endvalue+startvalue-startvalue*((cos(((endvalue-actualvalue)/endvalue)*pi)+1)/2);
                //  round((log2((255-value)/255)/-8)*255);
                //  round((((power(100,(value/500))-1)/(value-1)*value)/9.5)*255);


                // Dimmkurve anwenden
                channel_value_highresolution_filtered:=channel_value_highresolution[pDimmerKernelChannel.channel];
                case channel_dimmcurve[pDimmerKernelChannel.channel] of
                  0: channel_value_highresolution_filtered:=channel_value_highresolution[pDimmerKernelChannel.channel];  // Linear
                  1: if channel_value_highresolution[pDimmerKernelChannel.channel] < 32768 then channel_value_highresolution_filtered:=0 else channel_value_highresolution_filtered:=65535; // Schalten
                  2: // Viertel-Sinus
                  begin
                    //  sin((x/150)*(pi/2))*150+64-64*sin((x/150)*(pi/2))
                    //  sin((actualvalue/endvalue)*(pi/2))*endvalue+startvalue-startvalue*sin((actualvalue/endvalue)*(pi/2))
                    actualvalue:=round(((actualvalue-startvalue)/(endvalue-startvalue))*maxres);
                    channel_value_highresolution_filtered:=round((sin((actualvalue/maxres)*(pi/2))*endvalue+startvalue-startvalue*sin((actualvalue/maxres)*(pi/2)))*257);
                  end;
                  3: // Viertel-Sinus Invertiert
                  begin
                    //  150-(sin(((150-x)/150)*(pi/2))*150+64-64*sin(((150-x)/150)*(pi/2)))+64
                    //  endvalue-(sin(((endvalue-actualvalue)/endvalue)*(pi/2))*endvalue+startvalue-startvalue*sin(((endvalue-actualvalue)/endvalue)*(pi/2)))+startvalue
                    actualvalue:=round(((actualvalue-startvalue)/(endvalue-startvalue))*maxres);
                    channel_value_highresolution_filtered:=round((endvalue-(sin(((maxres-actualvalue)/maxres)*(pi/2))*endvalue+startvalue-startvalue*sin(((maxres-actualvalue)/maxres)*(pi/2)))+startvalue)*257);
                  end;
                  4:
                  begin
                    //  ((cos(((maxres*256-x)/maxres*256)*pi)+1)/2)*150+64-64*((cos(((maxres*256-x)/maxres*256)*pi)+1)/2)
                    //  ((cos(((maxres*256-actualvalue)/maxres*256)*pi)+1)/2)*endvalue+startvalue-startvalue*((cos(((maxres*256-actualvalue)/maxres*256)*pi)+1)/2)
                    actualvalue:=round(((actualvalue-startvalue)/(endvalue-startvalue))*maxres);
                    channel_value_highresolution_filtered:=round((((cos(((maxres-actualvalue)/maxres)*pi)+1)/2)*endvalue+startvalue-startvalue*((cos(((maxres-actualvalue)/maxres)*pi)+1)/2))*257); // Halber Cosinus
                  end;
                  5:
                  begin
                    actualvalue:=round(((actualvalue-startvalue)/(endvalue-startvalue))*maxres);
                    channel_value_highresolution_filtered:=round((power(((cos(power(((maxres-actualvalue)/maxres),2)*pi)+1)/2),4)*endvalue+startvalue-startvalue*power(((cos(power(((maxres-actualvalue)/maxres),2)*pi)+1)/2),4))*257); // Gestauchter halber Cosinus
                  end;
                  6:
                  begin
                    //  (((x-127)/25.266)^3+127)
                    //  (power(((actualvalue-127)/25.266),3)+127)
                    actualvalue:=round(((actualvalue-startvalue)/(endvalue-startvalue))*maxres);
                    channel_value_highresolution_filtered:=round(((power(((actualvalue-127)/25.266),3)+127)/maxres*endvalue+startvalue-startvalue*(power(((actualvalue-127)/25.266),3)+127)/maxres)*257);
                  end;
                  7:
                  begin
                    if (actualvalue>=0) and (actualvalue<51) then channel_value_highresolution_filtered:=0;
                    if (actualvalue>=51) and (actualvalue<102) then channel_value_highresolution_filtered:=51*257;
                    if (actualvalue>=102) and (actualvalue<153) then channel_value_highresolution_filtered:=102*257;
                    if (actualvalue>=153) and (actualvalue<204) then channel_value_highresolution_filtered:=153*257;
                    if (actualvalue>=204) and (actualvalue<maxres*256) then channel_value_highresolution_filtered:=204*257;
                    if (actualvalue>=255) then channel_value_highresolution_filtered:=255*257;
                  end;
                  8:
                  begin
                    //  x+sin(x/4)*10;
                    //  round(actualvalue+sin(actualvalue/4)*10)
                    channel_value_highresolution_filtered:=round((actualvalue+sin(actualvalue/4)*10)*257);
                  end;
                  9:
                  begin
                    //  x+sin(x/4)*10;
                    //  round(actualvalue+sin(actualvalue/4)*40)
                    channel_value_highresolution_filtered:=round((actualvalue+sin(actualvalue/4)*40)*257);
                  end;
                  10:
                  begin
                    // y:=round((log2((255-x)/255)/-8)*255)
                    if actualvalue=endvalue then
                      channel_value_highresolution_filtered:=endvalue*257
                    else
                      channel_value_highresolution_filtered:=(log2(((endvalue-startvalue)-(actualvalue-startvalue))/(endvalue-startvalue))/-8)*(endvalue-startvalue)*257;
                  end;
                  11:
                  begin
                    // y:=round((((power(100,(x/500))-1)/(x-1)*x)/9.5)*255);      round(  (  (  (power(100,(x/500))-1)   /(x-1)*x)/9.5)*255)
                    if actualvalue=endvalue then
                      channel_value_highresolution_filtered:=endvalue*257
                    else
                    begin
                      if (((actualvalue-startvalue)-1)=0) then
                        channel_value_highresolution_filtered:=0
                      else
                        channel_value_highresolution_filtered:=(((power(100,((actualvalue-startvalue)/500))-1)/((actualvalue-startvalue)-1)*(actualvalue-startvalue))/9.5)*(endvalue-startvalue)*257;
                    end;
                  end;
                end;

                if channel_value_highresolution_filtered>65535 then channel_value_highresolution_filtered:=65535;
                if channel_value_highresolution_filtered<0 then channel_value_highresolution_filtered:=0;

                // Coarse-Kanal setzen
                tempvalue1:=pDimmerKernelChannel.channel;
                tempvalue2:=trunc(channel_value_highresolution_filtered/257);
                if channel_value[tempvalue1]<>tempvalue2 then
                begin
                  channel_value[tempvalue1]:=tempvalue2;
                  data.ch[tempvalue1]:=maxres-tempvalue2;
                  SendMSG(MSG_ACTUALCHANNELVALUE,tempvalue1,tempvalue2);
                end;

                // Fine-Kanal, sofern vorhanden, setzen
                if pDimmerKernelChannel.IsPanTiltChannel and (pDimmerKernelChannel.FineChannel>0) then
                begin
                  tempvalue1:=pDimmerKernelChannel.FineChannel;
                  tempvalue2:=trunc(frac(channel_value_highresolution_filtered/257)*256);
                  if channel_value[tempvalue1]<>tempvalue2 then
                  begin
                    channel_value[tempvalue1]:=tempvalue2;
                    data.ch[tempvalue1]:=maxres-tempvalue2;
                    SendMSG(MSG_ACTUALCHANNELVALUE,tempvalue1,tempvalue2);
                  end;
                end;
              end else
              begin
                // nichts zu tun, da Schritte zwischen Ist- und Sollwert bereits =0
                pDimmerKernelChannel.DeleteChannel:=true;
              end;

              if not pDimmerKernelChannel.DeleteChannel then
              if channel_value_highresolution[pDimmerKernelChannel.channel]=channel_endvalue[pDimmerKernelChannel.channel] Then
              begin
                // DDF-Fenster aktualisieren
                for j:=0 to length(DDFWindows)-1 do
                  DDFWindows[j].refreshchannel[pDimmerKernelChannel.channel]:=true;
                // DeviceScene-Fenster aktualisieren
                if DDFWindowDeviceScene.Showing then
                  DDFWindowDeviceScene.refreshchannel[pDimmerKernelChannel.channel]:=true;
                // Gerätesteuerungsfenster aktualisieren
                if geraetesteuerung.Showing then
                  geraetesteuerung.refreshchannel[pDimmerKernelChannel.channel]:=true;

                // Dimmerkanal löschen, da fertig gedimmt
                pDimmerKernelChannel.DeleteChannel:=true;
              end;
            end;
            1: // Audiodatei faden
            begin
              if not pDimmerKernelChannel.DontSetValues then
              begin
                // Kanal ist das erste Mal an der Reihe
                pDimmerKernelChannel.DontSetValues:=true;

                // Zunächst alle anderen Dimmerkanäle mit gleicher Adresse zum Löschen freigeben, sofern sie bereits dimmen
                for j:=length(DimmerKernelChannelArray)-1 downto 0 do
                begin
                  pDimmerKernelChannel2:=DimmerKernelChannelArray[j];
                  if (pDimmerKernelChannel2.Index=pDimmerKernelChannel.Index) and not (pDimmerKernelChannel2=pDimmerKernelChannel) and not (pDimmerKernelChannel2.channel_delay>0) then
                  begin
                    // Delay ist vorbei, Kanal hat gleiche Adresse und ist nicht identisch mit gleich auszuführendem. Also kann gelöscht werden.
                    pDimmerKernelChannel2.DeleteChannel:=true;
                  end;
                end;
              end else
              begin
                BASS_ChannelGetAttribute(AudioszenenCHAN[pDimmerKernelChannel.Index].MixerHandle, BASS_ATTRIB_VOL, volume);

                if pDimmerKernelChannel.Start then
                begin
                  // Audiodatei soll gestartet werden
                  if not (BASS_ChannelIsActive(AudioszenenCHAN[pDimmerKernelChannel.Index].MixerHandle)=BASS_ACTIVE_PLAYING) then
                  begin
                    BASS_ChannelPlay(AudioszenenCHAN[pDimmerKernelChannel.Index].MixerHandle, False);
                    volume:=0;
                    BASS_ChannelSetAttribute(AudioszenenCHAN[pDimmerKernelChannel.Index].MixerHandle, BASS_ATTRIB_VOL, volume);
                  end;

                  if (pDimmerKernelChannel.channel_steps>0) then
                  begin
                    // Einblenden
                    if volume+(pDimmerKernelChannel.channel_steps/(65535/DimmerKernelResolution))<=1 then
                      volume:=volume+(pDimmerKernelChannel.channel_steps/(65535/DimmerKernelResolution))
                    else
                      volume:=pDimmerKernelChannel.channel_endvalue/65535;
                  end else
                  begin
                    volume:=pDimmerKernelChannel.channel_endvalue/65535;
                  end;
                  pDimmerKernelChannel.channel_increase:=round(volume*65535);
                  BASS_ChannelSetAttribute(AudioszenenCHAN[pDimmerKernelChannel.Index].MixerHandle, BASS_ATTRIB_VOL, volume);

                  // Wenn Endwert erreicht oder überschritten, dann DimmerKanal löschen
                  if (volume>=(pDimmerKernelChannel.channel_endvalue/65535)) or (volume>=1) then
                  begin
                    pDimmerKernelChannel.DeleteChannel:=true;
                  end;
                end else
                begin
                  // Audiodatei soll beendet werden
                  if (pDimmerKernelChannel.channel_steps>0) then
                  begin
                    // Ausblenden
                    if volume-(pDimmerKernelChannel.channel_steps/(65535/DimmerKernelResolution))>=0 then
                      volume:=volume-(pDimmerKernelChannel.channel_steps/(65535/DimmerKernelResolution))
                    else
                      volume:=0;
                  end else
                  begin
                    volume:=0;
                  end;
                  pDimmerKernelChannel.channel_increase:=round(volume*65535);
                  BASS_ChannelSetAttribute(AudioszenenCHAN[pDimmerKernelChannel.Index].MixerHandle, BASS_ATTRIB_VOL, volume);

                  // Wenn Endwert erreicht oder unterschritten, dann Datei beenden und DimmerKanal löschen
                  if (volume<=(pDimmerKernelChannel.channel_endvalue/65535)) or (volume<=0) then
                  begin
                    BASS_ChannelStop(AudioszenenCHAN[pDimmerKernelChannel.Index].MixerHandle);
                    BASS_Mixer_ChannelRemove(AudioszenenCHAN[pDimmerKernelChannel.Index].StandardHandle);
                    BASS_StreamFree(AudioszenenCHAN[pDimmerKernelChannel.Index].StandardHandle);
                    BASS_StreamFree(AudioszenenCHAN[pDimmerKernelChannel.Index].MixerHandle);
                    AudioszenenCHAN[pDimmerKernelChannel.Index].StandardHandle:=0;
                    AudioszenenCHAN[pDimmerKernelChannel.Index].MixerHandle:=0;
                    pDimmerKernelChannel.DeleteChannel:=true;
                  end;
                end;
              end; // Ende von DontSetValues
            end; // Ende von Audiodatei faden
            2: // Szenenbefehl faden
            begin
              if not pDimmerKernelChannel.DontSetValues then
              begin
                // Kanal ist das erste Mal an der Reihe (nach Ablauf des Delay oder bei Delay=0)
                pDimmerKernelChannel.DontSetValues:=true;

{
                // Zunächst alle anderen Dimmerkanäle mit gleicher Adresse zum Löschen freigeben, sofern sie bereits dimmen
                for j:=length(DimmerKernelChannelArray)-1 downto 0 do
                begin
                  pDimmerKernelChannel2:=DimmerKernelChannelArray[j];
                  if IsEqualGUID(pDimmerKernelChannel2.BefehlTyp, pDimmerKernelChannel.BefehlTyp) and not (pDimmerKernelChannel2=pDimmerKernelChannel) and not (pDimmerKernelChannel2.channel_delay>0) then
                  begin
                    // Delay ist vorbei, Kanal hat gleiche Adresse und ist nicht identisch mit gleich auszuführendem. Also kann gelöscht werden.
                    pDimmerKernelChannel2.DeleteChannel:=true;
                  end;
                end;
}
                // Nun die neuen Dimmerwerte setzen
                for j:=0 to length(mainform.Befehlssystem)-1 do
                begin
                  for k:=0 to length(mainform.Befehlssystem[j].Steuerung)-1 do
                  begin
                    if IsEqualGUID(Befehlssystem[j].Steuerung[k].GUID, pDimmerKernelChannel.BefehlTyp) then
                    begin
                      pDimmerKernelChannel.channel_steps:=Abs(mainform.Befehlssystem[j].Steuerung[k].CurrentValue - pDimmerKernelChannel.channel_endvalue);
                      pDimmerKernelChannel.channel_startvalue:=mainform.Befehlssystem[j].Steuerung[k].CurrentValue;
                      pDimmerKernelChannel.CurrentValue:=mainform.Befehlssystem[j].Steuerung[k].CurrentValue;
                      mainform.StartBefehl(pDimmerKernelChannel.IndexGUID, pDimmerKernelChannel.CurrentValue);
                      break;
                    end;
                  end;
                end;

                if pDimmerKernelChannel.IsDelayedChan then
                begin
                  StartDeviceSceneBefehl(pDimmerKernelChannel.IndexGUID, pDimmerKernelChannel.BefehlTyp, pDimmerKernelChannel.channel_endvalue, pDimmerKernelChannel.channel_fadetime, 0);

                  // da in der oberen Zeile ein neues Dimmerkernelobjekt erstellt wird, kann dieses hier gelöscht werden
                  pDimmerKernelChannel.DeleteChannel:=true;
                end;
              end;

              if not pDimmerKernelChannel.DeleteChannel then
              if (pDimmerKernelChannel.channel_fadetime=0) then
              begin
                // Fadetime=0
{
                for j:=0 to length(mainform.Befehlssystem)-1 do
                begin
                  for k:=0 to length(mainform.Befehlssystem[j].Steuerung)-1 do
                  begin
                    if IsEqualGUID(mainform.Befehlssystem[j].Steuerung[k].GUID, pDimmerKernelChannel.BefehlTyp) then
                    begin
}
                      pDimmerKernelChannel.CurrentValue:=pDimmerKernelChannel.channel_endvalue;
                      mainform.StartBefehl(pDimmerKernelChannel.IndexGUID, pDimmerKernelChannel.CurrentValue);
{
                      break;
                    end;
                  end;
                end;
}

                pDimmerKernelChannel.DeleteChannel:=true;
              end else if (pDimmerKernelChannel.channel_fadetime>0) then
              begin
                // Fadetime>0
                pDimmerKernelChannel.channel_increase:=pDimmerKernelChannel.channel_increase+1;
                if pDimmerKernelChannel.channel_steps>0 then
                begin
                  if pDimmerKernelChannel.channel_increase >= Round((pDimmerKernelChannel.channel_fadetime div DimmerKernelResolution) / pDimmerKernelChannel.channel_steps) then
                  begin
                    pDimmerKernelChannel.channel_increase:=0;

                    if (pDimmerKernelChannel.CurrentValue<pDimmerKernelChannel.channel_endvalue) and ((pDimmerKernelChannel.FadeDirection=255) or (pDimmerKernelChannel.FadeDirection=0)) then
                    begin
                      // Nach oben Dimmen
                      pDimmerKernelChannel.FadeDirection:=255;
                      if (pDimmerKernelChannel.channel_fadetime<10000) then
                      begin
                        inkrement:=Round(pDimmerKernelChannel.channel_steps / (pDimmerKernelChannel.channel_fadetime div DimmerKernelResolution));
                        if inkrement<1 then
                          inkrement:=1;

                        if pDimmerKernelChannel.CurrentValue+inkrement<255 then
                          pDimmerKernelChannel.CurrentValue:=pDimmerKernelChannel.CurrentValue+inkrement//1 // TODO: da 255 Schritte durchfahren werden, werden hier mindestens 255*20ms=5100ms=5.1s benötigt. Kleinere Fadezeiten sind derzeit nicht möglich!!!
                        else
                          pDimmerKernelChannel.CurrentValue:=255;
                      end else
                      begin
                        if pDimmerKernelChannel.CurrentValue+1<255 then
                          pDimmerKernelChannel.CurrentValue:=pDimmerKernelChannel.CurrentValue+1//1 // TODO: da 255 Schritte durchfahren werden, werden hier mindestens 255*20ms=5100ms=5.1s benötigt. Kleinere Fadezeiten sind derzeit nicht möglich!!!
                        else
                          pDimmerKernelChannel.CurrentValue:=255;
                      end;
                    end else if (pDimmerKernelChannel.CurrentValue>pDimmerKernelChannel.channel_endvalue) and ((pDimmerKernelChannel.FadeDirection=128) or (pDimmerKernelChannel.FadeDirection=0)) then
                    begin
                      // Nach unten Dimmen
                      pDimmerKernelChannel.FadeDirection:=128;
                      if (pDimmerKernelChannel.channel_fadetime<10000) then
                      begin
                        inkrement:=Round(pDimmerKernelChannel.channel_steps / (pDimmerKernelChannel.channel_fadetime div DimmerKernelResolution));
                        if inkrement<1 then
                          inkrement:=1;

                        if pDimmerKernelChannel.CurrentValue-inkrement>0 then
                          pDimmerKernelChannel.CurrentValue:=pDimmerKernelChannel.CurrentValue-inkrement//1 // TODO: da 255 Schritte durchfahren werden, werden hier mindestens 255*20ms=5100ms=5.1s benötigt. Kleinere Fadezeiten sind derzeit nicht möglich!!!
                        else
                          pDimmerKernelChannel.CurrentValue:=0;
                      end else
                      begin
                        if pDimmerKernelChannel.CurrentValue-1>0 then
                          pDimmerKernelChannel.CurrentValue:=pDimmerKernelChannel.CurrentValue-1//1 // TODO: da 255 Schritte durchfahren werden, werden hier mindestens 255*20ms=5100ms=5.1s benötigt. Kleinere Fadezeiten sind derzeit nicht möglich!!!
                        else
                          pDimmerKernelChannel.CurrentValue:=0;
                      end;
                    end else
                    begin
                      pDimmerKernelChannel.DeleteChannel:=true;
                    end;

                    StartBefehl(pDimmerKernelChannel.IndexGUID, pDimmerKernelChannel.CurrentValue);
                  end;
                end else
                begin
                  // nichts zu tun, da Schritte zwischen Ist- und Sollwert bereits =0
                  pDimmerKernelChannel.DeleteChannel:=true;
                end;
              end;

              if not pDimmerKernelChannel.DeleteChannel then
              if pDimmerKernelChannel.CurrentValue=pDimmerKernelChannel.channel_endvalue Then
              begin
                // Kanal löschen, da fertig gedimmt
                pDimmerKernelChannel.DeleteChannel:=true;
              end;
            end; // Ende von Befehl faden
          end; // Ende von Case DimmerChannelTyp
        end;
      end else // Ende von "if not Delete then"
      begin
      end; // Ende von "if not Delete then else"
    end; // Ende von DimmerkernelChannel ForToDo

    // Garbage-Collector: Alle zum Löschen freigegebenen Kanäle löschen
    for j:=length(DimmerKernelChannelArray)-1 downto 0 do
    begin
      pDimmerKernelChannel2:=DimmerKernelChannelArray[j];
      if pDimmerKernelChannel2<>nil then
      begin
        if (pDimmerKernelChannel2.DeleteChannel) then
        begin
          dispose(pDimmerKernelChannel2);
          DimmerKernelChannelArray[j]:=DimmerKernelChannelArray[length(DimmerKernelChannelArray)-1];
          setlength(DimmerKernelChannelArray,length(DimmerKernelChannelArray)-1);
        end else if (pDimmerKernelChannel2.channel_endvalue=channel_value[pDimmerKernelChannel2.channel]) and (not pDimmerKernelChannel2.IsDelayedChan) then
        begin
          // Endwert des Kanals ist erreicht -> Löschen
{
          // ist glaube ich nicht notwendig
          dispose(pDimmerKernelChannel2);
          DimmerKernelChannelArray[j]:=DimmerKernelChannelArray[length(DimmerKernelChannelArray)-1];
          setlength(DimmerKernelChannelArray,length(DimmerKernelChannelArray)-1);
}
        end;
      end else
      begin
        // Letztes Element auf freiwerdenden Platz und letztes Element löschen
        DimmerKernelChannelArray[j]:=DimmerKernelChannelArray[length(DimmerKernelChannelArray)-1];
        setlength(DimmerKernelChannelArray,length(DimmerKernelChannelArray)-1);
      end;
    end;

//    if MeasureKernelLaufzeit then
    begin
      dTime2 := GetTime();
      KernelLaufzeit:=dTime2-dTime1;
    end;
  end; // end von with mainform
end;

procedure ExecuteBewegungsszenenEvent;
var
  i, j, k, m, n:integer;
  figur:integer;
  timevalue,tempzeit:Cardinal;
  pan, tilt:boolean;
  panchan, tiltchan:integer;
  PositionInDeviceArray, PositionInGroupArray:integer;
  effektspeedvalue:integer;
  tempcardinal,tempdelay:cardinal;
begin
  if mainform.pcdimmerresetting then exit;

  // Bewegungsszenen ablaufen lassen
  with mainform do
  begin
    with bewegungsszeneneditorform do
    for k:=0 to length(Bewegungsszenen)-1 do
    begin
      // Welche Figur wird verwendet?
      figur:=-1;
      for m:=0 to length(figuren)-1 do
        if IsEqualGUID(Bewegungsszenen[k].figur,figuren[m].ID) then
        begin
          figur:=m;
          break;
        end;
      if BewegungsszenenAktiv[k].Aktiv then
      begin
        for i:=0 to length(Bewegungsszenen[k].Devices)-1 do
        begin
          // Alle Geräte durchiterieren
          PositionInDeviceArray:=-1;
          for n:=0 to length(mainform.Devices)-1 do
          begin
            if IsEqualGUID(mainform.Devices[n].ID,Bewegungsszenen[k].Devices[i].ID) then
            begin
              PositionInDeviceArray:=n;
              break;
            end;
          end;

          // Alle Gruppen durchiterieren
          PositionInGroupArray:=-1;
          for n:=0 to length(mainform.DeviceGroups)-1 do
          begin
            if IsEqualGUID(mainform.DeviceGroups[n].ID,Bewegungsszenen[k].Devices[i].ID) then
            begin
              PositionInGroupArray:=n;
              break;
            end;
          end;

          if PositionInDeviceArray>=0 then
          begin
            // Gerät
            for n:=0 to length(Bewegungsszenen[k].Devices[i].DeviceChannel)-1 do
            if Bewegungsszenen[k].Devices[i].DeviceChannel[n].ChanActive then
            begin
              // Wartezeiten für jeden Kanal einzeln inkrementieren
              BewegungsszenenAktiv[k].Zeit[i][n]:=BewegungsszenenAktiv[k].Zeit[i][n]+1;

              if not Bewegungsszenen[k].IsBeatControlled then
              begin
                if (masterform.speedmaster.max-masterform.speedmaster.position)<256 then
                begin // Langsamer
                  timevalue:=mainform.BewegungsszenenZeit[k][i][n]+round((maxres-(masterform.speedmaster.max-masterform.speedmaster.position))*10);
                end else if (masterform.speedmaster.max-masterform.speedmaster.position)>256 then
                begin // Schneller
                  timevalue:=mainform.BewegungsszenenZeit[k][i][n]-round((((masterform.speedmaster.max-masterform.speedmaster.position)-257)/256)*mainform.BewegungsszenenZeit[k][i][n]);
                end else
                begin
                  timevalue:=mainform.BewegungsszenenZeit[k][i][n];
                end;
                if timevalue<25 then timevalue:=25;
              end else
              begin
                timevalue:=25;
              end;

              // Falls aktuelle Zeit abgewartet, dann wechseln zu nächstem Punkt
  //            if (BewegungsszenenAktiv[k].Zeit[i][n] >= mainform.BewegungsszenenZeit[k][i][n]) then
              if ((not Bewegungsszenen[k].IsBeatControlled) and (BewegungsszenenAktiv[k].Zeit[i][n] >= timevalue)) or (Bewegungsszenen[k].IsBeatControlled and NextMovingSceneStep) then
              begin
                BewegungsszenenAktiv[k].Zeit[i][n]:=0;

                // Dimmzeit zwischen aktuellem Punkt und nächstem Punkt berechnen
                if BewegungsszenenAktiv[k].Position[i][n]+1>=length(figuren[figur].posx) then
                  BewegungsszenenZeit[k][i][n]:=round(ZeitzwischenzweiPunkten(GetX(i,n,BewegungsszenenAktiv[k].Position[i][n],Bewegungsszenen[k].ID),GetY(i,n,BewegungsszenenAktiv[k].Position[i][n],Bewegungsszenen[k].ID),GetX(i,n,0,Bewegungsszenen[k].ID),GetY(i,n,0,Bewegungsszenen[k].ID),length(Figuren[figur].posx),Bewegungsszenen[k].id))
                else
                  BewegungsszenenZeit[k][i][n]:=round(ZeitzwischenzweiPunkten(GetX(i,n,BewegungsszenenAktiv[k].Position[i][n],Bewegungsszenen[k].ID),GetY(i,n,BewegungsszenenAktiv[k].Position[i][n],Bewegungsszenen[k].ID),GetX(i,n,BewegungsszenenAktiv[k].Position[i][n]+1,Bewegungsszenen[k].ID),GetY(i,n,BewegungsszenenAktiv[k].Position[i][n]+1,Bewegungsszenen[k].ID),length(Figuren[figur].posx),Bewegungsszenen[k].id));

                if Bewegungsszenen[k].IsBeatControlled then
                begin
                  timevalue:=beatform.TimeBetweenBeats;
                end else
                begin
                  if (masterform.speedmaster.max-masterform.speedmaster.position)<256 then
                  begin // Langsamer
                    timevalue:=mainform.BewegungsszenenZeit[k][i][n]+round((maxres-(masterform.speedmaster.max-masterform.speedmaster.position))*10);
                  end else if (masterform.speedmaster.max-masterform.speedmaster.position)>256 then
                  begin // Schneller
                    timevalue:=mainform.BewegungsszenenZeit[k][i][n]-round((((masterform.speedmaster.max-masterform.speedmaster.position)-257)/256)*mainform.BewegungsszenenZeit[k][i][n]);
                  end else
                  begin
                    timevalue:=mainform.BewegungsszenenZeit[k][i][n];
                  end;
                end;
                if timevalue<25 then timevalue:=25;

                if Bewegungsszenen[k].DontFade then
                  tempzeit:=0
                else
                  tempzeit:=timevalue;

                // Delay-Zeit prüfen
                if Bewegungsszenen[k].Devices[i].DeviceChannel[n].delay<0 then
                  tempdelay:=0
                else
                  tempdelay:=Bewegungsszenen[k].Devices[i].DeviceChannel[n].delay;

                if ((Bewegungsszenen[k].Devices[i].DeviceChannel[n].y and (not Bewegungsszenen[k].Devices[i].DeviceChannel[n].mixXY)) or (Bewegungsszenen[k].Devices[i].DeviceChannel[n].x and Bewegungsszenen[k].Devices[i].DeviceChannel[n].mixXY)) then
                begin
                  // Falls Y-Wert
                  if BewegungsszenenAktiv[k].Position[i][n]+1>=length(figuren[figur].posx) then
                  begin // zurück zur ersten Position
                    if (Bewegungsszenen[k].repeats=-1) or (BewegungsszenenAktiv[k].Repeats[i][n]<Bewegungsszenen[k].repeats) then
                    begin
                      geraetesteuerung.set_channel(Bewegungsszenen[k].Devices[i].ID, mainform.devices[PositionInDeviceArray].kanaltyp[n], (GetY(i,n,BewegungsszenenAktiv[k].Position[i][n],Bewegungsszenen[k].ID) * maxres div 400), (GetY(i,n,0,Bewegungsszenen[k].ID) * maxres div 400),tempzeit,tempdelay);
                    end;
                  end else
                  begin // nächste Figurenposition abspielen
                    geraetesteuerung.set_channel(Bewegungsszenen[k].Devices[i].ID, mainform.devices[PositionInDeviceArray].kanaltyp[n], (GetY(i,n,BewegungsszenenAktiv[k].Position[i][n],Bewegungsszenen[k].ID) * maxres div 400), (GetY(i,n,BewegungsszenenAktiv[k].Position[i][n]+1,Bewegungsszenen[k].ID) * maxres div 400),tempzeit,tempdelay);
                  end;
                end else
                if ((Bewegungsszenen[k].Devices[i].DeviceChannel[n].x and (not Bewegungsszenen[k].Devices[i].DeviceChannel[n].mixXY)) or (Bewegungsszenen[k].Devices[i].DeviceChannel[n].y and Bewegungsszenen[k].Devices[i].DeviceChannel[n].mixXY)) then
                begin
                  // Falls X-Wert
                  if BewegungsszenenAktiv[k].Position[i][n]+1>=length(figuren[figur].posx) then
                  begin // zurück zur ersten Position
                    if (Bewegungsszenen[k].repeats=-1) or (BewegungsszenenAktiv[k].Repeats[i][n]<Bewegungsszenen[k].repeats) then
                    begin
                      geraetesteuerung.set_channel(Bewegungsszenen[k].Devices[i].ID, mainform.devices[PositionInDeviceArray].kanaltyp[n], (GetX(i,n,BewegungsszenenAktiv[k].Position[i][n],Bewegungsszenen[k].ID) * maxres div 400), (GetX(i,n,0,Bewegungsszenen[k].ID) * maxres div 400),tempzeit,tempdelay);
                    end;
                  end else
                  begin // nächste Figurenposition abspielen
                    geraetesteuerung.set_channel(Bewegungsszenen[k].Devices[i].ID, mainform.devices[PositionInDeviceArray].kanaltyp[n], (GetX(i,n,BewegungsszenenAktiv[k].Position[i][n],Bewegungsszenen[k].ID) * maxres div 400), (GetX(i,n,BewegungsszenenAktiv[k].Position[i][n]+1,Bewegungsszenen[k].ID) * maxres div 400),tempzeit,tempdelay);
                  end;
                end;

                // Szene an aktueller Position abspielen
                for j:=0 to length(Bewegungsszenen[k].Devices[i].Szenen[n])-1 do
                  if Bewegungsszenen[k].Devices[i].Szenen[n][j].Position=BewegungsszenenAktiv[k].Position[i][n] then
                    StartScene(Bewegungsszenen[k].Devices[i].Szenen[n][j].ID,false,false, -1);

                // nächste Position
                BewegungsszenenAktiv[k].Position[i][n]:=BewegungsszenenAktiv[k].Position[i][n]+1;
                if BewegungsszenenAktiv[k].Position[i][n]>=length(figuren[figur].posx) then
                begin
                  BewegungsszenenAktiv[k].Position[i][n]:=0;

                  if Bewegungsszenen[k].repeats>-1 then
                  begin
                    if BewegungsszenenAktiv[k].Repeats[i][n]>=Bewegungsszenen[k].repeats then
                    begin
                      BewegungsszenenAktiv[k].Aktiv:=false;
                    end else
                    begin
                      BewegungsszenenAktiv[k].Repeats[i][n]:=BewegungsszenenAktiv[k].Repeats[i][n]+1;
                    end;
                  end else
                  begin
                    BewegungsszenenAktiv[k].Repeats[i][n]:=BewegungsszenenAktiv[k].Repeats[i][n]+1;
                  end;
                end;
              end;
            end;
          end else if PositionInGroupArray>=0 then
          begin
            // Gruppe
            for n:=0 to length(Bewegungsszenen[k].Devices[i].DeviceChannel)-1 do
            if Bewegungsszenen[k].Devices[i].DeviceChannel[n].ChanActive then
            begin
              if (Bewegungsszenen[k].Devices[i].DeviceChannel[n].x or Bewegungsszenen[k].Devices[i].DeviceChannel[n].y) then
              begin
                if not Bewegungsszenen[k].IsBeatControlled then
                begin
                  // Wartezeiten für jeden Kanal einzeln inkrementieren
                  BewegungsszenenAktiv[k].Zeit[i][n]:=BewegungsszenenAktiv[k].Zeit[i][n]+1;

                  if (masterform.speedmaster.max-masterform.speedmaster.position)<256 then
                  begin // Langsamer
                    timevalue:=mainform.BewegungsszenenZeit[k][i][n]+round((maxres-(masterform.speedmaster.max-masterform.speedmaster.position))*10);
                  end else if (masterform.speedmaster.max-masterform.speedmaster.position)>256 then
                  begin // Schneller
                    timevalue:=mainform.BewegungsszenenZeit[k][i][n]-round((((masterform.speedmaster.max-masterform.speedmaster.position)-257)/256)*mainform.BewegungsszenenZeit[k][i][n]);
                  end else
                  begin
                    timevalue:=mainform.BewegungsszenenZeit[k][i][n];
                  end;
                  if timevalue<25 then timevalue:=25;
                end else
                begin
                  timevalue:=25;
                end;

                // Falls aktuelle Zeit abgewartet, dann wechseln zu nächstem Punkt
  //              if (BewegungsszenenAktiv[k].Zeit[i][n] >= mainform.BewegungsszenenZeit[k][i][n]) then
                if ((not Bewegungsszenen[k].IsBeatControlled) and (BewegungsszenenAktiv[k].Zeit[i][n] >= timevalue)) or (Bewegungsszenen[k].IsBeatControlled and NextMovingSceneStep) then
                begin
                  BewegungsszenenAktiv[k].Zeit[i][n]:=0;

                  // Dimmzeit zwischen aktuellem Punkt und nächstem Punkt berechnen
                  if BewegungsszenenAktiv[k].Position[i][n]+1>=length(figuren[figur].posx) then
                    BewegungsszenenZeit[k][i][n]:=round(ZeitzwischenzweiPunkten(GetX(i,n,BewegungsszenenAktiv[k].Position[i][n],Bewegungsszenen[k].ID),GetY(i,n,BewegungsszenenAktiv[k].Position[i][n],Bewegungsszenen[k].ID),GetX(i,n,0,Bewegungsszenen[k].ID),GetY(i,n,0,Bewegungsszenen[k].ID),length(Figuren[figur].posx),Bewegungsszenen[k].id))
                  else
                    BewegungsszenenZeit[k][i][n]:=round(ZeitzwischenzweiPunkten(GetX(i,n,BewegungsszenenAktiv[k].Position[i][n],Bewegungsszenen[k].ID),GetY(i,n,BewegungsszenenAktiv[k].Position[i][n],Bewegungsszenen[k].ID),GetX(i,n,BewegungsszenenAktiv[k].Position[i][n]+1,Bewegungsszenen[k].ID),GetY(i,n,BewegungsszenenAktiv[k].Position[i][n]+1,Bewegungsszenen[k].ID),length(Figuren[figur].posx),Bewegungsszenen[k].id));

                  if Bewegungsszenen[k].IsBeatControlled then
                  begin
                    timevalue:=beatform.TimeBetweenBeats;
                  end else
                  begin
                    if (masterform.speedmaster.max-masterform.speedmaster.position)<256 then
                    begin // Langsamer
                      timevalue:=mainform.BewegungsszenenZeit[k][i][n]+round((maxres-(masterform.speedmaster.max-masterform.speedmaster.position))*10);
                    end else if (masterform.speedmaster.max-masterform.speedmaster.position)>256 then
                    begin // Schneller
                      timevalue:=mainform.BewegungsszenenZeit[k][i][n]-round((((masterform.speedmaster.max-masterform.speedmaster.position)-257)/256)*mainform.BewegungsszenenZeit[k][i][n]);
                    end else
                    begin
                      timevalue:=mainform.BewegungsszenenZeit[k][i][n];
                    end;
                  end;
                  if timevalue<25 then timevalue:=25;

                  if Bewegungsszenen[k].DontFade then tempzeit:=0 else tempzeit:=timevalue;

                  // Kanalwerte ausgeben
                  // Delay-Zeit prüfen
                  if Bewegungsszenen[k].Devices[i].DeviceChannel[n].delay<0 then
                    tempdelay:=mainform.DeviceGroups[geraetesteuerung.GetGroupPositionInGroupArray(Bewegungsszenen[k].Devices[i].ID)].Delay
                  else
                    tempdelay:=Bewegungsszenen[k].Devices[i].DeviceChannel[n].delay;

//                  if (Bewegungsszenen[k].Devices[i].DeviceChannel[n].y) or ((Bewegungsszenen[k].Devices[i].DeviceChannel[n].x) and Bewegungsszenen[k].Devices[i].DeviceChannel[n].mixXY) then
                  if (Bewegungsszenen[k].Devices[i].DeviceChannel[n].y and (not Bewegungsszenen[k].Devices[i].DeviceChannel[n].mixXY)) or (Bewegungsszenen[k].Devices[i].DeviceChannel[n].x and (Bewegungsszenen[k].Devices[i].DeviceChannel[n].mixXY)) then
                  begin
                    // Falls Y
                    if BewegungsszenenAktiv[k].Position[i][n]+1>=length(figuren[figur].posx) then
                    begin
                      if (Bewegungsszenen[k].repeats=-1) or (BewegungsszenenAktiv[k].Repeats[i][n]<Bewegungsszenen[k].repeats) then
                      begin
                        geraetesteuerung.set_group(Bewegungsszenen[k].Devices[i].ID, DeviceChannelNames[n], (GetY(i,n,BewegungsszenenAktiv[k].Position[i][n],Bewegungsszenen[k].ID) * maxres div 400), (GetY(i,n,0,Bewegungsszenen[k].ID) * maxres div 400),tempzeit,tempdelay);
                      end;
                    end else
                    begin
                      geraetesteuerung.set_group(Bewegungsszenen[k].Devices[i].ID, DeviceChannelNames[n], (GetY(i,n,BewegungsszenenAktiv[k].Position[i][n],Bewegungsszenen[k].ID) * maxres div 400), (GetY(i,n,BewegungsszenenAktiv[k].Position[i][n]+1,Bewegungsszenen[k].ID) * maxres div 400),tempzeit,tempdelay);
                    end;
                  end else if (Bewegungsszenen[k].Devices[i].DeviceChannel[n].x and (not Bewegungsszenen[k].Devices[i].DeviceChannel[n].mixXY)) or ((Bewegungsszenen[k].Devices[i].DeviceChannel[n].y) and Bewegungsszenen[k].Devices[i].DeviceChannel[n].mixXY) then
                  begin
                    // Falls X
                    if BewegungsszenenAktiv[k].Position[i][n]+1>=length(figuren[figur].posx) then
                    begin
                      if (Bewegungsszenen[k].repeats=-1) or (BewegungsszenenAktiv[k].Repeats[i][n]<Bewegungsszenen[k].repeats) then
                      begin
                        geraetesteuerung.set_group(Bewegungsszenen[k].Devices[i].ID, DeviceChannelNames[n], (GetX(i,n,BewegungsszenenAktiv[k].Position[i][n],Bewegungsszenen[k].ID) * maxres div 400), (GetX(i,n,0,Bewegungsszenen[k].ID) * maxres div 400),tempzeit,tempdelay);
                      end;
                    end else
                    begin
                      geraetesteuerung.set_group(Bewegungsszenen[k].Devices[i].ID, DeviceChannelNames[n], (GetX(i,n,BewegungsszenenAktiv[k].Position[i][n],Bewegungsszenen[k].ID) * maxres div 400), (GetX(i,n,BewegungsszenenAktiv[k].Position[i][n]+1,Bewegungsszenen[k].ID) * maxres div 400),tempzeit,tempdelay);
                    end;
                  end else if (Bewegungsszenen[k].Devices[i].DeviceChannel[n].x) and (Bewegungsszenen[k].Devices[i].DeviceChannel[n].y) then
                  begin
                  end;

                  // Szene an aktueller Position abspielen
                  for j:=0 to length(Bewegungsszenen[k].Devices[i].Szenen[n])-1 do
                    if Bewegungsszenen[k].Devices[i].Szenen[n][j].Position=BewegungsszenenAktiv[k].Position[i][n] then
                      StartScene(Bewegungsszenen[k].Devices[i].Szenen[n][j].ID,false,false, -1);

                  // nächste Position
                  BewegungsszenenAktiv[k].Position[i][n]:=BewegungsszenenAktiv[k].Position[i][n]+1;

                  if BewegungsszenenAktiv[k].Position[i][n]>=length(figuren[figur].posx) then
                  begin
                    BewegungsszenenAktiv[k].Position[i][n]:=0;//BewegungsszenenAktiv[k].Position[i][n]-1;

                    if Bewegungsszenen[k].repeats>-1 then
                    begin
                      if BewegungsszenenAktiv[k].Repeats[i][n]>=Bewegungsszenen[k].repeats then
                      begin
                        BewegungsszenenAktiv[k].Aktiv:=false;
                      end else
                      begin
                        BewegungsszenenAktiv[k].Repeats[i][n]:=BewegungsszenenAktiv[k].Repeats[i][n]+1;
                      end;
                    end else
                    begin
                      BewegungsszenenAktiv[k].Repeats[i][n]:=BewegungsszenenAktiv[k].Repeats[i][n]+1;
                    end;
                  end;
                end;
              end;
            end;
          end;
        end;
      end;
    end;
    NextMovingSceneStep:=false;

    // Effekte ablaufen lassen
    for i:=0 to length(effektsequenzereffekte)-1 do
    begin
      if AktuellerEffekt[i].Aktiv and (not AktuellerEffekt[i].beatgesteuert) then
      begin
        AktuellerEffekt[i].Zeit:=AktuellerEffekt[i].Zeit+1;
        if length(effektsequenzereffekte[i].Effektschritte)=0 then
        begin
          StopEffekt(effektsequenzereffekte[i].ID);
          //AktuellerEffekt[i].Aktiv:=false;
        end else
        begin
  //        timevalue:=round((effektsequenzereffekte[i].Effektschritte[AktuellerEffekt[i].AktuellerSchritt].wartezeit)*(256-effektsequenzereffekte[i].speed)/128);

          effektspeedvalue:=effektsequenzereffekte[i].speed+(256-masterform.speedmaster.position);
          if effektspeedvalue>255 then
            effektspeedvalue:=255
          else if effektspeedvalue<0 then
            effektspeedvalue:=0;

          tempcardinal:=effektspeedvalue;
          timevalue:=round((effektsequenzereffekte[i].Effektschritte[AktuellerEffekt[i].AktuellerSchritt].wartezeit)*(256-tempcardinal)/128);
          if timevalue<5 then timevalue:=5;
          if (AktuellerEffekt[i].Zeit>=timevalue)then
          begin
            AktuellerEffekt[i].Zeit:=0;
            EffektSchaltvorgang(i, nil);
          end;
        end;
      end;
    end;

    // Audioszenen auf Ende überprüfen
    for i:=0 to length(AudioSzenen)-1 do
    begin
      if AudioSzenen[i].dauer>0 then
      begin
        if (BASS_ChannelIsActive(AudioszenenCHAN[i].MixerHandle) = BASS_ACTIVE_PLAYING) then
        begin
          if trunc(BASS_ChannelBytes2Seconds(AudioszenenCHAN[i].MixerHandle,BASS_ChannelGetPosition(AudioszenenCHAN[i].MixerHandle, BASS_POS_BYTE))*1000)>AudioSzenen[i].dauer then
          begin
            BASS_ChannelStop(AudioszenenCHAN[i].MixerHandle);
            BASS_Mixer_ChannelRemove(AudioszenenCHAN[i].StandardHandle);
            BASS_StreamFree(AudioszenenCHAN[i].MixerHandle);
            BASS_StreamFree(AudioszenenCHAN[i].StandardHandle);
            AudioszenenCHAN[i].MixerHandle:=0;
            AudioszenenCHAN[i].StandardHandle:=0;
          end;
        end;
      end;
    end;
  end; // end von with mainform
end;

//-------------------------------------------------

procedure TMainform.Timer1Timer(Sender: TObject);
var
  X,Y:integer;
  Shift:TShiftState;
  i,j,k,l,m,value,col,row,channelperrow,fadergroup,offset:integer;
  dobreak:boolean;
begin
  if HandleMouseMove then
  begin
    X:=CurrentMousePositionX;
    Y:=CurrentMousePositionY;
    Shift:=CurrentMouseMoveShiftState;

    HandleMouseMove:=false;

    if (faderpanelup and (Y>Paintbox1.Height-258)) or (Y>(Paintbox1.Height-48)) then
    begin
      if not UserAccessGranted(2, false) then exit;

      if not faderpanelup then
      begin
        faderpanelup:=true;
      end;

      faderpaneltimerbyte:=0;
      FaderpanelhideTimer.Enabled:=true;

      if faderpanelup then
        offset:=258
      else
        offset:=48;

      // Maus über Faderpanel
      if (Shift=[ssLeft]) then
      begin
        if ((y-(Paintbox1.Height-offset))>50) then
        begin
          // Fader bewegen
          value:=(y-(Paintbox1.Height-offset))+11-74;
          if value<0 then value:=0;
          if value>167 then value:=167;
          value:=round(value/167*255);
          // mainform.SendData(scrollbar1.position+mouseoverfader,-1,value,0,0);
          mainform.SendData(faderchannel[mouseoverfader],-1,value,0,0);

          fadergroup:=0;
          for i:=0 to length(faderselected)-1 do
          begin
            if faderselected[i] and (i=(faderchannel[mouseoverfader]-1)) then fadergroup:=1;
            if faderselectedalt[i] and (i=(faderchannel[mouseoverfader]-1)) then fadergroup:=fadergroup+2;
            if faderselectedshift[i] and (i=(faderchannel[mouseoverfader]-1)) then fadergroup:=fadergroup+4;
          end;

          for i:=0 to length(faderselected)-1 do
          begin
            if faderselected[i] and (fadergroup and 1 = 1) then
              mainform.SendData(i+1,-1,value,0,0);

            if faderselectedalt[i] and (fadergroup and 2 = 2) then
              mainform.SendData(i+1,-1,value,0,0);

            if faderselectedshift[i] and (fadergroup and 4 = 4) then
              mainform.SendData(i+1,-1,value,0,0);
          end;
        end;
      end else
      begin
        if (X>0) and (X<40) then
        begin
          // linker Rand
          scrolltoright:=false;
          scrolltoleft:=true;
        end else if (X>(Paintbox1.Width-40)) and (X<Paintbox1.Width) then
        begin
          // rechter Rand
          scrolltoright:=true;
          scrolltoleft:=false;
        end else
        begin
          scrolltoright:=false;
          scrolltoleft:=false;
        end;
      end;
      RefreshMainformScreen:=true;
    end else
    begin
      case pagecontrol1.ActivePageIndex of
        0:  // Bühne
        begin
          if not UserAccessGranted(2, false) then exit;

          grafischebuehnenansicht.dorefresh:=(Shift=[ssLeft]) or (Shift=[ssLeft, ssAlt]);

  /////////// DeviceHoverEffect
          grafischebuehnenansicht.MouseOnDeviceID:=StringToGUID('{00000000-0000-0000-0000-000000000000}');
          dobreak:=false;
          for i:=0 to length(mainform.devices)-1 do
          begin
            for j:=0 to length(mainform.devices[i].bank)-1 do
            begin
              if mainform.devices[i].ShowInStageview then
              if mainform.devices[i].bank[j]=BankSelect.Itemindex then
              begin
                // Auswahl.Left=Links Auswahl.Right=Rechts                                                                      Auswahl.Top=Oben Auswahl.Bottom=Unten
                if (mainform.devices[i].left[j]<=X)
                and ((mainform.devices[i].left[j]+mainform.devices[i].picturesize)>=X)
                and (mainform.devices[i].Top[j]<=Y)
                and ((mainform.devices[i].Top[j]+mainform.devices[i].picturesize)>=Y) then
                begin
                  grafischebuehnenansicht.MouseOnDeviceID:=mainform.devices[i].ID;
                  grafischebuehnenansicht.MouseOnDeviceHover:=i;
                  dobreak:=true;
                  break;
                end;
              end;
            end;
            if dobreak then
              break;
          end;
          if not dobreak then
          begin
            grafischebuehnenansicht.MouseOnDeviceID:=StringToGUID('{00000000-0000-0000-0000-000000000000}');
            grafischebuehnenansicht.MouseOnDeviceHover:=-1;
          end;
  ////////////

  /////////// DeviceHighlight
          if CheckBox6.Checked then
          begin
            // Altes Gerät zurücksetzen
            geraetesteuerung.set_color(grafischebuehnenansicht.LastMouseOverHighlightDevice.ID, grafischebuehnenansicht.LastMouseOverHighlightDevice.R, grafischebuehnenansicht.LastMouseOverHighlightDevice.G, grafischebuehnenansicht.LastMouseOverHighlightDevice.B, 150, 0);
            geraetesteuerung.set_shutter(grafischebuehnenansicht.LastMouseOverHighlightDevice.ID, grafischebuehnenansicht.LastMouseOverHighlightDevice.ShutterOpenOrClose);
            geraetesteuerung.set_dimmer(grafischebuehnenansicht.LastMouseOverHighlightDevice.ID, grafischebuehnenansicht.LastMouseOverHighlightDevice.Dimmer, 150, 0);
            geraetesteuerung.set_channel(grafischebuehnenansicht.LastMouseOverHighlightDevice.ID, 'a', grafischebuehnenansicht.LastMouseOverHighlightDevice.A, 150, 0);
            geraetesteuerung.set_channel(grafischebuehnenansicht.LastMouseOverHighlightDevice.ID, 'w', grafischebuehnenansicht.LastMouseOverHighlightDevice.W, 150, 0);

            // Aktuelle Werte speichern
            if not IsEqualGUID(grafischebuehnenansicht.LastMouseOverHighlightDevice.ID, grafischebuehnenansicht.MouseOnDeviceID) then
            begin
              grafischebuehnenansicht.LastMouseOverHighlightDevice.ID:=grafischebuehnenansicht.MouseOnDeviceID;
              grafischebuehnenansicht.LastMouseOverHighlightDevice.Dimmer:=geraetesteuerung.get_dimmer(grafischebuehnenansicht.MouseOnDeviceID);
              grafischebuehnenansicht.LastMouseOverHighlightDevice.R:=geraetesteuerung.get_channel(grafischebuehnenansicht.MouseOnDeviceID, 'R');
              grafischebuehnenansicht.LastMouseOverHighlightDevice.G:=geraetesteuerung.get_channel(grafischebuehnenansicht.MouseOnDeviceID, 'G');
              grafischebuehnenansicht.LastMouseOverHighlightDevice.B:=geraetesteuerung.get_channel(grafischebuehnenansicht.MouseOnDeviceID, 'B');
              grafischebuehnenansicht.LastMouseOverHighlightDevice.A:=geraetesteuerung.get_channel(grafischebuehnenansicht.MouseOnDeviceID, 'A');
              grafischebuehnenansicht.LastMouseOverHighlightDevice.W:=geraetesteuerung.get_channel(grafischebuehnenansicht.MouseOnDeviceID, 'W');
              grafischebuehnenansicht.LastMouseOverHighlightDevice.ShutterOpenOrClose:=geraetesteuerung.get_shutter(grafischebuehnenansicht.MouseOnDeviceID);
            end;

            // Aktuelles Gerät setzen
            if grafischebuehnenansicht.MouseOnDeviceHover>-1 then
            begin
              geraetesteuerung.set_shutter(grafischebuehnenansicht.MouseOnDeviceID, 255);
              geraetesteuerung.set_color(grafischebuehnenansicht.MouseOnDeviceID, 255, 255, 255, 150, 0);
              geraetesteuerung.set_dimmer(grafischebuehnenansicht.MouseOnDeviceID, 255, 150, 0);
              geraetesteuerung.set_channel(grafischebuehnenansicht.MouseOnDeviceID, 'a', 255, 150, 0);
              geraetesteuerung.set_channel(grafischebuehnenansicht.MouseOnDeviceID, 'w', 255, 150, 0);
            end;
          end;
  ////////////

          if grafischebuehnenansicht.MouseOnDevice>-1 then
          begin
            if CheckBox3.Checked then exit;

            if mainform.devices[grafischebuehnenansicht.MouseOnDevice].hasDimmer then
            begin
              for k:=0 to length(mainform.devices[grafischebuehnenansicht.MouseOnDevice].kanaltyp)-1 do
              if lowercase(mainform.devices[grafischebuehnenansicht.MouseOnDevice].kanaltyp[k])='dimmer' then
                Paintbox1.Hint:=mainform.devices[grafischebuehnenansicht.MouseOnDevice].Name+' ('+mainform.levelstr(255-mainform.data.ch[mainform.devices[grafischebuehnenansicht.MouseOnDevice].Startaddress+k])+'), Geräteicon'
            end else
            begin
              Paintbox1.Hint:='Geräteicon, '+mainform.devices[grafischebuehnenansicht.MouseOnDevice].Name;
            end;

            if Shift = [ssLeft] then
            begin
              // Linke Maustaste
              grafischebuehnenansicht.RedrawPictures:=true;

              if (mainform.devices[grafischebuehnenansicht.MouseOnDevice].selected[grafischebuehnenansicht.MouseOnDeviceCopy]=false) then
              begin // einzelnes Gerätebild verschieben
                // Sender GeräteBild
                mainform.devices[grafischebuehnenansicht.MouseOnDevice].Left[grafischebuehnenansicht.MouseOnDeviceCopy]:=X-round(mainform.devices[grafischebuehnenansicht.MouseOnDevice].picturesize/2);
                mainform.devices[grafischebuehnenansicht.MouseOnDevice].Top[grafischebuehnenansicht.MouseOnDeviceCopy]:=Y-round(mainform.devices[grafischebuehnenansicht.MouseOnDevice].picturesize/2);

                for m:=0 to length(mainform.Devices)-1 do
                begin
                  if (mainform.Devices[m].MatrixDeviceLevel=2) and (IsEqualGUID(mainform.Devices[m].MatrixMainDeviceID, mainform.devices[grafischebuehnenansicht.MouseOnDevice].ID)) then
                  begin
                    mainform.Devices[m].left[grafischebuehnenansicht.MouseOnDeviceCopy]:=X-round(mainform.Devices[m].picturesize/2)+mainform.Devices[m].picturesize*mainform.Devices[m].MatrixXPosition;
                    mainform.Devices[m].top[grafischebuehnenansicht.MouseOnDeviceCopy]:=Y-round(mainform.Devices[m].picturesize/2)+mainform.Devices[m].picturesize*mainform.Devices[m].MatrixYPosition;
                  end;
                end;
                // Sender GeräteBild Ende
              end else
              begin
                // Andere GeräteBilder
                for k:=0 to length(mainform.devices)-1 do
                for l:=0 to length(mainform.devices[k].selected)-1 do
                begin
                  if ((mainform.devices[k].selected[l])) then
                  begin
                    grafischebuehnenansicht.StopDeviceMoving:=(mainform.devices[k].OldPos[l].X-(grafischebuehnenansicht.MouseDownPoint.X-X)<0) or (mainform.devices[k].OldPos[l].X-(grafischebuehnenansicht.MouseDownPoint.X-X+mainform.devices[k].picturesize)>paintbox1.Width) or (mainform.devices[k].OldPos[l].Y-(grafischebuehnenansicht.MouseDownPoint.Y-Y)<0) or (mainform.devices[k].OldPos[l].Y-(grafischebuehnenansicht.MouseDownPoint.Y-Y+mainform.devices[k].picturesize)>paintbox1.Height);
                    if not grafischebuehnenansicht.StopDeviceMoving then
                    begin
                      mainform.devices[k].Left[l]:=mainform.devices[k].OldPos[l].X-(grafischebuehnenansicht.MouseDownPoint.X-X);
                      mainform.devices[k].Top[l]:=mainform.devices[k].OldPos[l].Y-(grafischebuehnenansicht.MouseDownPoint.Y-Y);
                    end;
                  end;
                end;
                // Andere GeräteBilder Ende

                // Andere Kanal-Bilder
                for k:=0 to length(mainform.buehnenansichtdevices)-1 do
                begin
                  if ((mainform.buehnenansichtdevices[k].selected)) then
                  begin
                    grafischebuehnenansicht.StopDeviceMoving:=(mainform.buehnenansichtdevices[k].OldPos.X-(grafischebuehnenansicht.MouseDownPoint.X-X)<0) or (mainform.buehnenansichtdevices[k].OldPos.X-(grafischebuehnenansicht.MouseDownPoint.X-X+mainform.buehnenansichtdevices[k].picturesize)>paintbox1.Width) or (mainform.buehnenansichtdevices[k].OldPos.Y-(grafischebuehnenansicht.MouseDownPoint.Y-Y)<0) or (mainform.buehnenansichtdevices[k].OldPos.Y-(grafischebuehnenansicht.MouseDownPoint.Y-Y+mainform.buehnenansichtdevices[k].picturesize)>paintbox1.Height);
                    if not grafischebuehnenansicht.StopDeviceMoving then
                    begin
                      mainform.buehnenansichtdevices[k].left:=mainform.buehnenansichtdevices[k].OldPos.X-(grafischebuehnenansicht.MouseDownPoint.X-X);
                      mainform.buehnenansichtdevices[k].top:=mainform.buehnenansichtdevices[k].OldPos.Y-(grafischebuehnenansicht.MouseDownPoint.Y-Y);
                    end;
                  end;
                end;
                // Andere Kanal-Bilder Ende
              end;
              // Ende von Linke Maustaste
            end;
          end else if grafischebuehnenansicht.MouseOnBuehnenansichtDevice>-1 then
          begin
            if CheckBox3.Checked then exit;

            Paintbox1.Hint:='Kanalicon, Kanal: '+inttostr(mainform.Buehnenansichtdevices[grafischebuehnenansicht.MouseOnBuehnenansichtDevice].channel)+' ('+inttostr(mainform.channel_value[mainform.Buehnenansichtdevices[grafischebuehnenansicht.MouseOnBuehnenansichtDevice].channel])+')';

              if Shift = [ssLeft] then
              begin
                // Linke Maustaste
                if (mainform.Buehnenansichtdevices[grafischebuehnenansicht.MouseOnBuehnenansichtDevice].selected=false) then
                begin // einzelnes Gerätebild verschieben
                  // Sender KanalBild
                  mainform.Buehnenansichtdevices[grafischebuehnenansicht.MouseOnBuehnenansichtDevice].Left:=X-round(mainform.Buehnenansichtdevices[grafischebuehnenansicht.MouseOnBuehnenansichtDevice].picturesize/2);
                  mainform.Buehnenansichtdevices[grafischebuehnenansicht.MouseOnBuehnenansichtDevice].Top:=Y-round(mainform.Buehnenansichtdevices[grafischebuehnenansicht.MouseOnBuehnenansichtDevice].picturesize/2);
                  // Sender KanalBild Ende
                end else
                begin
                  // Andere KanalBilder
                  for k:=0 to length(mainform.Buehnenansichtdevices)-1 do
                  begin
                    if ((mainform.Buehnenansichtdevices[k].selected)) then
                    begin
                      grafischebuehnenansicht.StopDeviceMoving:=(mainform.Buehnenansichtdevices[k].OldPos.X-(grafischebuehnenansicht.MouseDownPoint.X-X)<0) or (mainform.Buehnenansichtdevices[k].OldPos.X-(grafischebuehnenansicht.MouseDownPoint.X-X+mainform.Buehnenansichtdevices[k].picturesize)>paintbox1.Width) or (mainform.Buehnenansichtdevices[k].OldPos.Y-(grafischebuehnenansicht.MouseDownPoint.Y-Y)<0) or (mainform.Buehnenansichtdevices[k].OldPos.Y-(grafischebuehnenansicht.MouseDownPoint.Y-Y+mainform.Buehnenansichtdevices[k].picturesize)>paintbox1.Height);
                      if not grafischebuehnenansicht.StopDeviceMoving then
                      begin
                        mainform.Buehnenansichtdevices[k].Left:=mainform.Buehnenansichtdevices[k].OldPos.X-(grafischebuehnenansicht.MouseDownPoint.X-X);
                        mainform.Buehnenansichtdevices[k].Top:=mainform.Buehnenansichtdevices[k].OldPos.Y-(grafischebuehnenansicht.MouseDownPoint.Y-Y);
                      end;
                    end;
                  end;
                  // Andere KanalBilder Ende

                  // Andere Geräte-Bilder
                  for k:=0 to length(mainform.devices)-1 do
                  for l:=0 to length(mainform.devices[k].selected)-1 do
                  begin
                    if ((mainform.devices[k].selected[l])) then
                    begin
                      grafischebuehnenansicht.StopDeviceMoving:=(mainform.devices[k].OldPos[l].X-(grafischebuehnenansicht.MouseDownPoint.X-X)<0) or (mainform.devices[k].OldPos[l].X-(grafischebuehnenansicht.MouseDownPoint.X-X+mainform.devices[k].picturesize)>paintbox1.Width) or (mainform.devices[k].OldPos[l].Y-(grafischebuehnenansicht.MouseDownPoint.Y-Y)<0) or (mainform.devices[k].OldPos[l].Y-(grafischebuehnenansicht.MouseDownPoint.Y-Y+mainform.devices[k].picturesize)>paintbox1.Height);
                      if not grafischebuehnenansicht.StopDeviceMoving then
                      begin
                        mainform.devices[k].left[l]:=mainform.devices[k].OldPos[l].X-(grafischebuehnenansicht.MouseDownPoint.X-X);
                        mainform.devices[k].top[l]:=mainform.devices[k].OldPos[l].Y-(grafischebuehnenansicht.MouseDownPoint.Y-Y);
                      end;
                    end;
                  end;
                  // Andere Geräte-Bilder Ende
                end;
                // Ende von Linke Maustaste
              end;
          end else if grafischebuehnenansicht.MouseOnProgress>-1 then
          begin
            if Shift=[ssLeft] then
            begin
              value:=round(((X-mainform.devices[grafischebuehnenansicht.MouseOnProgress].left[grafischebuehnenansicht.MouseOnDeviceCopy])/mainform.devices[grafischebuehnenansicht.MouseOnProgress].picturesize)*255);
              if value<0 then value:=0;
              if value>255 then value:=255;
              if mainform.devices[grafischebuehnenansicht.MouseOnProgress].hasDimmer then
                geraetesteuerung.set_dimmer(mainform.devices[grafischebuehnenansicht.MouseOnProgress].ID,value)
              else if mainform.devices[grafischebuehnenansicht.MouseOnProgress].hasFog then
                geraetesteuerung.set_fog(mainform.devices[grafischebuehnenansicht.MouseOnProgress].ID,value);
            end;
          end else if grafischebuehnenansicht.MouseOnBuehnenansichtProgress>-1 then
          begin
            if Shift=[ssLeft] then
            begin
              value:=round(((X-mainform.buehnenansichtdevices[grafischebuehnenansicht.MouseOnBuehnenansichtProgress].left)/mainform.buehnenansichtdevices[grafischebuehnenansicht.MouseOnBuehnenansichtProgress].picturesize)*255);
              if value<0 then value:=0;
              if value>255 then value:=255;
              mainform.Senddata(mainform.buehnenansichtdevices[grafischebuehnenansicht.MouseOnBuehnenansichtProgress].channel, 255-value, 255-value, 0);
        //      mainform.channel_value[mainform.buehnenansichtdevices[grafischebuehnenansicht.MouseOnBuehnenansichtProgress].channel]:=value;
            end;
          end else if grafischebuehnenansicht.MouseOnBuehnenansichtColor>-1 then
          begin
          end else if grafischebuehnenansicht.MouseOnLabel>-1 then
          begin
          end else if grafischebuehnenansicht.MouseOnNumber>-1 then
          begin
          end else if grafischebuehnenansicht.MouseOnBuehnenansichtNumber>-1 then
          begin
          end else
          begin
          If shift=[ssLeft] then
          begin
            grafischebuehnenansicht.Auswahl.Right:=X;
            grafischebuehnenansicht.Auswahl.Bottom:=Y;
            grafischebuehnenansicht.ShowAuswahl:=true;

            for i:=0 to length(mainform.buehnenansichtdevices)-1 do
            begin
              if mainform.buehnenansichtdevices[i].bank=BankSelect.Itemindex then
              begin
                // grafischebuehnenansicht.Auswahl.Left=Links grafischebuehnenansicht.Auswahl.Right=Rechts                                                                      grafischebuehnenansicht.Auswahl.Top=Oben grafischebuehnenansicht.Auswahl.Bottom=Unten
                if (mainform.buehnenansichtdevices[i].left+(mainform.buehnenansichtdevices[i].picturesize div 2)<grafischebuehnenansicht.Auswahl.Left) and ((mainform.buehnenansichtdevices[i].left+(mainform.buehnenansichtdevices[i].picturesize div 2))>grafischebuehnenansicht.Auswahl.Right) and (mainform.buehnenansichtdevices[i].Top+(mainform.buehnenansichtdevices[i].picturesize div 2)>grafischebuehnenansicht.Auswahl.Top) and ((mainform.buehnenansichtdevices[i].Top+(mainform.buehnenansichtdevices[i].picturesize div 2))<grafischebuehnenansicht.Auswahl.Bottom)
                or (mainform.buehnenansichtdevices[i].left+(mainform.buehnenansichtdevices[i].picturesize div 2)>grafischebuehnenansicht.Auswahl.Left) and ((mainform.buehnenansichtdevices[i].left+(mainform.buehnenansichtdevices[i].picturesize div 2))<grafischebuehnenansicht.Auswahl.Right) and (mainform.buehnenansichtdevices[i].Top+(mainform.buehnenansichtdevices[i].picturesize div 2)<grafischebuehnenansicht.Auswahl.Top) and ((mainform.buehnenansichtdevices[i].Top+(mainform.buehnenansichtdevices[i].picturesize div 2))>grafischebuehnenansicht.Auswahl.Bottom)
                or (mainform.buehnenansichtdevices[i].left+(mainform.buehnenansichtdevices[i].picturesize div 2)>grafischebuehnenansicht.Auswahl.Left) and ((mainform.buehnenansichtdevices[i].left+(mainform.buehnenansichtdevices[i].picturesize div 2))<grafischebuehnenansicht.Auswahl.Right) and (mainform.buehnenansichtdevices[i].Top+(mainform.buehnenansichtdevices[i].picturesize div 2)>grafischebuehnenansicht.Auswahl.Top) and ((mainform.buehnenansichtdevices[i].Top+(mainform.buehnenansichtdevices[i].picturesize div 2))<grafischebuehnenansicht.Auswahl.Bottom)
                or (mainform.buehnenansichtdevices[i].left+(mainform.buehnenansichtdevices[i].picturesize div 2)<grafischebuehnenansicht.Auswahl.Left) and ((mainform.buehnenansichtdevices[i].left+(mainform.buehnenansichtdevices[i].picturesize div 2))>grafischebuehnenansicht.Auswahl.Right) and (mainform.buehnenansichtdevices[i].Top+(mainform.buehnenansichtdevices[i].picturesize div 2)<grafischebuehnenansicht.Auswahl.Top) and ((mainform.buehnenansichtdevices[i].Top+(mainform.buehnenansichtdevices[i].picturesize div 2))>grafischebuehnenansicht.Auswahl.Bottom) then
                  mainform.buehnenansichtdevices[i].selected:=true else mainform.buehnenansichtdevices[i].selected:=false;
              end;
            end;

            for i:=0 to length(mainform.devices)-1 do
            for j:=0 to length(mainform.devices[i].bank)-1 do
            begin
              if mainform.devices[i].bank[j]=BankSelect.Itemindex then
              begin
                // grafischebuehnenansicht.Auswahl.Left=Links grafischebuehnenansicht.Auswahl.Right=Rechts                                                                      grafischebuehnenansicht.Auswahl.Top=Oben grafischebuehnenansicht.Auswahl.Bottom=Unten
                if (mainform.devices[i].left[j]+(mainform.devices[i].picturesize div 2)<grafischebuehnenansicht.Auswahl.Left) and ((mainform.devices[i].left[j]+(mainform.devices[i].picturesize div 2))>grafischebuehnenansicht.Auswahl.Right) and (mainform.devices[i].Top[j]+(mainform.devices[i].picturesize div 2)>grafischebuehnenansicht.Auswahl.Top) and ((mainform.devices[i].Top[j]+(mainform.devices[i].picturesize div 2))<grafischebuehnenansicht.Auswahl.Bottom)
                or (mainform.devices[i].left[j]+(mainform.devices[i].picturesize div 2)>grafischebuehnenansicht.Auswahl.Left) and ((mainform.devices[i].left[j]+(mainform.devices[i].picturesize div 2))<grafischebuehnenansicht.Auswahl.Right) and (mainform.devices[i].Top[j]+(mainform.devices[i].picturesize div 2)<grafischebuehnenansicht.Auswahl.Top) and ((mainform.devices[i].Top[j]+(mainform.devices[i].picturesize div 2))>grafischebuehnenansicht.Auswahl.Bottom)
                or (mainform.devices[i].left[j]+(mainform.devices[i].picturesize div 2)>grafischebuehnenansicht.Auswahl.Left) and ((mainform.devices[i].left[j]+(mainform.devices[i].picturesize div 2))<grafischebuehnenansicht.Auswahl.Right) and (mainform.devices[i].Top[j]+(mainform.devices[i].picturesize div 2)>grafischebuehnenansicht.Auswahl.Top) and ((mainform.devices[i].Top[j]+(mainform.devices[i].picturesize div 2))<grafischebuehnenansicht.Auswahl.Bottom)
                or (mainform.devices[i].left[j]+(mainform.devices[i].picturesize div 2)<grafischebuehnenansicht.Auswahl.Left) and ((mainform.devices[i].left[j]+(mainform.devices[i].picturesize div 2))>grafischebuehnenansicht.Auswahl.Right) and (mainform.devices[i].Top[j]+(mainform.devices[i].picturesize div 2)<grafischebuehnenansicht.Auswahl.Top) and ((mainform.devices[i].Top[j]+(mainform.devices[i].picturesize div 2))>grafischebuehnenansicht.Auswahl.Bottom) then
                  mainform.devices[i].selected[j]:=true else mainform.devices[i].selected[j]:=false;
              end;
            end;
          end;

          If (shift=[ssLeft,ssShift]) or (shift=[ssLeft,ssShift,ssCtrl]) then
          begin
            grafischebuehnenansicht.Auswahl.Right:=X;
            grafischebuehnenansicht.Auswahl.Bottom:=Y;
            grafischebuehnenansicht.ShowAuswahl:=true;

            for i:=0 to length(mainform.devices)-1 do
            for j:=0 to length(mainform.devices[i].bank)-1 do
            begin
              if mainform.devices[i].bank[j]=BankSelect.Itemindex then
              begin
                // grafischebuehnenansicht.Auswahl.Left=Links grafischebuehnenansicht.Auswahl.Right=Rechts                                                                      grafischebuehnenansicht.Auswahl.Top=Oben grafischebuehnenansicht.Auswahl.Bottom=Unten
                if (mainform.devices[i].left[j]+(mainform.devices[i].picturesize div 2)<grafischebuehnenansicht.Auswahl.Left) and ((mainform.devices[i].left[j]+(mainform.devices[i].picturesize div 2))>grafischebuehnenansicht.Auswahl.Right) and (mainform.devices[i].Top[j]+(mainform.devices[i].picturesize div 2)>grafischebuehnenansicht.Auswahl.Top) and ((mainform.devices[i].Top[j]+(mainform.devices[i].picturesize div 2))<grafischebuehnenansicht.Auswahl.Bottom)
                or (mainform.devices[i].left[j]+(mainform.devices[i].picturesize div 2)>grafischebuehnenansicht.Auswahl.Left) and ((mainform.devices[i].left[j]+(mainform.devices[i].picturesize div 2))<grafischebuehnenansicht.Auswahl.Right) and (mainform.devices[i].Top[j]+(mainform.devices[i].picturesize div 2)<grafischebuehnenansicht.Auswahl.Top) and ((mainform.devices[i].Top[j]+(mainform.devices[i].picturesize div 2))>grafischebuehnenansicht.Auswahl.Bottom)
                or (mainform.devices[i].left[j]+(mainform.devices[i].picturesize div 2)>grafischebuehnenansicht.Auswahl.Left) and ((mainform.devices[i].left[j]+(mainform.devices[i].picturesize div 2))<grafischebuehnenansicht.Auswahl.Right) and (mainform.devices[i].Top[j]+(mainform.devices[i].picturesize div 2)>grafischebuehnenansicht.Auswahl.Top) and ((mainform.devices[i].Top[j]+(mainform.devices[i].picturesize div 2))<grafischebuehnenansicht.Auswahl.Bottom)
                or (mainform.devices[i].left[j]+(mainform.devices[i].picturesize div 2)<grafischebuehnenansicht.Auswahl.Left) and ((mainform.devices[i].left[j]+(mainform.devices[i].picturesize div 2))>grafischebuehnenansicht.Auswahl.Right) and (mainform.devices[i].Top[j]+(mainform.devices[i].picturesize div 2)<grafischebuehnenansicht.Auswahl.Top) and ((mainform.devices[i].Top[j]+(mainform.devices[i].picturesize div 2))>grafischebuehnenansicht.Auswahl.Bottom) then
                  mainform.DeviceSelected[i]:=true;
              end;
            end;
          end;
          end;
        end;
        1:  // Kanäle
        begin
          if not UserAccessGranted(2, false) then exit;

          if (Shift=[ssLeft]) then
          begin
            ScrollBar1.Position:=round((mouseychannel-y)/ChannelHeight+scrollbarpositiononmousedown);
            ErsteZeile:=Scrollbar1.position;
          end;

          lastx:=x;
          lasty:=y;

          if (Shift=[]) then
          begin
            col:=(x div ChannelWidth)+1;
            row:=(y div ChannelHeight)+ErsteZeile;
            channelperrow:=paintbox1.Width div ChannelWidth;
            MouseOverKanal:=channelperrow*row+col;
          end;

          if (Shift=[ssLeft, ssCtrl, ssShift]) then
          begin
            if (MouseOverKanal>-1) and (MouseOverKanal<mainform.lastchan) then
              if ((ChannelValueOnClick+(mouseychannel-y))>=0) and ((ChannelValueOnClick+(mouseychannel-y))<=255) then
                mainform.channel_value[MouseOverKanal]:=ChannelValueOnClick+(mouseychannel-y);
          end;

          Label1.Caption:='';
          Label2.Caption:='';
          Label6.Caption:='Min-Wert: '+mainform.levelstr(mainform.channel_minvalue[MouseOverKanal]);
          Label7.Caption:='Max-Wert: '+mainform.levelstr(mainform.channel_maxvalue[MouseOverKanal]);
          Label6.Alignment:=taRightJustify;
          Label7.Alignment:=taRightJustify;

          for i:=0 to length(mainform.devices)-1 do
          begin
            if (MouseOverKanal>=mainform.devices[i].Startaddress) and (MouseOverKanal<mainform.devices[i].Startaddress+mainform.devices[i].MaxChan) then
            begin
              if length(Label1.Caption)>0 then
                Label1.Caption:=Label1.Caption+', '+mainform.devices[i].Name
              else
                Label1.Caption:=mainform.devices[i].Name;
              Label2.Caption:=mainform.devices[i].kanalname[MouseOverKanal-mainform.devices[i].Startaddress]+' | '+mainform.levelstr(mainform.channel_value[MouseOverKanal]);
            end;
          end;
          RefreshMainformScreen:=true;
        end;
        2:  // Panel
        begin
          if not UserAccessGranted(3, false) then exit;

          kontrollpanel.PaintBox1MouseMove(nil, Shift, X, Y);
        end;
      end;
    end;
  end;


  if splashscreenvalue=1 then
  begin
    if (fadesplash=true) then
    begin
      if (splash.BlendValue>0) then
      begin
        splash.BlendValue:=splash.BlendValue-15;
        RefreshSplashText;
      end;
      if (splash.BlendValue<=0) then
      begin
        splash.Close;
        fadesplash:=false;
        killsplash:=true;
      end;
    end;
  end;

  if dxRibbonStatusBar1.Panels[6].Text<>LastEvent then
    dxRibbonStatusBar1.Panels[6].Text:=LastEvent;

  // Line-In / Mic-In Detection
  if (beatform.Temposourcebox.ItemIndex=1) then
  begin
    if beatform.visible then
    begin
      if (AudioIn.Active) Then
      begin
        beatform.vu_meter_micin.Percent := Round(100*AudioTempMax/32768);

        if BeatImpuls.SendVolumeToDataIn then
        begin
          mainform.ExecuteDataInEvent(BeatImpuls.SendVolumeToDataInChannel, round(255*AudioTempMax/32768));
        end;

        if beatform.Timer1.enabled then
        begin
          for i:=0 to length(beatform._BeatBuffer)-2 do
            beatform._BeatBuffer[i]:=beatform._BeatBuffer[i+1];
          beatform._BeatBuffer[length(beatform._BeatBuffer)-1]:=AudioTempMax;
        end;
        
        if (beatform.vu_meter_micin.Percent > 95) then beatform.vu_meter_micin.PFMainColor:=clred
        else if (beatform.vu_meter_micin.Percent > 80) and (beatform.vu_meter_micin.Percent < 95) then beatform.vu_meter_micin.PFMainColor:=clyellow
        else if (beatform.vu_meter_micin.Percent < 80) then beatform.vu_meter_micin.PFMainColor:=clgreen;
      end else
      begin
        beatform.vu_meter_micin.Percent:=0;
      end;
    end;
    
	  if (Round(100*AudioTempMax/32768) < beatform.audio_empfindlichkeit_micin.position) and (beatform.Temposourcebox.ItemIndex=1) then
	  begin
      if beatform.visible then
  	    beatform.beat.Color:=clBlack;

	    beat_next:=true;

      if MBS_Online then
        SendMidi(MBS_MSGoff,MBS_Data1off,MBS_Data2off);
	  end;

	  if (beatform.vu_meter_micin.percent > beatform.audio_empfindlichkeit_micin.position) and (beatform.Temposourcebox.ItemIndex=1) then
	  begin
{
      if beatform.visible then
  	    beatform.beat.color:=clMAroon;

      beatform.CalculateBeatTime;
      NextMovingSceneStep:=true;

	    if beat_next=true then
	    begin
        for i:=length(effektsequenzereffekte)-1 downto 0 do
        if i<length(effektsequenzereffekte) then
        begin
          if AktuellerEffekt[i].beatgesteuert and AktuellerEffekt[i].Aktiv then
          begin
            AktuellerEffekt[i].AnzahlBeats:=AktuellerEffekt[i].AnzahlBeats+1;

            if AktuellerEffekt[i].AktuellerSchritt<length(effektsequenzereffekte[i].Effektschritte) then
            begin
              if AktuellerEffekt[i].AnzahlBeats>=effektsequenzereffekte[i].Effektschritte[AktuellerEffekt[i].AktuellerSchritt].AnzahlBeats then
              begin
                AktuellerEffekt[i].AnzahlBeats:=0;
                Effektschaltvorgang(i, Sender);
              end;
            end;
          end;
        end;

        if MBS_Online then
          SendMidi(MBS_MSGon,MBS_Data1on,MBS_Data2on);
	    end;
	    beat_next:=false;
}
	    if beat_next=true then
        ExecuteBeat(nil);
	    beat_next:=false;
	  end;
  end;

  if DimmerkernelResolutionAutoset and (trunc(mainform.KernelLaufzeit*1000000)<5) then  // nur wenn Kernel im Leerlauf, also <5us, dann langsam Auflösung wieder hochfahren
  begin
    if DimmerkernelResolution>MinDimmerkernelResolution then
  	  DimmerkernelResolution:=DimmerkernelResolution-1; // Derzeitige KernelLaufzeit-1ms
    AutoFader.Interval:=DimmerkernelResolution;
  end;
end;

procedure TMainform.CompressProgress(Sender: TObject; Position,
  Total: Integer);
begin
  if not startingup then
  begin
    inprogress.ProgressBar1.Max:=Total;
    inprogress.ProgressBar1.Position:=position;
    // Vista Progressbar Workaround
    if windowsmajorversion>=6 then
    begin
      inprogress.ProgressBar1.Position:=position-1;
      inprogress.ProgressBar1.Position:=position+1;
    end;
    inprogress.Caption:=_(' Fortschritt: ')+inttostr(trunc((position / Total)*100))+'%';
    //  application.ProcessMessages;
  end;
end;

procedure TMainform.CompressDecompressingFile(Sender: TObject;
  const FileName: String; var WriteFile: Boolean);
begin
  if not startingup then
  begin
    inprogress.label8.Caption:=_(' Lade Datei... ');
    application.processmessages;
    inprogress.Show;
  	inprogress.filename.Caption:=_('Dekomprimiere: ')+ExtractFileName(FileName);
	  inprogress.Refresh;

    inprogress.ProgressBar2.Position:=inprogress.ProgressBar2.Position+1;
    // Vista Progressbar Workaround
    if windowsmajorversion>=6 then
    begin
      inprogress.ProgressBar2.Position:=inprogress.ProgressBar2.Position-1;
      inprogress.ProgressBar2.Position:=inprogress.ProgressBar2.Position+1;
    end;
    inprogress.Label1.Caption:=_('Datei (')+inttostr(inprogress.ProgressBar2.Position)+'/'+inttostr(filesinprojectdirectory)+')';
    inprogress.Label1.Refresh;
  end else
  begin
    if filesinprojectdirectory>1 then
    begin
      if splashscreenvalue=1 then
      begin
        splash.ShowFortschritt2:=true;
        splash.FortschrittMax2:=filesinprojectdirectory;
        splash.Fortschritt2:=splash.Fortschritt2+1;
        SplashAddText(_('Dekomprimiere (')+inttostr(splash.Fortschritt2)+'/'+inttostr(filesinprojectdirectory)+'): '+copy(ExtractFileName(FileName),0,30)+'...');
      end;
    end else
    begin
      SplashAddText(_('Dekomprimiere: ')+copy(ExtractFileName(FileName),0,30)+'...');
    end;
    RefreshSplashText;
  end;
end;

procedure TMainform.CompressCompressingFile(Sender: TObject;
  const FileName: String);
begin
  inprogress.label8.Caption:=_(' Speichere Datei... ');
  application.processmessages;
  inprogress.Show;
  inprogress.filename.Caption:=_('Komprimiere: ')+ExtractFileName(FileName);
  inprogress.ProgressBar2.Position:=inprogress.ProgressBar2.Position+1;
  // Vista Progressbar Workaround
  if windowsmajorversion>=6 then
  begin
    inprogress.ProgressBar2.Position:=inprogress.ProgressBar2.Position-1;
    inprogress.ProgressBar2.Position:=inprogress.ProgressBar2.Position+1;
  end;
  inprogress.Label1.Caption:=_('Datei (')+inttostr(inprogress.ProgressBar2.Position)+'/'+inttostr(filesinprojectdirectory)+')';
  inprogress.Label1.Refresh;
  inprogress.Refresh;
//  inprogress.Refresh;
end;

procedure TMainform.CompressDecompressedFile(Sender: TObject;
  const FileName: String; const FileSize: Cardinal);
begin
	if not startingup then
  begin
//  	inprogress.Hide;
  end else
  begin
    SplashCaptioninfo(_('Projekt vollständig geladen'));
    RefreshSplashText;
  end;
end;

procedure TMainform.CompressCompressedFile(Sender: TObject;
  const FileName: String);
begin
//  inprogress.Hide;
  inprogress.label3.visible:=false;
end;

procedure TMainform.FWM_DropFiles(var Msg: TMessage);
var
	i, anzahl, size: integer;
  Dateiname: String;
begin
  inherited;
  Dateiname := '';
  anzahl := DragQueryFile(Msg.WParam, $FFFFFFFF, nil, 0);

  for i := 0 to (anzahl - 1) do
  begin
    size := DragQueryFile(Msg.WParam, i , nil, 0);
    SetLength(Dateiname, size);
//    SetLength(Dateiname, DragQueryFile(Msg.WParam,i , PChar(Dateiname), size));
    DragQueryFile(Msg.WParam, i, PChar(Dateiname), size + 1);
    OpenPCDIMMERFile(Dateiname);
  end;
  DragFinish(Msg.WParam);
  Msg.Result := 0;
end;

procedure TMainform.Startoptionen1Click(Sender: TObject);
begin
  ShowMessage(
              '/nosplash'+#9+_('Zeigt beim Starten keinen Splashscreen an [ALT-Taste]')+#10+
              '/sp1 oder /sp2'+#9+#9+_('Wahl zwischen zwei verschiedenen Ladebildschirmen')+#10+
              '/debug'+#9+#9+_('Zeigt beim Starten die Logdatei an.')+#10+
              '/noaccu'+#9+#9+_('Verhindert den Start des Akku-Dienstes [Rechte SHIFT-Taste]')+#10+
              '/noproject'+#9+_('Verhindert das automatische Laden der letzten Projektdatei [Linke SHIFT-Taste]')+#10+
              '/minimized'+#9+_('Startet PC_DIMMER minimiert')+#10+
              '/restorelastvalues'+#9+_('Startet PC_DIMMER mit letzten Werten')+#10+
              '/starttimer'+#9+_('Startet den Timer mit als "DateiX" übergebener Timerdatei')+#10+
              '/loadfastsave'+#9+_('Lädt die per Fastsave gespeicherte Projektdatei (bei sehr großen Projekten entfällt hierdurch das Entpacken)')+#10+
              '');
end;

procedure CallbackGetDLLName(address:integer; channelname:PChar);stdcall;
begin
  with Mainform do
  if StartupFinished and (not shutdown) then
  begin
    if address>lastchan then exit;

    // Neuen Namen in GUI eintragen
    data.Names[address]:=copy(channelname,2,length(channelname));
    // GUI aktualisieren
    pluginsaktualisieren(nil);
  end;
end;

procedure CallbackGetDLLValue(address,startvalue,endvalue,fadetime,delay:integer);stdcall;
begin
  with Mainform do
  if StartupFinished and (not shutdown) then
  begin
    DataInPackets:=DataInPackets+1;

    if address>lastchan then exit;

    // Neue Werte an Hardware senden
    Senddata(address,maxres-startvalue,maxres-endvalue,fadetime,delay);

    // Neue Werte in GUI eintragen
    if fadetime=0 then
      data.ch[address]:=maxres-endvalue;
  end;
end;

procedure CallbackGetDLLValueEvent(address,endvalue:integer);stdcall;
begin
  if mainform.StartupFinished and (not mainform.shutdown) then
  begin
    mainform.DataInPackets:=mainform.DataInPackets+1;
    mainform.ExecuteDataInEvent(address, endvalue);
  end;
end;

function CallbackSetDLLValue(address:integer):integer;stdcall;
var
	k,kanalwert:integer;
begin
  with Mainform do
  if StartupFinished and (not shutdown) then
  begin
    kanalwert:=255;
    if not shutdown then
    begin
      if address<=lastchan then
      begin
        // Strings für Plugins nullterminieren
        datanames:=data.names[address]+#0;
        kanalwert:=data.ch[address];

        // Werte an Output-DLLs senden
        if not IsFreezeMode then
        begin
          DMXOutPackets:=DMXOutPackets+1;

          for k:=0 to length(OutputPlugins)-1 do
          begin
            try
              if Assigned(@OutputPlugins[k].SendData) and OutputPlugins[k].IsActive then
                OutputPlugins[k].SendData(address+OutputPlugins[k].Startaddress-1,FilterWithDimmcurve(address,maxres-kanalwert),FilterWithDimmcurve(address,maxres-kanalwert),0,@datanames);
            except
            end;
          end;
        end;

        // Werte an Plugin-DLLs senden
        for k:=0 to length(ProgramPlugins)-1 do
        begin
          if (@ProgramPlugins[k].SendData<>nil) then
          begin
            ProgramPlugins[k].SendData(address,data.ch[address],data.ch[address],0,@datanames);
          end;
        end;
      end;
    end;
    result:=FilterWithDimmcurve(address,maxres-kanalwert);
  end else
  begin
    result:=0;
  end;
end;

procedure CallbackMessage(MSG:Byte; Data1, Data2:Variant);stdcall;
var
	i,j:integer;
//  mididata:Variant;
  SzenenData:PTreeData;
  myID:TGUID;
  IDFound:integer;
begin
  with mainform do
  if StartupFinished and (not shutdown) then
  begin
	  if not startingup then
		case MSG of
	  	MSG_RECORDSCENE: // Szene
	    begin
          for i:=1 to lastchan do
          begin
            if (Data1[i]>-1) then
              recordchannelvalue[i]:=maxres-Data1[i]
            else
              recordchannelvalue[i]:=-1;
          end;
        audioeffektplayerform.RecordAudioeffekt(Data2);
	    end;
			MSG_AUDIOEFFECTPLAYERRECORD: // Boolean
	    begin
	    end;
			MSG_SYSTEMVOLUME: // Integer
	    begin
	  		//Bass_SetVolume(round((Data1/maxres)*100));
	  		masterform.volumeslider.position:=100-round((Data1/maxres)*100);
	    end;
			MSG_SYSTEMMUTE: // Boolean
	    begin
	      if Data1 then
	      	Bass_SetVolume(0)
	      else
	        Bass_SetVolume(100-masterform.volumeslider.position);
	    end;
			MSG_GRANDMASTER: // Integer
	    begin
	    	masterform.dimmermaster.Position:=round(((maxres-Data1)/maxres)*100);
	    end;
			MSG_FLASHMASTER: // Integer
	    begin
        masterform.flashmaster.position:=(maxres-Data1);
	    end;
      MSG_SPEEDMASTER:
      begin
        masterform.speedmaster.position:=(512-Data1);
      end;
			MSG_ADDLOGFILEENTRY: // String
	    begin
			  DebugAdd('PLUGIN: '+Data1);
	    end;
      MSG_SYSTEMSPEED: // Word
      begin
        if (beatform.Temposourcebox.ItemIndex=2) then
        begin
       		beatform.temposlider.Position:=Data1;
        end;
      end;
      MSG_NEW: ToolButton1Click(nil);
      MSG_OPEN: openproject(Data1, false);
      MSG_SAVE: saveproject(false,false,false);
      MSG_BEATIMPULSE: // Boolean
      begin
        if (beatform.Temposourcebox.ItemIndex=2) then
        begin
          if beatform.beat.color=clMaroon then
          begin
            beatform.beat.Color:=clBlack;
          end else
          begin
            beatform.beat.Color:=clMaroon;
          end;
          ExecuteBeat(nil);
        end;
      end;
      MSG_ACTUALCHANNELVALUE: senddata(Data1, maxres-Data2, maxres-Data2, 0);
      MSG_STARTSCENE: StartScene(StringToGUID(string(data1)),false,false, -1);
      MSG_STOPSCENE: StopScene(StringToGUID(string(data1)));
      MSG_MIDIIN:
      begin
//        mididata:=VarArrayCreate([0,2], varInteger);
//        mididata:=data1;
        GetMidi(data1[0], data1[1], data1[2]);
      end;
      MSG_MIDIOUT:
      begin
        SendMidi(data1[0], data1[1], data1[2]);
      end;
      MSG_OPENLIBRARY:
      begin
        setlength(szenenverwaltung_formarray,length(szenenverwaltung_formarray)+1);
        szenenverwaltung_formarray[length(szenenverwaltung_formarray)-1]:=Tszenenverwaltungform.Create(mainform);

        szenenverwaltung_formarray[length(szenenverwaltung_formarray)-1].Positionselection:=StringToGUID(data1);
        if (szenenverwaltung_formarray[length(szenenverwaltung_formarray)-1].showmodal=mrOK) then
        begin
          if szenenverwaltung_formarray[length(szenenverwaltung_formarray)-1].VST.SelectedCount>0 then
		  begin
			SzenenData:=szenenverwaltung_formarray[length(szenenverwaltung_formarray)-1].VST.GetNodeData(szenenverwaltung_formarray[length(szenenverwaltung_formarray)-1].VST.FocusedNode);

			SendMSG(MSG_LIBRARYVALUE, mainform.GetSceneInfo2(SzenenData^.ID,'name'), GUIDToString(SzenenData^.ID));
		  end;
        end;
        szenenverwaltung_formarray[length(szenenverwaltung_formarray)-1].Free;
        setlength(szenenverwaltung_formarray,length(szenenverwaltung_formarray)-1);
      end;

      // PluginScenes
      MSG_CREATEPLUGINSCENE:
      begin
        IDFound:=-1;
        for i:=0 to length(pluginszenen)-1 do
        begin
          if IsEqualGuid(pluginszenen[i].ID, StringToGUID(string(Data1))) then
          begin
            IDFound:=i;
            break;
          end;
        end;

        if IDFound=-1 then
        begin
          setlength(pluginszenen, length(pluginszenen)+1);
          pluginszenen[length(pluginszenen)-1].ID:=StringToGUID(string(Data1));
          pluginszenen[length(pluginszenen)-1].Name:=string(Data2);
          pluginszenen[length(pluginszenen)-1].Category:='';
        end else
        begin
          pluginszenen[i].Name:=string(Data2);
        end;

        // Szenenverwaltung aktualisieren
        if szenenverwaltung_formarray[0].Showing then
          szenenverwaltung_formarray[0].FormShow(nil);
      end;
      MSG_REFRESHPLUGINSCENE:
      begin
        for i:=0 to length(pluginszenen)-1 do
        begin
          if IsEqualGUID(StringToGUID(string(Data1)), pluginszenen[i].ID) then
          begin
            pluginszenen[i].Name:=string(Data2);

            // Szenenverwaltung aktualisieren
            if szenenverwaltung_formarray[0].Showing then
              szenenverwaltung_formarray[0].FormShow(nil);
            break;
          end;
        end;
      end;
      MSG_REMOVEPLUGINSCENE:
      begin
        for i:=0 to length(pluginszenen)-1 do
        begin
          if IsEqualGUID(StringToGUID(string(Data1)), pluginszenen[i].ID) then
          begin
            for j:=i to length(pluginszenen)-2 do
            begin
              pluginszenen[j].ID:=pluginszenen[j+1].ID;
              pluginszenen[j].Name:=pluginszenen[j+1].Name;
              pluginszenen[j].Category:=pluginszenen[j+1].Category;
            end;
            setlength(pluginszenen, length(pluginszenen)-1);


            // Szenenverwaltung aktualisieren
            if szenenverwaltung_formarray[0].Showing then
              szenenverwaltung_formarray[0].FormShow(nil);
            break;
          end;
        end;
      end;
      MSG_STARTPLUGINSCENE:
      begin
        // nur von Plugins auswerten
      end;
      MSG_STOPPLUGINSCENE:
      begin
        // nur von Plugins auswerten
      end;
      MSG_EDITPLUGINSCENE:
      begin
        // nur von Plugins auswerten
      end;
      MSG_REGISTERPLUGINCOMMAND:
      begin
        setlength(Befehlssystem[15].Steuerung, length(Befehlssystem[15].Steuerung)+1);
        Befehlssystem[15].Steuerung[length(Befehlssystem[15].Steuerung)-1].Bezeichnung:=string(Data2);
        Befehlssystem[15].Steuerung[length(Befehlssystem[15].Steuerung)-1].GUID:=StringToGUID(string(Data1));
        Befehlssystem[15].Steuerung[length(Befehlssystem[15].Steuerung)-1].InputValueOnly:=false;
        Befehlssystem[15].Steuerung[length(Befehlssystem[15].Steuerung)-1].IntegerArgCount:=0;
        Befehlssystem[15].Steuerung[length(Befehlssystem[15].Steuerung)-1].StringArgCount:=0;
        Befehlssystem[15].Steuerung[length(Befehlssystem[15].Steuerung)-1].GUIDArgCount:=0;
      end;
      MSG_SETCOLOR: geraetesteuerung.set_color(StringToGUID(string(Data1)), data2[0], data2[1], data2[2], 0, 0); // Data1=ID, Data2=array[0..2] of byte (=R,G,B)
      MSG_SETDIMMER: geraetesteuerung.set_dimmer(StringToGUID(string(Data1)), data2); // Data1=ID, Data2=byte
      MSG_SETSTROBE: geraetesteuerung.set_strobe(StringToGUID(string(Data1)), data2); // Data1=ID, Data2=byte
      MSG_SETSHUTTER: geraetesteuerung.set_shutter(StringToGUID(string(Data1)), data2); // Data1=ID, Data2=byte (0=off, 255=on)
      MSG_SETGOBOROT1: geraetesteuerung.set_gobo1rot(StringToGUID(string(Data1)), data2); // Data1=ID, Data2=byte (0=off, 255=on)
      MSG_SETGOBOROT2: geraetesteuerung.set_gobo2rot(StringToGUID(string(Data1)), data2); // Data1=ID, Data2=byte (0=off, 255=on)
      MSG_SETPRISMA: geraetesteuerung.set_prisma(StringToGUID(string(Data1)), data2); // Data1=ID, Data2=byte (0=off, 255=on)
      MSG_SETPRISMAROT: geraetesteuerung.set_prismarot(StringToGUID(string(Data1)), data2); // Data1=ID, Data2=byte (0=off, 255=on)
      MSG_SETIRIS: geraetesteuerung.set_iris(StringToGUID(string(Data1)), data2); // Data1=ID, Data2=byte (0=off, 255=on)
      MSG_STARTCOMMAND:
      begin
        TerminalSystem.BefehlsTyp:=StringToGUID(data1[0]);
        TerminalSystem.IntegerArg1:=strtoint(data1[1]);
        TerminalSystem.IntegerArg2:=strtoint(data1[2]);
        TerminalSystem.StringArg1:=data1[3];
        TerminalSystem.StringArg2:=data1[4];
        TerminalSystem.GUID1:=StringToGUID(data1[5]);
        TerminalSystem.GUID2:=StringToGUID(data1[6]);
        StartBefehl(StringToGUID('{46368186-DF3D-467A-9792-DAC6B03A21E3}'), integer(data2));
      end;
      MSG_SELECTDEVICE:
      begin
        myID:=StringToGUID(string(Data1));
        if Data2<128 then
          mainform.DeviceSelected[geraetesteuerung.GetDevicePositionInDeviceArray(@myID)]:=false
        else if Data2=128 then
          mainform.DeviceSelected[geraetesteuerung.GetDevicePositionInDeviceArray(@myID)]:=not mainform.DeviceSelected[geraetesteuerung.GetDevicePositionInDeviceArray(@myID)]
        else if Data2>128 then
          mainform.DeviceSelected[geraetesteuerung.GetDevicePositionInDeviceArray(@myID)]:=true;
        mainform.DeviceSelectionChanged(nil);
      end;
      MSG_SELECTEDDEVICESSETCHANNEL:
      begin
        for i:=0 to length(mainform.Devices)-1 do
        begin
          if mainform.DeviceSelected[i] then
            geraetesteuerung.set_channel(mainform.devices[i].ID, String(Data1), -1, Integer(Data2), 0, 0);
        end;
      end;
    end;
	end;
end;

procedure LockWindow(const Handle: HWND);
begin
  SendMessage(Handle, WM_SETREDRAW, 0, 0);
end;

procedure UnlockWindow(const Handle: HWND);
begin
  SendMessage(Handle, WM_SETREDRAW, 1, 0);
  RedrawWindow(Handle, nil, 0,
    RDW_ERASE or RDW_FRAME or RDW_INVALIDATE or RDW_ALLCHILDREN);
end;

procedure TMainform.ExecuteDataInEvent(address, endvalue:integer);
var
  i,j:integer;
begin
  if (address<1) or (address>8192) then exit;

  data_in_channels[address]:=endvalue;

  LastDataInChannel:=address;
  LastDataInValue:=endvalue;

  if DataInEventfrm.showing then
  begin
    DataInEventFrm.lastdatainaddress:=address;
    DataInEventFrm.lastdatainendvalue:=endvalue;
  end;

  // EditForm bei DataIn-Daten aktualisieren, wenn Form angezeigt wird
  if EditDataInEventfrm.showing then
  begin
    EditDataInEventfrm.address:=address;
    EditDataInEventfrm.endvalue:=endvalue;
  end;

  if DataInActiveRibbonBox.Down then
  begin
    // Zugewiesenes Ereignis bei Data-In ausführen
    if length(DataInEventArray)>0 then
    for i:=0 to length(DataInEventArray)-1 do
    begin
      if (address=DataInEventArray[i].channel) then
      begin
        // Zugewiesenes Ereignis herausfinden und ausführen
//        if (endvalue>=DataInEventArray[i].Befehl.OffValue) and (endvalue<=DataInEventArray[i].Befehl.OnValue) then
          StartBefehl(DataInEventArray[i].ID, endvalue);
      end;
    end;
  end;

  for i:=0 to length(Softpatch2)-1 do
  begin
    if Softpatch2[i].Channel2=address then
    begin
      for j:=0 to length(Softpatch2[i].RouteToPC_DIMMERChan)-1 do
      begin
        SendData(Softpatch2[i].RouteToPC_DIMMERChan[j],maxres-endvalue,maxres-endvalue,0);
      end;
    end;
  end;
end;

procedure TMainform.Kanalnamendrucken1Click(Sender: TObject);
var
  X1, X2: Integer;
  Y1, Y2: Integer;
  TmpI: Integer;
  F: Integer;
  TR: TRect;
  sGrid:TStringGrid;
  sTitle:string;
  i,j:integer;
  letzterdruckkanal,ersterdruckkanal:integer;
begin
  if drucken=nil then
    drucken:=Tdrucken.Create(drucken);

  if printer.Printers.Count=0 then
  begin
    ShowMessage(_('Es sind keine Drucker im System installiert.'));
    exit;
  end;

  drucken.ComboBox1.Items:=Printer.Printers;
  drucken.ComboBox1.ItemIndex:=Printer.PrinterIndex;

  drucken.Edit1.Text:=inttostr(1);
  drucken.Edit2.Text:=inttostr(lastchan);

  drucken.ShowModal;

if drucken.ModalResult=mrOK then
begin
  printer.PrinterIndex:=drucken.ComboBox1.ItemIndex;
  ersterdruckkanal:=strtoint(drucken.Edit1.Text);
  letzterdruckkanal:=strtoint(drucken.Edit2.Text);

  sTitle:=_('PC_DIMMER Kanalnamenübersicht (')+DateToStr(now)+' '+TimeToStr(now)+')';
  sGrid:=TStringGrid.Create(self);
  sGrid.FixedCols:=0;
  sGrid.FixedRows:=0;
  sGrid.ColCount:=4;
  sGrid.RowCount:=(lastchan div 2) + 1;
  sGrid.ColWidths[0]:=60;
  sGrid.ColWidths[1]:=200;
  sGrid.ColWidths[2]:=60;
  sGrid.ColWidths[3]:=200;

  sGrid.Cells[0,0]:=_('Kanal');
  sGrid.Cells[1,0]:=_('Kanalname');
  sGrid.Cells[2,0]:=_('Kanal');
  sGrid.Cells[3,0]:=_('Kanalname');

  j:=ersterdruckkanal;
  i:=ersterdruckkanal;
  repeat
  	// Ungerade Kanäle
	  sGrid.RowHeights[i]:=10;
 		sGrid.Cells[0,i]:=_('Kanal ')+inttostr(j);
 		sGrid.Cells[1,i]:=data.names[j];
    // Gerade Kanäle
 		sGrid.Cells[2,i]:=_('Kanal ')+inttostr(j+1);
 		sGrid.Cells[3,i]:=data.names[j+1];
    i:=i+1;
    j:=j+2;
  until (j>letzterdruckkanal) or ((j+1)>letzterdruckkanal) or (i>(letzterdruckkanal div 2 + 1));

  Printer.Title := sTitle;
  Printer.BeginDoc;
  Printer.Canvas.Pen.Color  := 0;
  Printer.Canvas.Font.Name  := 'Times New Roman';
  Printer.Canvas.Font.Size  := 12;
  Printer.Canvas.Font.Style := [fsBold, fsUnderline];
  Printer.Canvas.TextOut(0, 100, Printer.Title);
  for F := 0 to sGrid.ColCount - 1 do
  begin
    X1 := 0;
    for TmpI := 0 to (F - 1) do
      X1 := X1 + 5 * (sGrid.ColWidths[TmpI]);
    Y1 := 300;
    X2 := 0;
    for TmpI := 0 to F do
      X2 := X2 + 5 * (sGrid.ColWidths[TmpI]);
    Y2 := 450;
    TR := Rect(X1, Y1, X2 - 30, Y2);
    Printer.Canvas.Font.Style := [fsBold];
    Printer.Canvas.Font.Size := 7;
    Printer.Canvas.TextRect(TR, X1, 300, sGrid.Cells[F, 0]);
    Printer.Canvas.Font.Style := [];
    for TmpI := 1 to sGrid.RowCount - 1 do
    begin
      Y1 := 75 * TmpI + 300;
      Y2 := 75 * (TmpI + 1) + 300;
      TR := Rect(X1, Y1, X2 - 30, Y2);
      Printer.Canvas.TextRect(TR, X1, Y1, sGrid.Cells[F, TmpI]);
    end;
  end;
  Printer.EndDoc;
  sGrid.Free;
end;
end;

procedure TMainform.PowerButton1PowerbuttonPress(Sender: TObject);
begin
//	if not powerbutton1.PowerOffEnable then
//  	ShowMessage('Die Power-Taste Ihres Computers wurde gedrückt!.'+#10#10+'Diese Funktion ist im PC_DIMMER jedoch deaktiviert worden.'+#10#10+'Mit einem Klick auf das Symbol für das Aktivieren/Deaktivieren des Ein-/Aus-Schalters kann die Power-Taste wieder aktiviert werden.');

	if not powerbutton1.PowerOffEnable then
    MessageDlg(_('Die Power-Taste Ihres Computers wurde gedrückt!'+#10+'Diese Funktion ist im PC_DIMMER jedoch deaktiviert worden.'+#10#10+'Mit einem Klick auf das Symbol für das Aktivieren/Deaktivieren des Ein-/Aus-Schalters kann die Power-Taste wieder aktiviert werden.'), mtInformation, [mbOK], 0);
end;

procedure TMainform.Pluginsreaktivieren1Click(Sender: TObject);
var
	i:integer;
  ProcCall: procedure(funktionsadresse0,funktionsadresse1,funktionsadresse2,funktionsadresse3,funktionsadresse4:Pointer);stdcall;
  ProcCall2:procedure;stdcall;
  FuncCallDeactivate:function:boolean;stdcall;
  FuncCall,FuncCall2 : function : PChar;stdcall;
  LReg:TPCDRegistry;
begin
  if not UserAccessGranted(2) then exit; 

  inprogress.label8.Caption:=_(' Plugin-Reset... ');
  inprogress.ProgressBar1.Max:=100;
  application.processmessages;
  inprogress.Show;
  inprogress.filename.Caption:=_('Bereite Reset vor...');
  inprogress.ProgressBar1.Position:=0;
  inprogress.Refresh;

  DebugAdd('PLUGIN: Resetting Plugins:', false);
  DebugAdd('PLUGIN: Deactivating Plugins...');

// Input-Plugins deaktivieren
  for i:=0 to length(ProgramPlugins)-1 do
  begin
    FuncCallDeactivate := GetProcAddress(ProgramPlugins[i].Handle,'DLLDestroy');
    if not Assigned(FuncCallDeactivate) then
      FuncCallDeactivate := GetProcAddress(ProgramPlugins[i].Handle,'DLLDeactivate');
    if Assigned(FuncCallDeactivate) then
    begin
			inprogress.filename.Caption:=_('Deaktiviere Input-Plugin ')+ProgramPlugins[i].Filename;
			inprogress.ProgressBar1.Position:=21;
			inprogress.ProgressBar1.Position:=20;
			inprogress.Refresh;
  		DebugAdd('PLUGIN: Deactivating Plugin '+ProgramPlugins[i].Filename);
      if FuncCallDeactivate then
      begin
       	DebugAddToLine(' - OK');
			end else
      begin
				ShowMessage(_('Das Plugin "')+ProgramPlugins[i].Filename+_('" hat einen Fehler beim Deaktivieren gemeldet.'));
       	DebugAddToLine(' - ERROR');
      end;
    end else
    begin
	 		DebugAdd('PLUGIN: Error in Plugin '+ProgramPlugins[i].Filename);
    end;
  end;
  DebugAdd('PLUGIN: Deactivated all Inputplugins successful...');

  inprogress.filename.Caption:=_('Entferne DLL-Referenzen...');
  inprogress.ProgressBar1.Position:=41;
  inprogress.ProgressBar1.Position:=40;
  inprogress.Refresh;

  DebugAdd('PLUGIN: Freeing DLLs...');

  for i:=0 to length(ProgramPlugins)-1 do
  begin
    FreeLibrary(ProgramPlugins[i].Handle);
    @ProgramPlugins[i].SendData:=nil;
    @ProgramPlugins[i].SendMessage:=nil;
  end;

 	DebugAddToLine(' - OK');
  DebugAdd('PLUGIN: Reactivating Plugins:');

  for i:=0 to length(ProgramPlugins)-1 do
  begin
    ProgramPlugins[i].Handle := LoadLibrary(PChar(pcdimmerdirectory+'\plugins\'+ProgramPlugins[i].Filename));
    FuncCall := GetProcAddress(ProgramPlugins[i].Handle,'DLLGetName');
    FuncCall2 := GetProcAddress(ProgramPlugins[i].Handle,'DLLGetVersion');
    if Assigned(FuncCall) then
    begin
      ProgramPlugins[i].Name:=FuncCall;
      ProgramPlugins[i].Version:=FuncCall2;
    end else
    begin
      DebugAdd('PLUGIN: Error in inputplugin "'+ProgramPlugins[i].Filename+'"');
    end;

    DebugAdd('PLUGIN: Try to activate inputplugin "'+ProgramPlugins[i].Filename+'"');
    ProcCall := GetProcAddress(ProgramPlugins[i].Handle,'DLLCreate');
    if not Assigned(ProcCall) then
      ProcCall := GetProcAddress(ProgramPlugins[i].Handle,'DLLActivate');
    if Assigned(ProcCall) then
    begin
      inprogress.filename.Caption:=_('Reaktiviere Input-Plugin ')+ProgramPlugins[i].Filename;
      inprogress.ProgressBar1.Position:=61;
      inprogress.ProgressBar1.Position:=60;
      inprogress.Refresh;
      Proccall(@CallbackGetDLLValue,@CallbackGetDLLValueEvent,@CallbackGetDLLName,@CallbackSetDLLValue,@CallbackMessage);
      DebugAddToLine(' - OK');
    end else
    begin
      DebugAddToLine(' - ERROR');
    end;
    @ProgramPlugins[i].SendData := GetProcAddress(ProgramPlugins[i].Handle,'DLLSendData');
    @ProgramPlugins[i].SendMessage := GetProcAddress(ProgramPlugins[i].Handle,'DLLSendMessage');
  end;

  // Plugins starten
  for i:=0 to length(ProgramPlugins)-1 do
  begin
    ProcCall2 := GetProcAddress(ProgramPlugins[i].Handle,'DLLStart');
    if Assigned(ProcCall2) then
    begin
      inprogress.filename.Caption:=_('Starte Input-Plugin ')+ProgramPlugins[i].Filename;
      inprogress.ProgressBar1.Position:=61;
      inprogress.ProgressBar1.Position:=60;
      inprogress.Refresh;
      Proccall2;
    end;
  end;
  DebugAdd('PLUGIN: Sending values to all Plugins...');

	inprogress.filename.Caption:=_('Sende allen Plugins aktuelle Werte...');
	inprogress.ProgressBar1.Position:=81;
	inprogress.ProgressBar1.Position:=80;
	inprogress.Refresh;
  pluginsaktualisieren(sender);
 	DebugAddToLine(' - OK', false);
  DebugAdd('PLUGIN: Resetting Plugins successful...', false);
  DebugAdd('', true, false);

  LReg := TPCDRegistry.Create;
  for i:=0 to length(ProgramPlugins)-1 do
  begin
    inprogress.filename.Caption:=_('Öffne Plugin ')+ProgramPlugins[i].Filename;
    inprogress.ProgressBar1.Position:=91;
    inprogress.ProgressBar1.Position:=90;
    inprogress.Refresh;

    if LReg.OpenRegKey(ProgramPlugins[i].Filename) then
    begin
      if LReg.ValueExists('Showing Plugin') then
        if LReg.ReadBool('Showing Plugin') then
        begin
          if (ProgramPlugins[i].Handle<>0) then
          begin
            try
              @ProcCall2 := GetProcAddress(ProgramPlugins[i].Handle,'DLLShow');
              if Assigned(ProcCall2) then
                Proccall2;
            except
            end;
          end;
        end;
      LReg.CloseKey;
    end;
  end;
  LReg.Free;

  inprogress.hide;
end;

procedure TMainform.Projektverwaltung1Click(Sender: TObject);
begin
  if not UserAccessGranted(1) then exit;

  if autoinsertcomputerusername then
    projektbearbeiter:=JvComputerInfoEx1.Identification.LocalUserName;

  projektverwaltung.Edit1.Text:=projekttitel;
  projektverwaltung.Edit2.Text:=projektversion;
  projektverwaltung.Edit3.Text:=projektbearbeiter;
  projektverwaltung.label9.caption:=projektprogrammversion;
  projektverwaltung.label11.Caption:=projektdatum;
  projektverwaltung.label14.Caption:=projektuhrzeit;
  projektverwaltung.Label13.Caption:=projektspeicheranzahl;
  projektverwaltung.CheckBox1.Checked:=autoinsertcomputerusername;

	projektverwaltung.show;

  projekttitel:=projektverwaltung.Edit1.Text;
  projektversion:=projektverwaltung.Edit2.Text;
  projektbearbeiter:=projektverwaltung.Edit3.Text;
  autoinsertcomputerusername:=projektverwaltung.CheckBox1.Checked;
end;

procedure TMainform.Schnellspeichern1Click(Sender: TObject);
begin
  fastsaved:=true;
  saveproject(true,true,false);
end;

procedure TMainform.MidiInput1MidiInput(Sender: TObject);
var
	thisEvent: TMyMidiEvent;
  i,j,k:integer;
  QuarterType, temp:byte;
  SysexData:array of byte;
  MidiClockNow,frequency:Int64;
  ZeitZwischenMidiVierteln:extended;
  NewMidiTempo:extended;
  stopcmd, playcmd, reccmdon, reccmdoff, reccmd2:boolean; // MMC Response-Variablen
begin
{
  MIDI sendet in der Regel eine Message, und zwei Datenbytes:
  MSG: 0-255
  Data1: 0-127
  Data2: 0-127

  Aufteilung von MSG sieht wie folgt aus:
  0-239: NoteOn, NoteOff, Programchange und vieles mehr für normale Notendefinition (OK für PC_DIMMER)
  240: Sysex start
  241: MTC Viertel Frame
  242: Song-Positions Zeiger
  243: Songauswahl    (OK für PC_DIMMER)
  244: undefiniert
  245: undefiniert
  246: Time request
  247: Sysex end
  248: Midi-Clock
  249: Midi-Tick
  250: Midi Start     (OK für PC_DIMMER)
  251: Midi Continue  (OK für PC_DIMMER)
  252: Midi Stop      (OK für PC_DIMMER)
  253: undefiniert
  254: Active Sense
  255: Midi Reset     (OK für PC_DIMMER)
}

	with (Sender As TMidiInput) do
	begin
		while (MessageCount > 0) do
		begin
			thisEvent := GetMidiEvent;

      // generell MIDI verarbeiten
      if MIDIActiveRibbonBox.Down then
      begin
        MIDIInPackets:=MIDIInPackets+1;

        // Sysex-Daten lesen
        {
        Datenformat von Sysex-Daten (data kann beliebig lang sein)
        F0, 7F, nn, sub-ID, data, F7
        nn = channel number, 00 to 7F; 7F = global
        sub-IDs:
        01 = Long Form MTC
        02 = MIDI Show Control
        03 = Notation Information
        04 = Device Control
        05 = Real Time MTC Cueing
        06 = MIDI Machine Control Command
        07 = MIDI Machine Control Response
        08 = Single Note Retune
        }
        for i:=0 to length(MidiInControls)-1 do
        begin
          if Sender=MidiInControls[i] then
          begin
            setlength(SysexData, thisEvent.SysexLength);
            for j:=0 to length(SysexData)-1 do
              SysexData[j]:=Byte(thisEvent.Sysex[j]);

            // MIDI-TimeCode auslesen
            if (length(SysexData)=10) and (SysexData[0]=240) and (SysexData[1]=127) and (SysexData[2]=127) and (SysexData[3]=1) and (SysexData[4]=1) and (SysexData[9]=247) then
            begin
              temp:=SysexData[5] shl 3;
              MidiInTimeCode[i].h:=temp shr 3;
              MidiInTimeCode[i].min:=SysexData[6];
              MidiInTimeCode[i].s:=SysexData[7];
              MidiInTimeCode[i].Frame:=SysexData[8];

              MidiInTimeCode[i].Framemode:=SysexData[5] shr 5;
            end;

            // MIDI Machine Control Command-Daten auf normale MIDI-Nachricht umrouten
            {
            F0 7F deviceID 06 command F7
            The third byte is the Device ID.
            The fifth byte is the command:
            01 Stop
            02 Play
            03 Deferred Play
            04 Fast Forward
            05 Rewind
            06 Record Strobe (Punch In)
            07 Record Exit (Punch out)
            08 Record Ready (Record Pause)
            09 Pause
            0A Eject
            0B Chase
            0D MMC Reset
            40 Write
            44 Locate/Go to  (F0 7F deviceID 06 44 06 01 hr mn sc fr ff F7)
            47 Shuttle
            }                                                     //MMC Command
            if (length(SysexData)>=6) and (SysexData[0]=240) and ((SysexData[3]=6) or (SysexData[3]=7)) and (SysexData[length(SysexData)-1]=247) then
            begin
              if (SysexData[3]=6) then
              begin
                // MMC Command direkt als normale MIDI-Nachricht tarnen
                LastMidiMSG:=253; // 253 ist laut MIDI-Standard noch undefiniert -> also nutzen wir es für umgeroutete MMC Kommandos
                LastMidiData1:=SysexData[4]; // MMC-Command
                LastMidiData2:=127;
              end else if (SysexData[3]=7) then
              begin
                // MMC Response als normale MIDI-Nachricht tarnen
                LastMidiMSG:=245; // 245 ist laut MIDI-Standard noch undefiniert -> also nutzen wir es für umgeroutete MMC Kommandos

                stopcmd:=(SysexData[4]=strtoint('0x48')) and (SysexData[5]=strtoint('0x03')) and (SysexData[6]=strtoint('0x01')) and (SysexData[7]=strtoint('0x7F')) and (SysexData[8]=strtoint('0x01'));
                playcmd:=(SysexData[4]=strtoint('0x48')) and (SysexData[5]=strtoint('0x03')) and (SysexData[6]=strtoint('0x02')) and (SysexData[7]=strtoint('0x7F')) and (SysexData[8]=strtoint('0x01'));
                reccmdoff:=(SysexData[4]=strtoint('0x4D')) and (SysexData[5]=strtoint('0x01')) and (SysexData[6]=strtoint('0x00'));
                reccmdon:=(SysexData[4]=strtoint('0x4D')) and (SysexData[5]=strtoint('0x01')) and (SysexData[6]=strtoint('0x02'));
                reccmd2 :=(SysexData[4]=strtoint('0x4E')) and (SysexData[5]=strtoint('0x0E')) and (SysexData[6]=strtoint('0x00')) and (SysexData[7]=strtoint('0x00'));

                if stopcmd then
                begin
                  LastMidiData1:=0; // Cmd
                  LastMidiData2:=127;
                end;
                if playcmd then
                begin
                  LastMidiData1:=1; // Cmd
                  LastMidiData2:=127;
                end;
                if reccmdon then
                begin
                  LastMidiData1:=2; // Cmd
                  LastMidiData2:=127;
                end;
                if reccmdoff then
                begin
                  LastMidiData1:=3; // Cmd
                  LastMidiData2:=127;
                end;
                if reccmd2 then
                begin
                  LastMidiData1:=4; // Cmd
                  LastMidiData2:=127;
                end;
                LastMidiMMR:=LastMidiData1;
              end;

              if SysexData[4]=68 then
              begin
                // Locate/Goto ausführen
                MidiInTimeCode[i].h:=SysexData[7];
                MidiInTimeCode[i].min:=SysexData[8];
                MidiInTimeCode[i].s:=SysexData[9];
                MidiInTimeCode[i].Frame:=SysexData[10];
              end;

              // EditForm bei MIDI-Daten aktualisieren, wenn Form angezeigt wird
              if EditMIDIEVENTfrm.showing then
              begin
                EditMIDIEVENTfrm.Message1b.caption:=inttostr(LastMidiMSG);
                EditMIDIEVENTfrm.Data1b.caption:=inttostr(LastMidiData1);
                EditMIDIEVENTfrm.Data2b.caption:=inttostr(LastMidiData2);

                if EditMIDIEVENTfrm.recordmidi.checked then
                begin
                  EditMIDIEVENTfrm.Message1a.text:=inttostr(LastMidiMSG);
                  EditMIDIEVENTfrm.Data1a.text:=inttostr(LastMidiData1);
                  EditMIDIEVENTfrm.Data2a.text:=inttostr(LastMidiData2);
                  EditMIDIEVENTfrm.recordmidi.checked:=false;
                end;
              end;

              GetMidi(LastMidiMSG, LastMidiData1, LastMidiData2);
            end;

            break;
          end;
        end;
        // Ende der Sysex-Daten

        // normale MIDI-Nachrichten verarbeiten
        case thisEvent.MidiMessage of
          0..239,243,250,251,252,255:
          begin
            // 0-239: NoteOn, NoteOff, Programchange und vieles mehr für normale Notendefinition (OK für PC_DIMMER)
            // Normale MIDI-Nachricht
            LastMidiMSG:=thisEvent.MidiMessage;
            LastMidiData1:=thisEvent.Data1;
            LastMidiData2:=thisEvent.Data2;

            // EditForm bei MIDI-Daten aktualisieren, wenn Form angezeigt wird
            if EditMIDIEVENTfrm.showing then
            begin
              EditMIDIEVENTfrm.Message1b.caption:=inttostr(LastMidiMSG);
              EditMIDIEVENTfrm.Data1b.caption:=inttostr(LastMidiData1);
              EditMIDIEVENTfrm.Data2b.caption:=inttostr(LastMidiData2);

              if EditMIDIEVENTfrm.recordmidi.checked then
              begin
                EditMIDIEVENTfrm.Message1a.text:=inttostr(LastMidiMSG);
                EditMIDIEVENTfrm.Data1a.text:=inttostr(LastMidiData1);
                EditMIDIEVENTfrm.Data2a.text:=inttostr(LastMidiData2);
                EditMIDIEVENTfrm.recordmidi.checked:=false;
              end;
            end;

            GetMidi(thisEvent.MidiMessage, thisEvent.Data1, thisEvent.Data2);

            if UseMidiThru then
              SendMidi(thisEvent.MidiMessage, thisEvent.Data1, thisEvent.Data2);
          end; // Ende von 0..239,243,250,251,252,255
          248:
          begin
            //MIDI-CLOCK AUSWERTEN
            MidiClockTickCounter:=MidiClockTickCounter+1;
            if MidiClockTickCounter>24 then
            if (beatform.Temposourcebox.ItemIndex=5) then
            begin
              MidiClockTickCounter:=1;
              QueryPerformanceFrequency(frequency);
              if frequency>0 then
              begin
                // Zeit zwischen letztem und aktuellen ClockTick messen
                QueryPerformanceCounter(MidiClockNow);
                ZeitZwischenMidiVierteln:=((MidiClockNow-LastMidiClock)/frequency);

                MidiClockCounter:=MidiClockCounter+1;
                if MidiClockCounter>3 then
                begin
                  MidiClockCounter:=1;

                  // Gemittelten Wert errechnen
                  NewMidiTempo:=0;
                  for k:=1 to 3 do
                    NewMidiTempo:=NewMidiTempo+MidiClockValues[k];
                  NewMidiTempo:=NewMidiTempo/3;

                  // Mit altem Wert vergleichen und bei Bedarf aktualisieren
                  if (round(NewMidiTempo/3)<>round(LastMidiTempo/3)) then
                  begin
                    beatform.UpdateBPM(round(NewMidiTempo));
                  end;
                  LastMidiTempo:=NewMidiTempo;
                end;
                MidiClockValues[MIDIClockCounter]:=60/ZeitZwischenMidiVierteln;

                // Neue Zeitmarke für Differenzmessung zum nächsten Tick setzen
                QueryPerformanceCounter(LastMidiClock);
              end;
            end;
          end; // Ende von 248 MIDI-CLOCK AUSWERTEN
          else
          begin
{
  240: Sysex start
  241: MTC Viertel Frame
  242: Song-Positions Zeiger
  244: undefiniert
  245: undefiniert
  246: Time request
  247: Sysex end
  249: Midi-Tick
  253: undefiniert
  254: Active Sense
}
            // MIDI-TimeCode-Verarbeiten
            for i:=0 to length(MidiInControls)-1 do
            begin
              if Sender=MidiInControls[i] then
              begin
                if thisEvent.MidiMessage=241 then
                begin // MTC lesen
                  // 0nnn dddd
                  // nnn = QuarterType
                  QuarterType:=thisEvent.Data1 shr 4;
                  case QuarterType of
                    0: // LSB Frame
                    begin
                      temp:=thisEvent.Data1 shl 4;
                      MidiInTimeCode[i].LSBframe:=temp shr 4;
                      MidiInTimeCode[i].frame:=MidiInTimeCode[i].LSBframe or MidiInTimeCode[i].MSBframe;
                    end;
                    1: // MSB Frame
                    begin
                      MidiInTimeCode[i].MSBframe:=thisEvent.Data1 shl 4;
                      MidiInTimeCode[i].frame:=MidiInTimeCode[i].LSBframe or MidiInTimeCode[i].MSBframe;
                    end;
                    2: // LSB Second
                    begin
                      temp:=thisEvent.Data1 shl 4;
                      MidiInTimeCode[i].LSBs:=temp shr 4;
                      MidiInTimeCode[i].s:=MidiInTimeCode[i].LSBs or MidiInTimeCode[i].MSBs;
                    end;
                    3: // MSB Second
                    begin
                      MidiInTimeCode[i].MSBs:=thisEvent.Data1 shl 4;
                      MidiInTimeCode[i].s:=MidiInTimeCode[i].LSBs or MidiInTimeCode[i].MSBs;
                    end;
                    4: // LSB Minute
                    begin
                      temp:=thisEvent.Data1 shl 4;
                      MidiInTimeCode[i].LSBmin:=temp shr 4;
                      MidiInTimeCode[i].min:=MidiInTimeCode[i].LSBmin or MidiInTimeCode[i].MSBmin;
                    end;
                    5: // MSB Minute
                    begin
                      MidiInTimeCode[i].MSBmin:=thisEvent.Data1 shl 4;
                      MidiInTimeCode[i].min:=MidiInTimeCode[i].LSBmin or MidiInTimeCode[i].MSBmin;
                    end;
                    6: // LSB Hour
                    begin
                      temp:=thisEvent.Data1 shl 4;
                      MidiInTimeCode[i].LSBh:=temp shr 4;
                      MidiInTimeCode[i].h:=MidiInTimeCode[i].LSBh or MidiInTimeCode[i].MSBh;
                    end;
                    7: // MSB Hour and SMPTE Type 
                    begin
                    // 0nnn xyyd
                      temp:=thisEvent.Data1 shl 7;
                      MidiInTimeCode[i].MSBh:=temp shr 3;
                      MidiInTimeCode[i].h:=MidiInTimeCode[i].LSBh or MidiInTimeCode[i].MSBh;

                      temp:=thisEvent.Data1 shr 1;
                      temp:=temp shl 6;
                      MidiInTimeCode[i].Framemode:=temp shr 6;
                    end;
                  end;
                end;
                break;
              end;
            end;
          end; // Ende von else
        end;
        // Ende von normale MIDI-Nachrichten verarbeiten
      end;
			thisEvent.Free;
		end;
	end;
end;

procedure TMainform.GetMidi(MSG, Data1, Data2:byte);
var
  i,j:integer;
  MIDIINDATA:Variant;
begin
  // MIDI-Ereignis per MSG Senden
  MIDIINDATA:=VarArrayCreate([0,2], varInteger);
  MIDIINDATA[0]:=MSG;
  MIDIINDATA[1]:=Data1;
  MIDIINDATA[2]:=Data2;
  SendMSG(MSG_MIDIIN,MIDIINDATA,0);

  // Control7-Patch
  if UseControl7ForLevel then
  begin
    // Wenn Notenwert, dann letzte Note speichern
    if (MSG>=144) and (MSG<=159) then
    begin
      LastMIDINote[MSG-143]:=Data1;
    end;

    // Wenn Control7 (Volume), dann letzte Note mit diesen Volumewerten refreshen
    if (MSG>=176) and (MSG<=191) then
    begin
      //if (Data1=7) then // Reagiert auf Controller 7
      if Data1=LastMIDIController[MSG-175] then
      begin
        GetMidi(MSG-32, LastMIDINote[MSG-175], Data2);
      end;
    end;
  end;

  // Werte selektierter Kanäle von MIDI-Controller lesen
  j:=-1;
  for i:=0 to length(SelektierteGeraete)-1 do
  begin
    if MIDIActiveRibbonBox.Down and (SelektierteGeraete[i]>-1) then
    begin
      j:=j+1;
      if (j<length(SendValueOfSelectedDevicesToMidi)) then
      begin
        if ((SendValueOfSelectedDevicesToMidi[j].MSG=MIDIINDATA[0]) and (not SendValueOfSelectedDevicesToMidi[j].UseData2)) then
          geraetesteuerung.set_dimmer(mainform.Devices[SelektierteGeraete[i]].ID,round(MIDIINDATA[1]/127*maxres));
        if ((SendValueOfSelectedDevicesToMidi[j].MSG=MIDIINDATA[0]) and SendValueOfSelectedDevicesToMidi[j].UseData2 and (SendValueOfSelectedDevicesToMidi[j].Data1=MIDIINDATA[1])) then
          geraetesteuerung.set_dimmer(mainform.Devices[SelektierteGeraete[i]].ID,round(MIDIINDATA[2]/127*maxres));
      end else
      begin
        break;
      end;
    end;
  end;

  // Zugewiesenes Ereignis bei MIDI-Daten ausführen
  if length(MidiEventArray)>0 then
  for i:=0 to length(MidiEventArray)-1 do
  begin
    if (MSG=MidiEventArray[i].MIDIMessage) then
    begin
      if MidiEventArray[i].Data1orData2=2 then
      begin
//        if (round(Data2/127*maxres)>=MidiEventArray[i].Befehl.OffValue) and (round(Data2/127*maxres)<=MidiEventArray[i].Befehl.OnValue) then
        begin
          if Data1=MidiEventArray[i].MIDIData1 then
          begin
            if midieventfrm.showing then
            begin
              // Wenn Tastendruck, dann entsprechende Zeile markieren
              if (Data2>0) and (MSG>=144) and (MSG<=159) then
                midieventfrm.MIDIGrid.Cells[10,i+1]:='X'
              else
                midieventfrm.MIDIGrid.Cells[10,i+1]:='';

              // Aktuellen MIDI-Wert in Liste anzeigen
              midieventfrm.MIDIGrid.cells[1,i+1]:=inttostr(mainform.MidiEventArray[i].MIDIData1);	// Data1
              midieventfrm.MIDIGrid.cells[2,i+1]:=inttostr(Data2);
            end;

            // Zugewiesenes Ereignis herausfinden und Ausführen
            StartBefehl(MidiEventArray[i].ID, round(Data2/127*255));
          end;
        end;
      end else
      begin
//        if (round(Data1/127*maxres)>=MidiEventArray[i].Befehl.OffValue) and (round(Data1/127*maxres)<=MidiEventArray[i].Befehl.OnValue) then
        begin
          if midieventfrm.showing then
          begin
            // Wenn Tastendruck, dann entsprechende Zeile markieren
            if (Data1>0) and (MSG=144) then
              midieventfrm.MIDIGrid.Cells[10,i+1]:='X'
            else
              midieventfrm.MIDIGrid.Cells[10,i+1]:='';

            // Aktuellen MIDI-Wert in Liste anzeigen
            midieventfrm.MIDIGrid.cells[1,i+1]:=inttostr(Data1);
            midieventfrm.MIDIGrid.cells[2,i+1]:=inttostr(Data2);
          end;

          // Zugewiesenes Ereignis herausfinden und Ausführen
          StartBefehl(MidiEventArray[i].ID, round(Data1/127*255));
        end;
      end;
    end;
  end;
end;

procedure TMainform.MIDIEinstellungen1Click(Sender: TObject);
begin
  if not UserAccessGranted(1) then exit;

  refreshmidi;
  midieventfrm.Show;
end;

procedure TMainform.FormShow(Sender: TObject);
var
	LReg:TPCDRegistry;
  i,j,k,l,m,Count,Count2,Count3:integer;
  FuncCall,FuncCall2 : function : PChar;stdcall;
  ProcCall: procedure(funktionsadresse0,funktionsadresse1,funktionsadresse2,funktionsadresse3:Pointer;funktionsadresse4:Pointer);stdcall;
  ProcCall2:procedure;stdcall;
  text1:string;
  ergebnisse:Variant;
  Wnd: hWnd;
  P: TdxPNGImage;
  lpng: TdxPNGImage;
  PngStream: TStream;

  // Funktionen für Bild-Laden aus Plugins
  DLLGetResourceData:function(const ResName: PChar; Buffer: Pointer; var Length: Integer):boolean;stdcall;
  DLLGetResourceSize:function(const ResName: PChar): Integer; stdcall;
  Buffer:array of Byte;
  Size:Integer;
  S: TMemoryStream;
  PNG:TPNGObject;
  BMP32:TBitmap32;
begin
  if shutdown then exit;

  if not FirstStartAfterCreate then
    Exit;

  currentprojectversion := actualprojectversion;

  // Konstanten für Ribbon setzen, damit Ribbons nicht bei Doppelklick verschwinden
  dxribbon.dxRibbonOwnerMinimalWidth:=0;
  dxribbon.dxRibbonOwnerMinimalHeight:=0;


  // PNG-Workaround for Delphi 7: put PNG-images to dxBarLargeButton from PNGList
  PNGStream:=TMemoryStream.Create;
  lpng:=TdxPNGImage.Create;
  dxBarLargeButton9.HotGlyph.PixelFormat:=pf32bit;
  dxBarLargeButton9.HotGlyph.TransparentMode:=tmFixed;
  RibbonButtonPNGList.PngImages.Items[0].PngImage.SaveToStream(PNGStream);
  PNGStream.Position:=0;
  lpng.LoadFromStream(PNGStream);
  dxBarLargeButton9.HotGlyph.Assign(lpng);
  lpng.Free;
  PNGStream.Free;

  PNGStream:=TMemoryStream.Create;
  lpng:=TdxPNGImage.Create;
  dxBarLargeButton10.HotGlyph.PixelFormat:=pf32bit;
  dxBarLargeButton10.HotGlyph.TransparentMode:=tmFixed;
  RibbonButtonPNGList.PngImages.Items[1].PngImage.SaveToStream(PNGStream);
  PNGStream.Position:=0;
  lpng.LoadFromStream(PNGStream);
  dxBarLargeButton10.HotGlyph.Assign(lpng);
  lpng.Free;
  PNGStream.Free;

  // End of PNG-Workaround

  ///////////////////////////////
  // PLUGINS AKTIVIEREN
  ///////////////////////////////

  debuglistbox.Items.LoadFromFile(userdirectory+'\PC_DIMMER.log');
  DebugAdd('INIT: Found handle. PC_DIMMER Desktop is starting...');

  debuglistbox.Items.LoadFromFile(userdirectory+'\PC_DIMMER.log');
  SplashCaptioninfo(_('Inputplugins aktivieren...'));
  SplashProgress(1, 45, 100);
  RefreshSplashText;

  SplashCaptioninfo(_('Inputplugins aktivieren...'));
  RefreshSplashText;

  for i:=0 to length(ProgramPlugins)-1 do
  begin
    DebugAdd('PLUGIN: Try to activate inputplugin "'+ProgramPlugins[i].Filename+'"...');

    ProgramPlugins[i].Handle:=LoadLibrary(PChar(pcdimmerdirectory+'\plugins\'+ProgramPlugins[i].Filename));
    FuncCall := GetProcAddress(ProgramPlugins[i].Handle,'DLLGetName');
    FuncCall2 := GetProcAddress(ProgramPlugins[i].Handle,'DLLGetVersion');

    if Assigned(FuncCall) then
    begin
      SplashProgress(1, 60+round(15*(((i+1)/length(ProgramPlugins)))), 100);
      SplashAddText(_('Aktiviere ')+FuncCall);
      RefreshSplashText;

      ProgramPlugins[i].Name:=FuncCall;
      ProgramPlugins[i].Version:=FuncCall2;

      try
        DLLGetResourceData := GetProcAddress(ProgramPlugins[i].Handle, 'DLLGetResourceData');
        DLLGetResourceSize := GetProcAddress(ProgramPlugins[i].Handle, 'DLLGetResourceSize');

        if Assigned(DLLGetResourceData) and Assigned(DLLGetResourceSize) then
        begin
          Size := DLLGetResourceSize('PNGICON');
          if Size > 0 then
          begin
            SetLength(Buffer, Size);
            if DLLGetResourceData('PNGICON', @Buffer[0], Size) then
            begin
              S := TMemoryStream.Create;
              try
                S.WriteBuffer(Buffer[0], Size);
                S.Position := 0;
                PNG := TPNGObject.Create;
                BMP32 := TBitmap32.Create;
                try
                  PNG.LoadFromStream(S);
                  PNGToBitmap32(BMP32, PNG);
                  ProgramPlugins[i].Icon:=TBitmap.Create;
                  ProgramPlugins[i].Icon.Width:=BMP32.Width;
                  ProgramPlugins[i].Icon.Height:=BMP32.Height;
                  BitBlt(ProgramPlugins[i].Icon.Canvas.Handle, 0, 0, BMP32.Width, BMP32.Height, BMP32.Canvas.Handle, 0, 0, SrcCopy);
                finally
                  PNG.Free;
                  BMP32.Free;
                end;
              finally
                S.Free;
              end;
            end;
          end;
        end else
        begin
          ProgramPlugins[i].Icon:=PluginDemoRibbonBtn.HotGlyph;
        end;
      except
        ProgramPlugins[i].Icon:=PluginDemoRibbonBtn.HotGlyph;
      end;

      with mainform.PluginsRibbonGroup.ItemLinks.AddItem(TdxBarSubItem).Item as TdxBarSubItem do
      begin
        with ItemLinks.AddItem(TdxBarSeparator).Item as TdxBarSeparator do
        begin
          Name:='PluginRibbonSeparator'+inttostr(i);
          Caption:=_(ProgramPlugins[i].Name+' '+ProgramPlugins[i].Version);
        end;
        Caption:=ProgramPlugins[i].Name;
        Hint:=ProgramPlugins[i].Version;
        Glyph:=ProgramPlugins[i].Icon;
        LargeGlyph:=ProgramPlugins[i].Icon;
        Name:='PluginRibbonSubitem'+inttostr(i);
        LargeImageIndex:=0;

        with ItemLinks.AddItem(TdxBarButton).Item as TdxBarButton do
        begin
          Caption:=_('Anzeigen...');
          Name:='PluginShowRibbonBtn'+inttostr(i);
          OnClick:=mainform.PluginRibbonBtnClick;
        end;
        with ItemLinks.AddItem(TdxBarButton).Item as TdxBarButton do
        begin
          Caption:=_('Info...');
          Name:='PluginAboutRibbonBtn'+inttostr(i);
          OnClick:=mainform.PluginRibbonBtnClick;
        end;
      end;
    end;

    ProcCall := GetProcAddress(ProgramPlugins[i].Handle,'DLLCreate');
    if not Assigned(ProcCall) then
      ProcCall := GetProcAddress(ProgramPlugins[i].Handle,'DLLActivate');
    if Assigned(ProcCall) then
    begin
      Proccall(@CallbackGetDLLValue,@CallbackGetDLLValueEvent,@CallbackGetDLLName,@CallbackSetDLLValue,@CallbackMessage);
      DebugAddToLine(' - OK');
    end else
    begin
      DebugAddToLine(' - ERROR');
    end;
    @ProgramPlugins[i].SendData := GetProcAddress(ProgramPlugins[i].Handle,'DLLSendData');
    @ProgramPlugins[i].SendMessage := GetProcAddress(ProgramPlugins[i].Handle,'DLLSendMessage');
  end;
  // Plugins starten
  for i:=0 to length(ProgramPlugins)-1 do
  begin
    ProcCall2 := GetProcAddress(ProgramPlugins[i].Handle,'DLLStart');
    if Assigned(ProcCall2) then
    begin
      Proccall2;
    end;
  end;
  if length(ProgramPlugins)>0 then
  begin
    PluginRibbonTab.Visible:=true;
  end;


  SplashCaptioninfo(_('Outputplugins aktivieren...'));
  SplashProgress(1, 60, 100);
  RefreshSplashText;

  // Plugineinstellungen aus Registry lesen
  LReg := TPCDRegistry.Create;
  // Lese zuletzt verwendete Plugins
  for i:=0 to length(OutputPlugins)-1 do
  begin
    if LReg.OpenRegKey(OutputPlugins[i].Filename) then
    begin
      OutputPlugins[i].IsEnabled:=LReg.ReadWriteBool('Plugin Enabled', false);
      OutputPlugins[i].IsBlacklisted:=LReg.ReadWriteBool('Plugin Blacklisted', false);
      OutputPlugins[i].Startaddress:=LReg.ReadWriteInt('Plugin Startaddress', 1);
      OutputPlugins[i].Stopaddress:=LReg.ReadWriteInt('Plugin Stopaddress', 512);
      LReg.CloseKey;
    end else
    begin
      OutputPlugins[i].IsEnabled:=false;
      OutputPlugins[i].IsBlacklisted:=false;
      OutputPlugins[i].Startaddress:=1;
      OutputPlugins[i].Stopaddress:=512;
    end;
  end;
  LReg.Free;

  // Zuletzt genutzte Plugins rausfinden und aktivieren
  DebugAdd('', false, false);
  for i:=0 to length(OutputPlugins)-1 do
  begin
    if (OutputPlugins[i].IsEnabled and (not OutputPlugins[i].IsActive)) then
    begin
      DebugAdd('PLUGIN: Try to activate outputplugin "'+OutputPlugins[i].Filename+'"...');

      OutputPlugins[i].Handle:=LoadLibrary(PChar(pcdimmerdirectory+'\plugins\'+OutputPlugins[i].Filename));
      SplashProgress(1, 45+round(15*(i / length(OutputPlugins))), 100);
      SplashAddText(_('Aktiviere ')+OutputPlugins[i].Name);
      RefreshSplashText;
      ProcCall := GetProcAddress(OutputPlugins[i].Handle,'DLLCreate');
      if not Assigned(ProcCall) then
        ProcCall := GetProcAddress(OutputPlugins[i].Handle,'DLLActivate');
      if Assigned(ProcCall) then
      begin
        Proccall(@CallbackGetDLLValue,@CallbackGetDLLValueEvent,@CallbackGetDLLName,@CallbackSetDLLValue,@CallbackMessage);
        DebugAddToLine(' - OK');
      end else
      begin
        DebugAddToLine(' - ERROR');
      end;
      @OutputPlugins[i].SendData := GetProcAddress(OutputPlugins[i].Handle,'DLLSendData');
      @OutputPlugins[i].IsSending := GetProcAddress(OutputPlugins[i].Handle,'DLLIsSending');
      @OutputPlugins[i].SendMessage := GetProcAddress(OutputPlugins[i].Handle,'DLLSendMessage');
    end;
  end;
  // Plugins starten
  for i:=0 to length(OutputPlugins)-1 do
  if OutputPlugins[i].IsEnabled and (not OutputPlugins[i].IsActive) then
  begin
    ProcCall2 := GetProcAddress(OutputPlugins[i].Handle,'DLLStart');
    if Assigned(ProcCall2) then
    begin
      Proccall2;
      OutputPlugins[i].IsActive:=true;
    end;
  end;
  DebugAdd('', false, false);


  ///////////////////////////////
  // LETZTE WERTE WIEDERHERSTELLEN
  ///////////////////////////////
  // Letzte Werte wiederherstellen
  if LastSessionWasCorrupt or startupwitholdscene then
  begin
    RestoreValueBackup;
  end else
  begin
    for i:=1 to paramcount do
    begin
      if (paramstr(i)='/restorelastvalues') then
      begin
        RestoreLastValues:=true;
        RestoreValueBackup;
        break;
      end;
    end;
  end;

  SplashProgress(1, 75, 100);
  SplashCaptioninfo(_('Werte an Plugins und Interfaces übergeben...'));
  RefreshSplashText;

  DebugAdd('PLUGIN: Sending values to all Inputplugins...');
  for i:=0 to lastchan do
    Senddata(i, data.ch[i], data.ch[i], 0);
  DebugAddToLine(' - OK', false);
  DebugAdd('', true, false);

  // Allen DLLs die aktuellen Werte zusenden
  DebugAdd('PLUGIN: Sending values to all Programplugins...');
  pluginsaktualisieren(Sender);
  DebugAddToLine(' - OK', false);
  DebugAdd('', true, false);

  text:=GetWindowsLanguage;
  if text='DE' then
    SendMSG(MSG_SETLANGUAGE, integer(3), 0)
  else if text='EN' then
    SendMSG(MSG_SETLANGUAGE, integer(0), 0)
  else if text='FR' then
    SendMSG(MSG_SETLANGUAGE, integer(1), 0)
  else if text='NL' then
    SendMSG(MSG_SETLANGUAGE, integer(13), 0);

  SplashProgress(1, 76, 100);
  SplashCaptioninfo(_('Letztgenutzte Plugins anzeigen...'));
  RefreshSplashText;

  DragAcceptFiles(MainForm.Handle, True);

  if ShowLastPlugins then
  begin
    LReg := TPCDRegistry.Create;
    for i:=0 to length(ProgramPlugins)-1 do
    begin
      if LReg.OpenRegKey(ProgramPlugins[i].Filename) then
      begin
        if LReg.ValueExists('Showing Plugin') then
          if LReg.ReadBool('Showing Plugin') then
          begin
            if ProgramPlugins[i].Handle<>0 then
            begin
              try
                @ProcCall2 := GetProcAddress(ProgramPlugins[i].Handle,'DLLShow');
                if Assigned(ProcCall2) then
                  Proccall2;
              except
              end;
            end;
          end;
        LReg.CloseKey;
      end;
    end;
    LReg.Free;
  end;

  SplashProgress(1, 77, 100);
  SplashCaptioninfo(_('Letzte Module starten...'));
  RefreshSplashText;

  ///////////////////////////////
  // MODULE STARTEN
  ///////////////////////////////

  // Dimmerkernel starten
  SplashAddText(_('Starte Dimmerkernel...'));
  RefreshSplashText;
  DebugAdd('INIT: Starting Timer: Dimmerkernel');
  AutoFader.Enabled:=false;
  AutoFader.Interval:=DimmerkernelResolution;
  AutoFader.Enabled:=true;
  BewegungsszenenTimer.Enabled:=true;
  DebugAddToLine(' - OK');

  // Joystick starten
  SplashAddText('');
  SplashAddText(_('Starte Joystick...'));
  RefreshSplashText;
  DebugAdd('INIT: Starting Joystickcontrol');
  firststartaftercreate:=false;
  joystickform.InitializeJoystick;
  ActiveJoystickRibbonBox.Down:=enablejoystick;
  joystickform.JoystickTimer.Enabled:=enablejoystick;
 	DebugAddToLine(' - OK');

  // MIDI starten
  SplashAddText(_('Starte MIDI-In...'));
  RefreshSplashText;
  DebugAdd('INIT: Starting MIDI-Input...');
  StartMidiin(nil);

  SplashAddText(_('Starte MIDI-Out...'));
  RefreshSplashText;
  DebugAddToLine(' - OK', false);
  DebugAdd('INIT: Starting MIDI-Output...');
  StartMidiout(nil);
  DebugAddToLine(' - OK');

  refreshdatain;

  if length(DataInEventArray)>0 then
  begin
    DataInEventfrm.editDataInEvent.Enabled:=true;
    DataInEventfrm.deleteDataInEvent.Enabled:=true;
  end else
  begin
    DataInEventfrm.editDataInEvent.Enabled:=false;
    DataInEventfrm.deleteDataInEvent.Enabled:=false;
  end;

  // Akkukontrolle starten
  if (not dontstartaccu) then
  begin
    SplashAddText(_('Starte Akkukontrolle...'));
    RefreshSplashText;
    DebugAdd('INIT: Starting Thread: AccuControl');
    accuThread := TAccuThread.create(mainform.GetAccuLevel);
   	DebugAddToLine(' - OK');
  end else
  begin
    accupercent.Visible:=false;
    acculevel2.Visible:=false;
  end;

  SplashAddText(_('Starte Helper-Thread...'));
  RefreshSplashText;
  DebugAdd('INIT: Starting Thread: HelperThread');
  HelperThread := THelperThread.create();
  DebugAddToLine(' - OK');

  // Timecodeplayer starten
  SplashAddText(_('Starte MIDI-Timecodeplayer...'));
  RefreshSplashText;
  setlength(TimeCodePlayerBank,1);

  DebugAdd('INIT: Starting Timer: MIDI-Timecodeplayer');
  timecodeplayerform.GetMIDITimecodeTimer.Enabled:=true;
  DebugAddToLine(' - OK');

  SplashCaptioninfo(_('Netzwerk und Ambilight aktivieren...'));
  RefreshSplashText;

  LReg := TPCDRegistry.Create;
  if LReg.OpenRegKey('') then
  begin
    // HTTP-Server aktivieren, sofern beim letzten mal aktiv
    FHTTPServer := TPCDHTTPServer.Create(Application);
    if LReg.ValueExists('Start HTTP-Server') then
      if LReg.ReadBool('Start HTTP-Server') then
      begin
        FHTTPServer.Active := true;
        if not FHTTPServer.Active then
        begin
          DebugAdd('Init: Cannot start webserver.');
          ShowMessage(_('Webserver kann nicht gestartet werden!'));
        end;
      end;
    if LReg.ValueExists('Use HTTP Password') then
      FHTTPServer.UsePassword := LReg.ReadBool('Use HTTP Password');
    HTTPServerActivateRibbonBox.Down:=FHTTPServer.Active;

    if LReg.ValueExists('HTTP Password') then
    begin
      LReg.ReadBinaryData('HTTP Password',httppasswordscrambled,sizeof(httppasswordscrambled));

      with TCipher_Blowfish.Create do
      try
        Init(blowfishscramblekey);
        FHTTPServer.Password := DecodeBinary(httppasswordscrambled, TFormat_Copy);
      finally
        Free;
      end;
    end;

    // Terminalschnittstelle aktivieren, sofern beim letzten mal aktiv
    if LReg.ReadWriteBool('Terminalserver active', false) then
    begin
      if not FHTTPServer.Active then
      begin
        HTTPServerActivateRibbonBox.Down:=true;
        FHTTPServer.Active:=true;
      end;

      ActivateCommandReceiverRibbonBox.Down:=true;
      Commandserver.DefaultPort:=terminalport;
      Commandserver.Active:=ActivateCommandReceiverRibbonBox.Down;
    end;

    // MediaCenter Timecode empfangen, sofern beim letzten mal aktiv
    if LReg.ReadWriteBool('MediaCenter Timercodeserver active', false) then
    begin
      MCTRibbonBox.Down:=true;
      MediaCenterTimeCodeSocket.LocalPort:=mediacenterport;
      MediaCenterTimeCodeSocket.RemotePort:=mediacenterport;
      MediaCenterTimecodeSocket.Open;
    end;

    // MQTT-Client vorbereiten
    if LReg.ValueExists('MQTT Host') then
    begin
      mqtt.Host := LReg.ReadString('MQTT Host');
    end;
    if LReg.ValueExists('MQTT Port') then
    begin
      mqtt.Port := LReg.ReadInteger('MQTT Port');
    end;
    if LReg.ValueExists('MQTT User') then
    begin
      mqtt.Username := LReg.ReadString('MQTT User');
    end;
    if LReg.ValueExists('MQTT Password') then
    begin
      LReg.ReadBinaryData('MQTT Password',mqttpasswordscrambled,sizeof(mqttpasswordscrambled));

      with TCipher_Blowfish.Create do
      try
        Init(blowfishscramblekey);
        mqtt.Password := DecodeBinary(mqttpasswordscrambled, TFormat_Copy);
      finally
        Free;
      end;
    end;
    // MQTT Client aktivieren, sofern beim letzten mal aktiv
    if LReg.ValueExists('Start MQTT-Client') then
    begin
      if LReg.ReadBool('Start MQTT-Client') then
      begin
        mqtt.Activate(true);
        MQTTClientActivateRibbonBox.Down:=true;
      end;
    end;

    // WinLIRC-Server aktivieren, sofern beim letzten mal aktiv
    winlircform.cs.Active := LReg.ReadWriteBool('WinLIRC Server active', false);

    // Ambilight aktivieren, sofern beim letzten mal aktiv
    if LReg.ReadWriteBool('Ambilight active', false) then
    begin
      if messagedlg(_('Ambilight war in der letzten Sitzung aktiviert. Möchten Sie das Ambilight nun wieder einschalten?'),mtConfirmation,
      [mbYes,mbNo],0)=mrYes then
      begin
        ambilightform.Timer1.enabled:=true;
        ambilightform.Button2.Caption:=_('Ambilight ausschalten');
      end;
    end;

    // XTouchControl aktivieren, sofern beim letzten mal aktiv
    if LReg.ReadWriteBool('XTouchControl active', false) then
    begin
      xtouchcontrolform.xtouchserver.Active:=true;
      xtouchcontrolform.activebtn.Caption:=_('Ausschalten');
    end;

    try
      // Create HID-Functions for Elgato StreamDeck and maybe other devices
      // putting this component on the GUI will create strange errors
      // regarding "Device cannot be identified"
      // so we will create it manually in code
      // next function has a bug (see https://github.com/bitdump/BLHeli/issues/199)
      //HidCtl:=TJvHidDeviceController.Create(mainform, HidCtlDeviceCreateError, HidCtlDeviceChange);
      HidCtl:=TJvHidDeviceController.Create(mainform, HidCtlDeviceCreateError);
      HidCtl.OnDeviceChange:=HidCtlDeviceChange; // workaround to mitigate "Device cannot be identified"-errors on startup
      HidCtl.OnEnumerate:=HidCtlEnumerate;
      HidCtl.OnDeviceData:=HidCtlDeviceData;
    except
      ShowMessage(_('Problem beim Laden von HID-Geräten.'));
    end;

    LReg.CloseKey;
  end;
  LReg.Free;

  SplashCaptioninfo(_('Letzte Einstellungen laden...'));
  RefreshSplashText;

  // Einstellungen aus Registry lesen
  LReg := TPCDRegistry.Create;
  if LReg.OpenRegKey('') then
  begin
    if LReg.ValueExists('Autolocktime') then
      autolocktime:=LReg.ReadInteger('Autolocktime');
    if LReg.ValueExists('Autolockcode') then
    begin
      LReg.ReadBinaryData('Autolockcode',autolockcodescrambled,sizeof(autolockcodescrambled));

      with TCipher_Blowfish.Create do
      try
        Init(blowfishscramblekey);
        autolockcode := DecodeBinary(autolockcodescrambled, TFormat_Copy);
      finally
        Free;
      end;
    end;
    if LReg.ValueExists('Autologouttime') then
      autologouttime:=LReg.ReadInteger('Autologouttime');
    if LReg.ValueExists('StartupUser') then
      StartupUser:=LReg.ReadString('StartupUser');

    if LReg.ValueExists('Show text') then
    begin
      if LReg.ReadBool('Show text')<>checkbox1.Checked then
      begin
        checkbox1.checked:=LReg.ReadBool('Show text');
        CheckBox1MouseUp(nil, mbRight, [], 0, 0);
      end;
    end else
    begin
      checkbox1.checked:=true;
    end;

    if LReg.ValueExists('AutoGrid') then
    begin
      if LReg.ReadBool('AutoGrid')<>checkbox4.Checked then
      begin
        checkbox4.checked:=LReg.ReadBool('AutoGrid');
        CheckBox4MouseUp(nil, mbRight, [], 0, 0);
      end;
    end else
    begin
      checkbox4.checked:=true;
    end;

    if LReg.ValueExists('Huge colorshapes') then
    begin
      if LReg.ReadBool('Huge colorshapes')<>checkbox2.Checked then
      begin
        checkbox2.checked:=LReg.ReadBool('Huge colorshapes');
        CheckBox2MouseUp(nil, mbRight, [], 0, 0);
      end;
    end else
    begin
      checkbox2.checked:=false;
    end;

    if LReg.ValueExists('Only one DDF at time') then
    begin
      if LReg.ReadBool('Only one DDF at time')<>checkbox5.Checked then
      begin
        checkbox5.checked:=LReg.ReadBool('Only one DDF at time');
      end;
    end else
    begin
      checkbox5.checked:=false;
    end;

    if LReg.ValueExists('Lock icons') then
    begin
      if LReg.ReadBool('Lock icons')<>checkbox3.Checked then
      begin
        checkbox3.checked:=LReg.ReadBool('Lock icons');
      end;
    end else
    begin
      checkbox3.checked:=false;
    end;

    // Zeiten aus Registry laden
    ShortCutChecker.Interval := LReg.ReadWriteInt('Keyboardinterval', 25);
    Rfr_Main := LReg.ReadWriteInt('Refresh_Main', 50);
    if Rfr_Main < 15 then Rfr_Main := 15;
    MainformScreenRefreshTimer.Interval := Rfr_Main;

    Rfr_AEP := LReg.ReadWriteInt('Refresh_AEP', 100);
    if Rfr_AEP < 15 then Rfr_AEP := 15;
    audioeffektplayerform.audioeffekttimer.Interval:=Rfr_AEP; //>=25
    audioeffektplayerform.aktualisierungsintervall:=Rfr_AEP;

    Rfr_Buehnenansicht := LReg.ReadWriteInt('Refresh_Buehnenansicht', 50);
    if Rfr_Buehnenansicht < 15 then Rfr_Buehnenansicht := 15;
    grafischebuehnenansicht.RefreshTimer.Interval:=Rfr_Buehnenansicht;

    Rfr_Cuelist := LReg.ReadWriteInt('Refresh_Cuelist', 250);
    if Rfr_Cuelist < 15 then Rfr_Cuelist:=15;
    cuelistform.Timer1.Interval:=Rfr_Cuelist;

    Rfr_Faderpanel := LReg.ReadWriteInt('Refresh_Faderpanel', 50);
    if Rfr_Faderpanel < 15 then Rfr_Faderpanel:=15;
    faderpanelform.Timer1.Interval:=Rfr_Faderpanel;

    Rfr_Kanaluebersicht:=LReg.ReadWriteInt('Refresh_Kanaluebersicht', 50);
    if Rfr_Kanaluebersicht < 15 then Rfr_Kanaluebersicht:=15;
    kanaluebersichtform.RefreshTimer.Interval:=Rfr_Kanaluebersicht;

    Rfr_Kontrollpanel:=LReg.ReadWriteInt('Refresh_Kontrollpanel', 50);
    if Rfr_Kontrollpanel < 15 then Rfr_Kontrollpanel:=15;
    kontrollpanel.RefreshTimer.Interval:=Rfr_Kontrollpanel;

    Rfr_KontrollpanelCheckForActive:=LReg.ReadWriteInt('Refresh_KontrollpanelCheckForActive', 250);
    if Rfr_KontrollpanelCheckForActive < 15 then Rfr_KontrollpanelCheckForActive:=15;
    kontrollpanel.CheckForActive.Interval:=Rfr_KontrollpanelCheckForActive;

    Rfr_Submaster:=LReg.ReadWriteInt('Refresh_Submaster', 50);
    if Rfr_Submaster < 15 then Rfr_Submaster:=15;
    submasterform.Timer1.Interval:=Rfr_Submaster;

    if LReg.OpenKey('Faderpanel',true) then
    begin
      if LReg.ValueExists('Blendout Free Channels') then
      begin
        NurKanlemitGertenanzeigen1.Checked:=LReg.ReadBool('Blendout Free Channels');
      end;

      if LReg.ValueExists('Autohide') then
      begin
        Panelautomatischausblenden1.Checked:=LReg.ReadBool('Autohide');
      end;
      if LReg.ValueExists('Show Rectangles Full') then
      begin
        Kstchenimmervoll1.Checked:=LReg.ReadBool('Show Rectangles Full');
      end;
      LReg.CloseKey;
    end;

    LReg.CloseKey;
  end;
  LReg.Free;

  SplashProgress(1, 78, 100);
  SplashCaptioninfo(_('Fenster öffnen...'));
  RefreshSplashText;

  setlength(szenenverwaltung_formarray,1);
  szenenverwaltung_formarray[0]:=Tszenenverwaltungform.Create(self);
  szenenverwaltung_formarray[0].button1.visible:=false;
  szenenverwaltung_formarray[0].button2.visible:=false;
  szenenverwaltung_formarray[0].Checkbox1.left:=16;
  szenenverwaltung_formarray[0].IsNonModal:=true;
  szenenverwaltung_formarray[0].Position:=poDefault;
  szenenverwaltung_formarray[0].ClientWidth:=522;
  szenenverwaltung_formarray[0].ClientHeight:=418;

  ///////////////////////////////
  // FENSTER ÖFFNEN
  ///////////////////////////////

  // Einzelne Fenster anzeigen, die beim letzten Shutdown offen waren
  LReg := TPCDRegistry.Create;
  if LReg.OpenRegKey('') then
  begin
    SmallWindowstyle := LReg.ReadWriteBool('Small Windowstyle', true);

    if LReg.ReadWriteBool('Showing Kontrollpanel', false) then
    begin
      Kontrollpanel.Show;
      kontrollpanel.Width:=kontrollpanelrecord.formwidth;
      kontrollpanel.Height:=kontrollpanelrecord.formheight;
    end;
    if LReg.ReadWriteBool('Showing Geraetesteuerung', false) then
      geraetesteuerung.Show;
    if LReg.ReadWriteBool('Showing Effektsequenzer', false) then
      Effektsequenzer.Show;
	  if LReg.ReadWriteBool('Showing Audioeffektplayer', false) then
      Audioeffektplayerform.Show;
    if LReg.ReadWriteBool('Showing Buehnenansicht', false) then
    begin
      if FirstStartofStageview then
      begin
        FirstStartofStageview:=false;
        grafischebuehnenansicht.RefreshStageView;
      end;
      grafischebuehnenansicht.Show;
    end;
    if LReg.ReadWriteBool('Showing Submaster', false) then
      submasterform.Show;
    if LReg.ReadWriteBool('Showing Clock', false) then
      clockform.Show;
	  if LReg.ReadWriteBool('Showing CD-Player', false) then
    begin
      if cdplayerform=nil then
        cdplayerform:=tcdplayerform.Create(cdplayerform);
      cdplayerform.Show;
    end;
    if LReg.ReadWriteBool('Showing Textbuch', false) then
      textbuchform.Show;
    if LReg.ReadWriteBool('Showing Cuelist', false) then
      Cuelistform.Show;
    if LReg.ReadWriteBool('Showing Timecodeplayer', false) then
      Timecodeplayerform.Show;
    if LReg.ReadWriteBool('Showing Kanaluebersicht', false) then
      Kanaluebersichtform.Show;
    if LReg.ReadWriteBool('Showing Szenenverwaltung', false) then
      szenenverwaltung_formarray[0].Show;
    if LReg.ReadWriteBool('Showing Beattool', false) then
      beatform.Show;
    if LReg.ReadWriteBool('Showing Master', false) then
      masterform.Show;
    if LReg.ReadWriteBool('Showing Faderpanel', true) then
      faderpanelform.Show;
    if LReg.ReadWriteBool('Showing Touchscreen', false) then
      touchscreenform.Show;
    if LReg.ReadWriteBool('Showing DynGUI', true) then
      dynguiform.Show;
    if LReg.ReadWriteBool('Showing PartyModul', false) then
      pmmform.Show;
    if LReg.ReadWriteBool('Showing NodeControl', false) then
      nodecontrolform.Show;
    LReg.CloseKey;
  end;
  LReg.Free;

  LReg := TPCDRegistry.Create;
  if LReg.OpenRegKey('') then
  begin
    if LReg.ReadWriteBool('Sidebar visible', true) then
      sidebarform.show;
    if LReg.ReadWriteBool('Powercontrol visible', true) then
      leistungssteuerungform2.show;
    if LReg.ReadWriteBool('SelectionSidebar visible', true) then
      sidebarselectform.show;
    LReg.CloseKey;
  end;
  LReg.Free;

  debuglistbox.Items.SaveToFile(userdirectory+'\PC_DIMMER.log');
  SplashProgress(1, 79, 100);
  SplashCaptioninfo(_('DDF Bilder laden...'));
  SplashAddText(_('DDF Bilder laden...'));
  RefreshSplashText;

  LoadDDFPictures;

  SplashProgress(1, 80, 100);
  SplashCaptioninfo(_('Leeres Projekt erzeugen...'));
  NewProject(true);

  debuglistbox.Items.SaveToFile(userdirectory+'\PC_DIMMER.log');
  SplashProgress(1, 85, 100);
  SplashCaptioninfo(_('Dateien öffnen...'));
  SplashAddText('');
  RefreshSplashText;

  text1:='';
  DebugAdd('FILE: Searching for files to load...');
  for i:=1 to paramcount do
    text1:=text1+paramstr(i)+' | ';
  if text1<>'' then
    DebugAdd('FILE: '+text1)
  else
    DebugAddToLine(' - No Files found');

  // Versuche Dateien zu laden
  for i:=1 to paramcount do
  begin
    if length(paramstr(i))>=8 then
    begin
      SplashCaptioninfo(_('Dateien öffnen...')+ExtractFileName(paramstr(i)));
      SplashAddText(_('Lade Datei...')+ExtractFileName(paramstr(i)));
      DebugAdd('FILE: Loading PC_DIMMER-File: '+paramstr(i));

      if (paramstr(i)<>'/nosplash') or (paramstr(i)<>'/sp1') or (paramstr(i)<>'/sp2') or (paramstr(i)<>'/debug') or
        (paramstr(i)<>'/noaccu') or (paramstr(i)<>'/noproject') or (paramstr(i)<>'/minimized') or (paramstr(i)<>'/restorelastvalues') or
        (paramstr(i)<>'/starttimer') or (paramstr(i)<>'/loadfastsave') then
        OpenPCDIMMERFile(paramstr(i));
    end;
  end;

  // Werte Parameterschalter aus
  for i:=1 to paramcount do
  begin
    // Falls Skripttimerdatei gestartet werden soll
    if ((paramstr(i)='/starttimer') and (schedulerform.skripttimer_listbox.Items.Count>0)) then
    begin
      SplashAddText(_('Starte Skripttimer...'));
      schedulerform.skripttimer_start.Click;
    end;
    if paramstr(i)='/loadfastsave' then
    begin
      fastsaved:=true;
      SplashCaptioninfo(_('Dateien öffnen...Projekt'));
      SplashAddText(_('Lade Projekt...'));
      DebugAdd('FILE: Loading Projectfile: '+paramstr(i));
      openproject('', true);
    end;
  end;

  if LastSessionWasCorrupt then
  begin
    SplashCaptioninfo(_('Projektwiederherstellung...'));
    if FileExists(userdirectory+'Autobackup.pcdbkup') then
    begin
      if MessageDlg(_('Anscheinend wurde der PC_DIMMER beim letzten Mal nicht richtig beendet.'+#13#10#10+'Soll die letzte automatische Backupdatei wiederhergestellt werden (das letzte, nur schnellgespeicherte Projekt im Projektverzeichnis wird dabei überschrieben)?'), mtWarning, [mbYes, mbNo], 0)=mrYes then
      begin
        copyfile(PChar(userdirectory+'Autobackup.pcdbkup'),PChar(userdirectory+'ProjectTemp\Projekt'),true);
        OpenProject('',true);
      end;
    end;
  end;

  SplashProgress(1, 95, 100);
  SplashCaptioninfo(_('Timer aktivieren...'));
  DebugAdd('INIT: Activating timers...');
  RefreshSplashText;

  Uhrzeit_Timer.enabled:=true;
  Autobackuptimer.Enabled:=true;
  AkkuTimer.Enabled:=true;
  Timer1.enabled:=true;
  Optotimer.enabled:=true;
  ShortCutChecker.Enabled:=true;
  grafischebuehnenansicht.RefreshTimer.enabled:=true;
  grafischebuehnenansicht.dorefresh:=true;
  MainformScreenRefreshTimer.Enabled:=true;
  ElgatoStreamDeckForm.ElgatoStreamDeckTimer.Enabled:=true;
  ElgatoStreamDeckForm.ElgatoStreamDeckDisplayTimer.Enabled:=true;

  SplashProgress(1, 96, 100);
  SplashCaptioninfo(_('Abschließende Arbeiten'));
  RefreshSplashText;

  // OpenHistoryMenü aktualisieren
  dxBarApplicationMenu1.ExtraPane.Items.Clear;
  for i:=1 to 5 do
  begin
    TdxBarButton(FindComponent('openhistory'+inttostr(i)+'ribbon')).Caption:=ExtractFileName(data.openhistory[i-1]);
    if not (data.openhistory[i-1]='') then
    begin
      TdxBarButton(FindComponent('openhistory'+inttostr(i)+'ribbon')).Visible:=ivAlways;
      historyribbonitem:=dxBarApplicationMenu1.ExtraPane.Items.Add;
      historyribbonitem.DisplayText:=ExtractFileName(data.openhistory[i-1]);
      historyribbonitem.Data:=i;
    end;
  end;

  SplashProgress(1, 97, 100);
  SplashCaptioninfo(_('Oberfläche aktualisieren...'));
  RefreshSplashText;

  ScriptInterpreter.OnGetValue:=kontrollpanel.ScriptInterpreterGetValue;

  if not (LastSessionWasCorrupt or RestoreLastValues or startupwitholdscene) then
  begin
    DebugAdd('INIT: Initializing devices...');

    SplashProgress(1, 98, 100);
    SplashCaptioninfo(_('Geräte initialisieren...'));
    RefreshSplashText;
    // Initialisierungsfunktion ausführen
    for i:=0 to length(devices)-1 do
    begin
      for j:=0 to length(geraetesteuerung.DevicePrototyp)-1 do
      begin
        if devices[i].DeviceName=geraetesteuerung.deviceprototyp[j].DeviceName then
        begin
          XML.Xml.LoadFromFile(mainform.pcdimmerdirectory+'\Devices\'+geraetesteuerung.deviceprototyp[j].ddffilename);
          for k:=0 to XML.Xml.Root.Items.Count-1 do
          begin // <device>
            if XML.XML.Root.Items[k].Name='initvalues' then
            begin
              for l:=0 to Devices[i].MaxChan-1 do
              begin
                if XML.XML.Root.Items[k].Properties.IntValue(inttostr(l))>-1 then
                  senddata(Devices[i].startaddress+l,maxres-XML.XML.Root.Items[k].Properties.IntValue(inttostr(l)),maxres-XML.XML.Root.Items[k].Properties.IntValue(inttostr(l)),0);
                if XML.XML.Root.Items[k].Properties.IntValue('ch'+inttostr(l))>-1 then
                  senddata(Devices[i].startaddress+l,maxres-XML.XML.Root.Items[k].Properties.IntValue('ch'+inttostr(l)),maxres-XML.XML.Root.Items[k].Properties.IntValue('ch'+inttostr(l)),0);
              end;
              break;
            end;
          end;
          break;
        end;
      end;
    end;
  end;

  DebugAdd('INIT: Activating beat source...');
  MidiCallbackTimer.Enabled:=true;
  SplashProgress(1, 99, 100);
  SplashCaptioninfo(_('Beatquelle setzen...'));
  beatform.temposourcebox.itemindex:=lastbeatsource;
  beatform.temposourceboxChange(beatform.temposourcebox);

  Scrollbar1.Min:=0;
  if (mainform.lastchan div (mainform.paintbox1.Width div ChannelWidth))-1>0 then
    Scrollbar1.Max:=(mainform.lastchan div (mainform.paintbox1.Width div ChannelWidth))-1;

  SplashProgress(1, 100, 100);
  SplashCaptioninfo(_('Fertig.'));
  RefreshSplashText;

  // Splashscreen von Timer löschen lassen
  DebugAdd('INIT: Removing splashscreen...');
  case splashscreenvalue of
    0:
    begin
      // kein Splashscreen
    end;
    1:
    begin
      fadesplash:=true;
    end;
    2:
    begin
      splashscreen2.close;
      splashscreen2.Release;
      splashscreen2:=nil;
    end;
  end;

  DebugAdd('INIT: Starting timers...');
  
  if smallwindowstyle then
  begin
    mainform.ClientHeight:=dxRibbon1.Height+dxRibbonStatusBar1.Height+mainpanel.Height;
    mainform.Top:=0;
    mainform.Width:=Screen.WorkAreaWidth;
    mainform.Left:=Screen.WorkAreaLeft;

    grafischebuehnenansicht.RefreshTimer.enabled:=grafischebuehnenansicht.Showing;
    kontrollpanel.RefreshTimer.Enabled:=kontrollpanel.Showing;
    RefreshMainformScreen:=true;
//      MeasureKernelLaufzeit:=true;

    Panel1.Visible:=false;
    mainpanel.Visible:=true;
  end else
  begin
    mainform.ClientHeight:=680;
    mainform.WindowState:=wsMaximized;

{//disabled
      if DimmerkernelQueueForm=nil then
        MeasureKernelLaufzeit:=false
      else
        MeasureKernelLaufzeit:=DimmerkernelQueueForm.Showing;
}

    Panel1.Visible:=true;
    mainpanel.Visible:=false;
    PageControl1Change(nil);
  end;

  startingup:=false;
  BeginValueBackups:=true;

  if showtipofday then
  begin
    if tippoftheday=nil then
      tippoftheday:=Ttippoftheday.Create(tippoftheday);

    tippoftheday.Show;
    tippoftheday.BringToFront;
  end;

  DebugAdd('INIT: Login user ' + StartupUser + '...');
  
  // Login as set StartupUser
  if StartupUser<>'' then
  begin
    for i:=0 to length(UserAccounts)-1 do
    begin
      if UserAccounts[i].Name=StartupUser then
      begin
        ChangeUser(false, UserAccounts[i].Name, UserAccounts[i].AccessLevel);
        break;
      end;
    end;
  end;

  StartupFinished:=true;

  DebugAdd('----------------------------------------------------------------------------', false);
  DebugAdd('INIT: Starting up was successful, now showing the desktop...', false);
  DebugAdd('', true, false);
end;

procedure Tmainform.startmidiin(Sender: TObject);
var
  // MIDI-Setup
  i:integer;
 	testDeviceID: Word;
	thisControl: TMidiInput;
  tempstring,devicestring:string;
  productnamelist:array of string;
begin
  MidiInput1.Stop;
  MidiInput1.Close;

  // zunächst alle bisherigen MidiIns versuchen zu beenden
  for i:=0 to length(MidiInControls)-1 do
  begin
    thisControl:=MidiInControls[i];
    thiscontrol.Stop;
    thiscontrol.Close;
    thiscontrol.Free;
  end;

  // alle Listen säubern
  setlength(MidiInControls,0);
  setlength(MidiInTimeCode,0);
  midieventfrm.midiindevicelist.Items.clear;
  setlength(productnamelist,0);

  // aktuelle Geräte auflisten
  if midiInGetNumDevs > 0 then
  begin
    for testDeviceID := 0 To (midiInGetNumDevs-1) do
    begin
      thisControl := TMidiInput.Create(Self);
      thisControl.DeviceID := testDeviceID;
      thisControl.OnMidiInput := mainform.MIDIInput1MidiInput;
      setlength(MidiInControls,length(MidiInControls)+1);
      setlength(MidiInTimecode,length(MidiInTimecode)+1);
      MidiInControls[length(MidiInControls)-1]:=thisControl;
      midieventfrm.midiindevicelist.Items.Add(inttostr(thisControl.DeviceID+1)+': '+thisControl.ProductName);

      setlength(productnamelist,length(productnamelist)+1);
      productnamelist[length(productnamelist)-1]:=thisControl.ProductName;
    end;

    // zuletzt genutzte MIDI-Geräte finden und aktivieren
    tempstring:=lastmidiinputdevices;
    repeat
      if length(tempstring)>0 then
      begin
        if pos(',',tempstring)>0 then
        begin
          devicestring:=copy(tempstring, 0, pos(',',tempstring)-1);
          tempstring:=copy(tempstring, pos(',',tempstring)+1,length(tempstring));
        end else
        begin
          devicestring:=tempstring;
          tempstring:='';
        end;

        for i := 0 To (midiInGetNumDevs-1) do
        begin
          if devicestring=productnamelist[i] then
          begin
            midieventfrm.midiindevicelist.Checked[i]:=true;
            break;
          end;
        end;
      end;
    until length(tempstring)=0;
  end;
  setlength(MidiInTimecode,length(MidiInTimecode)+1);

  MIDIActiveRibbonBox.Down:=true;
end;

procedure Tmainform.startmidiout(Sender: TObject);
var
  i:integer;
 	testDeviceID: Word;
	thisControl: TMidiOutput;
  tempstring,devicestring:string;
  productnamelist:array of string;
begin
  MidiOutput1.Close;

  // zunächst alle bisherigen MidiIns versuchen zu beenden
  for i:=0 to length(MidiOutControls)-1 do
  begin
    thisControl:=MidiOutControls[i];
    thiscontrol.Close;
    thiscontrol.Free;
  end;

  // alle Listen säubern
  setlength(MidiOutControls,0);
  midieventfrm.midioutdevicelist.Items.clear;
  setlength(productnamelist,0);

  // aktuelle Geräte auflisten
  if midiOutGetNumDevs > 0 then
  begin
    for testDeviceID := 0 To (midiOutGetNumDevs-1) do
    begin
      thisControl := TMidiOutput.Create(Self);
      thisControl.DeviceID := testDeviceID;
      setlength(MidiOutControls,length(MidiOutControls)+1);
      MidiOutControls[length(MidiOutControls)-1]:=thisControl;
      midieventfrm.midioutdevicelist.Items.Add(inttostr(thisControl.DeviceID+1)+': '+thisControl.ProductName);

      setlength(productnamelist,length(productnamelist)+1);
      productnamelist[length(productnamelist)-1]:=thisControl.ProductName;
    end;

    // zuletzt genutzte MIDI-Geräte finden und aktivieren
    tempstring:=lastmidioutputdevices;
    repeat
      if length(tempstring)>0 then
      begin
        if pos(',',tempstring)>0 then
        begin
          devicestring:=copy(tempstring, 0, pos(',',tempstring)-1);
          tempstring:=copy(tempstring, pos(',',tempstring)+1,length(tempstring));
        end else
        begin
          devicestring:=tempstring;
          tempstring:='';
        end;

        for i := 0 To (midiOutGetNumDevs-1) do
        begin
          if devicestring=productnamelist[i] then
          begin
            midieventfrm.midioutdevicelist.Checked[i]:=true;
            break;
          end;
        end;
      end;
    until length(tempstring)=0;
  end;
end;

procedure Tmainform.stopmidi(Sender: TObject);
var
	i: Integer;
begin
  if (length(MidiInControls)>0) then
	begin
    for i := 0 to length(MidiInControls)-1 do
    begin
      TMidiInput(MidiInControls[i]).Stop;
      TMidiInput(MidiInControls[i]).Close;
      TMidiInput(MidiInControls[i]).Free;
    end;
    MIDIActiveRibbonBox.Down:=false;
  end;

  if (length(MidiOutControls)>0) then
	begin
    for i := 0 to length(MidiOutControls)-1 do
    begin
      TMidiOutput(MidiOutControls[i]).Close;
      TMidiOutput(MidiOutControls[i]).Free;
    end;
  end;
end;

procedure TMainform.refreshmidi;
var
  i:integer;
begin
    if length(MidiEventArray)+1<2 then
      MIDIEVENTfrm.MIDIGrid.RowCount:=2
    else
    	MIDIEVENTfrm.MIDIGrid.RowCount:=length(MidiEventArray)+1;

  	MIDIEVENTfrm.midigrid.Cells[0,1]:='';
    MIDIEVENTfrm.midigrid.cells[1,1]:='';
    MIDIEVENTfrm.midigrid.cells[2,1]:='';
    MIDIEVENTfrm.midigrid.cells[3,1]:='';
    MIDIEVENTfrm.midigrid.cells[4,1]:='';
    MIDIEVENTfrm.midigrid.cells[5,1]:='';
    MIDIEVENTfrm.midigrid.cells[6,1]:='';
    MIDIEVENTfrm.midigrid.cells[7,1]:='';
    MIDIEVENTfrm.midigrid.cells[8,1]:='';
    MIDIEVENTfrm.midigrid.cells[9,1]:='';
    MIDIEVENTfrm.midigrid.cells[10,1]:='';

    if length(MidiEventArray)>0 then
    begin
      MIDIEVENTfrm.editmidievent.Enabled:=true;
      MIDIEVENTfrm.deletemidievent.Enabled:=true;
    end else
    begin
      MIDIEVENTfrm.editmidievent.Enabled:=false;
      MIDIEVENTfrm.deletemidievent.Enabled:=false;
    end;

    if length(MidiEventArray)>0 then
    for i:=1 to MIDIEVENTfrm.MIDIGrid.rowcount do
    begin
      MIDIEVENTfrm.refreshList(i);
    end;

    MIDIEVENTfrm.SendValueToSelCountEdit.Value:=length(SendValueOfSelectedDevicesToMidi);

    if length(SendValueOfSelectedDevicesToMidi)>0 then
    begin
      MIDIEVENTfrm.SendValueToSelMSGEdit.Text:=inttostr(SendValueOfSelectedDevicesToMidi[0].MSG);
      MIDIEVENTfrm.SendValueToSelData1Edit.Text:=inttostr(SendValueOfSelectedDevicesToMidi[0].Data1);
      MIDIEVENTfrm.SendValueToSelData2Radiobox.Checked:=SendValueOfSelectedDevicesToMidi[0].UseData2;
    end else
    begin
      MIDIEVENTfrm.SendValueToSelMSGEdit.Text:='0';
      MIDIEVENTfrm.SendValueToSelData1Edit.Text:='0';
      MIDIEVENTfrm.SendValueToSelData2Radiobox.Checked:=true;
    end;
end;

procedure TMainform.refreshdatain;
var
  i:integer;
begin
  if length(DataInEventArray)+1<2 then
    DataInEventfrm.DataGrid.RowCount:=2
  else
    DataInEventfrm.DataGrid.RowCount:=length(DataInEventArray)+1;

  DataInEventfrm.DataGrid.Cells[0,1]:='';
  DataInEventfrm.DataGrid.cells[1,1]:='';
  DataInEventfrm.DataGrid.cells[2,1]:='';
  DataInEventfrm.DataGrid.cells[3,1]:='';
  DataInEventfrm.DataGrid.cells[4,1]:='';
  DataInEventfrm.DataGrid.cells[5,1]:='';
  DataInEventfrm.DataGrid.cells[6,1]:='';
  DataInEventfrm.DataGrid.cells[7,1]:='';
  DataInEventfrm.DataGrid.cells[8,1]:='';

  if length(DataInEventArray)>0 then
  begin
    DataInEventfrm.editDataInEvent.Enabled:=true;
    DataInEventfrm.deleteDataInEvent.Enabled:=true;
  end else
  begin
    DataInEventfrm.editDataInEvent.Enabled:=false;
    DataInEventfrm.deleteDataInEvent.Enabled:=false;
  end;

  if length(DataInEventArray)>0 then
  for i:=1 to DataInEventfrm.DataGrid.rowcount-1 do
  begin
    DataInEventfrm.refreshList(i);
  end;
end;

procedure TMainform.Szenenverwaltung1Click(Sender: TObject);
begin
  if not UserAccessGranted(1) then exit;

  szenenverwaltung_formarray[0].Show;
end;

procedure TMainform.Figureneditor1Click(Sender: TObject);
begin
  figureneditorform.LoadFigure:=-1;
  figureneditorform.ShowModal;
end;

procedure Tmainform.StartEinfacheSzene(ID: TGUID; NoFadetime, NoDelay:boolean; Fadetime:integer);
var
  i, j:integer;
begin
  for i:=0 to length(EinfacheSzenen)-1 do
  begin
    if IsEqualGUID(ID,EinfacheSzenen[i].ID) then
    begin
      for j:=1 to lastchan do
      begin
        channelvalue_temp[j]:=-1;
        if EinfacheSzenen[i].kanalaktiv[j] then
        begin
          channelvalue_temp[j]:=channel_value[j];
          if EinfacheSzenen[i].einblendzeit=0 then
            data.ch[j]:=maxres-EinfacheSzenen[i].kanal[j];
          if NoFadetime then
          begin
            SendData(j,data.ch[j], maxres-EinfacheSzenen[i].kanal[j], 0);
          end else
          begin
            if Fadetime=-1 then
              SendData(j,data.ch[j], maxres-EinfacheSzenen[i].kanal[j], EinfacheSzenen[i].einblendzeit)
            else
            begin
              if Fadetime<0 then
                Fadetime:=Random(abs(Fadetime));
              SendData(j,data.ch[j], maxres-EinfacheSzenen[i].kanal[j], Fadetime);
            end;
          end;
        end;
      end;
      break;
    end;
  end;
end;

procedure Tmainform.RestoreLastScene(fadezeit:integer);
var
  j:integer;
begin
  for j:=1 to lastchan do
  begin
    if channelvalue_temp[j]>-1 then
    begin
      data.ch[j]:=maxres-channelvalue_temp[j];
      SendData(j,maxres-channelvalue_temp[j], maxres-channelvalue_temp[j], 0);
    end;
  end;
end;

procedure Tmainform.StopEinfacheSzene(ID: TGUID);
var
  i, j:integer;
begin
  for i:=0 to length(EinfacheSzenen)-1 do
  begin
    if IsEqualGUID(ID,EinfacheSzenen[i].ID) then
    begin
      for j:=1 to lastchan do
      begin
        if EinfacheSzenen[i].kanalaktiv[j] then
        begin
          data.ch[j]:=maxres-channel_value[j];
          SendData(j,maxres-channel_value[j], maxres-channel_value[j], 0);
        end;
      end;
      break;
    end;
  end;
end;

procedure Tmainform.StartAudioSzene(ID: TGUID);
var
  i,j,k:integer;
  chaninfo:BASS_ChannelInfo;
begin
  for i:=0 to length(AudioSzenen)-1 do
  begin
    if IsEqualGUID(ID,AudioSzenen[i].ID) then
    begin
      if not (BASS_ChannelIsActive(AudioszenenCHAN[i].MixerHandle) = BASS_ACTIVE_PLAYING) then
      begin
        begin
          if lowercase(copy(Audioszenen[i].Datei, length(Audioszenen[i].Datei)-2, length(Audioszenen[i].Datei)))='ac3' then
            AudioszenenCHAN[i].StandardHandle:=BASS_AC3_StreamCreateFile(FALSE, PChar(SearchFileBeneathProject(Audioszenen[i].Datei)), 0, 0, BASS_STREAM_DECODE)
          else
            AudioszenenCHAN[i].StandardHandle:=BASS_StreamCreateFile(FALSE, PChar(SearchFileBeneathProject(Audioszenen[i].Datei)), 0, 0, BASS_STREAM_DECODE);
          AudioszenenCHAN[i].MixerHandle:=BASS_Mixer_StreamCreate(BASSDLLFREQUENZ, 8, BASS_MIXER_END); // 8ch Mixerkanal erstellen
          BASS_Mixer_StreamAddChannel(AudioszenenCHAN[i].MixerHandle, AudioszenenCHAN[i].StandardHandle, BASS_MIXER_MATRIX); // Audiokanal dem Mixerkanal zuweisen

          for j:=0 to 7 do
          begin
            Audioszenen[i].matrix1[j]:=Audioszenen[i].matrix[j][0];
            for k:=0 to 1 do
              Audioszenen[i].matrix2[j][k]:=Audioszenen[i].matrix[j][k];
            for k:=0 to 3 do
              Audioszenen[i].matrix4[j][k]:=Audioszenen[i].matrix[j][k];
            for k:=0 to 5 do
              Audioszenen[i].matrix6[j][k]:=Audioszenen[i].matrix[j][k];
          end;

          BASS_ChannelGetInfo(AudioszenenCHAN[i].StandardHandle, chaninfo);
          case chaninfo.chans of
            1: BASS_Mixer_ChannelSetMatrix(AudioszenenCHAN[i].StandardHandle, @Audioszenen[i].matrix1);
            2: BASS_Mixer_ChannelSetMatrix(AudioszenenCHAN[i].StandardHandle, @Audioszenen[i].matrix2);
            4: BASS_Mixer_ChannelSetMatrix(AudioszenenCHAN[i].StandardHandle, @Audioszenen[i].matrix4);
            6: BASS_Mixer_ChannelSetMatrix(AudioszenenCHAN[i].StandardHandle, @Audioszenen[i].matrix6);
            8: BASS_Mixer_ChannelSetMatrix(AudioszenenCHAN[i].StandardHandle, @Audioszenen[i].matrix);
          end;

          // Einblenden eintragen
          new(pDimmerChannel);
          pDimmerChannel.Start:=true;
          pDimmerChannel.ChannelType:=1;
          pDimmerChannel.Index:=i;
          if Audioszenen[i].FadeinTime>0 then
            pDimmerChannel.channel_steps:=round((Audioszenen[i].Volume*65535)/Audioszenen[i].FadeinTime)
          else
            pDimmerChannel.channel_steps:=0;
          pDimmerChannel.channel_delay:=0;
          pDimmerChannel.channel_endvalue := round(Audioszenen[i].Volume*65535);
          pDimmerChannel.channel_fadetime := (Audioszenen[i].FadeinTime);
          pDimmerChannel.DeleteChannel:=false;
          pDimmerChannel.DontSetValues:=false;
          pDimmerChannel.IsDelayedChan:=false;
          pDimmerChannel.FadeDirection:=0;

          setlength(DimmerKernelChannelArray,length(DimmerKernelChannelArray)+1);
          DimmerKernelChannelArray[length(DimmerKernelChannelArray)-1]:=pDimmerChannel;
        end;
      end;
      break;
    end;
  end;

//  if audiomanagerform.Showing then
//    audiomanagerform.Timer1Timer(nil);
  audiomanagerform.Show;
end;

procedure Tmainform.StopAudioSzene(ID: TGUID);
var
  i:integer;
begin
  for i:=0 to length(AudioSzenen)-1 do
  begin
    if IsEqualGUID(ID,AudioSzenen[i].ID) then
    begin
      new(pDimmerChannel);
      pDimmerChannel.Start:=false;
      pDimmerChannel.ChannelType:=1;
      pDimmerChannel.Index:=i;
      if Audioszenen[i].FadeoutTime>0 then
        pDimmerChannel.channel_steps:=round((Audioszenen[i].Volume*65535)/Audioszenen[i].FadeoutTime)
      else
        pDimmerChannel.channel_steps:=0;
      pDimmerChannel.channel_delay:=0;
      pDimmerChannel.channel_endvalue := 0;
      pDimmerChannel.channel_fadetime := (Audioszenen[i].FadeoutTime);
      pDimmerChannel.DeleteChannel:=false;
      pDimmerChannel.DontSetValues:=false;
      pDimmerChannel.IsDelayedChan:=false;
      pDimmerChannel.FadeDirection:=0;

      setlength(DimmerKernelChannelArray,length(DimmerKernelChannelArray)+1);
      DimmerKernelChannelArray[length(DimmerKernelChannelArray)-1]:=pDimmerChannel;
      break;
    end;
  end;

  if audiomanagerform.Showing then
    audiomanagerform.Timer1Timer(nil);
end;

procedure Tmainform.StartBewegungsSzene(ID: TGUID);
var
  i, j, k, m, figur:integer;
  tempdelay:cardinal;
begin
  for j:=0 to length(Bewegungsszenen)-1 do
  begin
    if IsEqualGUID(Bewegungsszenen[j].ID,ID) then
    begin
      BewegungsszenenAktiv[j].Aktiv:=false;
      // j = aktuelle Bewegungsszene

      // Welche Figur wird verwendet?
      figur:=-1;
      for m:=0 to length(figuren)-1 do
        if IsEqualGUID(Bewegungsszenen[j].figur,figuren[m].ID) then
        begin
          figur:=m;
          break;
        end;

      for i:=0 to length(Bewegungsszenen[j].Devices)-1 do
      begin
        if geraetesteuerung.GetGroupPositionInGroupArray(Bewegungsszenen[j].Devices[i].ID)>=0 then
        begin
          for k:=0 to length(Bewegungsszenen[j].Devices[i].DeviceChannel)-1 do
          if Bewegungsszenen[j].Devices[i].DeviceChannel[k].ChanActive then
          begin
            BewegungsszenenAktiv[j].Zeit[i][k]:=0;
            BewegungsszenenAktiv[j].Repeats[i][k]:=0;
//            if not Bewegungsszenen[j].startpositionrelativ then
              BewegungsszenenAktiv[j].Position[i][k]:=Bewegungsszenen[j].Devices[i].DeviceChannel[k].offset;

            // Dimmzeit zwischen aktuellem Punkt und nächstem Punkt berechnen
            if BewegungsszenenAktiv[j].Position[i][k]+1 > length(figuren[figur].posx)-1 then
              BewegungsszenenZeit[j][i][k]:=round(bewegungsszeneneditorform.ZeitzwischenzweiPunkten(bewegungsszeneneditorform.GetX(i,k,BewegungsszenenAktiv[j].position[i][k],Bewegungsszenen[j].ID),bewegungsszeneneditorform.GetY(i,k,BewegungsszenenAktiv[j].position[i][k],Bewegungsszenen[j].ID),bewegungsszeneneditorform.GetX(i,k,0,Bewegungsszenen[j].ID),bewegungsszeneneditorform.GetY(i,k,0,Bewegungsszenen[j].ID),length(mainform.Figuren[figur].posx),Bewegungsszenen[j].ID))
            else
              BewegungsszenenZeit[j][i][k]:=round(bewegungsszeneneditorform.ZeitzwischenzweiPunkten(bewegungsszeneneditorform.GetX(i,k,BewegungsszenenAktiv[j].position[i][k],Bewegungsszenen[j].ID),bewegungsszeneneditorform.GetY(i,k,BewegungsszenenAktiv[j].position[i][k],Bewegungsszenen[j].ID),bewegungsszeneneditorform.GetX(i,k,BewegungsszenenAktiv[j].position[i][k]+1,Bewegungsszenen[j].ID),bewegungsszeneneditorform.GetY(i,k,BewegungsszenenAktiv[j].position[i][k]+1,Bewegungsszenen[j].ID),length(Figuren[figur].posx),Bewegungsszenen[j].ID));

            // Kanalwerte ausgeben
            // Delay-Zeit prüfen
            if Bewegungsszenen[j].Devices[i].DeviceChannel[k].delay<0 then
              tempdelay:=mainform.DeviceGroups[geraetesteuerung.GetGroupPositionInGroupArray(Bewegungsszenen[j].Devices[i].ID)].Delay
            else
              tempdelay:=Bewegungsszenen[j].Devices[i].DeviceChannel[k].delay;

            if (Bewegungsszenen[j].Devices[i].DeviceChannel[k].y) and (not Bewegungsszenen[j].Devices[i].DeviceChannel[k].x) then
            begin
              if not Bewegungsszenen[j].Devices[i].DeviceChannel[j].mixXY then
                geraetesteuerung.set_group(Bewegungsszenen[j].Devices[i].ID, mainform.DeviceChannelNames[k], (bewegungsszeneneditorform.GetY(i,k,BewegungsszenenAktiv[j].Position[i][k],Bewegungsszenen[j].ID) * maxres div 400), (bewegungsszeneneditorform.GetY(i,k,BewegungsszenenAktiv[j].Position[i][k],Bewegungsszenen[j].ID) * maxres div 400),500,tempdelay)
              else
                geraetesteuerung.set_group(Bewegungsszenen[j].Devices[i].ID, mainform.DeviceChannelNames[k], (bewegungsszeneneditorform.GetX(i,k,BewegungsszenenAktiv[j].Position[i][k],Bewegungsszenen[j].ID) * maxres div 400), (bewegungsszeneneditorform.GetX(i,k,BewegungsszenenAktiv[j].Position[i][k],Bewegungsszenen[j].ID) * maxres div 400),500,tempdelay);
            end else if (Bewegungsszenen[j].Devices[i].DeviceChannel[k].x) and (not Bewegungsszenen[j].Devices[i].DeviceChannel[k].y) then
            begin
              if not Bewegungsszenen[j].Devices[i].DeviceChannel[j].mixXY then
                geraetesteuerung.set_group(Bewegungsszenen[j].Devices[i].ID, mainform.DeviceChannelNames[k], (bewegungsszeneneditorform.GetX(i,k,BewegungsszenenAktiv[j].Position[i][k],Bewegungsszenen[j].ID) * maxres div 400), (bewegungsszeneneditorform.GetX(i,k,BewegungsszenenAktiv[j].Position[i][k],Bewegungsszenen[j].ID) * maxres div 400),500,tempdelay)
              else
                geraetesteuerung.set_group(Bewegungsszenen[j].Devices[i].ID, mainform.DeviceChannelNames[k], (bewegungsszeneneditorform.GetY(i,k,BewegungsszenenAktiv[j].Position[i][k],Bewegungsszenen[j].ID) * maxres div 400), (bewegungsszeneneditorform.GetY(i,k,BewegungsszenenAktiv[j].Position[i][k],Bewegungsszenen[j].ID) * maxres div 400),500,tempdelay);
            end else if (Bewegungsszenen[j].Devices[i].DeviceChannel[k].x) and (mainform.Bewegungsszenen[j].Devices[i].DeviceChannel[k].y) then
            begin
            end;

            BewegungsszenenAktiv[j].Zeit[i][k]:=Bewegungsszenen[j].dauer;
          end;
        end else if geraetesteuerung.GetDevicePositionInDeviceArray(@Bewegungsszenen[j].Devices[i].ID)>=0 then
        begin
          for k:=0 to length(Bewegungsszenen[j].Devices[i].DeviceChannel)-1 do
          if Bewegungsszenen[j].Devices[i].DeviceChannel[k].ChanActive then
          begin
            // Ist Gerätekanal PAN/TILT?
            if Bewegungsszenen[j].startpositionrelativ then
            begin
              if uppercase(mainform.devices[geraetesteuerung.GetDevicePositionInDeviceArray(@Bewegungsszenen[j].Devices[i].ID)].kanaltyp[k])='PAN' then
              begin
                if Bewegungsszenen[j].Devices[i].DeviceChannel[k].x then
                  Bewegungsszenen[j].Devices[i].DeviceChannel[k].mittelpunktx:=round((geraetesteuerung.get_channel(Bewegungsszenen[j].Devices[i].ID, 'PAN')/255-0.5)*400)+800;
                if Bewegungsszenen[j].Devices[i].DeviceChannel[k].y then
                  Bewegungsszenen[j].Devices[i].DeviceChannel[k].mittelpunkty:=round((geraetesteuerung.get_channel(Bewegungsszenen[j].Devices[i].ID, 'PAN')/255-0.5)*400)+800;
              end else if uppercase(mainform.devices[geraetesteuerung.GetDevicePositionInDeviceArray(@Bewegungsszenen[j].Devices[i].ID)].kanaltyp[k])='TILT' then
              begin
                if Bewegungsszenen[j].Devices[i].DeviceChannel[k].x then
                  Bewegungsszenen[j].Devices[i].DeviceChannel[k].mittelpunktx:=round((geraetesteuerung.get_channel(Bewegungsszenen[j].Devices[i].ID, 'TILT')/255-0.5)*400)+800;
                if Bewegungsszenen[j].Devices[i].DeviceChannel[k].y then
                  Bewegungsszenen[j].Devices[i].DeviceChannel[k].mittelpunkty:=round((geraetesteuerung.get_channel(Bewegungsszenen[j].Devices[i].ID, 'TILT')/255-0.5)*400)+800;
              end;
            end;

            BewegungsszenenAktiv[j].Zeit[i][k]:=0;
//            if not Bewegungsszenen[j].startpositionrelativ then
              BewegungsszenenAktiv[j].Position[i][k]:=Bewegungsszenen[j].Devices[i].DeviceChannel[k].offset;

            // Dimmzeit zwischen aktuellem Punkt und nächstem Punkt berechnen
            if BewegungsszenenAktiv[j].Position[i][k]+1 > length(figuren[figur].posx)-1 then
              BewegungsszenenZeit[j][i][k]:=round(bewegungsszeneneditorform.ZeitzwischenzweiPunkten(bewegungsszeneneditorform.GetX(i,k,BewegungsszenenAktiv[j].position[i][k],Bewegungsszenen[j].ID),bewegungsszeneneditorform.GetY(i,k,BewegungsszenenAktiv[j].position[i][k],Bewegungsszenen[j].ID),bewegungsszeneneditorform.GetX(i,k,0,Bewegungsszenen[j].ID),bewegungsszeneneditorform.GetY(i,k,0,Bewegungsszenen[j].ID),length(mainform.Figuren[figur].posx),Bewegungsszenen[j].ID))
            else
              BewegungsszenenZeit[j][i][k]:=round(bewegungsszeneneditorform.ZeitzwischenzweiPunkten(bewegungsszeneneditorform.GetX(i,k,BewegungsszenenAktiv[j].position[i][k],Bewegungsszenen[j].ID),bewegungsszeneneditorform.GetY(i,k,BewegungsszenenAktiv[j].position[i][k],Bewegungsszenen[j].ID),bewegungsszeneneditorform.GetX(i,k,BewegungsszenenAktiv[j].position[i][k]+1,Bewegungsszenen[j].ID),bewegungsszeneneditorform.GetY(i,k,BewegungsszenenAktiv[j].position[i][k]+1,Bewegungsszenen[j].ID),length(Figuren[figur].posx),Bewegungsszenen[j].ID));

            // Kanalwerte ausgeben
            // Delay-Zeit prüfen
            if Bewegungsszenen[j].Devices[i].DeviceChannel[k].delay<0 then
              tempdelay:=0
            else
              tempdelay:=Bewegungsszenen[j].Devices[i].DeviceChannel[k].delay;

            if (Bewegungsszenen[j].Devices[i].DeviceChannel[k].y) and (not Bewegungsszenen[j].Devices[i].DeviceChannel[k].x) then
            begin
              if not Bewegungsszenen[j].Devices[i].DeviceChannel[j].mixXY then
                geraetesteuerung.set_channel(Bewegungsszenen[j].Devices[i].ID, mainform.devices[geraetesteuerung.GetDevicePositionInDeviceArray(@Bewegungsszenen[j].Devices[i].ID)].kanaltyp[k], (bewegungsszeneneditorform.GetY(i,k,BewegungsszenenAktiv[j].Position[i][k],Bewegungsszenen[j].ID) * maxres div 400), (bewegungsszeneneditorform.GetY(i,k,BewegungsszenenAktiv[j].Position[i][k],Bewegungsszenen[j].ID) * maxres div 400),500,tempdelay)
              else
                geraetesteuerung.set_channel(Bewegungsszenen[j].Devices[i].ID, mainform.devices[geraetesteuerung.GetDevicePositionInDeviceArray(@Bewegungsszenen[j].Devices[i].ID)].kanaltyp[k], (bewegungsszeneneditorform.GetX(i,k,BewegungsszenenAktiv[j].Position[i][k],Bewegungsszenen[j].ID) * maxres div 400), (bewegungsszeneneditorform.GetX(i,k,BewegungsszenenAktiv[j].Position[i][k],Bewegungsszenen[j].ID) * maxres div 400),500,tempdelay);
            end else if (Bewegungsszenen[j].Devices[i].DeviceChannel[k].x) and (not Bewegungsszenen[j].Devices[i].DeviceChannel[k].y) then
            begin
              if not Bewegungsszenen[j].Devices[i].DeviceChannel[j].mixXY then
                geraetesteuerung.set_channel(Bewegungsszenen[j].Devices[i].ID, mainform.devices[geraetesteuerung.GetDevicePositionInDeviceArray(@Bewegungsszenen[j].Devices[i].ID)].kanaltyp[k], (bewegungsszeneneditorform.GetX(i,k,BewegungsszenenAktiv[j].Position[i][k],Bewegungsszenen[j].ID) * maxres div 400), (bewegungsszeneneditorform.GetX(i,k,BewegungsszenenAktiv[j].Position[i][k],Bewegungsszenen[j].ID) * maxres div 400),500,tempdelay)
              else
                geraetesteuerung.set_channel(Bewegungsszenen[j].Devices[i].ID, mainform.devices[geraetesteuerung.GetDevicePositionInDeviceArray(@Bewegungsszenen[j].Devices[i].ID)].kanaltyp[k], (bewegungsszeneneditorform.GetY(i,k,BewegungsszenenAktiv[j].Position[i][k],Bewegungsszenen[j].ID) * maxres div 400), (bewegungsszeneneditorform.GetY(i,k,BewegungsszenenAktiv[j].Position[i][k],Bewegungsszenen[j].ID) * maxres div 400),500,tempdelay);
            end else if (Bewegungsszenen[j].Devices[i].DeviceChannel[k].x) and (mainform.Bewegungsszenen[j].Devices[i].DeviceChannel[k].y) then
            begin
            end;

            BewegungsszenenAktiv[j].Zeit[i][k]:=Bewegungsszenen[j].dauer;
          end;
        end;
      end;

      BewegungsszenenAktiv[j].Aktiv:=true;
      break;
    end;
  end;
end;

procedure Tmainform.StopBewegungsSzene(ID: TGUID);
var
  i,j,k:integer;
  tempdelay:cardinal;
begin
  for i:=0 to length(Bewegungsszenen)-1 do
  begin
    if IsEqualGUID(ID,Bewegungsszenen[i].ID) then
    begin
      BewegungsszenenAktiv[i].Aktiv:=false;

      for j:=0 to length(Bewegungsszenen[i].Devices)-1 do
      begin
        if geraetesteuerung.GetGroupPositionInGroupArray(Bewegungsszenen[i].Devices[j].ID)>=0 then
        begin
{
          for k:=0 to length(Bewegungsszenen[i].Devices[j].DeviceChannel)-1 do
          begin
            // Kanalwerte ausgeben
            // Delay-Zeit prüfen
            if Bewegungsszenen[i].Devices[j].DeviceChannel[k].delay<0 then
              tempdelay:=mainform.DeviceGroups[geraetesteuerung.GetGroupPositionInGroupArray(Bewegungsszenen[i].Devices[j].ID)].Delay
            else
              tempdelay:=Bewegungsszenen[i].Devices[j].DeviceChannel[k].delay;

            if (Bewegungsszenen[i].Devices[j].DeviceChannel[k].y) and (not Bewegungsszenen[i].Devices[j].DeviceChannel[k].x) then
            begin
              geraetesteuerung.set_group(Bewegungsszenen[i].Devices[j].ID, mainform.DeviceChannelNames[k], -1, -1, 0,tempdelay);
            end else if (Bewegungsszenen[i].Devices[j].DeviceChannel[k].x) and (not Bewegungsszenen[i].Devices[j].DeviceChannel[k].y) then
            begin
              geraetesteuerung.set_group(Bewegungsszenen[i].Devices[j].ID, mainform.DeviceChannelNames[k], -1, -1, 0,tempdelay);
            end else if (Bewegungsszenen[i].Devices[j].DeviceChannel[k].x) and (Bewegungsszenen[i].Devices[j].DeviceChannel[k].y) then
            if not Bewegungsszenen[i].Devices[j].DeviceChannel[k].mixXY then
            begin
            end;
          end;
}
        end else if geraetesteuerung.GetDevicePositionInDeviceArray(@Bewegungsszenen[i].Devices[j].ID)>=0 then
        begin
          for k:=0 to length(Bewegungsszenen[i].Devices[j].DeviceChannel)-1 do
          begin
            // Kanalwerte ausgeben
            // Delay-Zeit prüfen
            if Bewegungsszenen[i].Devices[j].DeviceChannel[k].delay<0 then
              tempdelay:=0
            else
              tempdelay:=Bewegungsszenen[i].Devices[j].DeviceChannel[k].delay;

            if (Bewegungsszenen[i].Devices[j].DeviceChannel[k].y) and (not Bewegungsszenen[i].Devices[j].DeviceChannel[k].x) then
            begin
              geraetesteuerung.set_channel(Bewegungsszenen[i].Devices[j].ID, mainform.devices[geraetesteuerung.GetDevicePositionInDeviceArray(@Bewegungsszenen[i].Devices[j].ID)].kanaltyp[k], geraetesteuerung.get_channel(Bewegungsszenen[i].Devices[j].ID,mainform.devices[geraetesteuerung.GetDevicePositionInDeviceArray(@Bewegungsszenen[i].Devices[j].ID)].kanaltyp[k]),geraetesteuerung.get_channel(Bewegungsszenen[i].Devices[j].ID,mainform.devices[geraetesteuerung.GetDevicePositionInDeviceArray(@Bewegungsszenen[i].Devices[j].ID)].kanaltyp[k]),0,tempdelay);
            end else if (Bewegungsszenen[i].Devices[j].DeviceChannel[k].x) and (not Bewegungsszenen[i].Devices[j].DeviceChannel[k].y) then
            begin
              geraetesteuerung.set_channel(Bewegungsszenen[i].Devices[j].ID, mainform.devices[geraetesteuerung.GetDevicePositionInDeviceArray(@Bewegungsszenen[i].Devices[j].ID)].kanaltyp[k], geraetesteuerung.get_channel(Bewegungsszenen[i].Devices[j].ID,mainform.devices[geraetesteuerung.GetDevicePositionInDeviceArray(@Bewegungsszenen[i].Devices[j].ID)].kanaltyp[k]),geraetesteuerung.get_channel(Bewegungsszenen[i].Devices[j].ID,mainform.devices[geraetesteuerung.GetDevicePositionInDeviceArray(@Bewegungsszenen[i].Devices[j].ID)].kanaltyp[k]),0,tempdelay);
            end else if (Bewegungsszenen[i].Devices[j].DeviceChannel[k].x) and (Bewegungsszenen[i].Devices[j].DeviceChannel[k].y) then
            if not Bewegungsszenen[i].Devices[j].DeviceChannel[k].mixXY then
            begin
            end;
          end;
        end;
      end;
      break;
    end;
  end;
end;

procedure Tmainform.StartBefehl(ID: TGUID);
begin
  if shutdown then exit;
  StartBefehl(ID, 255);
end;

procedure Tmainform.StartBefehl(ID: TGUID; Inputvalue: integer);
var
  i,j,k,h:integer;
  AktuellerBefehl:TBefehl2;
  Local_LastEvent:string;
begin
  if shutdown then exit;
  AktuellerBefehl.Typ:=StringToGUID('{00000000-0000-0000-0000-000000000000}');

  for i:=0 to length(Befehle2)-1 do
  begin
    if IsEqualGUID(ID,Befehle2[i].ID) then
    begin
      AktuellerBefehl.ID:=Befehle2[i].ID;
      AktuellerBefehl.Typ:=Befehle2[i].Typ;
      AktuellerBefehl.Name:=Befehle2[i].Name;
      AktuellerBefehl.Beschreibung:=Befehle2[i].Beschreibung;
      AktuellerBefehl.OnValue:=Befehle2[i].OnValue;
      AktuellerBefehl.SwitchValue:=Befehle2[i].SwitchValue;
      AktuellerBefehl.InvertSwitchValue:=Befehle2[i].InvertSwitchValue;
      AktuellerBefehl.OffValue:=Befehle2[i].OffValue;
      AktuellerBefehl.ScaleValue:=Befehle2[i].ScaleValue;
      AktuellerBefehl.RunOnProjectLoad:=Befehle2[i].RunOnProjectLoad;

      setlength(AktuellerBefehl.ArgInteger, length(Befehle2[i].ArgInteger));
      for j:=0 to length(Befehle2[i].ArgInteger)-1 do
        AktuellerBefehl.ArgInteger[j]:=Befehle2[i].ArgInteger[j];
      setlength(AktuellerBefehl.ArgString, length(Befehle2[i].ArgString));
      for j:=0 to length(Befehle2[i].ArgString)-1 do
        AktuellerBefehl.ArgString[j]:=Befehle2[i].ArgString[j];
      setlength(AktuellerBefehl.ArgGUID, length(Befehle2[i].ArgGUID));
      for j:=0 to length(Befehle2[i].ArgGUID)-1 do
        AktuellerBefehl.ArgGUID[j]:=Befehle2[i].ArgGUID[j];

      break;
    end;
  end;

  if IsEqualGUID(AktuellerBefehl.Typ, StringToGUID('{00000000-0000-0000-0000-000000000000}')) then
  for i:=0 to length(MidiEventArray)-1 do
  begin
    if IsEqualGUID(ID,MidiEventArray[i].ID) then
    begin
      AktuellerBefehl.Typ:=MidiEventArray[i].Befehl.Typ;
      AktuellerBefehl.Name:=MidiEventArray[i].Befehl.Name;
      AktuellerBefehl.Beschreibung:=MidiEventArray[i].Befehl.Beschreibung;
      AktuellerBefehl.OnValue:=MidiEventArray[i].Befehl.OnValue;
      AktuellerBefehl.SwitchValue:=MidiEventArray[i].Befehl.SwitchValue;
      AktuellerBefehl.InvertSwitchValue:=MidiEventArray[i].Befehl.InvertSwitchValue;
      AktuellerBefehl.OffValue:=MidiEventArray[i].Befehl.OffValue;
      AktuellerBefehl.ScaleValue:=MidiEventArray[i].Befehl.ScaleValue;

      setlength(AktuellerBefehl.ArgInteger, length(MidiEventArray[i].Befehl.ArgInteger));
      for j:=0 to length(MidiEventArray[i].Befehl.ArgInteger)-1 do
        AktuellerBefehl.ArgInteger[j]:=MidiEventArray[i].Befehl.ArgInteger[j];
      setlength(AktuellerBefehl.ArgString, length(MidiEventArray[i].Befehl.ArgString));
      for j:=0 to length(MidiEventArray[i].Befehl.ArgString)-1 do
        AktuellerBefehl.ArgString[j]:=MidiEventArray[i].Befehl.ArgString[j];
      setlength(AktuellerBefehl.ArgGUID, length(MidiEventArray[i].Befehl.ArgGUID));
      for j:=0 to length(MidiEventArray[i].Befehl.ArgGUID)-1 do
        AktuellerBefehl.ArgGUID[j]:=MidiEventArray[i].Befehl.ArgGUID[j];

      Local_LastEvent:='MIDI';

      break;
    end;
  end;

  if IsEqualGUID(AktuellerBefehl.Typ, StringToGUID('{00000000-0000-0000-0000-000000000000}')) then
  for i:=0 to length(DataInEventArray)-1 do
  begin
    if IsEqualGUID(ID,DataInEventArray[i].ID) then
    begin
      AktuellerBefehl.Typ:=DataInEventArray[i].Befehl.Typ;
      AktuellerBefehl.Name:=DataInEventArray[i].Befehl.Name;
      AktuellerBefehl.Beschreibung:=DataInEventArray[i].Befehl.Beschreibung;
      AktuellerBefehl.OnValue:=DataInEventArray[i].Befehl.OnValue;
      AktuellerBefehl.SwitchValue:=DataInEventArray[i].Befehl.SwitchValue;
      AktuellerBefehl.InvertSwitchValue:=DataInEventArray[i].Befehl.InvertSwitchValue;
      AktuellerBefehl.OffValue:=DataInEventArray[i].Befehl.OffValue;
      AktuellerBefehl.ScaleValue:=DataInEventArray[i].Befehl.ScaleValue;

      setlength(AktuellerBefehl.ArgInteger, length(DataInEventArray[i].Befehl.ArgInteger));
      for j:=0 to length(DataInEventArray[i].Befehl.ArgInteger)-1 do
        AktuellerBefehl.ArgInteger[j]:=DataInEventArray[i].Befehl.ArgInteger[j];
      setlength(AktuellerBefehl.ArgString, length(DataInEventArray[i].Befehl.ArgString));
      for j:=0 to length(DataInEventArray[i].Befehl.ArgString)-1 do
        AktuellerBefehl.ArgString[j]:=DataInEventArray[i].Befehl.ArgString[j];
      setlength(AktuellerBefehl.ArgGUID, length(DataInEventArray[i].Befehl.ArgGUID));
      for j:=0 to length(DataInEventArray[i].Befehl.ArgGUID)-1 do
        AktuellerBefehl.ArgGUID[j]:=DataInEventArray[i].Befehl.ArgGUID[j];

      Local_LastEvent:='DataIN';

      break;
    end;
  end;

  if IsEqualGUID(AktuellerBefehl.Typ, StringToGUID('{00000000-0000-0000-0000-000000000000}')) then
  for i:=0 to length(JoystickEvents)-1 do
  begin
    if IsEqualGUID(ID,JoystickEvents[i].ID) then
    begin
      AktuellerBefehl.Typ:=JoystickEvents[i].Befehl.Typ;
      AktuellerBefehl.Name:=JoystickEvents[i].Befehl.Name;
      AktuellerBefehl.Beschreibung:=JoystickEvents[i].Befehl.Beschreibung;
      AktuellerBefehl.OnValue:=JoystickEvents[i].Befehl.OnValue;
      AktuellerBefehl.SwitchValue:=JoystickEvents[i].Befehl.SwitchValue;
      AktuellerBefehl.InvertSwitchValue:=JoystickEvents[i].Befehl.InvertSwitchValue;
      AktuellerBefehl.OffValue:=JoystickEvents[i].Befehl.OffValue;
      AktuellerBefehl.ScaleValue:=JoystickEvents[i].Befehl.ScaleValue;

      setlength(AktuellerBefehl.ArgInteger, length(JoystickEvents[i].Befehl.ArgInteger));
      for j:=0 to length(JoystickEvents[i].Befehl.ArgInteger)-1 do
        AktuellerBefehl.ArgInteger[j]:=JoystickEvents[i].Befehl.ArgInteger[j];
      setlength(AktuellerBefehl.ArgString, length(JoystickEvents[i].Befehl.ArgString));
      for j:=0 to length(JoystickEvents[i].Befehl.ArgString)-1 do
        AktuellerBefehl.ArgString[j]:=JoystickEvents[i].Befehl.ArgString[j];
      setlength(AktuellerBefehl.ArgGUID, length(JoystickEvents[i].Befehl.ArgGUID));
      for j:=0 to length(JoystickEvents[i].Befehl.ArgGUID)-1 do
        AktuellerBefehl.ArgGUID[j]:=JoystickEvents[i].Befehl.ArgGUID[j];

      Local_LastEvent:='Joystick '+inttostr(i);

      break;
    end;
  end;

  if IsEqualGUID(AktuellerBefehl.Typ, StringToGUID('{00000000-0000-0000-0000-000000000000}')) then
  for i:=0 to length(TastencodeArray)-1 do
  begin
    if IsEqualGUID(ID,TastencodeArray[i].ID) then
    begin
      AktuellerBefehl.Typ:=TastencodeArray[i].Befehl.Typ;
      AktuellerBefehl.Name:=TastencodeArray[i].Befehl.Name;
      AktuellerBefehl.Beschreibung:=TastencodeArray[i].Befehl.Beschreibung;
      AktuellerBefehl.OnValue:=TastencodeArray[i].Befehl.OnValue;
      AktuellerBefehl.SwitchValue:=TastencodeArray[i].Befehl.SwitchValue;
      AktuellerBefehl.InvertSwitchValue:=TastencodeArray[i].Befehl.InvertSwitchValue;
      AktuellerBefehl.OffValue:=TastencodeArray[i].Befehl.OffValue;
      AktuellerBefehl.ScaleValue:=TastencodeArray[i].Befehl.ScaleValue;

      setlength(AktuellerBefehl.ArgInteger, length(TastencodeArray[i].Befehl.ArgInteger));
      for j:=0 to length(TastencodeArray[i].Befehl.ArgInteger)-1 do
        AktuellerBefehl.ArgInteger[j]:=TastencodeArray[i].Befehl.ArgInteger[j];
      setlength(AktuellerBefehl.ArgString, length(TastencodeArray[i].Befehl.ArgString));
      for j:=0 to length(TastencodeArray[i].Befehl.ArgString)-1 do
        AktuellerBefehl.ArgString[j]:=TastencodeArray[i].Befehl.ArgString[j];
      setlength(AktuellerBefehl.ArgGUID, length(TastencodeArray[i].Befehl.ArgGUID));
      for j:=0 to length(TastencodeArray[i].Befehl.ArgGUID)-1 do
        AktuellerBefehl.ArgGUID[j]:=TastencodeArray[i].Befehl.ArgGUID[j];

      Local_LastEvent:=_('Tastatur');

      break;
    end;
  end;

  if IsEqualGUID(AktuellerBefehl.Typ, StringToGUID('{00000000-0000-0000-0000-000000000000}')) then
  for i:=0 to length(submasterbank)-1 do
  begin
    for j:=1 to 16 do
    begin
      if IsEqualGUID(ID,submasterbank[i].Befehl[j].ID) then
      begin
        AktuellerBefehl.Typ:=submasterbank[i].Befehl[j].Typ;
        AktuellerBefehl.Name:=submasterbank[i].Befehl[j].Name;
        AktuellerBefehl.Beschreibung:=submasterbank[i].Befehl[j].Beschreibung;
        AktuellerBefehl.OnValue:=submasterbank[i].Befehl[j].OnValue;
        AktuellerBefehl.SwitchValue:=submasterbank[i].Befehl[j].SwitchValue;
        AktuellerBefehl.InvertSwitchValue:=submasterbank[i].Befehl[j].InvertSwitchValue;
        AktuellerBefehl.OffValue:=submasterbank[i].Befehl[j].OffValue;
        AktuellerBefehl.ScaleValue:=submasterbank[i].Befehl[j].ScaleValue;

        setlength(AktuellerBefehl.ArgInteger, length(submasterbank[i].Befehl[j].ArgInteger));
        for k:=0 to length(submasterbank[i].Befehl[j].ArgInteger)-1 do
          AktuellerBefehl.ArgInteger[k]:=submasterbank[i].Befehl[j].ArgInteger[k];
        setlength(AktuellerBefehl.ArgString, length(submasterbank[i].Befehl[j].ArgString));
        for k:=0 to length(submasterbank[i].Befehl[j].ArgString)-1 do
          AktuellerBefehl.ArgString[k]:=submasterbank[i].Befehl[j].ArgString[k];
        setlength(AktuellerBefehl.ArgGUID, length(submasterbank[i].Befehl[j].ArgGUID));
        for k:=0 to length(submasterbank[i].Befehl[j].ArgGUID)-1 do
          AktuellerBefehl.ArgGUID[k]:=submasterbank[i].Befehl[j].ArgGUID[k];

        Local_LastEvent:='Submaster';

        break;
      end;
    end;
  end;

  if IsEqualGUID(AktuellerBefehl.Typ, StringToGUID('{00000000-0000-0000-0000-000000000000}')) then
  for i:=0 to length(devicescenes)-1 do
  for j:=0 to length(devicescenes[i].Befehle)-1 do
  begin
    if IsEqualGUID(ID,devicescenes[i].Befehle[j].ID) then
    begin
      AktuellerBefehl.Typ:=devicescenes[i].Befehle[j].Typ;
      AktuellerBefehl.Name:=devicescenes[i].Befehle[j].Name;
      AktuellerBefehl.Beschreibung:=devicescenes[i].Befehle[j].Beschreibung;
      AktuellerBefehl.OnValue:=devicescenes[i].Befehle[j].OnValue;
      AktuellerBefehl.SwitchValue:=devicescenes[i].Befehle[j].SwitchValue;
      AktuellerBefehl.InvertSwitchValue:=devicescenes[i].Befehle[j].InvertSwitchValue;
      AktuellerBefehl.OffValue:=devicescenes[i].Befehle[j].OffValue;
      AktuellerBefehl.ScaleValue:=devicescenes[i].Befehle[j].ScaleValue;

      setlength(AktuellerBefehl.ArgInteger, length(devicescenes[i].Befehle[j].ArgInteger));
      for k:=0 to length(devicescenes[i].Befehle[j].ArgInteger)-1 do
        AktuellerBefehl.ArgInteger[k]:=devicescenes[i].Befehle[j].ArgInteger[k];
      setlength(AktuellerBefehl.ArgString, length(devicescenes[i].Befehle[j].ArgString));
      for k:=0 to length(devicescenes[i].Befehle[j].ArgString)-1 do
        AktuellerBefehl.ArgString[k]:=devicescenes[i].Befehle[j].ArgString[k];
      setlength(AktuellerBefehl.ArgGUID, length(devicescenes[i].Befehle[j].ArgGUID));
      for k:=0 to length(devicescenes[i].Befehle[j].ArgGUID)-1 do
        AktuellerBefehl.ArgGUID[k]:=devicescenes[i].Befehle[j].ArgGUID[k];

      Local_LastEvent:=_('Geräteszene');

      break;
    end;
  end;

  if IsEqualGUID(AktuellerBefehl.Typ, StringToGUID('{00000000-0000-0000-0000-000000000000}')) then
//  for g:=0 to length(effektaudio_record)-1 do
  for h:=1 to 8 do
  for i:=0 to length(Effektaudiodatei_record.layer[h].effekt)-1 do
  for j:=0 to length(Effektaudiodatei_record.layer[h].effekt[i].Befehle)-1 do
  begin
    if IsEqualGUID(ID,Effektaudiodatei_record.layer[h].effekt[i].Befehle[j].ID) then
    begin
      AktuellerBefehl.Typ:=Effektaudiodatei_record.layer[h].effekt[i].Befehle[j].Typ;
      AktuellerBefehl.Name:=Effektaudiodatei_record.layer[h].effekt[i].Befehle[j].Name;
      AktuellerBefehl.Beschreibung:=Effektaudiodatei_record.layer[h].effekt[i].Befehle[j].Beschreibung;
      AktuellerBefehl.OnValue:=Effektaudiodatei_record.layer[h].effekt[i].Befehle[j].OnValue;
      AktuellerBefehl.SwitchValue:=Effektaudiodatei_record.layer[h].effekt[i].Befehle[j].SwitchValue;
      AktuellerBefehl.InvertSwitchValue:=Effektaudiodatei_record.layer[h].effekt[i].Befehle[j].InvertSwitchValue;
      AktuellerBefehl.OffValue:=Effektaudiodatei_record.layer[h].effekt[i].Befehle[j].OffValue;
      AktuellerBefehl.ScaleValue:=Effektaudiodatei_record.layer[h].effekt[i].Befehle[j].ScaleValue;

      setlength(AktuellerBefehl.ArgInteger, length(Effektaudiodatei_record.layer[h].effekt[i].Befehle[j].ArgInteger));
      for k:=0 to length(Effektaudiodatei_record.layer[h].effekt[i].Befehle[j].ArgInteger)-1 do
        AktuellerBefehl.ArgInteger[k]:=Effektaudiodatei_record.layer[h].effekt[i].Befehle[j].ArgInteger[k];
      setlength(AktuellerBefehl.ArgString, length(Effektaudiodatei_record.layer[h].effekt[i].Befehle[j].ArgString));
      for k:=0 to length(Effektaudiodatei_record.layer[h].effekt[i].Befehle[j].ArgString)-1 do
        AktuellerBefehl.ArgString[k]:=Effektaudiodatei_record.layer[h].effekt[i].Befehle[j].ArgString[k];
      setlength(AktuellerBefehl.ArgGUID, length(Effektaudiodatei_record.layer[h].effekt[i].Befehle[j].ArgGUID));
      for k:=0 to length(Effektaudiodatei_record.layer[h].effekt[i].Befehle[j].ArgGUID)-1 do
        AktuellerBefehl.ArgGUID[k]:=Effektaudiodatei_record.layer[h].effekt[i].Befehle[j].ArgGUID[k];

      Local_LastEvent:=_('Direktszene AEP');

      break;
    end;
  end;

  if IsEqualGUID(AktuellerBefehl.Typ, StringToGUID('{00000000-0000-0000-0000-000000000000}')) then
  for h:=0 to length(Effektsequenzereffekte)-1 do
  for i:=0 to length(Effektsequenzereffekte[h].Effektschritte)-1 do
  for j:=0 to length(Effektsequenzereffekte[h].Effektschritte[i].Befehle)-1 do
  begin
    if IsEqualGUID(ID,Effektsequenzereffekte[h].Effektschritte[i].Befehle[j].ID) then
    begin
      AktuellerBefehl.Typ:=Effektsequenzereffekte[h].Effektschritte[i].Befehle[j].Typ;
      AktuellerBefehl.Name:=Effektsequenzereffekte[h].Effektschritte[i].Befehle[j].Name;
      AktuellerBefehl.Beschreibung:=Effektsequenzereffekte[h].Effektschritte[i].Befehle[j].Beschreibung;
      AktuellerBefehl.OnValue:=Effektsequenzereffekte[h].Effektschritte[i].Befehle[j].OnValue;
      AktuellerBefehl.SwitchValue:=Effektsequenzereffekte[h].Effektschritte[i].Befehle[j].SwitchValue;
      AktuellerBefehl.InvertSwitchValue:=Effektsequenzereffekte[h].Effektschritte[i].Befehle[j].InvertSwitchValue;
      AktuellerBefehl.OffValue:=Effektsequenzereffekte[h].Effektschritte[i].Befehle[j].OffValue;
      AktuellerBefehl.ScaleValue:=Effektsequenzereffekte[h].Effektschritte[i].Befehle[j].ScaleValue;

      setlength(AktuellerBefehl.ArgInteger, length(Effektsequenzereffekte[h].Effektschritte[i].Befehle[j].ArgInteger));
      for k:=0 to length(Effektsequenzereffekte[h].Effektschritte[i].Befehle[j].ArgInteger)-1 do
        AktuellerBefehl.ArgInteger[k]:=Effektsequenzereffekte[h].Effektschritte[i].Befehle[j].ArgInteger[k];
      setlength(AktuellerBefehl.ArgString, length(Effektsequenzereffekte[h].Effektschritte[i].Befehle[j].ArgString));
      for k:=0 to length(Effektsequenzereffekte[h].Effektschritte[i].Befehle[j].ArgString)-1 do
        AktuellerBefehl.ArgString[k]:=Effektsequenzereffekte[h].Effektschritte[i].Befehle[j].ArgString[k];
      setlength(AktuellerBefehl.ArgGUID, length(Effektsequenzereffekte[h].Effektschritte[i].Befehle[j].ArgGUID));
      for k:=0 to length(Effektsequenzereffekte[h].Effektschritte[i].Befehle[j].ArgGUID)-1 do
        AktuellerBefehl.ArgGUID[k]:=Effektsequenzereffekte[h].Effektschritte[i].Befehle[j].ArgGUID[k];

      Local_LastEvent:=_('Direktszene Effekt');

      break;
    end;
  end;

  if IsEqualGUID(AktuellerBefehl.Typ, StringToGUID('{00000000-0000-0000-0000-000000000000}')) then
  for i:=0 to length(mainform.ElgatoStreamDeckArray)-1 do
  for k:=0 to length(mainform.ElgatoStreamDeckArray[i].Buttons)-1 do
  begin
    if IsEqualGUID(ID,mainform.ElgatoStreamDeckArray[i].Buttons[k].Befehl.ID) then
    begin
      AktuellerBefehl.Typ:=mainform.ElgatoStreamDeckArray[i].Buttons[k].Befehl.Typ;
      AktuellerBefehl.Name:=mainform.ElgatoStreamDeckArray[i].Buttons[k].Befehl.Name;
      AktuellerBefehl.Beschreibung:=mainform.ElgatoStreamDeckArray[i].Buttons[k].Befehl.Beschreibung;
      AktuellerBefehl.OnValue:=mainform.ElgatoStreamDeckArray[i].Buttons[k].Befehl.OnValue;
      AktuellerBefehl.SwitchValue:=mainform.ElgatoStreamDeckArray[i].Buttons[k].Befehl.SwitchValue;
      AktuellerBefehl.InvertSwitchValue:=mainform.ElgatoStreamDeckArray[i].Buttons[k].Befehl.InvertSwitchValue;
      AktuellerBefehl.OffValue:=mainform.ElgatoStreamDeckArray[i].Buttons[k].Befehl.OffValue;
      AktuellerBefehl.ScaleValue:=mainform.ElgatoStreamDeckArray[i].Buttons[k].Befehl.ScaleValue;

      setlength(AktuellerBefehl.ArgInteger, length(mainform.ElgatoStreamDeckArray[i].Buttons[k].Befehl.ArgInteger));
      for j:=0 to length(mainform.ElgatoStreamDeckArray[i].Buttons[k].Befehl.ArgInteger)-1 do
        AktuellerBefehl.ArgInteger[j]:=mainform.ElgatoStreamDeckArray[i].Buttons[k].Befehl.ArgInteger[j];
      setlength(AktuellerBefehl.ArgString, length(mainform.ElgatoStreamDeckArray[i].Buttons[k].Befehl.ArgString));
      for j:=0 to length(mainform.ElgatoStreamDeckArray[i].Buttons[k].Befehl.ArgString)-1 do
        AktuellerBefehl.ArgString[j]:=mainform.ElgatoStreamDeckArray[i].Buttons[k].Befehl.ArgString[j];
      setlength(AktuellerBefehl.ArgGUID, length(mainform.ElgatoStreamDeckArray[i].Buttons[k].Befehl.ArgGUID));
      for j:=0 to length(mainform.ElgatoStreamDeckArray[i].Buttons[k].Befehl.ArgGUID)-1 do
        AktuellerBefehl.ArgGUID[j]:=mainform.ElgatoStreamDeckArray[i].Buttons[k].Befehl.ArgGUID[j];

      Local_LastEvent:='StreamDeck #'+inttostr(i+1)+'@Btn'+inttostr(k+1);

      break;
    end;
  end;

  if IsEqualGUID(AktuellerBefehl.Typ, StringToGUID('{00000000-0000-0000-0000-000000000000}')) then
  if IsEqualGUID(ID, StringToGUID('{46368186-DF3D-467A-9792-DAC6B03A21E3}')) then
  begin
    AktuellerBefehl.ID:=ID;
    AktuellerBefehl.Typ:=TerminalSystem.BefehlsTyp;
    AktuellerBefehl.Name:=_('Terminal-Schnittstelle');
    AktuellerBefehl.Beschreibung:='';
    AktuellerBefehl.OnValue:=255;
    AktuellerBefehl.SwitchValue:=128;
    AktuellerBefehl.OffValue:=0;
    AktuellerBefehl.ScaleValue:=false;
    AktuellerBefehl.RunOnProjectLoad:=false;

    setlength(AktuellerBefehl.ArgInteger, 2);
    setlength(AktuellerBefehl.ArgString, 2);
    setlength(AktuellerBefehl.ArgGUID, 2);

    AktuellerBefehl.ArgInteger[0]:=TerminalSystem.IntegerArg1;
    AktuellerBefehl.ArgInteger[1]:=TerminalSystem.IntegerArg2;
    AktuellerBefehl.ArgString[0]:=TerminalSystem.StringArg1;
    AktuellerBefehl.ArgString[1]:=TerminalSystem.StringArg2;
    AktuellerBefehl.ArgGUID[0]:=TerminalSystem.GUID1;
    AktuellerBefehl.ArgGUID[1]:=TerminalSystem.GUID2;

    Local_LastEvent:='Terminal';
  end;

  // Befehl ausführen
  StartBefehl(AktuellerBefehl, inputvalue, Local_LastEvent);
end;

procedure Tmainform.StartBefehl(AktuellerBefehl:TBefehl2; Inputvalue: integer; Source:String);
var
  g,h,i,j,k,tempvar,input,value:integer;
  temp1,temp2,temp3:integer;
  S1, S2:single;
  EventFired:boolean;
begin
  if IsEqualGUID(AktuellerBefehl.Typ, StringToGUID('{00000000-0000-0000-0000-000000000000}')) then
    exit;

  value:=inputvalue;

  {
  // Sicherstellen, dass der maximale Wert auch bei schnellem Faderbewegen noch ausgeführt wird
  // (dies birgt das Problem, dass dann auch alle unteren Schwellen-Events ausgeführt werden)
  if (value<AktuellerBefehl.OffValue) then
    value:=AktuellerBefehl.OffValue;
  if (value>AktuellerBefehl.OnValue) then
    value:=AktuellerBefehl.OnValue;
  }
  // Befehl nicht ausführen, wenn außerhalb der Grenzwerte
  if (value<AktuellerBefehl.OffValue) or (value>AktuellerBefehl.OnValue) then
    exit;

  LastEvent:=Source+': '+inttostr(inputvalue);

  if AktuellerBefehl.ScaleValue then
    value:=round((value-AktuellerBefehl.OffValue)*(255/(AktuellerBefehl.OnValue-AktuellerBefehl.OffValue)));

  if AktuellerBefehl.InvertSwitchValue then
    EventFired:=(Value<=AktuellerBefehl.SwitchValue)
  else
    EventFired:=(Value>=AktuellerBefehl.SwitchValue);

  for j:=0 to length(mainform.Befehlssystem)-1 do
  begin
    for k:=0 to length(mainform.Befehlssystem[j].Steuerung)-1 do
    begin
      if IsEqualGUID(Befehlssystem[j].Steuerung[k].GUID, AktuellerBefehl.Typ) then
      begin
        Befehlssystem[j].Steuerung[k].CurrentValue:=Value;
      end;
    end;
  end;


  // Befehl ausführen
  try
    // Audioeffektplayer
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[0].Steuerung[0].GUID) and EventFired then
    begin // Start/stop
      if audioeffektplayerform.PlayEffektaudio.Enabled then
        audioeffektplayerform.PlayEffektaudio.Click
      else
        audioeffektplayerform.StopEffektaudio.Click;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[0].Steuerung[1].GUID) and EventFired then
    begin // Start
      if audioeffektplayerform.PlayEffektaudio.Enabled then
        audioeffektplayerform.PlayEffektaudio.Click;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[0].Steuerung[2].GUID) and EventFired then
    begin // Stop
      if audioeffektplayerform.StopEffektaudio.Enabled then
        audioeffektplayerform.StopEffektaudio.Click;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[0].Steuerung[3].GUID) and EventFired then
    begin // Springe zu Position
      BASS_ChannelSetPosition(audioeffektplayerform._chan[0],BASS_ChannelSeconds2Bytes(audioeffektplayerform._chan[0],AktuellerBefehl.ArgInteger[0]/1000), BASS_POS_BYTE);
      BASS_ChannelSetPosition(audioeffektplayerform._chan[1],BASS_ChannelGetPosition(audioeffektplayerform._chan[0], BASS_POS_BYTE), BASS_POS_BYTE);
      BASS_ChannelSetPosition(audioeffektplayerform._chan[2],BASS_ChannelGetPosition(audioeffektplayerform._chan[0], BASS_POS_BYTE), BASS_POS_BYTE);
      BASS_ChannelSetPosition(audioeffektplayerform._chan[3],BASS_ChannelGetPosition(audioeffektplayerform._chan[0], BASS_POS_BYTE), BASS_POS_BYTE);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[0].Steuerung[4].GUID) and EventFired then
    begin // Repeat ein/aus
      audioeffektplayerform.Repeataktiviert.Checked:=not audioeffektplayerform.Repeataktiviert.Checked;
      audioeffektplayerform.Repeataktiviert1.Checked:=audioeffektplayerform.Repeataktiviert.Checked;
      Effektaudiodatei_record.repeatactive:=audioeffektplayerform.Repeataktiviert.Checked;
      exit;
    end; // Aufnahme ein/aus
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[0].Steuerung[5].GUID) and EventFired then
    begin
      if audioeffektplayerform.recordbtn_on.Visible then
        audioeffektplayerform.recordbtn_on.Click
      else
        audioeffektplayerform.recordbtn_off.Click;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[0].Steuerung[6].GUID) and EventFired then
    begin // Effekte ein/aus
      audioeffektplayerform.effekteein.Checked:=not audioeffektplayerform.effekteein.Checked;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[0].Steuerung[7].GUID) and EventFired then
    begin // Vorherige Audiodatei
      audioeffektplayerform.audioeffektfilenameboxDropDown(audioeffektplayerform.audioeffektfilenamebox);
      if audioeffektplayerform.audioeffektfilenamebox.ItemIndex>0 then
      begin
        audioeffektplayerform.audioeffektfilenamebox.ItemIndex:=audioeffektplayerform.audioeffektfilenamebox.ItemIndex-1;
        audioeffektplayerform.audioeffektfilenameboxChange(audioeffektplayerform.audioeffektfilenamebox);
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[0].Steuerung[8].GUID) and EventFired then
    begin // Nächste Audiodatei
      audioeffektplayerform.audioeffektfilenameboxDropDown(audioeffektplayerform.audioeffektfilenamebox);
      if audioeffektplayerform.audioeffektfilenamebox.ItemIndex+1<audioeffektplayerform.audioeffektfilenamebox.Items.Count-1 then
      begin
        audioeffektplayerform.audioeffektfilenamebox.ItemIndex:=audioeffektplayerform.audioeffektfilenamebox.ItemIndex+1;
        audioeffektplayerform.audioeffektfilenameboxChange(audioeffektplayerform.audioeffektfilenamebox);
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[0].Steuerung[9].GUID) and EventFired then
    begin // Springe zu Audiodatei
      audioeffektplayerform.audioeffektfilenameboxDropDown(audioeffektplayerform.audioeffektfilenamebox);
      if (AktuellerBefehl.ArgInteger[0]>=0) and (AktuellerBefehl.ArgInteger[0]<audioeffektplayerform.audioeffektfilenamebox.Items.Count) then
      begin
        audioeffektplayerform.audioeffektfilenamebox.ItemIndex:=AktuellerBefehl.ArgInteger[0];
        audioeffektplayerform.audioeffektfilenameboxChange(audioeffektplayerform.audioeffektfilenamebox);
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[0].Steuerung[10].GUID) and EventFired then
    begin // Springe zu Audiodatei
      audioeffektplayerform.audioeffektfilenameboxDropDown(audioeffektplayerform.audioeffektfilenamebox);
      if (AktuellerBefehl.ArgInteger[0]>=0) and (AktuellerBefehl.ArgInteger[0]<audioeffektplayerform.audioeffektfilenamebox.Items.Count) then
      begin
        audioeffektplayerform.audioeffektfilenamebox.ItemIndex:=AktuellerBefehl.ArgInteger[0];
        audioeffektplayerform.audioeffektfilenameboxChange(audioeffektplayerform.audioeffektfilenamebox);
      end;
      if audioeffektplayerform.PlayEffektaudio.Enabled then
        audioeffektplayerform.PlayEffektaudio.Click;
      exit;
    end;

    // Szenen
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[1].Steuerung[0].GUID) and EventFired then
    begin // Start
      StartScene(AktuellerBefehl.ArgGUID[0],false,false, -1);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[1].Steuerung[1].GUID) and EventFired then
    begin // Stop
      StopScene(AktuellerBefehl.ArgGUID[0]);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[1].Steuerung[2].GUID) and EventFired then
    begin // Start/Stop
      if IsSceneActive(AktuellerBefehl.ArgGUID[0]) then
        StopScene(AktuellerBefehl.ArgGUID[0]) // Szene stoppen
      else
        StartScene(AktuellerBefehl.ArgGUID[0],false,false, -1); // Szene starten
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[1].Steuerung[3].GUID)then
    begin // Flash
      if EventFired then
      begin
        StartScene(AktuellerBefehl.ArgGUID[0],false,false, value, -1); // Szene starten
      end else
      begin
        StartScene(AktuellerBefehl.ArgGUID[0], false, false, value, -1); // Szene ausschalten
        StopScene(AktuellerBefehl.ArgGUID[0]); // Szene stoppen
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[1].Steuerung[4].GUID) and EventFired then
    begin // Szenenzeit festlegen
      SetSceneTime(AktuellerBefehl.ArgGUID[0],AktuellerBefehl.ArgInteger[0]);
      exit;
    end;

    // Beattool
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[2].Steuerung[0].GUID) and EventFired then
    begin // Sync-Button
      beatform.beat_syncBtnClick(nil);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[2].Steuerung[1].GUID) and EventFired then
    begin // BPM-Wert
  //    if AktuellerBefehl.ArgInteger[0]>0 then
  //      beatform.temposlider.Position:=60000 div AktuellerBefehl.ArgInteger[0];
      beatform.UpdateBPM(AktuellerBefehl.ArgInteger[0]);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[2].Steuerung[2].GUID) and EventFired then
    begin // BPM-Wert abfragen
      beatform.UpdateBPM(strtoint(InputBox(_('Geschwindigkeit eingeben'),_('Bitte geben Sie eine Geschwindigkeit in Beats-Per-Minute (BPM) an:'),'60')));
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[2].Steuerung[3].GUID) and EventFired then
    begin // Beat auslösen
      ExecuteBeat(nil);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[2].Steuerung[4].GUID) and EventFired then
    begin // Beatquelle setzen
      beatform.TemposourceboxDropDown(nil);
      Application.ProcessMessages;
      sleep(250);
      beatform.Temposourcebox.ItemIndex:=AktuellerBefehl.ArgInteger[0];
      beatform.TemposourceboxChange(beatform.Temposourcebox);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[2].Steuerung[5].GUID) and EventFired then
    begin // Temposlider setzen
      beatform.temposlider.Position:=59999-(AktuellerBefehl.ArgInteger[0]*100);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[2].Steuerung[6].GUID) then
    begin // Temposlider auf Eingangswert
      beatform.temposlider.Position:=round(59999-((Value/maxres)*59999));
      exit;
    end;

    // Master / MIDI
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[0].GUID) then
    begin // Grandmaster auf Eingang
      masterform.dimmerMaster.Position:=255-Value;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[1].GUID) and EventFired then
    begin // Grandmaster setzen
      masterform.dimmerMaster.Position:=round(((100-AktuellerBefehl.ArgInteger[0])/100)*255);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[2].GUID) and EventFired then
    begin // Grandmaster abfragen
      masterform.dimmerMaster.Position:=100-strtoint(InputBox(_('Grandmaster setzen'),_('Bitte geben Sie einen Wert für den Grandmaster an [Wert von 0..100]:'),'100'));
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[3].GUID) then
    begin // Flashmaster auf Eingang
      masterform.FlashMaster.Position:=255-Value;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[4].GUID) and EventFired then
    begin // Flashmaster setzen
      masterform.FlashMaster.Position:=round(((100-AktuellerBefehl.ArgInteger[0])/100)*255);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[5].GUID) and EventFired then
    begin // Flashmaster auf abfragen
      masterform.FlashMaster.Position:=100-strtoint(InputBox(_('Flashmaster setzen'),_('Bitte geben Sie einen Wert für den Flashmaster an [Wert von 0..100]:'),'100'));
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[6].GUID) then
    begin // Speedmaster auf Eingang
      masterform.SpeedMaster.Position:=512-(Value*2);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[7].GUID) and EventFired then
    begin // Speedmaster setzen
      masterform.SpeedMaster.Position:=round(((AktuellerBefehl.ArgInteger[0]+100)/200)*512);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[8].GUID) and EventFired then
    begin // Speedmaster abfragen
      masterform.SpeedMaster.Position:=100-strtoint(InputBox(_('Speedmaster setzen'),_('Bitte geben Sie einen Wert für den Speedmaster an [Wert von -100..0..100]:'),'0'));
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[9].GUID) then
    begin // Audiomaster auf Eingang
      masterform.volumeslider.Position:=100-round(Value/maxres*100);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[10].GUID) and EventFired then
    begin // Audiomaster setzen
      masterform.volumeslider.Position:=round(((100-AktuellerBefehl.ArgInteger[0])/100)*255);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[11].GUID) and EventFired then
    begin // Audiomaster abfragen
      masterform.volumeslider.Position:=100-strtoint(InputBox(_('Audiomaster setzen'),_('Bitte geben Sie einen Wert für den Audiomaster an [Wert von 0..100]:'),'100'));
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[12].GUID) and EventFired then
    begin // Audio-Mute ein/aus
      if Bass_GetVolume=0 then
        Bass_SetVolume(masterform.volumeslider.position)
      else
        Bass_SetVolume(0);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[13].GUID) and EventFired then
    begin // MIDI-Befehl senden
      if MIDIActiveRibbonBox.Down then
        SendMidi(AktuellerBefehl.ArgInteger[0],AktuellerBefehl.ArgInteger[1],AktuellerBefehl.ArgInteger[2]);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[14].GUID) then
    begin // Eingangswert als MIDI-Befehl
      if AktuellerBefehl.ArgInteger[0]=-1 then
        temp1:=round(Value/2)
      else
        temp1:=AktuellerBefehl.ArgInteger[0];
      if AktuellerBefehl.ArgInteger[1]=-1 then
        temp2:=round(Value/2)
      else
        temp2:=AktuellerBefehl.ArgInteger[1];
      if AktuellerBefehl.ArgInteger[2]=-1 then
        temp3:=round(Value/2)
      else
        temp3:=AktuellerBefehl.ArgInteger[2];

      if MIDIActiveRibbonBox.Down then
        SendMidi(temp1, temp2, temp3);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[15].GUID) and EventFired then
    begin // Kanalsetzmodus wechseln
      if Kanalsetzmodus<4 then
        Kanalsetzmodus:=Kanalsetzmodus+1
      else
        Kanalsetzmodus:=0;

      case Kanalsetzmodus of
        0: dxRibbonStatusBar1.Panels[2].Text:=_('1 Einschalten');
        1: dxRibbonStatusBar1.Panels[2].Text:=_('2 Ausschalten');
        2: dxRibbonStatusBar1.Panels[2].Text:=_('3 Einblenden');
        3: dxRibbonStatusBar1.Panels[2].Text:=_('4 Ausblenden');
        4: dxRibbonStatusBar1.Panels[2].Text:=_('5 Flashen');
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[16].GUID) and EventFired then
    begin // PC_DIMMER Programmfunktion
      case AktuellerBefehl.ArgInteger[0] of
        0: ToolButton1Click(nil); // Neues Projekt...
        1: ToolButton3Click(nil); // Projekt öffnen...
        2: ToolButton4Click(nil); // Projekt speichern
        3: Schnellspeichern1Click(nil); // Projekt schnellspeichern
        4: Projektspeichern1Click(nil); // Projekt speichern unter...
        5: Projektverwaltung1Click(nil); // Projektverwaltung
        6: Kanalnamendrucken1Click(nil); // Kanalnamen ausdrucken
        7: Exit1Click(nil); // PC_DIMMER beenden...
        8: TBItem17Click(nil); // PC_DIMMER sperren...
        9: begin mainform.SetFocus; commandedit.SetFocus; end; // Fokus auf Kommandozeile
        10: // PC_DIMMER entsperren...
        begin
          lockedform.enterthematrix.Text:='';
          lockedform.timer1.Enabled:=false;
          lockedform.darfbeenden:=true;
          lockedform.modalresult:=mrOK;
        end;
  {
        21: Kontrollpanel1Click(nil); // Kontrollpanel
        22: Effektsequenzer1Click(nil); // Effektsequenzer
        23: TBItem17Click(nil); // Synchrone Scannerbewegung
        24: TBItem25Click(nil); // Zeitgesteuerte Ereignisse
        25: Szenenverwaltung1Click(nil); // Szenenverwaltung
        26: Figureneditor1Click(nil); // Figureneditor
        27: TBItem20Click(nil); // Geräteeditor
        28: TBItem13Click(nil); // Audioeffektplayer
        29: Leistungssteuerung1Click(nil); // Leistungssteuerung
        30: Gertesteuerung2Click(nil); // Gerätesteuerung
        31: Bhnenansicht1Click(nil); // Bühnenansicht
        32: Submaster1Click(nil); // Submaster
        33: Joysticksteuerung1Click(nil); // Joysticksteuerung
        34: ResetWindowPositionsClick(nil); // Fensterpositionen resetten
  }
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[17].GUID) and EventFired then
    begin // Externes Programm starten
      case AktuellerBefehl.ArgInteger[2] of
        0: ShellExecute(Handle, 'open', PChar(string(AktuellerBefehl.ArgString[0])), PChar(string(AktuellerBefehl.ArgString[1])), nil, SW_SHOW);
        1: ShellExecute(Handle, 'open', PChar(string(AktuellerBefehl.ArgString[0])), PChar(string(AktuellerBefehl.ArgString[1])), nil, SW_MINIMIZE);
        2: ShellExecute(Handle, 'open', PChar(string(AktuellerBefehl.ArgString[0])), PChar(string(AktuellerBefehl.ArgString[1])), nil, SW_MAXIMIZE);
        3: ShellExecute(Handle, 'open', PChar(string(AktuellerBefehl.ArgString[0])), PChar(string(AktuellerBefehl.ArgString[1])), nil, SW_HIDE);
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[18].GUID) and EventFired then
    begin // Freeze-Modus toggeln
      IsFreezeMode:=not IsFreezeMode;

      if IsFreezeMode then
      begin
        OutputOffRibbonBtn.Down:=true;
      end else
      begin
        OutputOffRibbonBtn.Down:=false;
      end;

      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[19].GUID) and EventFired then
    begin // Stoppe alle Effekte
      StopAllEffects;
      
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[20].GUID) and EventFired then
    begin // Partymodul-Preset wählen
      if pmmform.presetbox.Items.Count>0 then
      begin
        if (AktuellerBefehl.ArgInteger[0]-1)<pmmform.presetbox.Items.Count then
        begin
          pmmform.presetbox.ItemIndex:=AktuellerBefehl.ArgInteger[0]-1;
          pmmform.presetboxClick(nil);
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[21].GUID) and EventFired then
    begin // Partymodul-Preset Zufallsmodus
      pmmform.randompresetcheck.Checked:=not pmmform.randompresetcheck.Checked;
      pmmform.presettimer.Enabled:=pmmform.randompresetcheck.Checked;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[22].GUID) and EventFired then
    begin // Blackout ein/aus
      BlackoutRibbonBtn.Click;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[23].GUID) and EventFired then
    begin // Ambilight ein
      ambilightform.Timer1.enabled:=true;
      ambilightform.Button2.Caption:=_('Ambilight ausschalten');
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[24].GUID) and EventFired then
    begin // Ambilight aus
      ambilightform.Timer1.enabled:=false;
      ambilightform.Button2.Caption:=_('Ambilight einschalten');
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[25].GUID) and EventFired then
    begin // Zeitsteuerung ein
      schedulerform.TimerDeaktiviertCheckbox.checked:=true;
      skripttimer_offline:=schedulerform.TimerDeaktiviertCheckbox.checked;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[26].GUID) and EventFired then
    begin // Zeitsteuerung aus
      schedulerform.TimerDeaktiviertCheckbox.checked:=false;
      skripttimer_offline:=schedulerform.TimerDeaktiviertCheckbox.checked;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[27].GUID) and EventFired then
    begin // Alle Audioeffekte stoppen
      for i:=0 to length(audioszenen)-1 do
        mainform.StopScene(audioszenen[i].ID);
      Audioeffektplayerform.StopEffektaudioClick(nil);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[28].GUID) and EventFired then
    begin // Datei öffnen
      OpenPCDIMMERFile(AktuellerBefehl.ArgString[0]);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[29].GUID) and EventFired then
    begin // Benutzer wechseln
      ChangeUser(false);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[30].GUID) and EventFired then
    begin // MQTT: Payload senden
      mqtt.Publish(string(AktuellerBefehl.ArgString[0]), string(AktuellerBefehl.ArgString[1]), qtAT_MOST_ONCE, false);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[3].Steuerung[31].GUID) and EventFired then
    begin // MQTT: Wert senden
      mqtt.Publish(string(AktuellerBefehl.ArgString[0]), inttostr(round(Value/maxres*100)), qtAT_MOST_ONCE, false);
      exit;
    end;

    // Einzelkanaländerung
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[4].Steuerung[0].GUID) then
    begin // Eingangswert
      if AktuellerBefehl.ArgInteger[0]>0 then
      begin
        data.ch[AktuellerBefehl.ArgInteger[0]]:=Value;
        SendData(AktuellerBefehl.ArgInteger[0],255-Value,255-Value,0);
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[4].Steuerung[1].GUID) and EventFired then
    begin // Fester Wert schalten
      if AktuellerBefehl.ArgInteger[0]>0 then
      begin
        data.ch[AktuellerBefehl.ArgInteger[0]]:=255-AktuellerBefehl.ArgInteger[1];
        SendData(AktuellerBefehl.ArgInteger[0],255-AktuellerBefehl.ArgInteger[1],255-AktuellerBefehl.ArgInteger[1],0);
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[4].Steuerung[2].GUID) and EventFired then
    begin // Abgefragter Wert schalten
      if AktuellerBefehl.ArgInteger[0]>0 then
      begin
        input:=strtoint(InputBox(_('Kanalwert eingeben'),_('Bitte geben Sie einen Kanalwert [0..255] ein, auf den der Kanal "')+data.names[AktuellerBefehl.ArgInteger[0]]+_('" geschaltet werden soll:'),'0'));
        data.ch[AktuellerBefehl.ArgInteger[0]]:=255-input;
        SendData(AktuellerBefehl.ArgInteger[0],255-input,255-input,0);
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[4].Steuerung[3].GUID) and EventFired then
    begin // Wert dimmen
      if AktuellerBefehl.ArgInteger[0]>0 then
      begin
        SendData(AktuellerBefehl.ArgInteger[0],data.ch[AktuellerBefehl.ArgInteger[0]],255-AktuellerBefehl.ArgInteger[1],AktuellerBefehl.ArgInteger[2]);
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[4].Steuerung[4].GUID) and EventFired then
    begin // Abgefragten Wert dimmen
      if AktuellerBefehl.ArgInteger[0]>0 then
      begin
        input:=strtoint(InputBox(_('Kanalwert eingeben'),_('Bitte geben Sie einen Kanalwert [0..255] ein, auf den der Kanal "')+data.names[AktuellerBefehl.ArgInteger[0]]+_('" gedimmt werden soll:'),'0'));
        SendData(AktuellerBefehl.ArgInteger[0],data.ch[AktuellerBefehl.ArgInteger[0]],255-input,AktuellerBefehl.ArgInteger[1]);
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[4].Steuerung[5].GUID) and EventFired then
    begin // Kanalwert +
  //    if channel_value[AktuellerBefehl.ArgInteger[0]]+AktuellerBefehl.ArgInteger[1]<=255 then
  //      channel_value[AktuellerBefehl.ArgInteger[0]]:=channel_value[AktuellerBefehl.ArgInteger[0]]+AktuellerBefehl.ArgInteger[1];
      SendData(AktuellerBefehl.ArgInteger[0],data.ch[AktuellerBefehl.ArgInteger[0]],data.ch[AktuellerBefehl.ArgInteger[0]]-AktuellerBefehl.ArgInteger[1],0);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[4].Steuerung[6].GUID) and EventFired then
    begin // Kanalwert -
  //    if channel_value[AktuellerBefehl.ArgInteger[0]]-AktuellerBefehl.ArgInteger[1]>=0 then
  //      channel_value[AktuellerBefehl.ArgInteger[0]]:=channel_value[AktuellerBefehl.ArgInteger[0]]-AktuellerBefehl.ArgInteger[1];
      SendData(AktuellerBefehl.ArgInteger[0],data.ch[AktuellerBefehl.ArgInteger[0]],data.ch[AktuellerBefehl.ArgInteger[0]]+AktuellerBefehl.ArgInteger[1],0);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[4].Steuerung[7].GUID) then
    begin // Kanalminimum setzen Eingangswert
      channel_minvalue[AktuellerBefehl.ArgInteger[0]]:=Value;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[4].Steuerung[8].GUID) then
    begin // Kanalmaximum setzen Eingangswert
      channel_maxvalue[AktuellerBefehl.ArgInteger[0]]:=Value;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[4].Steuerung[9].GUID) and EventFired then
    begin // Kanalminimum setzen
      channel_minvalue[AktuellerBefehl.ArgInteger[0]]:=AktuellerBefehl.ArgInteger[1];
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[4].Steuerung[10].GUID) and EventFired then
    begin // Kanalmaximum setzen
      channel_maxvalue[AktuellerBefehl.ArgInteger[0]]:=AktuellerBefehl.ArgInteger[1];
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,Befehlssystem[4].Steuerung[11].GUID) then
    begin // Kanalwert setzen (Modusabhängig)
      case Kanalsetzmodus of
        0: if EventFired then SendData(AktuellerBefehl.ArgInteger[0],255-AktuellerBefehl.ArgInteger[1],255-AktuellerBefehl.ArgInteger[1],0); // Einschalten
        1: if EventFired then SendData(AktuellerBefehl.ArgInteger[0],255,255,0); // Ausschalten
        2: if EventFired then SendData(AktuellerBefehl.ArgInteger[0],255-channel_value[AktuellerBefehl.ArgInteger[0]],255-AktuellerBefehl.ArgInteger[1],1000); // Einblenden
        3: if EventFired then SendData(AktuellerBefehl.ArgInteger[0],255-channel_value[AktuellerBefehl.ArgInteger[0]],255,1000); // Ausblenden
        4:
        begin
          channelvalue_temp[AktuellerBefehl.ArgInteger[0]]:=channel_value[AktuellerBefehl.ArgInteger[0]];
  //        SendData(AktuellerBefehl.ArgInteger[0],255-AktuellerBefehl.ArgInteger[1],255-AktuellerBefehl.ArgInteger[1],0); // Flash
          if AktuellerBefehl.ArgInteger[1]=-1 then
            temp1:=value
          else
            temp1:=AktuellerBefehl.ArgInteger[1];
          SendData(AktuellerBefehl.ArgInteger[0],255-temp1,255-temp1,0); // Flash
        end;
      end;
      exit;
    end;

    // Geräte / Gruppen
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[5].Steuerung[0].GUID) then
    begin // Aktuell selektierte Geräte auf Eingangswert
      for j:=0 to length(DeviceSelected)-1 do
      begin
        if DeviceSelected[j] then
        begin
          geraetesteuerung.set_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],Value,Value,0)
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[5].Steuerung[1].GUID) and EventFired then
    begin // Aktuell selektierte Geräte auf Wert
      for j:=0 to length(DeviceSelected)-1 do
      begin
        if DeviceSelected[j] then
        begin
          geraetesteuerung.set_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],AktuellerBefehl.ArgInteger[1],AktuellerBefehl.ArgInteger[1],0)
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[5].Steuerung[2].GUID) then
    begin // Bühnenansichtgerät auf Eingangswert
      if not IsEqualGUID(grafischebuehnenansicht.MouseOnDeviceID, StringToGUID('{00000000-0000-0000-0000-000000000000}')) then
        geraetesteuerung.set_channel(grafischebuehnenansicht.MouseOnDeviceID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],Value,Value,0);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[5].Steuerung[3].GUID) and EventFired then
    begin // Bühnenansichtgerät auf Wert
      if not IsEqualGUID(grafischebuehnenansicht.MouseOnDeviceID, StringToGUID('{00000000-0000-0000-0000-000000000000}')) then
        geraetesteuerung.set_channel(grafischebuehnenansicht.MouseOnDeviceID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],AktuellerBefehl.ArgInteger[1],AktuellerBefehl.ArgInteger[1],0);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[5].Steuerung[4].GUID) then
    begin // Bestimmtes Gerät auf Eingangswert
      for j:=0 to length(devices)-1 do
      begin
        if IsEqualGUID(AktuellerBefehl.ArgGUID[0],devices[j].ID) then
        begin
          geraetesteuerung.set_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],Value,Value,0);
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[5].Steuerung[5].GUID) then
    begin // Bestimmte Gerätegruppe auf Eingangswert
      for j:=0 to length(devicegroups)-1 do
      begin
        if IsEqualGUID(AktuellerBefehl.ArgGUID[0],devicegroups[j].ID) then
        begin
          geraetesteuerung.set_group(devicegroups[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],Value,Value,0);
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[5].Steuerung[6].GUID) and EventFired then
    begin // Bestimmtes Gerät auf Wert schalten
      for j:=0 to length(devices)-1 do
      begin
        if IsEqualGUID(AktuellerBefehl.ArgGUID[0],devices[j].ID) then
        begin
          geraetesteuerung.set_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],AktuellerBefehl.ArgInteger[1],AktuellerBefehl.ArgInteger[1],0);
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[5].Steuerung[7].GUID) and EventFired then
    begin // Bestimmte Gerätegruppe auf Wert schalten
      for j:=0 to length(devicegroups)-1 do
      begin
        if IsEqualGUID(AktuellerBefehl.ArgGUID[0],devicegroups[j].ID) then
        begin
          geraetesteuerung.set_group(devicegroups[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],AktuellerBefehl.ArgInteger[1],AktuellerBefehl.ArgInteger[1],0);
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[5].Steuerung[8].GUID) and EventFired then
    begin // Bestimmtes Gerät auf Wert dimmen
      for j:=0 to length(devices)-1 do
      begin
        if IsEqualGUID(AktuellerBefehl.ArgGUID[0],devices[j].ID) then
        begin
          geraetesteuerung.set_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],-1,AktuellerBefehl.ArgInteger[1],AktuellerBefehl.ArgInteger[2]);
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[5].Steuerung[9].GUID) and EventFired then
    begin // Bestimmte Gerätegruppe auf Wert dimmen
      for j:=0 to length(devicegroups)-1 do
      begin
        if IsEqualGUID(AktuellerBefehl.ArgGUID[0],devicegroups[j].ID) then
        begin
          geraetesteuerung.set_group(devicegroups[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],-1,AktuellerBefehl.ArgInteger[1],AktuellerBefehl.ArgInteger[2]);
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[5].Steuerung[10].GUID) and EventFired then
    begin // Selektierte Geräte +
      for j:=0 to length(devices)-1 do
      begin
        if DeviceSelected[j] then
        begin
          geraetesteuerung.set_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],geraetesteuerung.get_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]])+AktuellerBefehl.ArgInteger[1],geraetesteuerung.get_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]])+AktuellerBefehl.ArgInteger[1],0);
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[5].Steuerung[11].GUID) and EventFired then
    begin // Selektierte Geräte -
      for j:=0 to length(devices)-1 do
      begin
        if DeviceSelected[j] then
        begin
          geraetesteuerung.set_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],geraetesteuerung.get_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]])-AktuellerBefehl.ArgInteger[1],geraetesteuerung.get_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]])-AktuellerBefehl.ArgInteger[1],0);
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[5].Steuerung[12].GUID) and EventFired then
    begin // Bühnenansichtgerät +
      if not IsEqualGUID(grafischebuehnenansicht.MouseOnDeviceID, StringToGUID('{00000000-0000-0000-0000-000000000000}')) then
        geraetesteuerung.set_channel(grafischebuehnenansicht.MouseOnDeviceID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],geraetesteuerung.get_channel(grafischebuehnenansicht.MouseOnDeviceID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]])+AktuellerBefehl.ArgInteger[1],geraetesteuerung.get_channel(grafischebuehnenansicht.MouseOnDeviceID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]])+AktuellerBefehl.ArgInteger[1],0);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[5].Steuerung[13].GUID) and EventFired then
    begin // Bühnenansichtgerät -
      if not IsEqualGUID(grafischebuehnenansicht.MouseOnDeviceID, StringToGUID('{00000000-0000-0000-0000-000000000000}')) then
        geraetesteuerung.set_channel(grafischebuehnenansicht.MouseOnDeviceID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],geraetesteuerung.get_channel(grafischebuehnenansicht.MouseOnDeviceID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]])-AktuellerBefehl.ArgInteger[1],geraetesteuerung.get_channel(grafischebuehnenansicht.MouseOnDeviceID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]])-AktuellerBefehl.ArgInteger[1],0);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[5].Steuerung[14].GUID) and EventFired then
    begin // Bestimmtes Gerät +
      for j:=0 to length(devices)-1 do
      begin
        if IsEqualGUID(AktuellerBefehl.ArgGUID[0],devices[j].ID) then
        begin
          geraetesteuerung.set_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],geraetesteuerung.get_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]])+AktuellerBefehl.ArgInteger[1],geraetesteuerung.get_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]])+AktuellerBefehl.ArgInteger[1],0);
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[5].Steuerung[15].GUID) and EventFired then
    begin // Bestimmtes Gerät -
      for j:=0 to length(devices)-1 do
      begin
        if IsEqualGUID(AktuellerBefehl.ArgGUID[0],devices[j].ID) then
        begin
          geraetesteuerung.set_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],geraetesteuerung.get_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]])-AktuellerBefehl.ArgInteger[1],geraetesteuerung.get_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]])-AktuellerBefehl.ArgInteger[1],0);
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[5].Steuerung[16].GUID) then
    begin // Selektierte Geräte setzen (Modusabhängig)
      if AktuellerBefehl.ArgInteger[1]=-1 then
        temp1:=value
      else
        temp1:=AktuellerBefehl.ArgInteger[1];

      for j:=0 to length(DeviceSelected)-1 do
      begin
        if DeviceSelected[j] then
        begin
          case Kanalsetzmodus of
            0: if EventFired then geraetesteuerung.set_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],geraetesteuerung.get_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]]),temp1,0); // Einschalten
            1: if EventFired then geraetesteuerung.set_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],geraetesteuerung.get_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]]),0,0); // Ausschalten
            2: if EventFired then geraetesteuerung.set_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],geraetesteuerung.get_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]]),temp1,1000); // Einblenden
            3: if EventFired then geraetesteuerung.set_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],geraetesteuerung.get_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]]),0,1000); // Ausblenden
            4: geraetesteuerung.set_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],temp1,temp1,0); // Flash
          end;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[5].Steuerung[17].GUID) then
    begin // Bühnenansichtgerät setzen (Modusabhängig)
      if AktuellerBefehl.ArgInteger[1]=-1 then
        temp1:=value
      else
        temp1:=AktuellerBefehl.ArgInteger[1];

      if not IsEqualGUID(grafischebuehnenansicht.MouseOnDeviceID, StringToGUID('{00000000-0000-0000-0000-000000000000}')) then
      case Kanalsetzmodus of
        0: if EventFired then geraetesteuerung.set_channel(grafischebuehnenansicht.MouseOnDeviceID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],geraetesteuerung.get_channel(grafischebuehnenansicht.MouseOnDeviceID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]]),temp1,0); // Einschalten
        1: if EventFired then geraetesteuerung.set_channel(grafischebuehnenansicht.MouseOnDeviceID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],geraetesteuerung.get_channel(grafischebuehnenansicht.MouseOnDeviceID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]]),0,0); // Ausschalten
        2: if EventFired then geraetesteuerung.set_channel(grafischebuehnenansicht.MouseOnDeviceID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],geraetesteuerung.get_channel(grafischebuehnenansicht.MouseOnDeviceID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]]),temp1,1000); // Einblenden
        3: if EventFired then geraetesteuerung.set_channel(grafischebuehnenansicht.MouseOnDeviceID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],geraetesteuerung.get_channel(grafischebuehnenansicht.MouseOnDeviceID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]]),0,1000); // Ausblenden
//        4: geraetesteuerung.set_channel(grafischebuehnenansicht.MouseOnDeviceID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],geraetesteuerung.get_channel(grafischebuehnenansicht.MouseOnDeviceID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]]),AktuellerBefehl.ArgInteger[1],0); // Flash
        4: geraetesteuerung.set_channel(grafischebuehnenansicht.MouseOnDeviceID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],temp1,temp1,0); // Flash
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[5].Steuerung[18].GUID) then
    begin // Bestimmte Geräte setzen (Modusabhängig)
      if AktuellerBefehl.ArgInteger[1]=-1 then
        temp1:=value
      else
        temp1:=AktuellerBefehl.ArgInteger[1];

      for j:=0 to length(devices)-1 do
      begin
        if IsEqualGUID(AktuellerBefehl.ArgGUID[0],devices[j].ID) then
        begin
          case Kanalsetzmodus of
            0: if EventFired then geraetesteuerung.set_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],geraetesteuerung.get_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]]),temp1,0); // Einschalten
            1: if EventFired then geraetesteuerung.set_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],geraetesteuerung.get_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]]),0,0); // Ausschalten
            2: if EventFired then geraetesteuerung.set_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],geraetesteuerung.get_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]]),temp1,1000); // Einblenden
            3: if EventFired then geraetesteuerung.set_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],geraetesteuerung.get_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]]),0,1000); // Ausblenden
//            4: geraetesteuerung.set_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],geraetesteuerung.get_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]]),AktuellerBefehl.ArgInteger[1],0); // Flash
            4: geraetesteuerung.set_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],temp1, temp1,0); // Flash
          end;
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[5].Steuerung[19].GUID) then
    begin // Bestimmte Gerätegruppe setzen (Modusabhängig)
      if AktuellerBefehl.ArgInteger[1]=-1 then
        temp1:=value
      else
        temp1:=AktuellerBefehl.ArgInteger[1];

      for j:=0 to length(devicegroups)-1 do
      begin // alle Gerätegruppen durchsuchen
        if IsEqualGUID(AktuellerBefehl.ArgGUID[0],devicegroups[j].ID) then
        begin
          // Richtige Gerätegruppe gefunden
          for k:=0 to length(devicegroups[j].IDs)-1 do
          begin
            case Kanalsetzmodus of
              0: if EventFired then geraetesteuerung.set_group(devicegroups[j].IDs[k],DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],-1,temp1,0); // Einschalten
              1: if EventFired then geraetesteuerung.set_group(devicegroups[j].IDs[k],DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],-1,0,0); // Ausschalten
              2: if EventFired then geraetesteuerung.set_group(devicegroups[j].IDs[k],DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],-1,temp1,1000); // Einblenden
              3: if EventFired then geraetesteuerung.set_group(devicegroups[j].IDs[k],DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],-1,0,1000); // Ausblenden
//              4: geraetesteuerung.set_group(devicegroups[j].IDs[k],DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],-1,0,1000); // Flash
              4: geraetesteuerung.set_group(devicegroups[j].IDs[k],DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],temp1,temp1,0); // Flash
            end;
          end;
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[5].Steuerung[20].GUID) and EventFired then
    begin // Alle Kanaltypen auf Null setzen (Teil-Blackout)
      for j:=0 to length(Devices)-1 do
        geraetesteuerung.set_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],0,0,AktuellerBefehl.ArgInteger[1]);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[5].Steuerung[21].GUID) and EventFired then
    begin // Aktuell selektierte Geräte 16-Bit PAN/TILT
      for j:=0 to length(DeviceSelected)-1 do
      begin
        if DeviceSelected[j] then
        begin
          if (AktuellerBefehl.ArgInteger[0]=0) or (AktuellerBefehl.ArgInteger[0]=2) then
          begin
            // Hier abfrage, ob get_channel(PanFine)=-1 und get_channel(TiltFine)=-1. Dann nämlich nur 8-Bit-Steuerung anwenden!!!

            if geraetesteuerung.get_channel(Devices[j].ID, 'PANFINE')>-1 then
            begin
              // 16-Bit PAN
              // Aktuellen Wert holen
              S1:=geraetesteuerung.get_channel(Devices[j].ID, 'PAN')+(geraetesteuerung.get_channel(Devices[j].ID, 'PANFINE')/256);
              // Aktuellen Wert auf 128 zentrieren, mit Faktor multiplizieren und diesen Wert auf aktuellen Wert aufaddieren
//              S1:=S1+(((Value-128)*1)*AktuellerBefehl.ArgInteger[1]/1000); // Linearer Verlauf
              S1:=S1+((sign(Value-128)*(Value-128)*(Value-128)/128)*AktuellerBefehl.ArgInteger[1]/1000); // Exponentieller Verlauf
              // neuen Wert wieder auf PAN und PANFINE setzen
              geraetesteuerung.set_channel(Devices[j].ID,'PAN',trunc(S1),trunc(S1),0);
              geraetesteuerung.set_channel(Devices[j].ID,'PANFINE',trunc(frac(S1)*256),trunc(frac(S1)*256),0);
            end else
            begin
              // 8-Bit PAN
              S1:=geraetesteuerung.get_channel(Devices[j].ID, 'PAN');
              // Aktuellen Wert auf 128 zentrieren, mit Faktor multiplizieren und diesen Wert auf aktuellen Wert aufaddieren
//              S1:=S1+(((Value-128))*AktuellerBefehl.ArgInteger[1]/1000); // Linearer Verlauf
              S1:=S1+((sign(Value-128)*(Value-128)*(Value-128)/128)*AktuellerBefehl.ArgInteger[1]/1000); // Exponentieller Verlauf
              // neuen Wert wieder setzen
              geraetesteuerung.set_channel(Devices[j].ID, 'PAN',round(S1),round(S1),0);
            end;
          end else if (AktuellerBefehl.ArgInteger[0]=1) or (AktuellerBefehl.ArgInteger[0]=3) then
          begin
            if geraetesteuerung.get_channel(Devices[j].ID, 'TILTFINE')>-1 then
            begin
              // 16-Bit TILT
              // Aktuellen Wert holen
              S1:=geraetesteuerung.get_channel(Devices[j].ID, 'TILT')+(geraetesteuerung.get_channel(Devices[j].ID, 'TILTFINE')/256);
              // Aktuellen Wert auf 128 zentrieren, mit Faktor multiplizieren und diesen Wert auf aktuellen Wert aufaddieren
//              S1:=S1+(((Value-128)*1)*AktuellerBefehl.ArgInteger[1]/1000); // Linearer Verlauf
              S1:=S1+((sign(Value-128)*(Value-128)*(Value-128)/128)*AktuellerBefehl.ArgInteger[1]/1000); // Exponentieller Verlauf
              // neuen Wert wieder auf PAN und PANFINE setzen
              geraetesteuerung.set_channel(Devices[j].ID,'TILT',trunc(S1),trunc(S1),0);
              geraetesteuerung.set_channel(Devices[j].ID,'TILTFINE',trunc(frac(S1)*256),trunc(frac(S1)*256),0);
            end else
            begin
              // 8-Bit TILT
              S1:=geraetesteuerung.get_channel(Devices[j].ID, 'TILT');
              // Aktuellen Wert auf 128 zentrieren, mit Faktor multiplizieren und diesen Wert auf aktuellen Wert aufaddieren
//              S1:=S1+(((Value-128))*AktuellerBefehl.ArgInteger[1]/1000); // Linearer Verlauf
              S1:=S1+((sign(Value-128)*(Value-128)*(Value-128)/128)*AktuellerBefehl.ArgInteger[1]/1000); // Exponentieller Verlauf
              // neuen Wert wieder setzen
              geraetesteuerung.set_channel(Devices[j].ID, 'TILT',round(S1),round(S1),0);
            end;
          end else
          begin
            // andere Kanäle
            // Aktuellen Wert holen
            S1:=geraetesteuerung.get_channel(Devices[j].ID, DeviceChannelNames[AktuellerBefehl.ArgInteger[0]]);
            // Aktuellen Wert auf 128 zentrieren, mit Faktor multiplizieren und diesen Wert auf aktuellen Wert aufaddieren
//            S1:=S1+(((Value-128))*AktuellerBefehl.ArgInteger[1]/1000); // Linearer Verlauf
            S1:=S1+((sign(Value-128)*(Value-128)*(Value-128)/128)*AktuellerBefehl.ArgInteger[1]/1000); // Exponentieller Verlauf
            // neuen Wert wieder setzen
            geraetesteuerung.set_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],round(S1),round(S1),0);
          end;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[5].Steuerung[22].GUID) and EventFired then
    begin // Bühnenansichtgerät 16-Bit PAN/TILT
      if not IsEqualGUID(grafischebuehnenansicht.MouseOnDeviceID, StringToGUID('{00000000-0000-0000-0000-000000000000}')) then
      begin
        if (AktuellerBefehl.ArgInteger[0]=0) or (AktuellerBefehl.ArgInteger[0]=2) then
        begin
          // Hier abfrage, ob get_channel(PanFine)=-1 und get_channel(TiltFine)=-1. Dann nämlich nur 8-Bit-Steuerung anwenden!!!

          if geraetesteuerung.get_channel(Devices[geraetesteuerung.GetDevicePositionInDeviceArray(@grafischebuehnenansicht.MouseOnDeviceID)].ID, 'PANFINE')>-1 then
          begin
            // 16-Bit PAN
            // Aktuellen Wert holen
            S1:=geraetesteuerung.get_channel(grafischebuehnenansicht.MouseOnDeviceID, 'PAN')+(geraetesteuerung.get_channel(grafischebuehnenansicht.MouseOnDeviceID, 'PANFINE')/256);
            // Aktuellen Wert auf 128 zentrieren, mit Faktor multiplizieren und diesen Wert auf aktuellen Wert aufaddieren
  //          S1:=S1+(((Value-128)*1)*AktuellerBefehl.ArgInteger[1]/1000); // Linearer Verlauf
            S1:=S1+((sign(Value-128)*(Value-128)*(Value-128)/128)*AktuellerBefehl.ArgInteger[1]/1000); // Exponentieller Verlauf
            // neuen Wert wieder auf PAN und PANFINE setzen
            geraetesteuerung.set_channel(grafischebuehnenansicht.MouseOnDeviceID,'PAN',trunc(S1),trunc(S1),0);
            geraetesteuerung.set_channel(grafischebuehnenansicht.MouseOnDeviceID,'PANFINE',trunc(frac(S1)*256),trunc(frac(S1)*256),0);
          end else
          begin
            // 8-Bit PAN
            S1:=geraetesteuerung.get_channel(grafischebuehnenansicht.MouseOnDeviceID, 'PAN');
            // Aktuellen Wert auf 128 zentrieren, mit Faktor multiplizieren und diesen Wert auf aktuellen Wert aufaddieren
//              S1:=S1+(((Value-128))*AktuellerBefehl.ArgInteger[1]/1000); // Linearer Verlauf
            S1:=S1+((sign(Value-128)*(Value-128)*(Value-128)/128)*AktuellerBefehl.ArgInteger[1]/1000); // Exponentieller Verlauf
            // neuen Wert wieder setzen
            geraetesteuerung.set_channel(grafischebuehnenansicht.MouseOnDeviceID,'PAN',round(S1),round(S1),0);
          end;
        end else if (AktuellerBefehl.ArgInteger[0]=1) or (AktuellerBefehl.ArgInteger[0]=3) then
        begin
          // Hier abfrage, ob get_channel(PanFine)=-1 und get_channel(TiltFine)=-1. Dann nämlich nur 8-Bit-Steuerung anwenden!!!

          if geraetesteuerung.get_channel(Devices[geraetesteuerung.GetDevicePositionInDeviceArray(@grafischebuehnenansicht.MouseOnDeviceID)].ID, 'TILTFINE')>-1 then
          begin
            // 16-Bit TILT
            // Aktuellen Wert holen
            S1:=geraetesteuerung.get_channel(grafischebuehnenansicht.MouseOnDeviceID, 'TILT')+(geraetesteuerung.get_channel(grafischebuehnenansicht.MouseOnDeviceID, 'TILTFINE')/256);
            // Aktuellen Wert auf 128 zentrieren, mit Faktor multiplizieren und diesen Wert auf aktuellen Wert aufaddieren
  //          S1:=S1+(((Value-128)*1)*AktuellerBefehl.ArgInteger[1]/1000); // Linearer Verlauf
            S1:=S1+((sign(Value-128)*(Value-128)*(Value-128)/128)*AktuellerBefehl.ArgInteger[1]/1000); // Exponentieller Verlauf
            // neuen Wert wieder auf PAN und PANFINE setzen
            geraetesteuerung.set_channel(grafischebuehnenansicht.MouseOnDeviceID,'TILT',trunc(S1),trunc(S1),0);
            geraetesteuerung.set_channel(grafischebuehnenansicht.MouseOnDeviceID,'TILTFINE',trunc(frac(S1)*256),trunc(frac(S1)*256),0);
          end else
          begin
            // 8-Bit TILT
            S1:=geraetesteuerung.get_channel(grafischebuehnenansicht.MouseOnDeviceID, 'TILT');
            // Aktuellen Wert auf 128 zentrieren, mit Faktor multiplizieren und diesen Wert auf aktuellen Wert aufaddieren
//              S1:=S1+(((Value-128))*AktuellerBefehl.ArgInteger[1]/1000); // Linearer Verlauf
            S1:=S1+((sign(Value-128)*(Value-128)*(Value-128)/128)*AktuellerBefehl.ArgInteger[1]/1000); // Exponentieller Verlauf
            // neuen Wert wieder setzen
            geraetesteuerung.set_channel(grafischebuehnenansicht.MouseOnDeviceID,'TILT',round(S1),round(S1),0);
          end;
        end else
        begin
          // andere Kanäle
          // Aktuellen Wert holen
          S1:=geraetesteuerung.get_channel(grafischebuehnenansicht.MouseOnDeviceID, DeviceChannelNames[AktuellerBefehl.ArgInteger[0]]);
          // Aktuellen Wert auf 128 zentrieren, mit Faktor multiplizieren und diesen Wert auf aktuellen Wert aufaddieren
//          S1:=S1+(((Value-128))*AktuellerBefehl.ArgInteger[1]/1000); // Linearer Verlauf
          S1:=S1+((sign(Value-128)*(Value-128)*(Value-128)/128)*AktuellerBefehl.ArgInteger[1]/1000); // Exponentieller Verlauf
          // neuen Wert wieder setzen
          geraetesteuerung.set_channel(grafischebuehnenansicht.MouseOnDeviceID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],round(S1),round(S1),0);
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[5].Steuerung[23].GUID) and EventFired then
    begin // Bestimmtes Gerät 16-Bit PAN/TILT
      for j:=0 to length(devices)-1 do
      begin
        if IsEqualGUID(AktuellerBefehl.ArgGUID[0],devices[j].ID) then
        begin
          if (AktuellerBefehl.ArgInteger[0]=0) or (AktuellerBefehl.ArgInteger[0]=2) then
          begin
            // Hier abfrage, ob get_channel(PanFine)=-1 und get_channel(TiltFine)=-1. Dann nämlich nur 8-Bit-Steuerung anwenden!!!

            if geraetesteuerung.get_channel(Devices[j].ID, 'PANFINE')>-1 then
            begin
              // 16-Bit PAN
              // Aktuellen Wert holen
              S1:=geraetesteuerung.get_channel(Devices[j].ID, 'PAN')+(geraetesteuerung.get_channel(Devices[j].ID, 'PANFINE')/256);
              // Aktuellen Wert auf 128 zentrieren, mit Faktor multiplizieren und diesen Wert auf aktuellen Wert aufaddieren
  //            S1:=S1+(((Value-128)*1)*AktuellerBefehl.ArgInteger[1]/1000); // Linearer Verlauf
              S1:=S1+((sign(Value-128)*(Value-128)*(Value-128)/128)*AktuellerBefehl.ArgInteger[1]/1000); // Exponentieller Verlauf
              // neuen Wert wieder auf PAN und PANFINE setzen
              geraetesteuerung.set_channel(Devices[j].ID,'PAN',trunc(S1),trunc(S1),0);
              geraetesteuerung.set_channel(Devices[j].ID,'PANFINE',trunc(frac(S1)*256),trunc(frac(S1)*256),0);
            end else
            begin
              // 8-Bit PAN
              S1:=geraetesteuerung.get_channel(Devices[j].ID, 'PAN');
              // Aktuellen Wert auf 128 zentrieren, mit Faktor multiplizieren und diesen Wert auf aktuellen Wert aufaddieren
  //              S1:=S1+(((Value-128))*AktuellerBefehl.ArgInteger[1]/1000); // Linearer Verlauf
              S1:=S1+((sign(Value-128)*(Value-128)*(Value-128)/128)*AktuellerBefehl.ArgInteger[1]/1000); // Exponentieller Verlauf
              // neuen Wert wieder setzen
              geraetesteuerung.set_channel(Devices[j].ID,'PAN',round(S1),round(S1),0);
            end;
          end else if (AktuellerBefehl.ArgInteger[0]=1) or (AktuellerBefehl.ArgInteger[0]=3) then
          begin
            // Hier abfrage, ob get_channel(PanFine)=-1 und get_channel(TiltFine)=-1. Dann nämlich nur 8-Bit-Steuerung anwenden!!!

            if geraetesteuerung.get_channel(Devices[j].ID, 'TILTFINE')>-1 then
            begin
              // 16-Bit TILT
              // Aktuellen Wert holen
              S1:=geraetesteuerung.get_channel(Devices[j].ID, 'TILT')+(geraetesteuerung.get_channel(Devices[j].ID, 'TILTFINE')/256);
              // Aktuellen Wert auf 128 zentrieren, mit Faktor multiplizieren und diesen Wert auf aktuellen Wert aufaddieren
  //            S1:=S1+(((Value-128)*1)*AktuellerBefehl.ArgInteger[1]/1000); // Linearer Verlauf
              S1:=S1+((sign(Value-128)*(Value-128)*(Value-128)/128)*AktuellerBefehl.ArgInteger[1]/1000); // Exponentieller Verlauf
              // neuen Wert wieder auf PAN und PANFINE setzen
              geraetesteuerung.set_channel(Devices[j].ID,'TILT',trunc(S1),trunc(S1),0);
              geraetesteuerung.set_channel(Devices[j].ID,'TILTFINE',trunc(frac(S1)*256),trunc(frac(S1)*256),0);
            end else
            begin
              // 8-Bit TILT
              S1:=geraetesteuerung.get_channel(Devices[j].ID, 'TILT');
              // Aktuellen Wert auf 128 zentrieren, mit Faktor multiplizieren und diesen Wert auf aktuellen Wert aufaddieren
  //              S1:=S1+(((Value-128))*AktuellerBefehl.ArgInteger[1]/1000); // Linearer Verlauf
              S1:=S1+((sign(Value-128)*(Value-128)*(Value-128)/128)*AktuellerBefehl.ArgInteger[1]/1000); // Exponentieller Verlauf
              // neuen Wert wieder setzen
              geraetesteuerung.set_channel(Devices[j].ID,'TILT',round(S1),round(S1),0);
            end;
          end else
          begin
            // andere Kanäle
            // Aktuellen Wert holen
            S1:=geraetesteuerung.get_channel(Devices[j].ID, DeviceChannelNames[AktuellerBefehl.ArgInteger[0]]);
            // Aktuellen Wert auf 128 zentrieren, mit Faktor multiplizieren und diesen Wert auf aktuellen Wert aufaddieren
//            S1:=S1+(((Value-128))*AktuellerBefehl.ArgInteger[1]/1000); // Linearer Verlauf
            S1:=S1+((sign(Value-128)*(Value-128)*(Value-128)/128)*AktuellerBefehl.ArgInteger[1]/1000); // Exponentieller Verlauf
            // neuen Wert wieder setzen
            geraetesteuerung.set_channel(Devices[j].ID,DeviceChannelNames[AktuellerBefehl.ArgInteger[0]],round(S1),round(S1),0);
          end;
        end;
      end;
      exit;
    end;

    // Geräte-/Gruppensetup
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[6].Steuerung[0].GUID) and EventFired then
    begin // Selektiere nur dieses Gerät
      for j:=0 to length(devices)-1 do
      begin
        if IsEqualGUID(devices[j].ID,AktuellerBefehl.ArgGUID[0]) then
        begin
          deviceselected[j]:=true;
        end else
        begin
          deviceselected[j]:=false;
        end;
      end;
      DeviceSelectionChanged(nil);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[6].Steuerung[1].GUID) and EventFired then
    begin // Geräteselektion ein/aus
      for j:=0 to length(devices)-1 do
      begin
        if IsEqualGUID(devices[j].ID,AktuellerBefehl.ArgGUID[0]) then
        begin
          deviceselected[j]:=not deviceselected[j];
          break;
        end;
      end;
      DeviceSelectionChanged(nil);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[6].Steuerung[2].GUID) and EventFired then
    begin // Selektierung ein
      for j:=0 to length(devices)-1 do
      begin
        if IsEqualGUID(devices[j].ID,AktuellerBefehl.ArgGUID[0]) then
        begin
          deviceselected[j]:=true;
          break;
        end;
      end;
      DeviceSelectionChanged(nil);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[6].Steuerung[3].GUID) and EventFired then
    begin // Selektierung aus
      for j:=0 to length(devices)-1 do
      begin
        if IsEqualGUID(devices[j].ID,AktuellerBefehl.ArgGUID[0]) then
        begin
          deviceselected[j]:=false;
          break;
        end;
      end;
      DeviceSelectionChanged(nil);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[6].Steuerung[4].GUID) and EventFired then
    begin // Selektiere nur diese Gruppe
      SelectDeviceGroup(AktuellerBefehl.ArgGUID[0], false);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[6].Steuerung[5].GUID) and EventFired then
    begin // Gruppenselektion ein/aus
      for j:=0 to length(devicegroups)-1 do
      begin
        if IsEqualGUID(devicegroups[j].ID,AktuellerBefehl.ArgGUID[0]) then
        begin
          for k:=0 to length(devicegroups[j].IDs)-1 do
          begin
            tempvar:=geraetesteuerung.GetDevicePositionInDeviceArray(@devicegroups[j].IDs[k]);
            deviceselected[tempvar]:=not deviceselected[tempvar];
          end;
          break;
        end;
      end;
      DeviceSelectionChanged(nil);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[6].Steuerung[6].GUID) and EventFired then
    begin // Gruppenselektion ein
      SelectDeviceGroup(AktuellerBefehl.ArgGUID[0], true);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[6].Steuerung[7].GUID) and EventFired then
    begin // Gruppenselektion aus
      DeSelectDeviceGroup(AktuellerBefehl.ArgGUID[0]);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[6].Steuerung[8].GUID) and EventFired then
    begin // Selektion aus
      for j:=0 to length(devices)-1 do
      begin
        deviceselected[j]:=false;
      end;
      DeviceSelectionChanged(nil);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[6].Steuerung[9].GUID) and EventFired then
    begin // Kalibrierung setzen
      for j:=0 to length(devices)-1 do
      begin
        if IsEqualGUID(devices[j].ID,AktuellerBefehl.ArgGUID[0]) then
        begin
          devices[j].typeofscannercalibration:=AktuellerBefehl.ArgInteger[0];
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[6].Steuerung[10].GUID) and EventFired then
    begin // Kalibrierung setzen (Gruppe)
      for j:=0 to length(devicegroups)-1 do
      begin
        if IsEqualGUID(devicegroups[j].ID,AktuellerBefehl.ArgGUID[0]) then
        begin
          for k:=0 to length(devicegroups[j].IDs)-1 do
          begin
            devices[geraetesteuerung.GetDevicePositionInDeviceArray(@devicegroups[j].IDs[k])].typeofscannercalibration:=AktuellerBefehl.ArgInteger[0];
          end;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[6].Steuerung[11].GUID) and EventFired then
    begin // Invert PAN ein/aus
      for j:=0 to length(devices)-1 do
      begin
        if IsEqualGUID(devices[j].ID,AktuellerBefehl.ArgGUID[0]) then
        begin
          devices[j].invertpan:=not devices[j].invertpan;
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[6].Steuerung[12].GUID) and EventFired then
    begin // Invert PAN ein
      for j:=0 to length(devices)-1 do
      begin
        if IsEqualGUID(devices[j].ID,AktuellerBefehl.ArgGUID[0]) then
        begin
          devices[j].invertpan:=true;
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[6].Steuerung[13].GUID) and EventFired then
    begin // Invert PAN aus
      for j:=0 to length(devices)-1 do
      begin
        if IsEqualGUID(devices[j].ID,AktuellerBefehl.ArgGUID[0]) then
        begin
          devices[j].invertpan:=false;
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[6].Steuerung[14].GUID) and EventFired then
    begin // Invert TILT ein/aus
      for j:=0 to length(devices)-1 do
      begin
        if IsEqualGUID(devices[j].ID,AktuellerBefehl.ArgGUID[0]) then
        begin
          devices[j].inverttilt:=not devices[j].inverttilt;
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[6].Steuerung[15].GUID) and EventFired then
    begin // Invert TILT ein
      for j:=0 to length(devices)-1 do
      begin
        if IsEqualGUID(devices[j].ID,AktuellerBefehl.ArgGUID[0]) then
        begin
          devices[j].inverttilt:=true;
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[6].Steuerung[16].GUID) and EventFired then
    begin // Invert TILT aus
      for j:=0 to length(devices)-1 do
      begin
        if IsEqualGUID(devices[j].ID,AktuellerBefehl.ArgGUID[0]) then
        begin
          devices[j].inverttilt:=false;
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[6].Steuerung[17].GUID) and EventFired then
    begin // Autoszenen ein/aus
      for j:=0 to length(devices)-1 do
      begin
        if IsEqualGUID(devices[j].ID,AktuellerBefehl.ArgGUID[0]) then
        begin
          devices[j].autoscening:=not devices[j].autoscening;
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[6].Steuerung[18].GUID) and EventFired then
    begin // Autoszenen ein
      for j:=0 to length(devices)-1 do
      begin
        if IsEqualGUID(devices[j].ID,AktuellerBefehl.ArgGUID[0]) then
        begin
          devices[j].autoscening:=true;
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[6].Steuerung[19].GUID) and EventFired then
    begin // Autoszenen aus
      for j:=0 to length(devices)-1 do
      begin
        if IsEqualGUID(devices[j].ID,AktuellerBefehl.ArgGUID[0]) then
        begin
          devices[j].autoscening:=false;
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[6].Steuerung[20].GUID) and EventFired then
    begin // Gruppe aktiviert/deaktiviert
      for j:=0 to length(devicegroups)-1 do
      begin
        if IsEqualGUID(devicegroups[j].ID,AktuellerBefehl.ArgGUID[0]) then
        begin
          devicegroups[j].Active:=not devicegroups[j].Active;
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[6].Steuerung[21].GUID) and EventFired then
    begin // Gruppe aktiviert
      for j:=0 to length(devicegroups)-1 do
      begin
        if IsEqualGUID(devicegroups[j].ID,AktuellerBefehl.ArgGUID[0]) then
        begin
          devicegroups[j].Active:=true;
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[6].Steuerung[22].GUID) and EventFired then
    begin // Gruppe deaktiviert
      for j:=0 to length(devicegroups)-1 do
      begin
        if IsEqualGUID(devicegroups[j].ID,AktuellerBefehl.ArgGUID[0]) then
        begin
          devicegroups[j].Active:=false;
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[6].Steuerung[23].GUID) then
    begin // Gruppe Fanning-Modus auf Eingangswert
      for j:=0 to length(devicegroups)-1 do
      begin
        if IsEqualGUID(devicegroups[j].ID,AktuellerBefehl.ArgGUID[0]) then
        begin
          devicegroups[j].FanMode:=Value;
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[6].Steuerung[24].GUID) then
    begin // Gruppe Fanning-Master auf Eingangswert
      for j:=0 to length(devicegroups)-1 do
      begin
        if IsEqualGUID(devicegroups[j].ID,AktuellerBefehl.ArgGUID[0]) then
        begin
          devicegroups[j].MasterDevice:=devicegroups[j].IDs[trunc((length(devicegroups[j].IDs)-1)*(Value/255))];
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[6].Steuerung[25].GUID) then
    begin // Gruppe Fanning-Modus setzen
      for j:=0 to length(devicegroups)-1 do
      begin
        if IsEqualGUID(devicegroups[j].ID,AktuellerBefehl.ArgGUID[0]) then
        begin
          devicegroups[j].FanMode:=AktuellerBefehl.ArgInteger[0];
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[6].Steuerung[26].GUID) then
    begin // Gruppe Fanning-Master setzen
      for j:=0 to length(devicegroups)-1 do
      begin
        if IsEqualGUID(devicegroups[j].ID,AktuellerBefehl.ArgGUID[0]) then
        begin
          devicegroups[j].MasterDevice:=devicegroups[j].IDs[trunc((length(devicegroups[j].IDs)-1)*(AktuellerBefehl.ArgInteger[0]/255))];
          break;
        end;
      end;
      exit;
    end;

    // Cueliste
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[7].Steuerung[0].GUID) and EventFired then
    begin // Start
      if cuelistform.playBtn.Enabled then cuelistform.playBtn.Click;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[7].Steuerung[1].GUID) and EventFired then
    begin // Stop
      if cuelistform.stopBtn.Enabled then cuelistform.stopBtn.Click;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[7].Steuerung[2].GUID) and EventFired then
    begin // Abspielen und nächstes Selektieren
      if cuelistform.playBtn.Enabled then cuelistform.playBtn.Click;
      if cuelistform.StringGrid1.Row<cuelistform.StringGrid1.RowCount-1 then
        cuelistform.StringGrid1.Row:=cuelistform.StringGrid1.Row+1;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[7].Steuerung[3].GUID) and EventFired then
    begin // Vorheriges Objekt abspielen 
      if cuelistform.backBtn.Enabled then cuelistform.backBtn.Click;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[7].Steuerung[4].GUID) and EventFired then
    begin // Nächstes Objekt abspielen
      if cuelistform.nextBtn.Enabled then cuelistform.nextBtn.Click;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[7].Steuerung[5].GUID) and EventFired then
    begin // Vorherige Bank
      if (cuelistform.BankSelect.ItemIndex-1)>=0 then
      begin
        cuelistform.BankSelect.ItemIndex:=cuelistform.BankSelect.ItemIndex-1;
        cuelistform.BankSelectChange(cuelistform.BankSelect);
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[7].Steuerung[6].GUID) and EventFired then
    begin // Nächste Bank
      if (cuelistform.BankSelect.ItemIndex+1)<cuelistform.BankSelect.Items.Count then
      begin
        cuelistform.BankSelect.ItemIndex:=cuelistform.BankSelect.ItemIndex+1;
        cuelistform.BankSelectChange(cuelistform.BankSelect);
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[7].Steuerung[7].GUID) and EventFired then
    begin // Record-Button
      if ((cuelistform.BankSelect.ItemIndex+1)<cuelistform.BankSelect.Items.Count) and (cuelistform.recordbtn.Enabled) then
      begin
        case AktuellerBefehl.ArgInteger[0] of
          0: cuelistform.AlleKanleaufnehmen1Click(nil);
          1: cuelistform.NurselektierteGerteaufnehmen1Click(nil);
          2: cuelistform.NurseitletzterSzenegenderteKanleaufnehmen1Click(nil);
          3: cuelistform.SelektierteGerteUNDgenderteKanleaufnehmen1Click(nil);
          4: cuelistform.Szenemanuelleinstellen1Click(nil);
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[7].Steuerung[8].GUID) then
    begin // Crossfader verstellen
      if (cuelistform.Showing) and (cuelistform.BankSelect.ItemIndex>-1) and ((cuelistform.BankSelect.ItemIndex)<cuelistform.BankSelect.Items.Count) and (cuelistform.TrackBar1.Enabled) then
      begin
        cuelistform.TrackBar1.SetFocus;

        cuelistform.TrackBar1Enter(cuelistform.Trackbar1);
        cuelistform.TrackBar1.Position:=Value;
        cuelistform.TrackBar1Change(cuelistform.Trackbar1);
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[7].Steuerung[9].GUID) and EventFired then
    begin // An den Anfang springen
      if cuelistform.BankSelect.ItemIndex<cuelistform.BankSelect.Items.Count then
      begin
        cuelistform.StringGrid1.Row:=1;
      end;
      exit;
    end;

    // Videoscreen
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[8].Steuerung[0].GUID) and EventFired then
    begin // Play
      if videoscreenform<>nil then
      begin
        case AktuellerBefehl.ArgInteger[0] of
          0: videoscreenform.Filtergraph1.Play; // Videoscreen Play
          1: videoscreenform.Filtergraph2.Play; // Videoscreen Play
          2: videoscreenform.Filtergraph3.Play; // Videoscreen Play
          3: videoscreenform.Filtergraph4.Play; // Videoscreen Play
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[8].Steuerung[1].GUID) and EventFired then
    begin // Play von Beginn
      if videoscreenform<>nil then
      begin
        videoscreenform.SetVideoPosition(AktuellerBefehl.ArgInteger[0]+1,0);
        case AktuellerBefehl.ArgInteger[0] of
          0: videoscreenform.Filtergraph1.Play;
          1: videoscreenform.Filtergraph2.Play;
          2: videoscreenform.Filtergraph3.Play;
          3: videoscreenform.Filtergraph4.Play;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[8].Steuerung[2].GUID) and EventFired then
    begin // Pause
      if videoscreenform<>nil then
      begin
        case AktuellerBefehl.ArgInteger[0] of
          0: videoscreenform.Filtergraph1.Pause; // Videoscreen Pause
          1: videoscreenform.Filtergraph2.Pause; // Videoscreen Pause
          2: videoscreenform.Filtergraph3.Pause; // Videoscreen Pause
          3: videoscreenform.Filtergraph4.Pause; // Videoscreen Pause
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[8].Steuerung[3].GUID) and EventFired then
    begin // Stop
      if videoscreenform<>nil then
      begin
        case AktuellerBefehl.ArgInteger[0] of
          0: videoscreenform.Filtergraph1.Stop; // Videoscreen Stop
          1: videoscreenform.Filtergraph2.Stop; // Videoscreen Stop
          2: videoscreenform.Filtergraph3.Stop; // Videoscreen Stop
          3: videoscreenform.Filtergraph4.Stop; // Videoscreen Stop
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[8].Steuerung[4].GUID) and EventFired then
    begin // Springe zu Position
      if videoscreenform<>nil then
      begin
        videoscreenform.SetVideoPosition(AktuellerBefehl.ArgInteger[0]+1,AktuellerBefehl.ArgInteger[1]);
      end;
      exit;
    end;

    // Effekte
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[9].Steuerung[0].GUID) and EventFired then
    begin // Start/Stop
      for j:=0 to length(effektsequenzereffekte)-1 do
      begin
        if IsEqualGUID(AktuellerBefehl.ArgGUID[0],effektsequenzereffekte[j].ID) then
        begin
          if AktuellerEffekt[j].Aktiv then
            StopEffekt(AktuellerBefehl.ArgGUID[0])
          else
            StartEffekt(AktuellerBefehl.ArgGUID[0]);
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[9].Steuerung[1].GUID) and EventFired then
    begin // Start
      StartEffekt(AktuellerBefehl.ArgGUID[0]);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[9].Steuerung[2].GUID) and EventFired then
    begin // Stop
      StopEffekt(AktuellerBefehl.ArgGUID[0]);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[9].Steuerung[3].GUID) then
    begin // Flash
      if length(AktuellerBefehl.ArgGUID)>0 then
      if EventFired then
        StartEffekt(AktuellerBefehl.ArgGUID[0])
      else
        StopEffekt(AktuellerBefehl.ArgGUID[0]);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[9].Steuerung[4].GUID) and EventFired then
    begin // Nächster Schritt
      for j:=0 to length(effektsequenzereffekte)-1 do
      begin
        if IsEqualGUID(AktuellerBefehl.ArgGUID[0],effektsequenzereffekte[j].ID) then
        begin
          AktuellerEffekt[j].PleaseStopOnNextStep:=false; // otherwise you have to click twice
          EffektSchaltvorgang(j, nil);
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[9].Steuerung[5].GUID) and EventFired then
    begin // Bestimmten Schritt starten
      for j:=0 to length(effektsequenzereffekte)-1 do
      begin
        if IsEqualGUID(AktuellerBefehl.ArgGUID[0],effektsequenzereffekte[j].ID) and (AktuellerBefehl.ArgInteger[0]<length(effektsequenzereffekte[j].Effektschritte)) then
        begin
          StartEffektstep(effektsequenzereffekte[j].ID, AktuellerBefehl.ArgInteger[0]);
          AktuellerEffekt[j].AktuellerSchritt:=AktuellerBefehl.ArgInteger[0];
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[9].Steuerung[6].GUID) and EventFired then
    begin // Intensität setzen
      for j:=0 to length(effektsequenzereffekte)-1 do
      begin
        if IsEqualGUID(AktuellerBefehl.ArgGUID[0],effektsequenzereffekte[j].ID) then
        begin
          effektsequenzereffekte[j].intensitaet:=AktuellerBefehl.ArgInteger[0];
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[9].Steuerung[7].GUID) then
    begin // Intensität auf Eingangswert setzen
      for j:=0 to length(effektsequenzereffekte)-1 do
      begin
        if IsEqualGUID(AktuellerBefehl.ArgGUID[0],effektsequenzereffekte[j].ID) then
        begin
          effektsequenzereffekte[j].intensitaet:=Value;
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[9].Steuerung[8].GUID) and EventFired then
    begin // Beschleunigung setzen
      for j:=0 to length(effektsequenzereffekte)-1 do
      begin
        if IsEqualGUID(AktuellerBefehl.ArgGUID[0],effektsequenzereffekte[j].ID) then
        begin
          effektsequenzereffekte[j].speed:=AktuellerBefehl.ArgInteger[0];
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[9].Steuerung[9].GUID) and EventFired then
    begin // Wiederholung ein/aus
      for j:=0 to length(effektsequenzereffekte)-1 do
      begin
        if IsEqualGUID(AktuellerBefehl.ArgGUID[0],effektsequenzereffekte[j].ID) then
        begin
          effektsequenzereffekte[j].Repeating:=not effektsequenzereffekte[j].Repeating;
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[9].Steuerung[10].GUID) and EventFired then
    begin // Modus setzen
      for j:=0 to length(effektsequenzereffekte)-1 do
      begin
        if IsEqualGUID(AktuellerBefehl.ArgGUID[0],effektsequenzereffekte[j].ID) then
        begin
          effektsequenzereffekte[j].Modus:=AktuellerBefehl.ArgInteger[0];
          break;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[9].Steuerung[11].GUID) and EventFired then
    begin // Alle Effekte stoppen
      for j:=0 to length(AktuellerEffekt)-1 do
      begin
        StopEffekt(effektsequenzereffekte[j].ID);
        //AktuellerEffekt[j].Aktiv:=False;
      end;
      exit;
    end;

    // Submaster
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[10].Steuerung[0].GUID) then
    begin // Auf Eingangswert schalten
      if (AktuellerBefehl.ArgInteger[0]>0) and (AktuellerBefehl.ArgInteger[0]<17) then
        submasterform.ChangeSubmaster(AktuellerBefehl.ArgInteger[0], Value);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[10].Steuerung[1].GUID) and EventFired then
    begin // Auf festen Wert schalten
      if (AktuellerBefehl.ArgInteger[0]>0) and (AktuellerBefehl.ArgInteger[0]<17) then
        submasterform.ChangeSubmaster(AktuellerBefehl.ArgInteger[0], AktuellerBefehl.ArgInteger[1]);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[10].Steuerung[2].GUID) then
    begin // Auf festen Wert flashen
      if (AktuellerBefehl.ArgInteger[0]>0) and (AktuellerBefehl.ArgInteger[0]<17) then
      begin
        submasterform.slidervalue_temp[AktuellerBefehl.ArgInteger[0]-1]:=mainform.Submasterbank[BankSelect.ItemIndex].CurrentValue[AktuellerBefehl.ArgInteger[0]];
        if EventFired then
          submasterform.ChangeSubmaster(AktuellerBefehl.ArgInteger[0], AktuellerBefehl.ArgInteger[1])
        else
          submasterform.ChangeSubmaster(AktuellerBefehl.ArgInteger[0], submasterform.slidervalue_temp[AktuellerBefehl.ArgInteger[0]-1]);
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[10].Steuerung[3].GUID) and EventFired then
    begin // Auf abgefragten Wert schalten
      if (AktuellerBefehl.ArgInteger[0]>0) and (AktuellerBefehl.ArgInteger[0]<17) then
      begin
        input:=strtoint(InputBox(_('Faderwert eingeben'),_('Bitte geben Sie einen Faderwert [0..255] ein, auf den der Fader "')+submasterbank[submasterform.BankSelect.Itemindex].SubmasterName[AktuellerBefehl.ArgInteger[0]]+_('" gesetzt werden soll:'),'0'));
        submasterform.slidervalue_temp[AktuellerBefehl.ArgInteger[0]-1]:=mainform.Submasterbank[BankSelect.ItemIndex].CurrentValue[AktuellerBefehl.ArgInteger[0]];
        submasterform.ChangeSubmaster(AktuellerBefehl.ArgInteger[0], input);
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[10].Steuerung[4].GUID) and EventFired then
    begin // Faderwert +
      if (AktuellerBefehl.ArgInteger[0]>0) and (AktuellerBefehl.ArgInteger[0]<17) then
        if mainform.Submasterbank[BankSelect.ItemIndex].CurrentValue[AktuellerBefehl.ArgInteger[0]]+AktuellerBefehl.ArgInteger[1]<=255 then
          submasterform.ChangeSubmaster(AktuellerBefehl.ArgInteger[0], mainform.Submasterbank[BankSelect.ItemIndex].CurrentValue[AktuellerBefehl.ArgInteger[0]]+AktuellerBefehl.ArgInteger[1]);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[10].Steuerung[5].GUID) and EventFired then
    begin // Faderwert -
      if (AktuellerBefehl.ArgInteger[0]>0) and (AktuellerBefehl.ArgInteger[0]<17) then
        if mainform.Submasterbank[BankSelect.ItemIndex].CurrentValue[AktuellerBefehl.ArgInteger[0]]-AktuellerBefehl.ArgInteger[1]>=0 then
          submasterform.ChangeSubmaster(AktuellerBefehl.ArgInteger[0], mainform.Submasterbank[BankSelect.ItemIndex].CurrentValue[AktuellerBefehl.ArgInteger[0]]-AktuellerBefehl.ArgInteger[1]);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[10].Steuerung[6].GUID) and EventFired then
    begin // Vorherige Bank
      if (submasterform.BankSelect.ItemIndex-1)>=0 then
      begin
        submasterform.BankSelect.ItemIndex:=submasterform.BankSelect.ItemIndex-1;
        submasterform.BankSelectChange(submasterform.BankSelect);
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[10].Steuerung[7].GUID) and EventFired then
    begin // Nächste Bank
      if (submasterform.BankSelect.ItemIndex+1)<submasterform.BankSelect.Items.Count then
      begin
        submasterform.BankSelect.ItemIndex:=submasterform.BankSelect.ItemIndex+1;
        submasterform.BankSelectChange(submasterform.BankSelect);
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[10].Steuerung[8].GUID) and EventFired then
    begin // Bestimmte Bank
      if (AktuellerBefehl.ArgInteger[0]>0) and (AktuellerBefehl.ArgInteger[0]<submasterform.BankSelect.Items.Count+1) then
      begin
        submasterform.BankSelect.ItemIndex:=AktuellerBefehl.ArgInteger[0]-1;
        submasterform.BankSelectChange(submasterform.BankSelect);
      end;
      exit;
    end;

    // Kontrollpanel
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[11].Steuerung[0].GUID) and EventFired then
    begin // Button schalten
      kontrollpanel.OverBtn.X:=AktuellerBefehl.ArgInteger[1]-1;
      kontrollpanel.OverBtn.Y:=AktuellerBefehl.ArgInteger[0]-1;

      //kontrollpanel.PaintBox1MouseMove(nil, [], trunc(kontrollpanel.btnwidth.Value*(AktuellerBefehl.ArgInteger[1]-1)+(kontrollpanel.btnwidth.Value / 2)), trunc(kontrollpanel.btnheight.Value*(AktuellerBefehl.ArgInteger[0]-1)+(kontrollpanel.btnheight.Value / 2)));
      kontrollpanel.PaintBox1MouseDown(nil, mbLeft, [ssLeft], trunc(kontrollpanel.btnwidth.Value*(AktuellerBefehl.ArgInteger[1]-1)+(kontrollpanel.btnwidth.Value / 2)), trunc(kontrollpanel.btnheight.Value*(AktuellerBefehl.ArgInteger[0]-1)+(kontrollpanel.btnheight.Value / 2)));
      kontrollpanel.PaintBox1MouseUp(nil, mbLeft, [], trunc(kontrollpanel.btnwidth.Value*(AktuellerBefehl.ArgInteger[1]-1)+(kontrollpanel.btnwidth.Value / 2)), trunc(kontrollpanel.btnheight.Value*(AktuellerBefehl.ArgInteger[0]-1)+(kontrollpanel.btnheight.Value / 2)));
  //    kontrollpanel.button[(AktuellerBefehl.ArgInteger[0]-1)-1][(AktuellerBefehl.ArgInteger[1]-1)-1].OnMouseDown(kontrollpanel.button[(AktuellerBefehl.ArgInteger[0]-1)-1][(AktuellerBefehl.ArgInteger[1]-1)-1],mbLeft,[ssLeft],0,0);
  //    kontrollpanel.button[(AktuellerBefehl.ArgInteger[0]-1)-1][(AktuellerBefehl.ArgInteger[1]-1)-1].OnMouseUp(kontrollpanel.button[(AktuellerBefehl.ArgInteger[0]-1)-1][(AktuellerBefehl.ArgInteger[1]-1)-1],mbLeft,[],0,0);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[11].Steuerung[1].GUID) then
    begin // Button ein/aus
      kontrollpanel.OverBtn.X:=AktuellerBefehl.ArgInteger[1]-1;
      kontrollpanel.OverBtn.Y:=AktuellerBefehl.ArgInteger[0]-1;
      //kontrollpanel.PaintBox1MouseMove(nil, [], trunc(kontrollpanel.btnwidth.Value*(AktuellerBefehl.ArgInteger[1]-1)+(kontrollpanel.btnwidth.Value / 2)), trunc(kontrollpanel.btnheight.Value*(AktuellerBefehl.ArgInteger[0]-1)+(kontrollpanel.btnheight.Value / 2)));
      if EventFired then
      begin
        if not kontrollpanelbuttons[kontrollpanel.OverBtn.Y][kontrollpanel.OverBtn.X].Down then
          kontrollpanel.PaintBox1MouseDown(nil, mbLeft, [ssLeft], trunc(kontrollpanel.btnwidth.Value*(AktuellerBefehl.ArgInteger[1]-1)+(kontrollpanel.btnwidth.Value / 2)), trunc(kontrollpanel.btnheight.Value*(AktuellerBefehl.ArgInteger[0]-1)+(kontrollpanel.btnheight.Value / 2)))
  //      kontrollpanel.button[(AktuellerBefehl.ArgInteger[0]-1)-1][(AktuellerBefehl.ArgInteger[1]-1)-1].OnMouseDown(kontrollpanel.button[(AktuellerBefehl.ArgInteger[0]-1)-1][(AktuellerBefehl.ArgInteger[1]-1)-1],mbLeft,[ssLeft],0,0)
      end else
      begin
        if kontrollpanelbuttons[kontrollpanel.OverBtn.Y][kontrollpanel.OverBtn.X].Down then
          kontrollpanel.PaintBox1MouseUp(nil, mbLeft, [], trunc(kontrollpanel.btnwidth.Value*(AktuellerBefehl.ArgInteger[1]-1)+(kontrollpanel.btnwidth.Value / 2)), trunc(kontrollpanel.btnheight.Value*(AktuellerBefehl.ArgInteger[0]-1)+(kontrollpanel.btnheight.Value / 2)));
  //      kontrollpanel.button[(AktuellerBefehl.ArgInteger[0]-1)-1][(AktuellerBefehl.ArgInteger[1]-1)-1].OnMouseUp(kontrollpanel.button[(AktuellerBefehl.ArgInteger[0]-1)-1][(AktuellerBefehl.ArgInteger[1]-1)-1],mbLeft,[],0,0);
      end;
      exit;
    end;

    // Joysticksteuerung
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[12].Steuerung[0].GUID) and EventFired then
    begin // Positionierung absolut/relativ
      joystickevents[AktuellerBefehl.ArgInteger[0]].positionrelativ:=not joystickevents[AktuellerBefehl.ArgInteger[0]].positionrelativ;
      if (joystickevents[AktuellerBefehl.ArgInteger[0]].positionrelativ=false) then
      begin
        if joystickform.RadioButton1.Checked then
        begin
          if AktuellerBefehl.ArgInteger[0]=0 then
            joystickform.PositionXY.Left:=(joystickform.fadenkreuz.Width div 2)-(joystickform.PositionXY.Width div 2)
          else if AktuellerBefehl.ArgInteger[0]=1 then
            joystickform.PositionXY.Top:=(joystickform.fadenkreuz.Height div 2)-(joystickform.PositionXY.Height div 2);
          joystickform.PositionXYMoved;
        end else if joystickform.Radiobutton2.Checked then
        begin
          if AktuellerBefehl.ArgInteger[0]=2 then
            joystickform.PositionXY.Left:=(joystickform.fadenkreuz.Width div 2)-(joystickform.PositionXY.Width div 2)
          else if AktuellerBefehl.ArgInteger[0]=3 then
            joystickform.PositionXY.Top:=(joystickform.fadenkreuz.Height div 2)-(joystickform.PositionXY.Height div 2);
          joystickform.PositionXYMoved;
        end else if joystickform.Radiobutton3.Checked then
        begin
          if AktuellerBefehl.ArgInteger[0]=4 then
            joystickform.PositionXY.Left:=(joystickform.fadenkreuz.Width div 2)-(joystickform.PositionXY.Width div 2)
          else if AktuellerBefehl.ArgInteger[0]=5 then
            joystickform.PositionXY.Top:=(joystickform.fadenkreuz.Height div 2)-(joystickform.PositionXY.Height div 2);
          joystickform.PositionXYMoved;
        end else if joystickform.Radiobutton4.Checked then
        begin
          if AktuellerBefehl.ArgInteger[0]=6 then
            joystickform.PositionXY.Left:=(joystickform.fadenkreuz.Width div 2)-(joystickform.PositionXY.Width div 2)
          else if AktuellerBefehl.ArgInteger[0]=7 then
            joystickform.PositionXY.Top:=(joystickform.fadenkreuz.Height div 2)-(joystickform.PositionXY.Height div 2);
          joystickform.PositionXYMoved;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[12].Steuerung[1].GUID) and EventFired then
    begin // Positionierung absolut
      joystickevents[AktuellerBefehl.ArgInteger[0]].positionrelativ:=false;
      if (joystickevents[AktuellerBefehl.ArgInteger[0]].positionrelativ=false) then
      begin
        if joystickform.RadioButton1.Checked then
        begin
          if AktuellerBefehl.ArgInteger[0]=0 then
            joystickform.PositionXY.Left:=(joystickform.fadenkreuz.Width div 2)-(joystickform.PositionXY.Width div 2)
          else if AktuellerBefehl.ArgInteger[0]=1 then
            joystickform.PositionXY.Top:=(joystickform.fadenkreuz.Height div 2)-(joystickform.PositionXY.Height div 2);
          joystickform.PositionXYMoved;
        end else if joystickform.Radiobutton2.Checked then
        begin
          if AktuellerBefehl.ArgInteger[0]=2 then
            joystickform.PositionXY.Left:=(joystickform.fadenkreuz.Width div 2)-(joystickform.PositionXY.Width div 2)
          else if AktuellerBefehl.ArgInteger[0]=3 then
            joystickform.PositionXY.Top:=(joystickform.fadenkreuz.Height div 2)-(joystickform.PositionXY.Height div 2);
          joystickform.PositionXYMoved;
        end else if joystickform.Radiobutton3.Checked then
        begin
          if AktuellerBefehl.ArgInteger[0]=4 then
            joystickform.PositionXY.Left:=(joystickform.fadenkreuz.Width div 2)-(joystickform.PositionXY.Width div 2)
          else if AktuellerBefehl.ArgInteger[0]=5 then
            joystickform.PositionXY.Top:=(joystickform.fadenkreuz.Height div 2)-(joystickform.PositionXY.Height div 2);
          joystickform.PositionXYMoved;
        end else if joystickform.Radiobutton4.Checked then
        begin
          if AktuellerBefehl.ArgInteger[0]=6 then
            joystickform.PositionXY.Left:=(joystickform.fadenkreuz.Width div 2)-(joystickform.PositionXY.Width div 2)
          else if AktuellerBefehl.ArgInteger[0]=7 then
            joystickform.PositionXY.Top:=(joystickform.fadenkreuz.Height div 2)-(joystickform.PositionXY.Height div 2);
          joystickform.PositionXYMoved;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[12].Steuerung[2].GUID) and EventFired then
    begin // Positionierung relativ
      joystickevents[AktuellerBefehl.ArgInteger[0]].positionrelativ:=true;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[12].Steuerung[3].GUID) and EventFired then
    begin // Position zentrieren
      joystickform.CenterBtnClick(nil);
      exit;
    end;
    // NodeControl
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[13].Steuerung[0].GUID) and EventFired then
    begin // Knotenset abrufen
      if (AktuellerBefehl.ArgInteger[0]<length(mainform.NodeControlSets)) then
      begin
        nodecontrolform.nodecontrolsetscombobox.ItemIndex:=AktuellerBefehl.ArgInteger[0];
        nodecontrolform.nodecontrolsetscomboboxChange(nil);
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[13].Steuerung[1].GUID) then
    begin // Knotenposition X auf Wert setzen
      if (AktuellerBefehl.ArgInteger[0]<length(mainform.NodeControlSets)) then
      begin
        if (AktuellerBefehl.ArgInteger[1]<length(mainform.NodeControlSets[AktuellerBefehl.ArgInteger[0]].NodeControlNodes)) then
        begin
          mainform.NodeControlSets[AktuellerBefehl.ArgInteger[0]].NodeControlNodes[AktuellerBefehl.ArgInteger[1]].X:=AktuellerBefehl.ArgInteger[2];
          nodecontrolform.PleaseRecalculateDistances:=true;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[13].Steuerung[2].GUID) then
    begin // Knotenposition Y auf Wert setzen
      if (AktuellerBefehl.ArgInteger[0]<length(mainform.NodeControlSets)) then
      begin
        if (AktuellerBefehl.ArgInteger[1]<length(mainform.NodeControlSets[AktuellerBefehl.ArgInteger[0]].NodeControlNodes)) then
        begin
          mainform.NodeControlSets[AktuellerBefehl.ArgInteger[0]].NodeControlNodes[AktuellerBefehl.ArgInteger[1]].Y:=AktuellerBefehl.ArgInteger[2];
          nodecontrolform.PleaseRecalculateDistances:=true;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[13].Steuerung[3].GUID) then
    begin // Knotenausdehnung auf Wert setzen
      if (AktuellerBefehl.ArgInteger[0]<length(mainform.NodeControlSets)) then
      begin
        mainform.NodeControlSets[AktuellerBefehl.ArgInteger[0]].stretching:=AktuellerBefehl.ArgInteger[1];
        nodecontrolform.CheckButtons;
        nodecontrolform.PleaseRecalculateDistances:=true;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[13].Steuerung[4].GUID) then
    begin // Knotenkontrast auf Wert setzen
      if (AktuellerBefehl.ArgInteger[0]<length(mainform.NodeControlSets)) then
      begin
        mainform.NodeControlSets[AktuellerBefehl.ArgInteger[0]].contrast:=AktuellerBefehl.ArgInteger[1];
        nodecontrolform.CheckButtons;
        nodecontrolform.PleaseRecalculateDistances:=true;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[13].Steuerung[5].GUID) then
    begin // Knotenfadezeit auf Wert setzen
      if (AktuellerBefehl.ArgInteger[0]<length(mainform.NodeControlSets)) then
      begin
        mainform.NodeControlSets[AktuellerBefehl.ArgInteger[0]].fadetime:=AktuellerBefehl.ArgInteger[1];
        nodecontrolform.CheckButtons;
        nodecontrolform.PleaseRecalculateDistances:=true;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[13].Steuerung[6].GUID) then
    begin // Knotenposition X auf Eingangswert
      if (AktuellerBefehl.ArgInteger[0]<length(mainform.NodeControlSets)) then
      begin
        if (AktuellerBefehl.ArgInteger[1]<length(mainform.NodeControlSets[AktuellerBefehl.ArgInteger[0]].NodeControlNodes)) then
        begin
          mainform.NodeControlSets[AktuellerBefehl.ArgInteger[0]].NodeControlNodes[AktuellerBefehl.ArgInteger[1]].X:=round((Value/255)*nodecontrolform.PaintBox1.Width);
          nodecontrolform.PleaseRecalculateDistances:=true;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[13].Steuerung[7].GUID) then
    begin // Knotenposition Y auf Eingangswert
      if (AktuellerBefehl.ArgInteger[0]<length(mainform.NodeControlSets)) then
      begin
        if (AktuellerBefehl.ArgInteger[1]<length(mainform.NodeControlSets[AktuellerBefehl.ArgInteger[0]].NodeControlNodes)) then
        begin
          mainform.NodeControlSets[AktuellerBefehl.ArgInteger[0]].NodeControlNodes[AktuellerBefehl.ArgInteger[1]].Y:=round((Value/255)*nodecontrolform.PaintBox1.Height);
          nodecontrolform.PleaseRecalculateDistances:=true;
        end;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[13].Steuerung[8].GUID) then
    begin // Knotenausdehnung auf Eingangswert
      if (AktuellerBefehl.ArgInteger[0]<length(mainform.NodeControlSets)) then
      begin
        mainform.NodeControlSets[AktuellerBefehl.ArgInteger[0]].stretching:=round((Value/255)*254000);
        nodecontrolform.CheckButtons;
        nodecontrolform.PleaseRecalculateDistances:=true;
      end;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[13].Steuerung[9].GUID) then
    begin // Knotenkontrast auf Eingangswert
      if (AktuellerBefehl.ArgInteger[0]<length(mainform.NodeControlSets)) then
      begin
        mainform.NodeControlSets[AktuellerBefehl.ArgInteger[0]].contrast:=round((Value/255)*50);
        nodecontrolform.CheckButtons;
        nodecontrolform.PleaseRecalculateDistances:=true;
      end;
      exit;
    end;
    // CD-Player
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[14].Steuerung[0].GUID) and EventFired then
    begin // Play
      cdplayerform.cdplaybtn.Click;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[14].Steuerung[1].GUID) and EventFired then
    begin // Pause
      cdplayerform.cdpausebtn.Click;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[14].Steuerung[2].GUID) and EventFired then
    begin // Stop
      cdplayerform.cdstop.Click;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[14].Steuerung[3].GUID) and EventFired then
    begin // Prev
      cdplayerform.cdprevious.Click;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[14].Steuerung[4].GUID) and EventFired then
    begin // Next
      cdplayerform.cdnext.Click;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[14].Steuerung[5].GUID) and EventFired then
    begin // Play specific Title
      cdplayerform.PlayTrack(AktuellerBefehl.ArgInteger[0], AktuellerBefehl.ArgInteger[1]);
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[14].Steuerung[6].GUID) and EventFired then
    begin // Repeat
      cdplayerform.audioplayer_alsschleife.Checked:=not cdplayerform.audioplayer_alsschleife.Checked;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[14].Steuerung[7].GUID) and EventFired then
    begin // Random
      cdplayerform.shuffle.Checked:=not cdplayerform.shuffle.Checked;
      exit;
    end;
    if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[14].Steuerung[8].GUID) and EventFired then
    begin // Next
      cdplayerform.cdopen.Click;
      exit;
    end;
  except
  end;

  // Wenn hier angekommen, dann ist Befehl nicht hinterlegt -> per Message senden:
//  for i:=0 to length(mainform.Befehlssystem)-1 do
  i:=14;
  begin
    for j:=0 to length(mainform.Befehlssystem[i].Steuerung)-1 do
    begin
      if IsEqualGUID(AktuellerBefehl.Typ,mainform.Befehlssystem[i].Steuerung[j].GUID) then
      begin
        SendMSG(MSG_STARTPLUGINCOMMAND, GUIDToString(AktuellerBefehl.Typ), Value);
        exit;
      end;
    end;
  end;
end;

procedure Tmainform.GetBefehlState(AktuellerBefehl:TBefehl2; var Text_PCD_Function:string; var Text_Function:string; var Text_Value:string; var Value:integer);
var
  j:integer;
begin
  {$I GetBefehlState.inc}
end;

procedure Tmainform.ConvertBefehlToBefehl2;
var
  i:integer;
begin
  // Befehle an Befehl2 angleichen
  setlength(Befehle2, length(OldBefehle));

  for i:=0 to length(Befehle2)-1 do
  begin
    Befehle2[i].ID:=OldBefehle[i].ID;
    Befehle2[i].Name:=OldBefehle[i].Name;
    Befehle2[i].Beschreibung:=OldBefehle[i].Beschreibung;

    Befehle2[i].OnValue:=255;
    Befehle2[i].SwitchValue:=128;
    Befehle2[i].OffValue:=0;
    Befehle2[i].ScaleValue:=false;
    setlength(Befehle2[i].ArgInteger, 2);
    Befehle2[i].ArgInteger[0]:=OldBefehle[i].Arg1;
    Befehle2[i].ArgInteger[1]:=OldBefehle[i].Arg2;
    setlength(Befehle2[i].ArgGUID, 1);
    Befehle2[i].ArgGUID[0]:=OldBefehle[i].Arg3;
  end;
end;

procedure TMainform.ConvertMidiToMidi2;
var
  i:integer;
begin
  for i:=0 to length(MidiEventArray)-1 do
  begin
    CreateGUID(MidiEventArray[i].ID);
    MidiEventArray[i].Befehl.OnValue:=255;
    MidiEventArray[i].Befehl.SwitchValue:=128;
    MidiEventArray[i].Befehl.OffValue:=0;
    MidiEventArray[i].Befehl.ScaleValue:=false;
    setlength(MidiEventArray[i].Befehl.ArgInteger, 2);
    MidiEventArray[i].Befehl.ArgInteger[0]:=MidiEventArray[i].Wert1;
    MidiEventArray[i].Befehl.ArgInteger[1]:=MidiEventArray[i].Wert2;
    setlength(MidiEventArray[i].Befehl.ArgGUID, 1);
    MidiEventArray[i].Befehl.ArgGUID[0]:=MidiEventArray[i].Arg3;
  end;
end;


procedure TMainform.ConvertDataInToDataIn2;
var
  i:integer;
begin
  for i:=0 to length(DatainEventArray)-1 do
  begin
    CreateGUID(DatainEventArray[i].ID);
    DatainEventArray[i].Befehl.OnValue:=255;
    DatainEventArray[i].Befehl.SwitchValue:=128;
    DatainEventArray[i].Befehl.OffValue:=0;
    DatainEventArray[i].Befehl.ScaleValue:=false;
    setlength(DatainEventArray[i].Befehl.ArgInteger, 2);
    DatainEventArray[i].Befehl.ArgInteger[0]:=DatainEventArray[i].Wert1;
    DatainEventArray[i].Befehl.ArgInteger[1]:=DatainEventArray[i].Wert2;
    setlength(DatainEventArray[i].Befehl.ArgInteger, 1);
    DatainEventArray[i].Befehl.ArgGUID[0]:=DatainEventArray[i].Arg3;
  end;
end;

procedure TMainform.ConvertJoystickToJoystick2;
var
  i:integer;
begin
  for i:=0 to length(JoystickEvents)-1 do
  begin
    CreateGUID(JoystickEvents[i].ID);
    JoystickEvents[i].Befehl.OnValue:=255;
    JoystickEvents[i].Befehl.SwitchValue:=128;
    JoystickEvents[i].Befehl.OffValue:=0;
    JoystickEvents[i].Befehl.ScaleValue:=false;
    setlength(JoystickEvents[i].Befehl.ArgInteger, 2);
    JoystickEvents[i].Befehl.ArgInteger[0]:=OldJoystickEvents[i].Arg1;
    JoystickEvents[i].Befehl.ArgInteger[1]:=OldJoystickEvents[i].Arg2;
    setlength(JoystickEvents[i].Befehl.ArgGUID, 1);
    JoystickEvents[i].Befehl.ArgGUID[0]:=OldJoystickEvents[i].Arg3;
  end;
end;

procedure TMainform.ConvertHotkeysToHotkeys2;
var
  i:integer;
begin
  setlength(TastencodeArray, length(OldTastencodeArray));

  for i:=0 to length(TastencodeArray)-1 do
  begin
    CreateGUID(TastencodeArray[i].ID);
    TastencodeArray[i].active:=OldTastencodeArray[i].active;
    TastencodeArray[i].Hotkey:=OldTastencodeArray[i].Hotkey;
    TastencodeArray[i].Global:=OldTastencodeArray[i].Global;

    TastencodeArray[i].Befehl.OnValue:=255;
    TastencodeArray[i].Befehl.SwitchValue:=128;
    TastencodeArray[i].Befehl.OffValue:=0;
    TastencodeArray[i].Befehl.ScaleValue:=false;
    setlength(TastencodeArray[i].Befehl.ArgInteger, 2);
    TastencodeArray[i].Befehl.ArgInteger[0]:=OldTastencodeArray[i].Arg1;
    TastencodeArray[i].Befehl.ArgInteger[1]:=OldTastencodeArray[i].Arg2;
    setlength(TastencodeArray[i].Befehl.ArgGUID, 1);
    TastencodeArray[i].Befehl.ArgGUID[0]:=OldTastencodeArray[i].Arg3;
  end;
end;

procedure TMainform.StartPreset(ID: TGUID);
var
  i, j, k:integer;
  R,G,B:byte;
begin
  for i:=0 to length(devicepresets)-1 do
  begin
    if IsEqualGUID(ID,devicepresets[i].ID) then
    begin // richtiges Preset gefunden
      if devicepresets[i].UseNewInterface then
      begin
        for j:=0 to length(mainform.devices)-1 do
        begin
          if DeviceSelected[j] then
          begin
            geraetesteuerung.set_gobo1rot(mainform.Devices[j].ID, devicepresets[i].GoboRot1);

            geraetesteuerung.set_gobo2rot(mainform.Devices[j].ID, devicepresets[i].GoboRot2);

            geraetesteuerung.set_prismarot(mainform.Devices[j].ID, devicepresets[i].PrismaRot);

            if devicepresets[i].Focus>-1 then
              geraetesteuerung.set_channel(mainform.Devices[j].ID, 'FOCUS', -1, devicepresets[i].Focus, 0);

            if devicepresets[i].Iris>-1 then
              geraetesteuerung.set_iris(mainform.Devices[j].ID, devicepresets[i].Iris);

            geraetesteuerung.set_channel(mainform.Devices[j].ID, 'PAN', -1, devicepresets[i].Pan, 0);
            geraetesteuerung.set_channel(mainform.Devices[j].ID, 'PANFINE', -1, devicepresets[i].PanFine, 0);
            geraetesteuerung.set_channel(mainform.Devices[j].ID, 'TILT', -1, devicepresets[i].Tilt, 0);
            geraetesteuerung.set_channel(mainform.Devices[j].ID, 'TILTFINE', -1, devicepresets[i].TiltFine, 0);

            TColor2RGB(devicepresets[i].Color, R,G,B);
            geraetesteuerung.set_color(mainform.Devices[j].ID, R, G, B, 0, 0);

            if devicepresets[i].Shutter=255 then
            begin
              // OFFEN
              geraetesteuerung.set_shutter(mainform.Devices[j].ID, 255);
            end else if devicepresets[i].Shutter=0 then
            begin
              // ZU
              geraetesteuerung.set_shutter(mainform.Devices[j].ID, 0);
            end else if devicepresets[i].shutter=128 then
            begin
              // UNBESTIMMT
            end;

            if devicepresets[i].Strobe>-1 then
              geraetesteuerung.set_strobe(mainform.Devices[i].ID, devicepresets[i].Strobe);
            if devicepresets[i].Dimmer>-1 then
              geraetesteuerung.set_dimmer(mainform.Devices[i].ID, devicepresets[i].Dimmer);
{
            if UpperCase(mainform.Devices[j].StrobeChannel)='DIMMER' then
            begin
              // Strobe und Dimmer auf gleichem Kanal -> Strobe nur bei Dimmer=255
              if devicepresets[i].dimmer=255 then
                geraetesteuerung.set_strobe(mainform.Devices[j].ID, devicepresets[i].Strobe)
              else
              begin
                if UpperCase(mainform.Devices[j].ShutterChannel)='DIMMER' then
                begin
                  if devicepresets[i].Shutter=0 then
                    geraetesteuerung.set_dimmer(mainform.Devices[j].ID, 0)
                  else if devicepresets[i].Shutter=128 then
                    geraetesteuerung.set_dimmer(mainform.Devices[j].ID, devicepresets[i].dimmer)
                  else if devicepresets[i].Shutter=255 then
                    geraetesteuerung.set_dimmer(mainform.Devices[j].ID, 255);
                end else
                  geraetesteuerung.set_dimmer(mainform.Devices[j].ID, devicepresets[i].dimmer);
              end;
            end else
            begin
              // getrennte Kanäle
              if UpperCase(mainform.Devices[j].ShutterChannel)='DIMMER' then
              begin
                if devicepresets[i].Shutter=0 then
                  geraetesteuerung.set_dimmer(mainform.Devices[j].ID, 0)
                else if devicepresets[i].Shutter=128 then
                  geraetesteuerung.set_dimmer(mainform.Devices[j].ID, devicepresets[i].dimmer)
                else if devicepresets[i].Shutter=255 then
                  geraetesteuerung.set_dimmer(mainform.Devices[j].ID, 255);
              end else
                geraetesteuerung.set_dimmer(mainform.Devices[j].ID, devicepresets[i].dimmer);
              geraetesteuerung.set_strobe(mainform.Devices[j].ID, devicepresets[i].Strobe);
            end;
}
            if devicepresets[i].PrismaEnabled=255 then
              geraetesteuerung.set_prisma(mainform.Devices[j].ID, 255)
            else if devicepresets[i].PrismaEnabled=0 then
              geraetesteuerung.set_prisma(mainform.Devices[j].ID, 0);
          end;
        end;
      end else
      begin
        for j:=0 to length(mainform.DevicePresets[i].ChanTyp)-1 do
        begin
          if devicepresets[i].chanActive[j] then
          begin // Kanaltyp aktiviert
            for k:=0 to length(Devices)-1 do
            begin // Kanalwert an selektierte Geräte senden
              if DeviceSelected[k] then
                geraetesteuerung.set_channel(Devices[k].ID,devicepresets[i].ChanTyp[j],-1,devicepresets[i].chanValue[j],0);
            end;
          end;
        end;
      end;
      break;
    end;
  end;
end;

procedure TMainform.StartPresetscene(ID: TGUID);
var
  i, j:integer;
  R,G,B:byte;
begin
  for i:=0 to length(PresetScenes)-1 do
  begin
    if IsEqualGUID(ID,PresetScenes[i].ID) then
    begin // richtige Presetszene gefunden
      for j:=0 to length(mainform.PresetScenes[i].Devices)-1 do
      begin
        geraetesteuerung.set_gobo1rot(mainform.PresetScenes[i].Devices[j], PresetScenes[i].GoboRot1);

        geraetesteuerung.set_gobo2rot(mainform.PresetScenes[i].Devices[j], PresetScenes[i].GoboRot2);

        geraetesteuerung.set_prismarot(mainform.PresetScenes[i].Devices[j], PresetScenes[i].PrismaRot);

        if PresetScenes[i].Focus>-1 then
          geraetesteuerung.set_channel(mainform.PresetScenes[i].Devices[j], 'FOCUS', -1, PresetScenes[i].Focus, 0);

        if PresetScenes[i].Iris>-1 then
          geraetesteuerung.set_iris(mainform.PresetScenes[i].Devices[j], PresetScenes[i].Iris);

        geraetesteuerung.set_channel(mainform.PresetScenes[i].Devices[j], 'PAN', -1, PresetScenes[i].Pan, 0);
        geraetesteuerung.set_channel(mainform.PresetScenes[i].Devices[j], 'PANFINE', -1, PresetScenes[i].PanFine, 0);
        geraetesteuerung.set_channel(mainform.PresetScenes[i].Devices[j], 'TILT', -1, PresetScenes[i].Tilt, 0);
        geraetesteuerung.set_channel(mainform.PresetScenes[i].Devices[j], 'TILTFINE', -1, PresetScenes[i].TiltFine, 0);

        TColor2RGB(PresetScenes[i].Color, R,G,B);
        geraetesteuerung.set_color(mainform.PresetScenes[i].Devices[j], R, G, B, 0, 0);

        if PresetScenes[i].Shutter=255 then
        begin
          // OFFEN
          geraetesteuerung.set_shutter(mainform.PresetScenes[i].Devices[j], 255);
        end else if PresetScenes[i].Shutter=0 then
        begin
          // ZU
          geraetesteuerung.set_shutter(mainform.PresetScenes[i].Devices[j], 0);
        end else if PresetScenes[i].shutter=128 then
        begin
          // UNBESTIMMT
        end;

        if PresetScenes[i].Strobe>-1 then
          geraetesteuerung.set_strobe(mainform.PresetScenes[i].Devices[j], PresetScenes[i].Strobe);
        if PresetScenes[i].Dimmer>-1 then
          geraetesteuerung.set_dimmer(mainform.PresetScenes[i].Devices[j], PresetScenes[i].Dimmer);

        if PresetScenes[i].PrismaEnabled=255 then
          geraetesteuerung.set_prisma(mainform.PresetScenes[i].Devices[j], 255)
        else if PresetScenes[i].PrismaEnabled=0 then
          geraetesteuerung.set_prisma(mainform.PresetScenes[i].Devices[j], 0);
      end;
      break;
    end;
  end;
end;

procedure TMainform.InitCodeScene(ID: TGUID);
var
  i:integer;
begin
  for i:=0 to length(CodeScenes)-1 do
  begin
    if IsEqualGUID(ID,CodeScenes[i].ID) then
    begin // richtige Codescene gefunden
      ExecuteCodeScene(CodeScenes[i].ID, 'InitScene');
      break;
    end;
  end;
end;

procedure TMainform.ExecuteCodeScene(ID: TGUID; Command: string);
var
  i:integer;
begin
  for i:=0 to length(CodeScenes)-1 do
  begin
    if IsEqualGUID(ID,CodeScenes[i].ID) then
    begin // richtige Codescene gefunden
      kontrollpanel.ScriptInterpreterCallingCodeSceneID:=CodeScenes[i].ID;
      kontrollpanel.ScriptInterpreter.Pas.Clear;
      kontrollpanel.ScriptInterpreter.Pas.Text:=CodeScenes[i].Code;
      kontrollpanel.ScriptInterpreter.Compile;
      kontrollpanel.ScriptInterpreterArgs.Count:=0;
      kontrollpanel.ScriptInterpreter.CallFunction(Command, kontrollpanel.ScriptInterpreterArgs, []);
      break;
    end;
  end;
end;

procedure TMainform.StartAutoszene(ID: TGUID; NoFadetime, NoDelay:boolean; Fadetime:integer);
var
  i,j:integer;
{
  i, j, k, kanalwert,Rdiff,Gdiff,Bdiff,temp,temp2,bestcolor,bestcolor2:integer;
  R,G,B:byte;
  rs,gs,bs,ys,yraw,ybrightness:single;
  colorchannelvalues:array of integer;
  colorchannelvalues2:array of integer;
  time:integer;
}
begin
//  kanalwert:=0;

  for i:=0 to length(autoszenen)-1 do
  begin
    if IsEqualGUID(ID,autoszenen[i].ID) then
    begin // richtige Autoszene gefunden
      for j:=0 to length(devices)-1 do
      begin
        if devices[j].autoscening then
        begin // Gerät soll autoscening anwenden
          geraetesteuerung.set_color(devices[j].ID, autoszenen[i].R, autoszenen[i].G, autoszenen[i].B, autoszenen[i].A, autoszenen[i].W, autoszenen[i].fadetime, 0);
        end;
      end;
      break;
    end;
  end;
end;

procedure Tmainform.StartMediaCenterSzene(ID: TGUID);
var
  i,timeout:integer;
  MediaCenterCommand:TMediaCenterCommand;
begin
  for i:=0 to length(mediacenterszenen)-1 do
  begin
    if IsEqualGUID(ID,mediacenterszenen[i].ID) then
    begin // richtige MediaCenter Szene gefunden
      if not ((MediaCenterSocket.Address=mediacenterszenen[i].Adresse) and (MediaCenterSocket.Port=mediacenterszenen[i].Port) and (MediaCenterSocket.Socket.Connected)) then
      begin
        if MediaCenterSocket.Socket.Connected then
          MediaCenterSocket.Active:=false;
        MediaCenterSocket.Address:=mediacenterszenen[i].Adresse;
        MediaCenterSocket.Port:=mediacenterszenen[i].Port;
        MediaCenterSocket.Active:=true;

        timeout:=0;
        repeat
          Application.ProcessMessages;
          sleep(100);
          timeout:=timeout+1;
        until (MediaCenterSocket.Socket.Connected) or (timeout>=30);
      end;

      if MediaCenterSocket.Socket.Connected then
      begin
        MediaCenterCommand.Befehl:=mediacenterszenen[i].Befehl;
        MediaCenterCommand.Data1:=mediacenterszenen[i].Data1;
        MediaCenterCommand.Data2:=mediacenterszenen[i].Data2;
        MediaCenterCommand.Text:=mediacenterszenen[i].Text;

        MediaCenterSocket.Socket.SendBuf(MediaCenterCommand, sizeof(MediaCenterCommand));
      end else
      begin
        ShowMessage(_('Es konnte keine Verbindung zum MediaCenter Server hergestellt werden. Bitte kontrollieren Sie ihre Angaben in den Feldern "Adresse" und "Port" der entsprechenden MediaCenter Szene.'));
      end;
      break;
    end;
  end;

{
  begin
    ShowMessage(_('Es besteht keine Verbindung zum MediaCenter. Bitte zunächst über den Hauptmenupunkt "Einstellungen" eine Verbindung herstellen.'));
  end;
}
end;

procedure TMainform.StopAutoszene(ID: TGUID);
var
  i, j:integer;
begin
  for i:=0 to length(autoszenen)-1 do
  begin
    if IsEqualGUID(ID,autoszenen[i].ID) then
    begin // richtige Autoszene gefunden
      for j:=0 to length(devices)-1 do
      begin
        if devices[j].autoscening then
        begin // Gerät soll autoscening anwenden
          if devices[j].hasRGB or devices[j].hasCMY then
          begin // Gerät unterstützt RGB-Mischung
            geraetesteuerung.set_channel(devices[j].ID,'R',geraetesteuerung.get_channel(devices[j].ID,'R'),geraetesteuerung.get_channel(devices[j].ID,'R'),0);
            geraetesteuerung.set_channel(devices[j].ID,'G',geraetesteuerung.get_channel(devices[j].ID,'G'),geraetesteuerung.get_channel(devices[j].ID,'G'),0);
            geraetesteuerung.set_channel(devices[j].ID,'B',geraetesteuerung.get_channel(devices[j].ID,'B'),geraetesteuerung.get_channel(devices[j].ID,'B'),0);
            if (autoszenen[i].A>-1) and devices[j].hasAmber then
              geraetesteuerung.set_channel(devices[j].ID,'A',geraetesteuerung.get_channel(devices[j].ID,'A'),geraetesteuerung.get_channel(devices[j].ID,'A'),0);
            if (autoszenen[i].W>-1) and devices[j].hasWhite then
              geraetesteuerung.set_channel(devices[j].ID,'W',geraetesteuerung.get_channel(devices[j].ID,'W'),geraetesteuerung.get_channel(devices[j].ID,'W'),0);

            geraetesteuerung.set_channel(devices[j].ID,'C',geraetesteuerung.get_channel(devices[j].ID,'C'),geraetesteuerung.get_channel(devices[j].ID,'C'),0);
            geraetesteuerung.set_channel(devices[j].ID,'M',geraetesteuerung.get_channel(devices[j].ID,'M'),geraetesteuerung.get_channel(devices[j].ID,'M'),0);
            geraetesteuerung.set_channel(devices[j].ID,'Y',geraetesteuerung.get_channel(devices[j].ID,'Y'),geraetesteuerung.get_channel(devices[j].ID,'Y'),0);

            if devices[j].hasUV then
              geraetesteuerung.set_channel(devices[j].ID,'UV',geraetesteuerung.get_channel(devices[j].ID,'UV'),geraetesteuerung.get_channel(devices[j].ID,'UV'),0);
          end else
          if devices[j].hasColor then
          begin
          end else
          begin // Gerät besitzt nur statische Farbe
            geraetesteuerung.set_dimmer(devices[j].ID,geraetesteuerung.get_dimmer(devices[j].ID));
          end;
        end;
      end;
      break;
    end;
  end;
end;

function TMainform.GetDeviceSceneChannelValue(ID: TGUID; Channel: integer):integer;
var
  i,j,k,l,m,groupposition,deviceposition,offset:integer;
  dobreak:boolean;
begin
  result:=-512;
  dobreak:=false;

  for i:=0 to length(EinfacheSzenen)-1 do
  if IsEqualGUID(EinfacheSzenen[i].ID,ID) then
  begin
    if EinfacheSzenen[i].kanalaktiv[Channel] then
      result:=EinfacheSzenen[i].kanal[Channel];
    dobreak:=true;
    break;
  end;

  if not dobreak then
  for i:=0 to length(devicescenes)-1 do
  if IsEqualGUID(devicescenes[i].ID,ID) then
  begin // Geräteszene gefunden
    for j:=0 to length(devicescenes[i].Devices)-1 do
    begin
      deviceposition:=geraetesteuerung.GetDevicePositionInDeviceArray(@devicescenes[i].Devices[j].ID);
      if deviceposition>-1 then
      begin
        for k:=0 to length(devicescenes[i].Devices[j].ChanValue)-1 do
        begin
          if devicescenes[i].Devices[j].ChanActive[k] then
          begin
            if Channel=(mainform.devices[deviceposition].Startaddress+k) then
            begin
              result:=devicescenes[i].Devices[j].ChanValue[k];
              dobreak:=true;
              break;
            end;
          end;
          if dobreak then break;
        end;
      end else
      begin
        // Ist eine Gruppe
        groupposition:=geraetesteuerung.GetGroupPositionInGroupArray(devicescenes[i].Devices[j].ID);
        if groupposition>-1 then
        begin
          for l:=0 to length(mainform.DeviceGroups[groupposition].IDs)-1 do
          begin
            deviceposition:=geraetesteuerung.GetDevicePositionInDeviceArray(@mainform.DeviceGroups[groupposition].IDs[l]);
            if deviceposition>-1 then
            begin
              for k:=0 to length(devicescenes[i].Devices[j].ChanValue)-1 do
              begin
                if devicescenes[i].Devices[j].ChanActive[k] then
                begin
                  offset:=-1;
                  for m:=0 to length(mainform.devices[deviceposition].kanaltyp)-1 do
                  begin
                    if mainform.devices[deviceposition].kanaltyp[m]=mainform.DeviceChannelNames[k] then
                    begin
                      offset:=m;
                      break;
                    end;
                  end;

                  if Channel=(mainform.devices[deviceposition].Startaddress+offset) then
                  begin
                    result:=devicescenes[i].Devices[j].ChanValue[k];
                    dobreak:=true;
                    break;
                  end;
                end;
                if dobreak then break;
              end;
            end;
          end;
        end;
      end;
    end;
    if dobreak then break;
  end;
end;

procedure TMainform.StartDeviceScene(ID: TGUID; NoFadetime, NoDelay:boolean; Intensity: Byte; Fadetime:integer);
var
  i,j,k,m,PositionInDeviceArray, PositionInGroupArray:integer;
  pan,tilt,panfine,tiltfine:boolean;
  panchan,tiltchan,panfinechan, tiltfinechan:integer;
  ChannelFadetime, ChannelDelay, ChannelValue:integer;
  Faktor:single;
begin
  for j:=1 to lastchan do
    channelvalue_temp[j]:=-1;

  if Fadetime<-1 then
    Fadetime:=Random(abs(Fadetime));

  Faktor:=(Intensity/255);

  for i:=0 to length(devicescenes)-1 do
  if IsEqualGUID(devicescenes[i].ID,ID) then
  begin // Geräteszene gefunden
    for j:=0 to length(devicescenes[i].Devices)-1 do
    begin
      panchan:=0;
      tiltchan:=0;
      panfinechan:=0;
      tiltfinechan:=0;
      pan:=false;
      tilt:=false;
      panfine:=false;
      tiltfine:=false;

      PositionInDeviceArray:=-1;
      PositionInGroupArray:=-1;

      for m:=0 to length(devices)-1 do
      begin
        if IsEqualGUID(devices[m].ID,devicescenes[i].Devices[j].ID) then
        begin
          PositionInDeviceArray:=m;
          break;
        end;
      end;

      for m:=0 to length(devicegroups)-1 do
      begin
        if IsEqualGUID(devicegroups[m].ID,devicescenes[i].Devices[j].ID) then
        begin
          PositionInGroupArray:=m;
          break;
        end;
      end;

      if PositionInDeviceArray>-1 then
      begin
        for k:=0 to length(devicescenes[i].Devices[j].ChanActive)-1 do
        begin
          if (lowercase(devices[PositionInDeviceArray].kanaltyp[k])='pan') and (devicescenes[i].Devices[j].ChanActive[k]) then
          begin
            pan:=true;
            panchan:=k;
          end;
          if (lowercase(devices[PositionInDeviceArray].kanaltyp[k])='panfine') and (devicescenes[i].Devices[j].ChanActive[k]) then
          begin
            panfine:=true;
            panfinechan:=k;
          end;
          if (lowercase(devices[PositionInDeviceArray].kanaltyp[k])='tilt') and (devicescenes[i].Devices[j].ChanActive[k]) then
          begin
            tilt:=true;
            tiltchan:=k;
          end;
          if (lowercase(devices[PositionInDeviceArray].kanaltyp[k])='tiltfine') and (devicescenes[i].Devices[j].ChanActive[k]) then
          begin
            tiltfine:=true;
            tiltfinechan:=k;
          end;
        end;

        for k:=0 to length(devicescenes[i].Devices[j].ChanActive)-1 do
        begin
          if devicescenes[i].Devices[j].ChanActive[k] then
          begin
            if pan and tilt and ((lowercase(devices[PositionInDeviceArray].kanaltyp[k])='tilt')) or ((lowercase(devices[PositionInDeviceArray].kanaltyp[k])='pan')) then
            begin
              mainform.devices[PositionInDeviceArray].PanStartvalue:=geraetesteuerung.get_channel(devicescenes[i].Devices[j].ID,'pan');
              mainform.devices[PositionInDeviceArray].PanEndvalue:=devicescenes[i].Devices[j].ChanValue[panchan];
              mainform.devices[PositionInDeviceArray].TiltStartvalue:=geraetesteuerung.get_channel(devicescenes[i].Devices[j].ID,'tilt');
              mainform.devices[PositionInDeviceArray].TiltEndvalue:=devicescenes[i].Devices[j].ChanValue[tiltchan];
              if panfine then
              begin
                mainform.devices[PositionInDeviceArray].PanFineStartvalue:=geraetesteuerung.get_channel(devicescenes[i].Devices[j].ID,'panfine');
                mainform.devices[PositionInDeviceArray].PanFineEndvalue:=devicescenes[i].Devices[j].ChanValue[panfinechan];
              end;
              if tiltfine then
              begin
                mainform.devices[PositionInDeviceArray].TiltFineStartvalue:=geraetesteuerung.get_channel(devicescenes[i].Devices[j].ID,'tiltfine');
                mainform.devices[PositionInDeviceArray].TiltFineEndvalue:=devicescenes[i].Devices[j].ChanValue[tiltfinechan];
              end;

              channelvalue_temp[devices[PositionInDeviceArray].Startaddress+k]:=channel_value[devices[PositionInDeviceArray].Startaddress+k];

              if NoFadetime then
              begin
                ChannelFadetime:=0;
                ChannelDelay:=0;
              end else
              begin
                if devicescenes[i].Devices[j].ChanFadetime[k]=-1 then
                begin
                  if Fadetime=-1 then
                    ChannelFadetime:=devicescenes[i].fadetime
                  else
                    ChannelFadetime:=Fadetime;
                end else if devicescenes[i].Devices[j].ChanFadetime[k]<-1 then
                begin
                  ChannelFadetime:=Random(abs(devicescenes[i].Devices[j].ChanFadetime[k]));
                end else
                begin
                  ChannelFadetime:=devicescenes[i].Devices[j].ChanFadetime[k];
                end;

                if devicescenes[i].Devices[j].ChanDelay[k]=-1 then
                begin
                  ChannelDelay:=devicescenes[i].Devices[j].ChanDelay[k];
                end else if devicescenes[i].Devices[j].ChanDelay[k]<-1 then
                begin
                  ChannelDelay:=Random(abs(devicescenes[i].Devices[j].ChanDelay[k]));
                end else
                begin
                  ChannelDelay:=devicescenes[i].Devices[j].ChanDelay[k];
                end;
              end;

              if devicescenes[i].Devices[j].ChanValueRandom[k] then
                ChannelValue:=Random(devicescenes[i].Devices[j].ChanValue[k]+1)
              else
                ChannelValue:=devicescenes[i].Devices[j].ChanValue[k];

              if devicescenes[i].Devices[j].ChanActiveRandom[k] then
              begin
                if ((Random(1025) mod 2)=0) then
                  geraetesteuerung.set_channel(devicescenes[i].Devices[j].ID,devices[PositionInDeviceArray].kanaltyp[k],-1,round(ChannelValue*Faktor),ChannelFadetime,ChannelDelay);
              end else
                geraetesteuerung.set_channel(devicescenes[i].Devices[j].ID,devices[PositionInDeviceArray].kanaltyp[k],-1,round(ChannelValue*Faktor),ChannelFadetime,ChannelDelay);
            end else
            begin
              channelvalue_temp[devices[PositionInDeviceArray].Startaddress+k]:=channel_value[devices[PositionInDeviceArray].Startaddress+k];

              if NoFadetime then
              begin
                ChannelFadetime:=0;
                ChannelDelay:=0;
              end else
              begin
                if devicescenes[i].Devices[j].ChanFadetime[k]=-1 then
                begin
                  if Fadetime=-1 then
                    ChannelFadetime:=devicescenes[i].fadetime
                  else
                    ChannelFadetime:=Fadetime;
                end else if devicescenes[i].Devices[j].ChanFadetime[k]<-1 then
                begin
                  ChannelFadetime:=Random(abs(devicescenes[i].Devices[j].ChanFadetime[k]));
                end else
                begin
                  ChannelFadetime:=devicescenes[i].Devices[j].ChanFadetime[k];
                end;

                if devicescenes[i].Devices[j].ChanDelay[k]=-1 then
                begin
                  ChannelDelay:=devicescenes[i].Devices[j].ChanDelay[k];
                end else if devicescenes[i].Devices[j].ChanDelay[k]<-1 then
                begin
                  ChannelDelay:=Random(abs(devicescenes[i].Devices[j].ChanDelay[k]));
                end else
                begin
                  ChannelDelay:=devicescenes[i].Devices[j].ChanDelay[k];
                end;
              end;

              if devicescenes[i].Devices[j].ChanValueRandom[k] then
                ChannelValue:=Random(devicescenes[i].Devices[j].ChanValue[k]+1)
              else
                ChannelValue:=devicescenes[i].Devices[j].ChanValue[k];

              if devicescenes[i].Devices[j].ChanActiveRandom[k] then
              begin
                if ((Random(1025) mod 2)=0) then
                  geraetesteuerung.set_channel(devicescenes[i].Devices[j].ID,devices[PositionInDeviceArray].kanaltyp[k],-1,round(ChannelValue*Faktor),ChannelFadetime,ChannelDelay);
              end else
                geraetesteuerung.set_channel(devicescenes[i].Devices[j].ID,devices[PositionInDeviceArray].kanaltyp[k],-1,round(ChannelValue*Faktor),ChannelFadetime,ChannelDelay);
            end;
          end;
        end;
      end else if PositionInGroupArray>-1 then
      begin
        for k:=0 to length(devicescenes[i].Devices[j].ChanActive)-1 do
        begin
          if devicescenes[i].Devices[j].ChanActive[k] then
          begin
            if NoFadetime then
            begin
              ChannelFadetime:=0;
              ChannelDelay:=0;
            end else
            begin
              if devicescenes[i].Devices[j].ChanFadetime[k]=-1 then
              begin
                if Fadetime=-1 then
                  ChannelFadetime:=devicescenes[i].fadetime
                else
                  ChannelFadetime:=Fadetime;
              end else if devicescenes[i].Devices[j].ChanFadetime[k]<-1 then
              begin
                ChannelFadetime:=Random(abs(devicescenes[i].Devices[j].ChanFadetime[k]));
              end else
              begin
                ChannelFadetime:=devicescenes[i].Devices[j].ChanFadetime[k];
              end;

              if devicescenes[i].Devices[j].ChanDelay[k]=-1 then
              begin
                ChannelDelay:=devicescenes[i].Devices[j].ChanDelay[k];
              end else if devicescenes[i].Devices[j].ChanDelay[k]<-1 then
              begin
                ChannelDelay:=Random(abs(devicescenes[i].Devices[j].ChanDelay[k]));
              end else
              begin
                ChannelDelay:=devicescenes[i].Devices[j].ChanDelay[k];
              end;
            end;

            if devicescenes[i].Devices[j].ChanValueRandom[k] then
              ChannelValue:=Random(devicescenes[i].Devices[j].ChanValue[k]+1)
            else
              ChannelValue:=devicescenes[i].Devices[j].ChanValue[k];

            if devicescenes[i].Devices[j].ChanActiveRandom[k] then
            begin
              if ((Random(1025) mod 2)=0) then
                geraetesteuerung.set_group(mainform.devicegroups[PositionInGroupArray].ID,DeviceChannelNames[k],-1,round(ChannelValue*Faktor),ChannelFadetime,ChannelDelay);
            end else
              geraetesteuerung.set_group(mainform.devicegroups[PositionInGroupArray].ID,DeviceChannelNames[k],-1,round(ChannelValue*Faktor),ChannelFadetime,ChannelDelay);
          end;
        end;
      end;
    end;

    // Szenenbefehle starten
    for j:=0 to length(mainform.devicescenes[i].Befehle)-1 do
    begin
      if mainform.devicescenes[i].Befehlswerte[j].ChanActiveRandom[0] then
      begin
        if ((Random(1025) mod 2)=0) then
        begin
          if mainform.devicescenes[i].Befehlswerte[j].ChanValueRandom[0] then
            ChannelValue:=Random(mainform.devicescenes[i].Befehlswerte[j].ChanValue[0]+1)
          else
            ChannelValue:=mainform.devicescenes[i].Befehlswerte[j].ChanValue[0];

          if mainform.devicescenes[i].Befehlswerte[j].ChanFadetime[0]=-1 then
            StartDeviceSceneBefehl(mainform.devicescenes[i].Befehle[j].ID, mainform.devicescenes[i].Befehle[j].Typ, Round(ChannelValue*Faktor), mainform.devicescenes[i].Fadetime, mainform.devicescenes[i].Befehlswerte[j].ChanDelay[0])
          else
            StartDeviceSceneBefehl(mainform.devicescenes[i].Befehle[j].ID, mainform.devicescenes[i].Befehle[j].Typ, Round(ChannelValue*Faktor), mainform.devicescenes[i].Befehlswerte[j].ChanFadetime[0], mainform.devicescenes[i].Befehlswerte[j].ChanDelay[0]);
        end;
      end else
      begin
        if mainform.devicescenes[i].Befehlswerte[j].ChanActive[0] then
        begin
          if mainform.devicescenes[i].Befehlswerte[j].ChanValueRandom[0] then
            ChannelValue:=Random(mainform.devicescenes[i].Befehlswerte[j].ChanValue[0]+1)
          else
            ChannelValue:=mainform.devicescenes[i].Befehlswerte[j].ChanValue[0];

          if mainform.devicescenes[i].Befehlswerte[j].ChanFadetime[0]=-1 then
            StartDeviceSceneBefehl(mainform.devicescenes[i].Befehle[j].ID, mainform.devicescenes[i].Befehle[j].Typ, Round(ChannelValue*Faktor), mainform.devicescenes[i].Fadetime, mainform.devicescenes[i].Befehlswerte[j].ChanDelay[0])
          else
            StartDeviceSceneBefehl(mainform.devicescenes[i].Befehle[j].ID, mainform.devicescenes[i].Befehle[j].Typ, Round(ChannelValue*Faktor), mainform.devicescenes[i].Befehlswerte[j].ChanFadetime[0], mainform.devicescenes[i].Befehlswerte[j].ChanDelay[0]);
        end;
      end;
    end;
    
    break;
  end;
end;

procedure Tmainform.StartDeviceSceneBefehl(ID, Typ: TGUID; Value, Fadetime, Delay:Integer);
begin
  if Fadetime<0 then
    Fadetime:=Random(abs(Fadetime));

  if (Fadetime>0) or (Delay>0) then
  begin
    new(pDimmerChannel);
    pDimmerChannel.Start:=false;
    pDimmerChannel.ChannelType:=2;
    pDimmerChannel.Index:=0;
    pDimmerChannel.IndexGUID:=ID;
    pDimmerChannel.BefehlTyp:=Typ;
    pDimmerChannel.channel_delay:=Delay;
    pDimmerChannel.channel_increase:=0;
    pDimmerChannel.channel_startvalue:=0;
    pDimmerChannel.channel_endvalue:=Value;
    pDimmerChannel.channel_fadetime:=Fadetime;
    pDimmerChannel.DeleteChannel:=false;
    pDimmerChannel.DontSetValues:=false;
    pDimmerChannel.IsDelayedChan:=(Delay>0);
    pDimmerChannel.FadeDirection:=0;

    setlength(DimmerKernelChannelArray,length(DimmerKernelChannelArray)+1);
    DimmerKernelChannelArray[length(DimmerKernelChannelArray)-1]:=pDimmerChannel;
  end else
  begin
    StartBefehl(ID, Value);
  end;
end;

procedure TMainform.StopDeviceScene(ID: TGUID);
var
  i,j,k,m,PositionInDeviceArray:integer;
  pan,tilt,panfine,tiltfine:boolean;
begin
  PositionInDeviceArray:=0;

  for i:=1 to mainform.lastchan do
    mainform.recordchannelvalue[i]:=-1;

  for i:=0 to length(devicescenes)-1 do
  if IsEqualGUID(devicescenes[i].ID,ID) then
  begin // Geräteszene gefunden
    for j:=0 to length(devicescenes[i].Devices)-1 do
    begin
      pan:=false;
      tilt:=false;
      panfine:=false;
      tiltfine:=false;

      for m:=0 to length(devices)-1 do
        if IsEqualGUID(devices[m].ID,devicescenes[i].Devices[j].ID) then
        begin
          PositionInDeviceArray:=m;
          break;
        end;

      for k:=0 to length(devicescenes[i].Devices[j].ChanActive)-1 do
      begin
        if (devicescenes[i].Devices[j].ChanActive[k]) and (lowercase(devices[PositionInDeviceArray].kanaltyp[k])='pan') then
        begin
          pan:=true;
        end;
        if (devicescenes[i].Devices[j].ChanActive[k]) and (lowercase(devices[PositionInDeviceArray].kanaltyp[k])='tilt') then
        begin
          tilt:=true;
        end;
        if (devicescenes[i].Devices[j].ChanActive[k]) and (lowercase(devices[PositionInDeviceArray].kanaltyp[k])='panfine') then
        begin
          panfine:=true;
        end;
        if (devicescenes[i].Devices[j].ChanActive[k]) and (lowercase(devices[PositionInDeviceArray].kanaltyp[k])='tiltfine') then
        begin
          tiltfine:=true;
        end;
      end;

      for k:=0 to length(devicescenes[i].Devices[j].ChanActive)-1 do
      begin
        if devicescenes[i].Devices[j].ChanActive[k] then
        begin
          if pan and tilt then
          begin
            mainform.devices[PositionInDeviceArray].PanStartvalue:=geraetesteuerung.get_channel(devicescenes[i].Devices[j].ID,'pan');
            mainform.devices[PositionInDeviceArray].PanEndvalue:=geraetesteuerung.get_channel(devicescenes[i].Devices[j].ID,'pan');
            mainform.devices[PositionInDeviceArray].TiltStartvalue:=geraetesteuerung.get_channel(devicescenes[i].Devices[j].ID,'tilt');
            mainform.devices[PositionInDeviceArray].TiltEndvalue:=geraetesteuerung.get_channel(devicescenes[i].Devices[j].ID,'tilt');
            if panfine then
            begin
              mainform.devices[PositionInDeviceArray].PanFineStartvalue:=geraetesteuerung.get_channel(devicescenes[i].Devices[j].ID,'panfine');
              mainform.devices[PositionInDeviceArray].PanFineEndvalue:=geraetesteuerung.get_channel(devicescenes[i].Devices[j].ID,'panfine');
            end;

            if tiltfine then
            begin
              mainform.devices[PositionInDeviceArray].TiltFineStartvalue:=geraetesteuerung.get_channel(devicescenes[i].Devices[j].ID,'tiltfine');
              mainform.devices[PositionInDeviceArray].TiltFineEndvalue:=geraetesteuerung.get_channel(devicescenes[i].Devices[j].ID,'tiltfine');
            end;

            channelvalue_temp[devices[PositionInDeviceArray].Startaddress+k]:=channel_value[devices[PositionInDeviceArray].Startaddress+k];
            geraetesteuerung.set_channel(devicescenes[i].Devices[j].ID,devices[PositionInDeviceArray].kanaltyp[k],geraetesteuerung.get_channel(devicescenes[i].Devices[j].ID,devices[PositionInDeviceArray].kanaltyp[k]),geraetesteuerung.get_channel(devicescenes[i].Devices[j].ID,devices[PositionInDeviceArray].kanaltyp[k]),0);
          end else
          begin
            Senddata(devices[PositionInDeviceArray].Startaddress+k,255-channel_value[devices[PositionInDeviceArray].Startaddress+k],255-channel_value[devices[PositionInDeviceArray].Startaddress+k],0);
         end;
        end;
      end;
    end;
    audioeffektplayerform.RecordAudioeffekt(0);
    break;
  end;
end;

procedure TMainform.StartKompositionsszene(ID: TGUID; NoFadetime, NoDelay:boolean; Fadetime:integer);
var
  i, j:integer;
begin
  for i:=0 to length(Kompositionsszenen)-1 do
  begin
    if IsEqualGUID(ID,Kompositionsszenen[i].ID) then
    begin
      for j:=0 to length(Kompositionsszenen[i].IDs)-1 do
      begin
        if Kompositionsszenen[i].StopScene[j] then
          StopScene(Kompositionsszenen[i].IDs[j])
        else
          StartScene(Kompositionsszenen[i].IDs[j], NoFadetime, NoDelay, Fadetime);
      end;
      break;
    end;
  end;
end;

procedure TMainform.StopKompositionsszene(ID: TGUID);
var
  i, j:integer;
begin
  for i:=0 to length(Kompositionsszenen)-1 do
  begin
    if IsEqualGUID(ID,Kompositionsszenen[i].ID) then
    begin
      for j:=0 to length(Kompositionsszenen[i].IDs)-1 do
      begin
        StopScene(Kompositionsszenen[i].IDs[j]);
      end;
      break;
    end;
  end;
end;

procedure TMainform.StartEffekt(ID: TGUID);
var
  i:integer;
begin
  SendMSG(MSG_STARTEFFECT, GUIDtoString(ID), 0);

  // Effektschritt ausführen
  for i:=0 to length(effektsequenzereffekte)-1 do
  begin
    if IsEqualGUID(ID,effektsequenzereffekte[i].ID) then
    begin
      if DoesSceneExists(effektsequenzereffekte[i].Startscene) then
      begin
        StartScene(effektsequenzereffekte[i].Startscene);
      end;

      AktuellerEffekt[i].Durchlauf:=0;
      AktuellerEffekt[i].PleaseStopOnNextStep:=false;

      if effektsequenzereffekte[i].startwithstepone then
      begin
        AktuellerEffekt[i].AktuellerSchritt:=-1;
        AktuellerEffekt[i].AnzahlderSchritte:=0;
        AktuellerEffekt[i].Zeit:=0;
        EffektSchaltvorgang(i, nil);
      end;

      AktuellerEffekt[i].Aktiv:=true;
//      AktuellerEffekt[i].Zeit:=0;
      break;
    end;
  end;
  effektsequenzer.RefreshGUI:=true;
end;

procedure TMainform.StopEffekt(ID: TGUID);
var
  i,j,k,l,deviceposition,groupposition:integer;
  channeltype:string;
begin
  SendMSG(MSG_STOPEFFECT, GUIDtoString(ID), 0);

  // Effektschritt ausführen
  for i:=0 to length(effektsequenzereffekte)-1 do
  begin
    if IsEqualGUID(ID,effektsequenzereffekte[i].ID) then
    begin
      // i=aktueller Effekt

      AktuellerEffekt[i].Aktiv:=false;
      AktuellerEffekt[i].PleaseStopOnNextStep:=false;
      for k:=0 to length(AktuellerEffekt[i].LastScene)-1 do
        StopScene(AktuellerEffekt[i].LastScene[k]);

      for j:=0 to length(effektsequenzereffekte[i].Effektschritte)-1 do
      begin
        // j=Effekt, welcher durch Effektschritt aufgerufen wurde
        if effektsequenzereffekte[i].Effektschritte[j].Typ=2 then
        begin
          for k:=0 to length(effektsequenzereffekte[i].Effektschritte[j].IDs)-1 do
            StopEffekt(effektsequenzereffekte[i].Effektschritte[j].IDs[k]);
        end;
      end;

      if effektsequenzereffekte[i].blackoutonstop then
      begin
        for j:=0 to length(effektsequenzereffekte[i].Effektschritte)-1 do
        begin
          case effektsequenzereffekte[i].Effektschritte[j].Typ of
            0:
            begin
              // Direktszene
              for k:=0 to length(effektsequenzereffekte[i].Effektschritte[j].Devices)-1 do
              begin
                deviceposition:=geraetesteuerung.GetDevicePositionInDeviceArray(@effektsequenzereffekte[i].Effektschritte[j].Devices[k].ID);

                if deviceposition>-1 then
                begin
                  for l:=0 to length(effektsequenzereffekte[i].Effektschritte[j].Devices[k].ChanActive)-1 do
                  begin
                    if effektsequenzereffekte[i].Effektschritte[j].Devices[k].ChanActive[l] or effektsequenzereffekte[i].Effektschritte[j].Devices[k].ChanActiveRandom[l] then
                    begin
                      channeltype:=mainform.devices[deviceposition].kanaltyp[l];
                      if (lowercase(channeltype)='dimmer') or (lowercase(channeltype)='r') or (lowercase(channeltype)='g') or (lowercase(channeltype)='b') or (lowercase(channeltype)='a') or (lowercase(channeltype)='w') or (lowercase(channeltype)='uv') then
                        geraetesteuerung.set_channel(effektsequenzereffekte[i].Effektschritte[j].Devices[k].ID, channeltype, -1, 0, 200);
                      if (lowercase(channeltype)='shutter') then
                        geraetesteuerung.set_shutter(effektsequenzereffekte[i].Effektschritte[j].Devices[k].ID, 0);
                    end;
                  end;
                end else
                begin
                  groupposition:=geraetesteuerung.GetGroupPositionInGroupArray(effektsequenzereffekte[i].Effektschritte[j].Devices[k].ID);
                  if groupposition>-1 then
                  begin
                    for l:=0 to length(effektsequenzereffekte[i].Effektschritte[j].Devices[k].ChanActive)-1 do
                    begin
                      if effektsequenzereffekte[i].Effektschritte[j].Devices[k].ChanActive[l] or effektsequenzereffekte[i].Effektschritte[j].Devices[k].ChanActiveRandom[l] then
                      begin
                        channeltype:=DeviceChannelNames[l];
                        if (lowercase(channeltype)='dimmer') or (lowercase(channeltype)='r') or (lowercase(channeltype)='g') or (lowercase(channeltype)='b') or (lowercase(channeltype)='a') or (lowercase(channeltype)='w') or (lowercase(channeltype)='uv') then
                          geraetesteuerung.set_group(effektsequenzereffekte[i].Effektschritte[j].Devices[k].ID, channeltype, -1, 0, 200);
                        if (lowercase(channeltype)='shutter') then
                          geraetesteuerung.set_shutter(effektsequenzereffekte[i].Effektschritte[j].Devices[k].ID, 0);
                      end;
                    end;
                  end;
                end;
              end;
            end;
            1:
            begin
              for k:=0 to length(effektsequenzereffekte[i].Effektschritte[j].IDs)-1 do
              begin
                StopScene(effektsequenzereffekte[i].Effektschritte[j].IDs[k]);
                BlackoutDeviceScene(effektsequenzereffekte[i].Effektschritte[j].IDs[k], 200);
                //StartScene(effektsequenzereffekte[i].Effektschritte[j].IDs[k], false, false, 0, 200); // will change all channeltypes to 0
              end;
            end;
          end;
        end;
      end;

      if DoesSceneExists(effektsequenzereffekte[i].Stopscene) then
      begin
        // Stopszene starten
        StartScene(effektsequenzereffekte[i].Stopscene);
      end;

      break;
    end;
  end;
  effektsequenzer.RefreshGUI:=true;
end;

procedure TMainform.StartEffektstep(ID: TGUID; Schrittnummer:Word);
var
  i,j,k,l,blendzeit,PositionInDeviceArray,PositionInGroupArray:integer;
  pan,tilt,panfine,tiltfine:boolean;
  panchan,tiltchan,panfinechan,tiltfinechan:integer;
  ChannelFadetime, ChannelDelay, ChannelValue:integer;
begin
  // Effektschritt ausführen
  for i:=0 to length(effektsequenzereffekte)-1 do
  begin
    if IsEqualGUID(ID,effektsequenzereffekte[i].ID) then
    begin
      if length(effektsequenzereffekte[i].Effektschritte)>0 then
      begin
        if (effektsequenzereffekte[i].Effektschritte[Schrittnummer].DeactivateLastScene) then
        begin
          for k:=0 to length(AktuellerEffekt[i].LastScene)-1 do
            StopScene(AktuellerEffekt[i].LastScene[k]);
        end;

        if AktuellerEffekt[i].DeactivateZeitsteuerung then
          AktuellerEffekt[i].Beatgesteuert:=true;
        AktuellerEffekt[i].Beatgesteuert:=not effektsequenzereffekte[i].Effektschritte[Schrittnummer].ActivateTimecontrol;

        if effektsequenzereffekte[i].Effektschritte[Schrittnummer].Typ=1 then
        begin
          setlength(AktuellerEffekt[i].LastScene,length(effektsequenzereffekte[i].Effektschritte[Schrittnummer].IDs));
          for k:=0 to length(effektsequenzereffekte[i].Effektschritte[Schrittnummer].IDs)-1 do
          begin
            StartScene(effektsequenzereffekte[i].Effektschritte[Schrittnummer].IDs[k],false,false, -1);
            AktuellerEffekt[i].LastScene[k]:=effektsequenzereffekte[i].Effektschritte[Schrittnummer].IDs[k];
          end;
        end else if effektsequenzereffekte[i].Effektschritte[Schrittnummer].Typ=0 then
        begin
          // Geräteszene abspielen
          for k:=0 to length(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices)-1 do
          begin
            panchan:=0;
            tiltchan:=0;
            panfinechan:=0;
            tiltfinechan:=0;
            pan:=false;
            tilt:=false;
            panfine:=false;
            tiltfine:=false;

            PositionInDeviceArray:=-1;
            PositionInGroupArray:=-1;

            for l:=0 to length(mainform.Devices)-1 do
            begin
              if IsEqualGUID(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ID,mainform.devices[l].ID) then
              begin
                PositionInDeviceArray:=l;
                break;
              end;
            end;
            for l:=0 to length(mainform.devicegroups)-1 do
            begin
              if IsEqualGUID(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ID,mainform.devicegroups[l].ID) then
              begin
                PositionInGroupArray:=l;
                break;
              end;
            end;

            if PositionInDeviceArray>-1 then
            begin
              for l:=0 to length(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanActive)-1 do
              begin
                if (lowercase(mainform.devices[PositionInDeviceArray].kanaltyp[l])='pan') and (effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanActive[l]) then
                begin
                  pan:=true;
                  panchan:=k;
                end;
                if (lowercase(mainform.devices[PositionInDeviceArray].kanaltyp[l])='tilt') and (effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanActive[l]) then
                begin
                  tilt:=true;
                  tiltchan:=k;
                end;
                if (lowercase(mainform.devices[PositionInDeviceArray].kanaltyp[l])='panfine') and (effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanActive[l]) then
                begin
                  panfine:=true;
                  panfinechan:=k;
                end;
                if (lowercase(mainform.devices[PositionInDeviceArray].kanaltyp[l])='tiltfine') and (effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanActive[l]) then
                begin
                  tiltfine:=true;
                  tiltfinechan:=k;
                end;
              end;

              for l:=0 to length(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanActive)-1 do
              begin
                if effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanActive[l] then
                begin
                  if pan and tilt then
                  begin
                    mainform.devices[PositionInDeviceArray].PanStartvalue:=geraetesteuerung.get_channel(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ID,'pan');
                    mainform.devices[PositionInDeviceArray].PanEndvalue:=effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanValue[panchan];
                    mainform.devices[PositionInDeviceArray].TiltStartvalue:=geraetesteuerung.get_channel(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ID,'tilt');
                    mainform.devices[PositionInDeviceArray].TiltEndvalue:=effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanValue[tiltchan];
                    if panfine then
                    begin
                      mainform.devices[PositionInDeviceArray].PanFineStartvalue:=geraetesteuerung.get_channel(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ID,'panfine');
                      mainform.devices[PositionInDeviceArray].PanFineEndvalue:=effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanValue[panfinechan];
                    end;
                    if tiltfine then
                    begin
                      mainform.devices[PositionInDeviceArray].TiltFineStartvalue:=geraetesteuerung.get_channel(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ID,'tiltfine');
                      mainform.devices[PositionInDeviceArray].TiltFineEndvalue:=effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanValue[tiltfinechan];
                    end;

                    if effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanFadetime[l]=-1 then
                    begin
                      ChannelFadetime:=effektsequenzereffekte[i].Effektschritte[Schrittnummer].einblendzeit;
                    end else if effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanFadetime[l]<-1 then
                    begin
                      ChannelFadetime:=Random(abs(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanFadetime[l]));
                    end else
                    begin
                      ChannelFadetime:=effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanFadetime[l];
                    end;

                    if effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanDelay[l]=-1 then
                    begin
                      ChannelDelay:=effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanDelay[l];
                    end else if effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanDelay[l]<-1 then
                    begin
                      ChannelDelay:=Random(abs(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanDelay[l]));
                    end else
                    begin
                      ChannelDelay:=effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanDelay[l];
                    end;

                    if effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanValueRandom[l] then
                      ChannelValue:=Random(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanValue[l]+1)
                    else
                      ChannelValue:=effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanValue[l];
                    ChannelValue:=round(ChannelValue*(effektsequenzereffekte[i].intensitaet/255));

                    if effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanActiveRandom[l] then
                    begin
                      if ((Random(1025) mod 2)=0) then
                        geraetesteuerung.set_channel(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ID,mainform.devices[PositionInDeviceArray].kanaltyp[l],geraetesteuerung.get_channel(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ID,mainform.devices[PositionInDeviceArray].kanaltyp[l]),ChannelValue,ChannelFadetime,ChannelDelay)
                    end else
                      geraetesteuerung.set_channel(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ID,mainform.devices[PositionInDeviceArray].kanaltyp[l],geraetesteuerung.get_channel(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ID,mainform.devices[PositionInDeviceArray].kanaltyp[l]),ChannelValue,ChannelFadetime,ChannelDelay);
                  end else
                  begin
                    if effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanFadetime[l]=-1 then
                    begin
                      ChannelFadetime:=effektsequenzereffekte[i].Effektschritte[Schrittnummer].einblendzeit;
                    end else if effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanFadetime[l]<-1 then
                    begin
                      ChannelFadetime:=Random(abs(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanFadetime[l]));
                    end else
                    begin
                      ChannelFadetime:=effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanFadetime[l];
                    end;

                    if effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanDelay[l]=-1 then
                    begin
                      ChannelDelay:=effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanDelay[l];
                    end else if effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanDelay[l]<-1 then
                    begin
                      ChannelDelay:=Random(abs(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanDelay[l]));
                    end else
                    begin
                      ChannelDelay:=effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanDelay[l];
                    end;

                    if effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanValueRandom[l] then
                      ChannelValue:=Random(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanValue[l]+1)
                    else
                      ChannelValue:=effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanValue[l];
                    ChannelValue:=round(ChannelValue*(effektsequenzereffekte[i].intensitaet/255));

                    if effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanActiveRandom[l] then
                    begin
                      if ((Random(1025) mod 2)=0) then
                        geraetesteuerung.set_channel(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ID,mainform.devices[PositionInDeviceArray].kanaltyp[l],geraetesteuerung.get_channel(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ID,mainform.devices[PositionInDeviceArray].kanaltyp[l]),ChannelValue,ChannelFadetime,ChannelDelay)
                    end else
                      geraetesteuerung.set_channel(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ID,mainform.devices[PositionInDeviceArray].kanaltyp[l],geraetesteuerung.get_channel(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ID,mainform.devices[PositionInDeviceArray].kanaltyp[l]),ChannelValue,ChannelFadetime,ChannelDelay);
                  end;
                end;
              end;
            end else if PositionInGroupArray>-1 then
            begin
              for l:=0 to length(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanActive)-1 do
              begin
                if effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanActive[l] then
                begin
                  if effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanFadetime[l]=-1 then
                  begin
                    ChannelFadetime:=effektsequenzereffekte[i].Effektschritte[Schrittnummer].einblendzeit;
                  end else if effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanFadetime[l]<-1 then
                  begin
                    ChannelFadetime:=Random(abs(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanFadetime[l]));
                  end else
                  begin
                    ChannelFadetime:=effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanFadetime[l];
                  end;

                  if effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanDelay[l]=-1 then
                  begin
                    ChannelDelay:=effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanDelay[l];
                  end else if effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanDelay[l]<-1 then
                  begin
                    ChannelDelay:=Random(abs(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanDelay[l]));
                  end else
                  begin
                    ChannelDelay:=effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanDelay[l];
                  end;

                  if effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanValueRandom[l] then
                    ChannelValue:=Random(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanValue[l]+1)
                  else
                    ChannelValue:=effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanValue[l];
                  ChannelValue:=round(ChannelValue*(effektsequenzereffekte[i].intensitaet/255));

                  if effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanActiveRandom[l] then
                  begin
                    if ((Random(1025) mod 2)=0) then
                      geraetesteuerung.set_group(mainform.devicegroups[PositionInGroupArray].ID,mainform.DeviceChannelNames[l],-1,ChannelValue,ChannelFadetime,ChannelDelay)
                  end else
                    geraetesteuerung.set_group(mainform.devicegroups[PositionInGroupArray].ID,mainform.DeviceChannelNames[l],-1,ChannelValue,ChannelFadetime,ChannelDelay);
                end;
              end;
            end;
{
            if PositionInDeviceArray>-1 then
            begin
              for l:=0 to length(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanActive)-1 do
              begin
                if (lowercase(Devices[PositionInDeviceArray].kanaltyp[l])='pan') and (effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanActive[l]) then
                begin
                  pan:=true;
                  panchan:=k;
                end;
                if (lowercase(Devices[PositionInDeviceArray].kanaltyp[l])='tilt') and (effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanActive[l]) then
                begin
                  tilt:=true;
                  tiltchan:=k;
                end;
                if (lowercase(Devices[PositionInDeviceArray].kanaltyp[l])='panfine') and (effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanActive[l]) then
                begin
                  panfine:=true;
                  panfinechan:=k;
                end;
                if (lowercase(Devices[PositionInDeviceArray].kanaltyp[l])='tiltfine') and (effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanActive[l]) then
                begin
                  tiltfine:=true;
                  tiltfinechan:=k;
                end;
              end;

              for l:=0 to length(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanActive)-1 do
              begin
                if effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanActive[l] then
                begin
                  if pan and tilt and ((lowercase(devices[PositionInDeviceArray].kanaltyp[l])='tilt')) or ((lowercase(devices[PositionInDeviceArray].kanaltyp[l])='pan')) then
                  begin
                    mainform.devices[PositionInDeviceArray].PanStartvalue:=geraetesteuerung.get_channel(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ID,'pan');
                    mainform.devices[PositionInDeviceArray].PanEndvalue:=effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanValue[panchan];
                    mainform.devices[PositionInDeviceArray].TiltStartvalue:=geraetesteuerung.get_channel(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ID,'tilt');
                    mainform.devices[PositionInDeviceArray].TiltEndvalue:=effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanValue[tiltchan];
                    if panfine then
                    begin
                      mainform.devices[PositionInDeviceArray].PanFineStartvalue:=geraetesteuerung.get_channel(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ID,'panfine');
                      mainform.devices[PositionInDeviceArray].PanFineEndvalue:=effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanValue[panfinechan];
                    end;
                    if tiltfine then
                    begin
                      mainform.devices[PositionInDeviceArray].TiltFineStartvalue:=geraetesteuerung.get_channel(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ID,'tiltfine');
                      mainform.devices[PositionInDeviceArray].TiltFineEndvalue:=effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanValue[tiltfinechan];
                    end;

                    channelvalue_temp[devices[PositionInDeviceArray].Startaddress+k]:=channel_value[devices[PositionInDeviceArray].Startaddress+k];
                    if effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanFadetime[l]=-1 then
                    begin
                      geraetesteuerung.set_channel(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ID,devices[PositionInDeviceArray].kanaltyp[l],-1,round(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanValue[l]*(effektsequenzereffekte[i].intensitaet/255)),effektsequenzereffekte[i].Effektschritte[Schrittnummer].einblendzeit,effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanDelay[l]);
                    end else
                    begin
                      geraetesteuerung.set_channel(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ID,devices[PositionInDeviceArray].kanaltyp[l],-1,round(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanValue[l]*(effektsequenzereffekte[i].intensitaet/255)),effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanFadetime[l],effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanDelay[l]);
                    end;
                  end else
                  begin
                    channelvalue_temp[devices[PositionInDeviceArray].Startaddress+k]:=channel_value[devices[PositionInDeviceArray].Startaddress+k];
                    if effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanFadetime[l]=-1 then
                    begin
                      geraetesteuerung.set_channel(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ID,devices[PositionInDeviceArray].kanaltyp[l],-1,round(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanValue[l]*(effektsequenzereffekte[i].intensitaet/255)),effektsequenzereffekte[i].Effektschritte[Schrittnummer].einblendzeit,effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanDelay[l]);
                    end else
                    begin
                      geraetesteuerung.set_channel(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ID,devices[PositionInDeviceArray].kanaltyp[l],-1,round(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanValue[l]*(effektsequenzereffekte[i].intensitaet/255)),effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanFadetime[l],effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanDelay[l]);
                    end;
                  end;
                end;
              end;
            end else if PositionInGroupArray>-1 then
            begin
              for l:=0 to length(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanActive)-1 do
              begin
                if effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanActive[l] then
                begin
                  if (effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanFadetime[l]=-1) then
                  begin
                    geraetesteuerung.set_group(mainform.devicegroups[PositionInGroupArray].ID,DeviceChannelNames[l],-1,round(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanValue[l]*(effektsequenzereffekte[i].intensitaet/255)),effektsequenzereffekte[i].Effektschritte[Schrittnummer].einblendzeit,effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanDelay[l]);
                  end else
                  begin
                    geraetesteuerung.set_group(mainform.devicegroups[PositionInGroupArray].ID,DeviceChannelNames[l],-1,round(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanValue[l]*(effektsequenzereffekte[i].intensitaet/255)),effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanFadetime[l],effektsequenzereffekte[i].Effektschritte[Schrittnummer].Devices[k].ChanDelay[l]);
                  end;
                end;
              end;
            end;
}
          end;

          // Szenenbefehle starten
          for j:=0 to length(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Befehle)-1 do
          if effektsequenzereffekte[i].Effektschritte[Schrittnummer].Befehlswerte[j].ChanActive[0] then
          begin
            if effektsequenzereffekte[i].Effektschritte[Schrittnummer].Befehlswerte[j].ChanFadetime[0]=-1 then
              StartDeviceSceneBefehl(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Befehle[j].ID, effektsequenzereffekte[i].Effektschritte[Schrittnummer].Befehle[j].Typ, effektsequenzereffekte[i].Effektschritte[Schrittnummer].Befehlswerte[j].ChanValue[0], effektsequenzereffekte[i].Effektschritte[Schrittnummer].einblendzeit, effektsequenzereffekte[i].Effektschritte[Schrittnummer].Befehlswerte[j].ChanDelay[0])
            else
              StartDeviceSceneBefehl(effektsequenzereffekte[i].Effektschritte[Schrittnummer].Befehle[j].ID, effektsequenzereffekte[i].Effektschritte[Schrittnummer].Befehle[j].Typ, effektsequenzereffekte[i].Effektschritte[Schrittnummer].Befehlswerte[j].ChanValue[0], effektsequenzereffekte[i].Effektschritte[Schrittnummer].Befehlswerte[j].ChanFadetime[0], effektsequenzereffekte[i].Effektschritte[Schrittnummer].Befehlswerte[j].ChanDelay[0]);
          end;
        end else if (effektsequenzereffekte[i].Effektschritte[Schrittnummer].Typ=2) then
        begin
          if (effektsequenzereffekte[i].Effektschritte[Schrittnummer].DeactivateLastScene) then
          begin
            // Alle Effektschritte des Effektes beenden
            for j:=0 to length(effektsequenzereffekte[i].Effektschritte)-1 do
              if effektsequenzereffekte[i].Effektschritte[j].Typ=2 then
                for k:=0 to length(effektsequenzereffekte[i].Effektschritte[j].IDs)-1 do
                  StopEffekt(effektsequenzereffekte[i].Effektschritte[j].IDs[k]);
          end;
          setlength(AktuellerEffekt[i].LastScene,length(effektsequenzereffekte[i].Effektschritte[Schrittnummer].IDs));
          for k:=0 to length(effektsequenzereffekte[i].Effektschritte[Schrittnummer].IDs)-1 do
          begin
            StartEffekt(effektsequenzereffekte[i].Effektschritte[Schrittnummer].IDs[k]);
            AktuellerEffekt[i].LastScene[k]:=effektsequenzereffekte[i].Effektschritte[Schrittnummer].IDs[k];
          end;
        end;
      end;
      break;
    end;
  end;
end;

procedure TMainform.Kontrollpanel1Click(Sender: TObject);
begin
  if not UserAccessGranted(3) then exit;

  if kontrollpanel.Showing then
    kontrollpanel.BringToFront
  else
  begin
    Kontrollpanel.Show;
    kontrollpanel.Width:=kontrollpanelrecord.formwidth;
    kontrollpanel.Height:=kontrollpanelrecord.formheight;
  end;
end;

function Tmainform.EditScene(ID: TGUID):String;
var
  deviceposition,delaytime:integer;
  i,j,k,l,m,n,t,h,min,s,ms:integer;
  scenefound:boolean;
begin
  // Einfache Einblendszene
  for j:=0 to length(EinfacheSzenen)-1 do
  begin
    if IsEqualGUID(EinfacheSzenen[j].ID,ID) then
    begin
      insscenedlg.Szenenname.Text:=mainform.einfacheszenen[j].Name;
      insscenedlg.Szenenbeschreibung.Enabled:=true;
      insscenedlg.Szenenbeschreibung.Text:=mainform.einfacheszenen[j].beschreibung;

      for k:=1 to lastchan do
        insscenedlg.active[k]:=mainform.einfacheszenen[j].kanalaktiv[k];

      // Kanalnamen in Dialogfeld schreiben
      insscenedlg.StringGrid1.RowCount:=mainform.lastchan+1;
      for k:=1 to mainform.lastchan do
      begin
        insscenedlg.StringGrid1.Cells[1,k]:=inttostr(k);
        insscenedlg.StringGrid1.Cells[2,k]:=mainform.data.Names[k];
        insscenedlg.StringGrid1.Cells[3,k]:=inttostr(round(mainform.einfacheszenen[j].kanal[k] * 100 / 255));
        insscenedlg.StringGrid1.Cells[4,k]:=inttostr(mainform.einfacheszenen[j].kanal[k]);
      end;

      // Fadezeit in Dialogfeld schreiben
      t:=mainform.einfacheszenen[j].einblendzeit;
      h:=t div 3600000;
      t:=t mod 3600000;
      min:=t div 60000;
      t:=t mod 60000;
      s:=t div 1000;
      t:=t mod 1000;
      ms:=t;

      insscenedlg.scenefade_time_h.Text:=inttostr(h);
      insscenedlg.scenefade_time_min.Text:=inttostr(min);
      insscenedlg.scenefade_time.Text:=inttostr(s);
      insscenedlg.scenefade_time_msec.Text:=inttostr(ms);

      insscenedlg.Caption:=_('Einfache Szene bearbeiten');

      if Insscenedlg.Showmodal=mrOK then
      begin
        // Array erweitern
        mainform.Einfacheszenen[j].Name:=insscenedlg.Szenenname.text;
        mainform.Einfacheszenen[j].beschreibung:=insscenedlg.Szenenbeschreibung.Text;

        // Fadezeit in Speicher schreiben
        t:=strtoint(insscenedlg.scenefade_time_msec.Text);
        t:=t+1000*strtoint(insscenedlg.scenefade_time.Text);
        t:=t+60*1000*strtoint(insscenedlg.scenefade_time_min.Text);
        t:=t+60*60*1000*strtoint(insscenedlg.scenefade_time_h.Text);
        mainform.Einfacheszenen[j].einblendzeit:=t;

        // Fade-Endwerte in Speicher schreiben
        for k:=1 to mainform.lastchan do
          mainform.Einfacheszenen[j].kanal[k]:=strtoint(insscenedlg.StringGrid1.Cells[4,k]);
        for k:=1 to mainform.lastchan do
          mainform.Einfacheszenen[j].kanalaktiv[k]:=insscenedlg.active[k];
      end;
      Result:=EinfacheSzenen[j].Name;
      insscenedlg.Szenenbeschreibung.Enabled:=false;
      break;
    end;
  end;
  // Geräteszenen
  for j:=0 to length(Devicescenes)-1 do
  begin
    if IsEqualGUID(Devicescenes[j].ID,ID) then
    begin
      devicesceneform.Szenenname.Text:=mainform.DeviceScenes[j].Name;
      devicesceneform.Szenenbeschreibung.Text:=mainform.DeviceScenes[j].Beschreibung;

      t:=mainform.DeviceScenes[j].Fadetime;
      h:=t div 3600000;
      t:=t mod 3600000;
      min:=t div 60000;
      t:=t mod 60000;
      s:=t div 1000;
      t:=t mod 1000;
      ms:=t;

      devicesceneform.scenefade_time_h.Text:=inttostr(h);
      devicesceneform.scenefade_time_min.Text:=inttostr(min);
      devicesceneform.scenefade_time.Text:=inttostr(s);
      devicesceneform.scenefade_time_msec.Text:=inttostr(ms);

      mainform.AktuelleDeviceScene.ID:=mainform.devicescenes[j].ID;
      mainform.AktuelleDeviceScene.Name:=mainform.devicescenes[j].Name;
      mainform.AktuelleDeviceScene.Beschreibung:=mainform.devicescenes[j].Beschreibung;
      mainform.AktuelleDeviceScene.Fadetime:=mainform.devicescenes[j].Fadetime;

      setlength(mainform.AktuelleDeviceScene.Devices,length(mainform.devicescenes[j].Devices));
      for i:=0 to length(mainform.devicescenes[j].Devices)-1 do
      begin
        mainform.AktuelleDeviceScene.Devices[i].ID:=mainform.devicescenes[j].Devices[i].ID;
        setlength(mainform.AktuelleDeviceScene.Devices[i].ChanActive,length(mainform.devicescenes[j].Devices[i].ChanActive));
        setlength(mainform.AktuelleDeviceScene.Devices[i].ChanValue,length(mainform.devicescenes[j].Devices[i].ChanValue));
        setlength(mainform.AktuelleDeviceScene.Devices[i].ChanActiveRandom,length(mainform.devicescenes[j].Devices[i].ChanActiveRandom));
        setlength(mainform.AktuelleDeviceScene.Devices[i].ChanValueRandom,length(mainform.devicescenes[j].Devices[i].ChanValueRandom));
        setlength(mainform.AktuelleDeviceScene.Devices[i].ChanDelay,length(mainform.devicescenes[j].Devices[i].ChanDelay));
        setlength(mainform.AktuelleDeviceScene.Devices[i].ChanFadetime,length(mainform.devicescenes[j].Devices[i].ChanFadetime));
        for k:=0 to length(mainform.devicescenes[j].Devices[i].ChanActive)-1 do
        begin
          mainform.AktuelleDeviceScene.Devices[i].ChanActive[k]:=mainform.devicescenes[j].Devices[i].ChanActive[k];
          mainform.AktuelleDeviceScene.Devices[i].ChanValue[k]:=mainform.devicescenes[j].Devices[i].ChanValue[k];
          mainform.AktuelleDeviceScene.Devices[i].ChanActiveRandom[k]:=mainform.devicescenes[j].Devices[i].ChanActiveRandom[k];
          mainform.AktuelleDeviceScene.Devices[i].ChanValueRandom[k]:=mainform.devicescenes[j].Devices[i].ChanValueRandom[k];
          mainform.AktuelleDeviceScene.Devices[i].ChanDelay[k]:=mainform.devicescenes[j].Devices[i].ChanDelay[k];
          mainform.AktuelleDeviceScene.Devices[i].ChanFadetime[k]:=mainform.devicescenes[j].Devices[i].ChanFadetime[k];
        end;
      end;

      setlength(mainform.AktuelleDeviceScene.Befehle, length(mainform.DeviceScenes[j].Befehle));
      setlength(mainform.AktuelleDeviceScene.Befehlswerte, length(mainform.DeviceScenes[j].Befehlswerte));
      for i:=0 to length(mainform.AktuelleDeviceScene.Befehle)-1 do
      begin
        mainform.AktuelleDeviceScene.Befehle[i].ID:=mainform.DeviceScenes[j].Befehle[i].ID;
        mainform.DeviceScenes[j].Befehle[i].ID:=StringToGUID('{00000000-0000-0000-0000-000000000000}'); // während Editieren auf 0 setzen

        mainform.AktuelleDeviceScene.Befehle[i].Typ:=mainform.DeviceScenes[j].Befehle[i].Typ;
        mainform.AktuelleDeviceScene.Befehle[i].Name:=mainform.DeviceScenes[j].Befehle[i].Name;
        mainform.AktuelleDeviceScene.Befehle[i].Beschreibung:=mainform.DeviceScenes[j].Befehle[i].Beschreibung;
        mainform.AktuelleDeviceScene.Befehle[i].OnValue:=mainform.DeviceScenes[j].Befehle[i].OnValue;
        mainform.AktuelleDeviceScene.Befehle[i].SwitchValue:=mainform.DeviceScenes[j].Befehle[i].SwitchValue;
        mainform.AktuelleDeviceScene.Befehle[i].InvertSwitchValue:=mainform.DeviceScenes[j].Befehle[i].InvertSwitchValue;
        mainform.AktuelleDeviceScene.Befehle[i].OffValue:=mainform.DeviceScenes[j].Befehle[i].OffValue;
        mainform.AktuelleDeviceScene.Befehle[i].ScaleValue:=mainform.DeviceScenes[j].Befehle[i].ScaleValue;

        setlength(mainform.AktuelleDeviceScene.Befehle[i].ArgInteger, length(mainform.DeviceScenes[j].Befehle[i].ArgInteger));
        setlength(mainform.AktuelleDeviceScene.Befehle[i].ArgString, length(mainform.DeviceScenes[j].Befehle[i].ArgString));
        setlength(mainform.AktuelleDeviceScene.Befehle[i].ArgGUID, length(mainform.DeviceScenes[j].Befehle[i].ArgGUID));
        for k:=0 to length(mainform.DeviceScenes[j].Befehle[i].ArgInteger)-1 do
          mainform.AktuelleDeviceScene.Befehle[i].ArgInteger[k]:=mainform.DeviceScenes[j].Befehle[i].ArgInteger[k];
        for k:=0 to length(mainform.DeviceScenes[j].Befehle[i].ArgString)-1 do
          mainform.AktuelleDeviceScene.Befehle[i].ArgString[k]:=mainform.DeviceScenes[j].Befehle[i].ArgString[k];
        for k:=0 to length(mainform.DeviceScenes[j].Befehle[i].ArgGUID)-1 do
          mainform.AktuelleDeviceScene.Befehle[i].ArgGUID[k]:=mainform.DeviceScenes[j].Befehle[i].ArgGUID[k];

        setlength(mainform.AktuelleDeviceScene.Befehlswerte[i].ChanActive, length(mainform.devicescenes[j].Befehlswerte[i].ChanActive));
        setlength(mainform.AktuelleDeviceScene.Befehlswerte[i].ChanValue, length(mainform.devicescenes[j].Befehlswerte[i].ChanValue));
        setlength(mainform.AktuelleDeviceScene.Befehlswerte[i].ChanActiveRandom, length(mainform.devicescenes[j].Befehlswerte[i].ChanActiveRandom));
        setlength(mainform.AktuelleDeviceScene.Befehlswerte[i].ChanValueRandom, length(mainform.devicescenes[j].Befehlswerte[i].ChanValueRandom));
        setlength(mainform.AktuelleDeviceScene.Befehlswerte[i].ChanDelay, length(mainform.devicescenes[j].Befehlswerte[i].ChanDelay));
        setlength(mainform.AktuelleDeviceScene.Befehlswerte[i].ChanFadetime, length(mainform.devicescenes[j].Befehlswerte[i].ChanFadetime));
        for k:=0 to length(mainform.devicescenes[j].Befehlswerte[i].ChanActive)-1 do
        begin
          mainform.AktuelleDeviceScene.Befehlswerte[i].ChanActive[k]:=mainform.devicescenes[j].Befehlswerte[i].ChanActive[k];
          mainform.AktuelleDeviceScene.Befehlswerte[i].ChanValue[k]:=mainform.devicescenes[j].Befehlswerte[i].ChanValue[k];
          mainform.AktuelleDeviceScene.Befehlswerte[i].ChanActiveRandom[k]:=mainform.devicescenes[j].Befehlswerte[i].ChanActiveRandom[k];
          mainform.AktuelleDeviceScene.Befehlswerte[i].ChanValueRandom[k]:=mainform.devicescenes[j].Befehlswerte[i].ChanValueRandom[k];
          mainform.AktuelleDeviceScene.Befehlswerte[i].ChanDelay[k]:=mainform.devicescenes[j].Befehlswerte[i].ChanDelay[k];
          mainform.AktuelleDeviceScene.Befehlswerte[i].ChanFadetime[k]:=mainform.devicescenes[j].Befehlswerte[i].ChanFadetime[k];
        end;
      end;

      devicesceneform.ShowModal;

      if devicesceneform.ModalResult=mrOK then
      begin
        mainform.devicescenes[j].ID:=mainform.AktuelleDeviceScene.ID;
        mainform.devicescenes[j].Name:=mainform.AktuelleDeviceScene.Name;
        mainform.devicescenes[j].Beschreibung:=mainform.AktuelleDeviceScene.Beschreibung;
        mainform.devicescenes[j].Fadetime:=mainform.AktuelleDeviceScene.Fadetime;

        setlength(mainform.devicescenes[j].Devices,length(mainform.AktuelleDeviceScene.Devices));
        for i:=0 to length(mainform.devicescenes[j].Devices)-1 do
        begin
          mainform.devicescenes[j].Devices[i].ID:=mainform.AktuelleDeviceScene.Devices[i].ID;
          setlength(mainform.devicescenes[j].Devices[i].ChanActive,length(mainform.AktuelleDeviceScene.Devices[i].ChanActive));
          setlength(mainform.devicescenes[j].Devices[i].ChanValue,length(mainform.AktuelleDeviceScene.Devices[i].ChanValue));
          setlength(mainform.devicescenes[j].Devices[i].ChanActiveRandom,length(mainform.AktuelleDeviceScene.Devices[i].ChanActiveRandom));
          setlength(mainform.devicescenes[j].Devices[i].ChanValueRandom,length(mainform.AktuelleDeviceScene.Devices[i].ChanValueRandom));
          setlength(mainform.devicescenes[j].Devices[i].ChanDelay,length(mainform.AktuelleDeviceScene.Devices[i].ChanDelay));
          setlength(mainform.devicescenes[j].Devices[i].ChanFadetime,length(mainform.AktuelleDeviceScene.Devices[i].ChanFadetime));
          for k:=0 to length(mainform.devicescenes[j].Devices[i].ChanActive)-1 do
          begin
            mainform.devicescenes[j].Devices[i].ChanActive[k]:=mainform.AktuelleDeviceScene.Devices[i].ChanActive[k];
            mainform.devicescenes[j].Devices[i].ChanValue[k]:=mainform.AktuelleDeviceScene.Devices[i].ChanValue[k];
            mainform.devicescenes[j].Devices[i].ChanActiveRandom[k]:=mainform.AktuelleDeviceScene.Devices[i].ChanActiveRandom[k];
            mainform.devicescenes[j].Devices[i].ChanValueRandom[k]:=mainform.AktuelleDeviceScene.Devices[i].ChanValueRandom[k];
            mainform.devicescenes[j].Devices[i].ChanDelay[k]:=mainform.AktuelleDeviceScene.Devices[i].ChanDelay[k];
            mainform.devicescenes[j].Devices[i].ChanFadetime[k]:=mainform.AktuelleDeviceScene.Devices[i].ChanFadetime[k];
          end;
        end;

        setlength(mainform.DeviceScenes[j].Befehle, length(mainform.AktuelleDeviceScene.Befehle));
        setlength(mainform.DeviceScenes[j].Befehlswerte, length(mainform.AktuelleDeviceScene.Befehlswerte));
        for i:=0 to length(mainform.DeviceScenes[j].Befehle)-1 do
        begin
          mainform.DeviceScenes[j].Befehle[i].ID:=mainform.AktuelleDeviceScene.Befehle[i].ID;
          mainform.DeviceScenes[j].Befehle[i].Typ:=mainform.AktuelleDeviceScene.Befehle[i].Typ;
          mainform.DeviceScenes[j].Befehle[i].Name:=mainform.AktuelleDeviceScene.Befehle[i].Name;
          mainform.DeviceScenes[j].Befehle[i].Beschreibung:=mainform.AktuelleDeviceScene.Befehle[i].Beschreibung;
          mainform.DeviceScenes[j].Befehle[i].OnValue:=mainform.AktuelleDeviceScene.Befehle[i].OnValue;
          mainform.DeviceScenes[j].Befehle[i].SwitchValue:=mainform.AktuelleDeviceScene.Befehle[i].SwitchValue;
          mainform.DeviceScenes[j].Befehle[i].InvertSwitchValue:=mainform.AktuelleDeviceScene.Befehle[i].InvertSwitchValue;
          mainform.DeviceScenes[j].Befehle[i].OffValue:=mainform.AktuelleDeviceScene.Befehle[i].OffValue;
          mainform.DeviceScenes[j].Befehle[i].ScaleValue:=mainform.AktuelleDeviceScene.Befehle[i].ScaleValue;

          setlength(mainform.DeviceScenes[j].Befehle[i].ArgInteger, length(mainform.AktuelleDeviceScene.Befehle[i].ArgInteger));
          setlength(mainform.DeviceScenes[j].Befehle[i].ArgString, length(mainform.AktuelleDeviceScene.Befehle[i].ArgString));
          setlength(mainform.DeviceScenes[j].Befehle[i].ArgGUID, length(mainform.AktuelleDeviceScene.Befehle[i].ArgGUID));
          for k:=0 to length(mainform.DeviceScenes[j].Befehle[i].ArgInteger)-1 do
            mainform.DeviceScenes[j].Befehle[i].ArgInteger[k]:=mainform.AktuelleDeviceScene.Befehle[i].ArgInteger[k];
          for k:=0 to length(mainform.DeviceScenes[j].Befehle[i].ArgString)-1 do
            mainform.DeviceScenes[j].Befehle[i].ArgString[k]:=mainform.AktuelleDeviceScene.Befehle[i].ArgString[k];
          for k:=0 to length(mainform.DeviceScenes[j].Befehle[i].ArgGUID)-1 do
            mainform.DeviceScenes[j].Befehle[i].ArgGUID[k]:=mainform.AktuelleDeviceScene.Befehle[i].ArgGUID[k];

          setlength(mainform.devicescenes[j].Befehlswerte[i].ChanActive,length(mainform.AktuelleDeviceScene.Befehlswerte[i].ChanActive));
          setlength(mainform.devicescenes[j].Befehlswerte[i].ChanValue,length(mainform.AktuelleDeviceScene.Befehlswerte[i].ChanValue));
          setlength(mainform.devicescenes[j].Befehlswerte[i].ChanActiveRandom,length(mainform.AktuelleDeviceScene.Befehlswerte[i].ChanActiveRandom));
          setlength(mainform.devicescenes[j].Befehlswerte[i].ChanValueRandom,length(mainform.AktuelleDeviceScene.Befehlswerte[i].ChanValueRandom));
          setlength(mainform.devicescenes[j].Befehlswerte[i].ChanDelay,length(mainform.AktuelleDeviceScene.Befehlswerte[i].ChanDelay));
          setlength(mainform.devicescenes[j].Befehlswerte[i].ChanFadetime,length(mainform.AktuelleDeviceScene.Befehlswerte[i].ChanFadetime));
          for k:=0 to length(mainform.devicescenes[j].Befehlswerte[i].ChanActive)-1 do
          begin
            mainform.devicescenes[j].Befehlswerte[i].ChanActive[k]:=mainform.AktuelleDeviceScene.Befehlswerte[i].ChanActive[k];
            mainform.devicescenes[j].Befehlswerte[i].ChanValue[k]:=mainform.AktuelleDeviceScene.Befehlswerte[i].ChanValue[k];
            mainform.devicescenes[j].Befehlswerte[i].ChanActiveRandom[k]:=mainform.AktuelleDeviceScene.Befehlswerte[i].ChanActiveRandom[k];
            mainform.devicescenes[j].Befehlswerte[i].ChanValueRandom[k]:=mainform.AktuelleDeviceScene.Befehlswerte[i].ChanValueRandom[k];
            mainform.devicescenes[j].Befehlswerte[i].ChanDelay[k]:=mainform.AktuelleDeviceScene.Befehlswerte[i].ChanDelay[k];
            mainform.devicescenes[j].Befehlswerte[i].ChanFadetime[k]:=mainform.AktuelleDeviceScene.Befehlswerte[i].ChanFadetime[k];
          end;
        end;

        mainform.devicescenes[j].Name:=devicesceneform.Szenenname.Text;
        mainform.devicescenes[j].Beschreibung:=devicesceneform.Szenenbeschreibung.Text;

        // Fadezeit in Speicher schreiben
        t:=strtoint(devicesceneform.scenefade_time_msec.Text);
        t:=t+1000*strtoint(devicesceneform.scenefade_time.Text);
        t:=t+60*1000*strtoint(devicesceneform.scenefade_time_min.Text);
        t:=t+60*60*1000*strtoint(devicesceneform.scenefade_time_h.Text);

        mainform.devicescenes[j].Fadetime:=t;
      end else
      begin
      end;
      break;
    end;
  end;
  // Audioszene
  for j:=0 to length(AudioSzenen)-1 do
  begin
    if IsEqualGUID(AudioSzenen[j].ID,ID) then
    begin
      audioszeneneditor.Edit1.Text:=mainform.Audioszenen[j].Name;
      audioszeneneditor.Edit2.Text:=mainform.Audioszenen[j].Beschreibung;
      audioszeneneditor.Edit3.Text:=mainform.Audioszenen[j].Datei;
                   
      for k:=0 to 7 do
      begin
        TJvSpinEdit(audioszeneneditor.FindComponent('l'+inttostr(k))).Value:=mainform.Audioszenen[j].matrix[0][k];
        TJvSpinEdit(audioszeneneditor.FindComponent('r'+inttostr(k))).Value:=mainform.Audioszenen[j].matrix[1][k];
        TJvSpinEdit(audioszeneneditor.FindComponent('cen'+inttostr(k))).Value:=mainform.Audioszenen[j].matrix[2][k];
        TJvSpinEdit(audioszeneneditor.FindComponent('lfe'+inttostr(k))).Value:=mainform.Audioszenen[j].matrix[3][k];
        TJvSpinEdit(audioszeneneditor.FindComponent('sl'+inttostr(k))).Value:=mainform.Audioszenen[j].matrix[4][k];
        TJvSpinEdit(audioszeneneditor.FindComponent('sr'+inttostr(k))).Value:=mainform.Audioszenen[j].matrix[5][k];
        TJvSpinEdit(audioszeneneditor.FindComponent('hl'+inttostr(k))).Value:=mainform.Audioszenen[j].matrix[6][k];
        TJvSpinEdit(audioszeneneditor.FindComponent('hr'+inttostr(k))).Value:=mainform.Audioszenen[j].matrix[7][k];
      end;
//        audioszeneneditor.audio_mono.Checked:=mainform.Audioszenen[j].Kanalsettings[0]=255;

      if FileExists(userdirectory+'ProjectTemp\'+mainform.Audioszenen[j].Datei) then
        audioszeneneditor.label6.caption:=userdirectory+'ProjectTemp\'+mainform.Audioszenen[j].Datei
      else
        audioszeneneditor.label6.caption:=mainform.Audioszenen[j].Datei;

      // Zeit in Dialogfeld schreiben
      t:=mainform.Audioszenen[j].dauer;
      h:=t div 3600000;
      t:=t mod 3600000;
      min:=t div 60000;
      t:=t mod 60000;
      s:=t div 1000;
      ms:=t mod 1000;
      audioszeneneditor.Edit4.Text:=inttostr(h);
      audioszeneneditor.Edit5.Text:=inttostr(min);
      audioszeneneditor.Edit6.Text:=inttostr(s);
      audioszeneneditor.Edit7.Text:=inttostr(ms);

      t:=mainform.Audioszenen[j].fadeintime;
      h:=t div 3600000;
      t:=t mod 3600000;
      min:=t div 60000;
      t:=t mod 60000;
      s:=t div 1000;
      ms:=t mod 1000;
      audioszeneneditor.editfadeinh.Text:=inttostr(h);
      audioszeneneditor.editfadeinmin.Text:=inttostr(min);
      audioszeneneditor.editfadeins.Text:=inttostr(s);
      audioszeneneditor.editfadeinms.Text:=inttostr(ms);

      t:=mainform.Audioszenen[j].fadeouttime;
      h:=t div 3600000;
      t:=t mod 3600000;
      min:=t div 60000;
      t:=t mod 60000;
      s:=t div 1000;
      ms:=t mod 1000;
      audioszeneneditor.editfadeouth.Text:=inttostr(h);
      audioszeneneditor.editfadeoutmin.Text:=inttostr(min);
      audioszeneneditor.editfadeouts.Text:=inttostr(s);
      audioszeneneditor.editfadeoutms.Text:=inttostr(ms);

      audioszeneneditor.editVolume.text:=inttostr(round(mainform.Audioszenen[j].Volume*100));

      audioszeneneditor.ShowModal;
      if audioszeneneditor.ModalResult=mrOK then
      begin
        mainform.Audioszenen[j].Name:=audioszeneneditor.Edit1.text;
        mainform.Audioszenen[j].Beschreibung:=audioszeneneditor.edit2.Text;
        mainform.Audioszenen[j].Datei:=audioszeneneditor.Edit3.Text;

        for k:=0 to 7 do
        begin
          for l:=0 to 7 do
            mainform.Audioszenen[j].matrix[k][l]:=0;
          mainform.Audioszenen[j].Kanalsettings[k]:=0;
        end;

        for k:=0 to 7 do
        begin
          mainform.Audioszenen[j].matrix[0][k]:=TJvSpinEdit(audioszeneneditor.FindComponent('l'+inttostr(k))).Value;
          mainform.Audioszenen[j].matrix[1][k]:=TJvSpinEdit(audioszeneneditor.FindComponent('r'+inttostr(k))).Value;
          mainform.Audioszenen[j].matrix[2][k]:=TJvSpinEdit(audioszeneneditor.FindComponent('cen'+inttostr(k))).Value;
          mainform.Audioszenen[j].matrix[3][k]:=TJvSpinEdit(audioszeneneditor.FindComponent('lfe'+inttostr(k))).Value;
          mainform.Audioszenen[j].matrix[4][k]:=TJvSpinEdit(audioszeneneditor.FindComponent('sl'+inttostr(k))).Value;
          mainform.Audioszenen[j].matrix[5][k]:=TJvSpinEdit(audioszeneneditor.FindComponent('sr'+inttostr(k))).Value;
          mainform.Audioszenen[j].matrix[6][k]:=TJvSpinEdit(audioszeneneditor.FindComponent('hl'+inttostr(k))).Value;
          mainform.Audioszenen[j].matrix[7][k]:=TJvSpinEdit(audioszeneneditor.FindComponent('hr'+inttostr(k))).Value;
        end;

{
        if audioszeneneditor.audio_mono.Checked then
          mainform.Audioszenen[j].Kanalsettings[0]:=255
        else
          mainform.Audioszenen[j].Kanalsettings[0]:=0;
}
        t:=strtoint(audioszeneneditor.Edit7.Text);
        t:=t+strtoint(audioszeneneditor.Edit6.Text)*1000;
        t:=t+strtoint(audioszeneneditor.Edit5.Text)*60*1000;
        t:=t+strtoint(audioszeneneditor.Edit4.Text)*60*60*1000;
        mainform.Audioszenen[j].Dauer:=t;

        t:=strtoint(audioszeneneditor.editfadeinms.Text);
        t:=t+strtoint(audioszeneneditor.editfadeins.Text)*1000;
        t:=t+strtoint(audioszeneneditor.editfadeinmin.Text)*60*1000;
        t:=t+strtoint(audioszeneneditor.editfadeinh.Text)*60*60*1000;
        mainform.Audioszenen[j].Fadeintime:=t;

        t:=strtoint(audioszeneneditor.editfadeoutms.Text);
        t:=t+strtoint(audioszeneneditor.editfadeouts.Text)*1000;
        t:=t+strtoint(audioszeneneditor.editfadeoutmin.Text)*60*1000;
        t:=t+strtoint(audioszeneneditor.editfadeouth.Text)*60*60*1000;
        mainform.Audioszenen[j].FadeOutTime:=t;

        mainform.Audioszenen[j].Volume:=strtoint(audioszeneneditor.editVolume.Text)/100;
      end;
      Result:=AudioSzenen[j].Name;
      break;
    end;
  end;
  // Bewegungsszene
  for j:=0 to length(Bewegungsszenen)-1 do
  begin
    if IsEqualGUID(Bewegungsszenen[j].ID,ID) then
    begin
      mainform.StopScene(ID);

      mainform.AktuelleBewegungsszene.ID:=mainform.Bewegungsszenen[j].ID;
      mainform.AktuelleBewegungsszene.Name:=mainform.Bewegungsszenen[j].Name;
      mainform.AktuelleBewegungsszene.Beschreibung:=mainform.Bewegungsszenen[j].Beschreibung;
      mainform.AktuelleBewegungsszene.IsBeatControlled:=mainform.Bewegungsszenen[j].IsBeatControlled;
      mainform.AktuelleBewegungsszene.figur:=mainform.Bewegungsszenen[j].figur;
      mainform.AktuelleBewegungsszene.dauer:=mainform.Bewegungsszenen[j].dauer;
      mainform.AktuelleBewegungsszene.DontFade:=mainform.Bewegungsszenen[j].DontFade;
      mainform.AktuelleBewegungsszene.repeats:=mainform.Bewegungsszenen[j].repeats;
      mainform.AktuelleBewegungsszene.identischespurgeschwidigkeit:=mainform.Bewegungsszenen[j].identischespurgeschwidigkeit;
      mainform.AktuelleBewegungsszene.startpositionrelativ:=mainform.Bewegungsszenen[j].startpositionrelativ;

      setlength(mainform.AktuelleBewegungsszene.Devices,length(mainform.Bewegungsszenen[j].Devices));

      setlength(bewegungsszeneneditorform.Zeit,length(mainform.Bewegungsszenen[j].Devices));
      setlength(bewegungsszeneneditorform.AktuelleBewegungsszeneZeit,length(mainform.Bewegungsszenen[j].Devices));
      setlength(bewegungsszeneneditorform.AktuelleBewegungsszeneRepeats,length(mainform.Bewegungsszenen[j].Devices));
      setlength(bewegungsszeneneditorform.AktuelleBewegungsszenePosition,length(mainform.Bewegungsszenen[j].Devices));

      for i:=0 to length(mainform.AktuelleBewegungsszene.Devices)-1 do
      begin
        setlength(mainform.AktuelleBewegungsszene.Devices[i].DeviceChannel,length(mainform.Bewegungsszenen[j].Devices[i].DeviceChannel));
        setlength(mainform.AktuelleBewegungsszene.Devices[i].Szenen,length(mainform.Bewegungsszenen[j].Devices[i].DeviceChannel));

        setlength(bewegungsszeneneditorform.Zeit[i],length(mainform.Bewegungsszenen[j].Devices[i].DeviceChannel));
        setlength(bewegungsszeneneditorform.AktuelleBewegungsszeneZeit[i],length(mainform.Bewegungsszenen[j].Devices[i].DeviceChannel));
        setlength(bewegungsszeneneditorform.AktuelleBewegungsszeneRepeats[i],length(mainform.Bewegungsszenen[j].Devices[i].DeviceChannel));
        setlength(bewegungsszeneneditorform.AktuelleBewegungsszenePosition[i],length(mainform.Bewegungsszenen[j].Devices[i].DeviceChannel));

        mainform.AktuelleBewegungsszene.Devices[i].ID:=mainform.Bewegungsszenen[j].Devices[i].ID;

        for k:=0 to length(mainform.AktuelleBewegungsszene.Devices[i].DeviceChannel)-1 do
        begin
          mainform.AktuelleBewegungsszene.Devices[i].DeviceChannel[k]:=mainform.Bewegungsszenen[j].Devices[i].DeviceChannel[k];

          setlength(mainform.AktuelleBewegungsszene.Devices[i].Szenen[k],length(mainform.Bewegungsszenen[j].Devices[i].Szenen[k]));
          for l:=0 to length(mainform.AktuelleBewegungsszene.Devices[i].Szenen[k])-1 do
          begin
            mainform.AktuelleBewegungsszene.Devices[i].Szenen[k][l]:=mainform.Bewegungsszenen[j].Devices[i].Szenen[k][l];
          end;
        end;
      end;

      if bewegungsszeneneditorform.showmodal=mrOK then
      begin
        mainform.Bewegungsszenen[j].ID:=mainform.AktuelleBewegungsszene.ID;
        mainform.Bewegungsszenen[j].Name:=mainform.AktuelleBewegungsszene.Name;
        mainform.Bewegungsszenen[j].IsBeatControlled:=mainform.AktuelleBewegungsszene.IsBeatControlled;
        mainform.Bewegungsszenen[j].Beschreibung:=mainform.AktuelleBewegungsszene.Beschreibung;
        mainform.Bewegungsszenen[j].figur:=mainform.AktuelleBewegungsszene.figur;
        mainform.Bewegungsszenen[j].dauer:=mainform.AktuelleBewegungsszene.dauer;
        mainform.Bewegungsszenen[j].DontFade:=mainform.AktuelleBewegungsszene.DontFade;
        mainform.Bewegungsszenen[j].repeats:=mainform.AktuelleBewegungsszene.repeats;
        mainform.Bewegungsszenen[j].identischespurgeschwidigkeit:=mainform.AktuelleBewegungsszene.identischespurgeschwidigkeit;
        mainform.Bewegungsszenen[j].startpositionrelativ:=mainform.AktuelleBewegungsszene.startpositionrelativ;

        setlength(mainform.Bewegungsszenen[j].Devices,length(mainform.AktuelleBewegungsszene.Devices));
        setlength(mainform.BewegungsszenenZeit[j],length(mainform.AktuelleBewegungsszene.Devices));
        setlength(mainform.BewegungsszenenAktiv[j].Zeit,length(mainform.AktuelleBewegungsszene.Devices));
        setlength(mainform.BewegungsszenenAktiv[j].Repeats,length(mainform.AktuelleBewegungsszene.Devices));
        setlength(mainform.BewegungsszenenAktiv[j].Position,length(mainform.AktuelleBewegungsszene.Devices));

        for i:=0 to length(mainform.AktuelleBewegungsszene.Devices)-1 do
        begin
          setlength(mainform.Bewegungsszenen[j].Devices[i].DeviceChannel,length(mainform.AktuelleBewegungsszene.Devices[i].DeviceChannel));
          setlength(mainform.Bewegungsszenen[j].Devices[i].Szenen,length(mainform.AktuelleBewegungsszene.Devices[i].DeviceChannel));

          setlength(mainform.BewegungsszenenZeit[j][i],length(mainform.AktuelleBewegungsszene.Devices[i].DeviceChannel));
          setlength(mainform.BewegungsszenenAktiv[j].Zeit[i],length(mainform.AktuelleBewegungsszene.Devices[i].DeviceChannel));
          setlength(mainform.BewegungsszenenAktiv[j].Repeats[i],length(mainform.AktuelleBewegungsszene.Devices[i].DeviceChannel));
          setlength(mainform.BewegungsszenenAktiv[j].Position[i],length(mainform.AktuelleBewegungsszene.Devices[i].DeviceChannel));

          mainform.Bewegungsszenen[j].Devices[i].ID:=mainform.AktuelleBewegungsszene.Devices[i].ID;

          for k:=0 to length(mainform.AktuelleBewegungsszene.Devices[i].DeviceChannel)-1 do
          begin
            mainform.Bewegungsszenen[j].Devices[i].DeviceChannel[k]:=mainform.AktuelleBewegungsszene.Devices[i].DeviceChannel[k];

            setlength(mainform.Bewegungsszenen[j].Devices[i].Szenen[k],length(mainform.AktuelleBewegungsszene.Devices[i].Szenen[k]));
            for l:=0 to length(mainform.AktuelleBewegungsszene.Devices[i].Szenen[k])-1 do
            begin
              mainform.Bewegungsszenen[j].Devices[i].Szenen[k][l]:=mainform.AktuelleBewegungsszene.Devices[i].Szenen[k][l];
            end;
          end;
        end;
      end;
      Result:=Bewegungsszenen[j].Name;
      break;
    end;
  end;
  // Befehle
  for j:=0 to length(Befehle2)-1 do
  begin
    if IsEqualGUID(Befehle2[j].ID,ID) then
    begin
      setlength(befehlseditor_array2,length(befehlseditor_array2)+1);
      befehlseditor_array2[length(befehlseditor_array2)-1]:=Tbefehlseditor2.Create(self);
      befehlseditor_array2[length(befehlseditor_array2)-1].CheckBox1.Visible:=true;

      befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.ID:=mainform.Befehle2[j].ID;
      befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.Typ:=mainform.Befehle2[j].Typ;
      befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.Name:=mainform.Befehle2[j].Name;
      befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.Beschreibung:=mainform.Befehle2[j].Beschreibung;
      befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.OnValue:=mainform.Befehle2[j].OnValue;
      befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.SwitchValue:=mainform.Befehle2[j].SwitchValue;
      befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.InvertSwitchValue:=mainform.Befehle2[j].InvertSwitchValue;
      befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.OffValue:=mainform.Befehle2[j].OffValue;
      befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.ScaleValue:=mainform.Befehle2[j].ScaleValue;
      befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.RunOnProjectLoad:=mainform.Befehle2[j].RunOnProjectLoad;

      setlength(befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.ArgInteger,length(mainform.Befehle2[j].ArgInteger));
      for i:=0 to length(mainform.Befehle2[j].ArgInteger)-1 do
        befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.ArgInteger[i]:=mainform.Befehle2[j].ArgInteger[i];
      setlength(befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.ArgString,length(mainform.Befehle2[j].ArgString));
      for i:=0 to length(mainform.Befehle2[j].ArgString)-1 do
        befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.ArgString[i]:=mainform.Befehle2[j].ArgString[i];
      setlength(befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.ArgGUID,length(mainform.Befehle2[j].ArgGUID));
      for i:=0 to length(mainform.Befehle2[j].ArgGUID)-1 do
        befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.ArgGUID[i]:=mainform.Befehle2[j].ArgGUID[i];

      befehlseditor_array2[length(befehlseditor_array2)-1].ShowModal;

      if befehlseditor_array2[length(befehlseditor_array2)-1].ModalResult=mrOK then
      begin
        mainform.Befehle2[j].Typ:=befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.Typ;
        mainform.Befehle2[j].Name:=befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.Name;
        mainform.Befehle2[j].Beschreibung:=befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.Beschreibung;
        mainform.Befehle2[j].OnValue:=befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.OnValue;
        mainform.Befehle2[j].SwitchValue:=befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.SwitchValue;
        mainform.Befehle2[j].InvertSwitchValue:=befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.InvertSwitchValue;
        mainform.Befehle2[j].OffValue:=befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.OffValue;
        mainform.Befehle2[j].ScaleValue:=befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.ScaleValue;
        mainform.Befehle2[j].RunOnProjectLoad:=befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.RunOnProjectLoad;
        setlength(mainform.Befehle2[j].ArgInteger,length(befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.ArgInteger));
        for i:=0 to length(befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.ArgInteger)-1 do
          mainform.Befehle2[j].ArgInteger[i]:=befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.ArgInteger[i];
        setlength(mainform.Befehle2[j].ArgString,length(befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.ArgString));
        for i:=0 to length(befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.ArgString)-1 do
          mainform.Befehle2[j].ArgString[i]:=befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.ArgString[i];
        setlength(mainform.Befehle2[j].ArgGUID,length(befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.ArgGUID));
        for i:=0 to length(befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.ArgGUID)-1 do
          mainform.Befehle2[j].ArgGUID[i]:=befehlseditor_array2[length(befehlseditor_array2)-1].AktuellerBefehl.ArgGUID[i];
      end;

      befehlseditor_array2[length(befehlseditor_array2)-1].Free;
      setlength(befehlseditor_array2,length(befehlseditor_array2)-1);
      Result:=Befehle2[j].Name;

      break;
    end;
  end;
  // Kombinationsszene
  for j:=0 to length(Kompositionsszenen)-1 do
  begin
    if IsEqualGUID(Kompositionsszenen[j].ID,ID) then
    begin
      setlength(kompositionsszeneeditor_array,length(kompositionsszeneeditor_array)+1);
      kompositionsszeneeditor_array[length(kompositionsszeneeditor_array)-1]:=Tkompositionsszeneeditor.Create(self);
//      setlength(AktuelleKompositionsszene,length(AktuelleKompositionsszene)+1);

      kompositionsszeneeditor_array[length(kompositionsszeneeditor_array)-1].ListBox1.Clear;
      kompositionsszeneeditor_array[length(kompositionsszeneeditor_array)-1].AktuelleKompositionsszene.ID:=mainform.kompositionsszenen[j].ID;
      kompositionsszeneeditor_array[length(kompositionsszeneeditor_array)-1].AktuelleKompositionsszene.Name:=mainform.kompositionsszenen[j].Name;
      kompositionsszeneeditor_array[length(kompositionsszeneeditor_array)-1].Edit1.Text:=mainform.kompositionsszenen[j].Name;
      kompositionsszeneeditor_array[length(kompositionsszeneeditor_array)-1].AktuelleKompositionsszene.Beschreibung:=mainform.kompositionsszenen[j].Beschreibung;
      kompositionsszeneeditor_array[length(kompositionsszeneeditor_array)-1].Edit2.Text:=mainform.kompositionsszenen[j].Beschreibung;
      setlength(kompositionsszeneeditor_array[length(kompositionsszeneeditor_array)-1].AktuelleKompositionsszene.IDs,length(mainform.kompositionsszenen[j].IDs));
      setlength(kompositionsszeneeditor_array[length(kompositionsszeneeditor_array)-1].AktuelleKompositionsszene.StopScene,length(mainform.kompositionsszenen[j].IDs));

      for i:=0 to length(mainform.kompositionsszenen[j].IDs)-1 do
      begin
        kompositionsszeneeditor_array[length(kompositionsszeneeditor_array)-1].AktuelleKompositionsszene.IDs[i]:=mainform.kompositionsszenen[j].IDs[i];
        kompositionsszeneeditor_array[length(kompositionsszeneeditor_array)-1].AktuelleKompositionsszene.StopScene[i]:=mainform.kompositionsszenen[j].StopScene[i];
      end;

      for i:=0 to length(mainform.kompositionsszenen[j].IDs)-1 do
      begin
        kompositionsszeneeditor_array[length(kompositionsszeneeditor_array)-1].Listbox1.Items.Add(mainform.GetSceneInfo2(mainform.kompositionsszenen[j].IDs[i], 'name'));
      end;

      kompositionsszeneeditor_array[length(kompositionsszeneeditor_array)-1].showmodal;

      if kompositionsszeneeditor_array[length(kompositionsszeneeditor_array)-1].ModalResult=mrOK then
      begin
        Kompositionsszenen[j].Name:=kompositionsszeneeditor_array[length(kompositionsszeneeditor_array)-1].Edit1.text;
        Kompositionsszenen[j].Beschreibung:=kompositionsszeneeditor_array[length(kompositionsszeneeditor_array)-1].edit2.Text;

        setlength(mainform.kompositionsszenen[j].IDs,length(kompositionsszeneeditor_array[length(kompositionsszeneeditor_array)-1].AktuelleKompositionsszene.IDs));
        setlength(mainform.kompositionsszenen[j].StopScene,length(kompositionsszeneeditor_array[length(kompositionsszeneeditor_array)-1].AktuelleKompositionsszene.IDs));

        for i:=0 to length(kompositionsszeneeditor_array[length(kompositionsszeneeditor_array)-1].AktuelleKompositionsszene.IDs)-1 do
        begin
          kompositionsszenen[j].IDs[i]:=kompositionsszeneeditor_array[length(kompositionsszeneeditor_array)-1].AktuelleKompositionsszene.IDs[i];
          kompositionsszenen[j].StopScene[i]:=kompositionsszeneeditor_array[length(kompositionsszeneeditor_array)-1].AktuelleKompositionsszene.StopScene[i];
        end;
      end;

      kompositionsszeneeditor_array[length(kompositionsszeneeditor_array)-1].Free;
      setlength(kompositionsszeneeditor_array,length(kompositionsszeneeditor_array)-1);

      Result:=Kompositionsszenen[j].Name;
      break;
    end;
  end;
  // Preset
  for j:=0 to length(DevicePresets)-1 do
  begin
    if IsEqualGUID(DevicePresets[j].ID,ID) then
    begin
      preseteditor.Edit1.Text:=mainform.devicepresets[j].Name;
      preseteditor.Edit2.Text:=mainform.devicepresets[j].Beschreibung;

      preseteditor.CheckListBox1.checked[0]:=mainform.DevicePresets[j].ChanActive[0];
      preseteditor.PositionXY.Left:=round(((mainform.DevicePresets[j].ChanValue[0]/255)*preseteditor.fadenkreuz.Width)-preseteditor.PositionXY.Width/2);
      preseteditor.CheckListBox1.checked[1]:=mainform.DevicePresets[j].ChanActive[1];
      preseteditor.PositionXY.Top:=round(((mainform.DevicePresets[j].ChanValue[1]/255)*preseteditor.fadenkreuz.Height)-preseteditor.PositionXY.Height/2);
      preseteditor.CheckListBox1.checked[2]:=mainform.DevicePresets[j].ChanActive[2];
      preseteditor.moves.position:=mainform.DevicePresets[j].ChanValue[2];
      preseteditor.CheckListBox1.checked[3]:=mainform.DevicePresets[j].ChanActive[3];
      preseteditor.speed.position:=mainform.DevicePresets[j].ChanValue[3];
      preseteditor.CheckListBox1.checked[4]:=mainform.DevicePresets[j].ChanActive[4];
      preseteditor.gobo1.position:=mainform.DevicePresets[j].ChanValue[4];
      preseteditor.CheckListBox1.checked[5]:=mainform.DevicePresets[j].ChanActive[5];
      preseteditor.gobo1rot.position:=mainform.DevicePresets[j].ChanValue[5];
      preseteditor.CheckListBox1.checked[6]:=mainform.DevicePresets[j].ChanActive[6];
      preseteditor.gobo2.position:=mainform.DevicePresets[j].ChanValue[6];
      preseteditor.CheckListBox1.checked[7]:=mainform.DevicePresets[j].ChanActive[7];
      preseteditor.gobo2rot.position:=mainform.DevicePresets[j].ChanValue[7];
      preseteditor.CheckListBox1.checked[8]:=mainform.DevicePresets[j].ChanActive[8];
      preseteditor.gobo3.position:=mainform.DevicePresets[j].ChanValue[8];
      preseteditor.CheckListBox1.checked[9]:=mainform.DevicePresets[j].ChanActive[9];
      preseteditor.goboextra.position:=mainform.DevicePresets[j].ChanValue[9];
      preseteditor.CheckListBox1.checked[10]:=mainform.DevicePresets[j].ChanActive[10];
      preseteditor.color1.position:=mainform.DevicePresets[j].ChanValue[10];
      preseteditor.CheckListBox1.checked[11]:=mainform.DevicePresets[j].ChanActive[11];
      preseteditor.color2.position:=mainform.DevicePresets[j].ChanValue[11];
      preseteditor.CheckListBox1.checked[12]:=mainform.DevicePresets[j].ChanActive[12];
      preseteditor.r.position:=mainform.DevicePresets[j].ChanValue[12];
      preseteditor.CheckListBox1.checked[13]:=mainform.DevicePresets[j].ChanActive[13];
      preseteditor.g.position:=mainform.DevicePresets[j].ChanValue[13];
      preseteditor.CheckListBox1.checked[14]:=mainform.DevicePresets[j].ChanActive[14];
      preseteditor.b.position:=mainform.DevicePresets[j].ChanValue[14];
      preseteditor.CheckListBox1.checked[15]:=mainform.DevicePresets[j].ChanActive[15];
      preseteditor.iris.position:=mainform.DevicePresets[j].ChanValue[15];
      preseteditor.CheckListBox1.checked[16]:=mainform.DevicePresets[j].ChanActive[16];
      preseteditor.shutter.position:=mainform.DevicePresets[j].ChanValue[16];
      preseteditor.CheckListBox1.checked[17]:=mainform.DevicePresets[j].ChanActive[17];
      preseteditor.dimmer.position:=mainform.DevicePresets[j].ChanValue[17];
      preseteditor.CheckListBox1.checked[18]:=mainform.DevicePresets[j].ChanActive[18];
      preseteditor.zoom.position:=mainform.DevicePresets[j].ChanValue[18];
      preseteditor.CheckListBox1.checked[19]:=mainform.DevicePresets[j].ChanActive[19];
      preseteditor.focus.position:=mainform.DevicePresets[j].ChanValue[19];
      preseteditor.CheckListBox1.checked[20]:=mainform.DevicePresets[j].ChanActive[20];
      preseteditor.prism.position:=mainform.DevicePresets[j].ChanValue[20];
      preseteditor.CheckListBox1.checked[21]:=mainform.DevicePresets[j].ChanActive[21];
      preseteditor.frost.position:=mainform.DevicePresets[j].ChanValue[21];
      preseteditor.CheckListBox1.checked[22]:=mainform.DevicePresets[j].ChanActive[22];
      preseteditor.special1.position:=mainform.DevicePresets[j].ChanValue[22];
      preseteditor.CheckListBox1.checked[23]:=mainform.DevicePresets[j].ChanActive[23];
      preseteditor.special2.position:=mainform.DevicePresets[j].ChanValue[23];
      preseteditor.CheckListBox1.checked[24]:=mainform.DevicePresets[j].ChanActive[24];
      preseteditor.special3.position:=mainform.DevicePresets[j].ChanValue[24];

      preseteditor.CheckBox1.Checked:=not mainform.DevicePresets[j].UseNewInterface;
      preseteditor.Panel2.visible:=preseteditor.CheckBox1.Checked;
      preseteditor.Panel3.Visible:=not preseteditor.CheckBox1.Checked;
      preseteditor.groupbox3.visible:=preseteditor.CheckBox1.Checked;
      if preseteditor.CheckBox1.Checked then
      begin
        preseteditor.groupbox2.height:=185;
        preseteditor.treeview1.height:=137;
      end else
      begin
        preseteditor.groupbox2.height:=345;
        preseteditor.treeview1.height:=297;
      end;

      case mainform.DevicePresets[j].Shutter of
        255: preseteditor.shuttercheck.State:=cbChecked;
        0: preseteditor.shuttercheck.State:=cbUnchecked;
        else preseteditor.shuttercheck.State:=cbGrayed;
      end;
      case mainform.DevicePresets[j].PrismaEnabled of
        255: preseteditor.prismacheck.State:=cbChecked;
        0: preseteditor.prismacheck.State:=cbUnchecked;
        else preseteditor.prismacheck.State:=cbGrayed;
      end;

      preseteditor.dimmerslider.position:=mainform.DevicePresets[j].Dimmer;
      preseteditor.stroboslider.position:=mainform.DevicePresets[j].Strobe;
      preseteditor.irisslider.position:=mainform.DevicePresets[j].Iris;
      preseteditor.fokusslider.position:=mainform.DevicePresets[j].Focus;
      preseteditor.prismaslider.position:=mainform.DevicePresets[j].PrismaRot;
      preseteditor.goborot1slider.position:=mainform.DevicePresets[j].GoboRot1;
      preseteditor.goborot2slider.position:=mainform.DevicePresets[j].GoboRot2;
      preseteditor.colorpicker2.SelectedColor:=mainform.DevicePresets[j].Color;

      preseteditor.PositionXY2.Left:=round(preseteditor.Fadenkreuz2.Width * mainform.DevicePresets[j].pan/255)-(preseteditor.PositionXY2.Width div 2);
      preseteditor.PositionXY2.Top:=round(preseteditor.Fadenkreuz2.Height * mainform.DevicePresets[j].tilt/255)-(preseteditor.PositionXY2.Height div 2);
      preseteditor.selectedgobo:=mainform.DevicePresets[j].Gobo;

      preseteditor.CheckState;
      preseteditor.showmodal;

      if preseteditor.ModalResult=mrOK then
      begin
        mainform.DevicePresets[j].Name:=preseteditor.Edit1.Text;
        mainform.DevicePresets[j].Beschreibung:=preseteditor.Edit2.Text;
        setlength(mainform.DevicePresets[j].ChanTyp,25);
        setlength(mainform.DevicePresets[j].ChanValue,25);
        setlength(mainform.DevicePresets[j].ChanActive,25);

        mainform.DevicePresets[j].ChanTyp[0]:='pan';
        mainform.DevicePresets[j].ChanActive[0]:=preseteditor.CheckListBox1.checked[0];
        mainform.DevicePresets[j].ChanValue[0]:=round(((preseteditor.PositionXY.Left+(preseteditor.PositionXY.Width/2))/preseteditor.Fadenkreuz.Width)*255);
        mainform.DevicePresets[j].ChanTyp[1]:='tilt';
        mainform.DevicePresets[j].ChanActive[1]:=preseteditor.CheckListBox1.checked[1];
        mainform.DevicePresets[j].ChanValue[1]:=round(((preseteditor.PositionXY.Top+(preseteditor.PositionXY.Height/2))/preseteditor.Fadenkreuz.Height)*255);
        mainform.DevicePresets[j].ChanTyp[2]:='moves';
        mainform.DevicePresets[j].ChanActive[2]:=preseteditor.CheckListBox1.checked[2];
        mainform.DevicePresets[j].ChanValue[2]:=preseteditor.moves.position;
        mainform.DevicePresets[j].ChanTyp[3]:='speed ';
        mainform.DevicePresets[j].ChanActive[3]:=preseteditor.CheckListBox1.checked[3];
        mainform.DevicePresets[j].ChanValue[3]:=preseteditor.speed.position;
        mainform.DevicePresets[j].ChanTyp[4]:='gobo1';
        mainform.DevicePresets[j].ChanActive[4]:=preseteditor.CheckListBox1.checked[4];
        mainform.DevicePresets[j].ChanValue[4]:=preseteditor.gobo1.position;
        mainform.DevicePresets[j].ChanTyp[5]:='gobo1rot';
        mainform.DevicePresets[j].ChanActive[5]:=preseteditor.CheckListBox1.checked[5];
        mainform.DevicePresets[j].ChanValue[5]:=preseteditor.gobo1rot.position;
        mainform.DevicePresets[j].ChanTyp[6]:='gobo2';
        mainform.DevicePresets[j].ChanActive[6]:=preseteditor.CheckListBox1.checked[6];
        mainform.DevicePresets[j].ChanValue[6]:=preseteditor.gobo2.position;
        mainform.DevicePresets[j].ChanTyp[7]:='gobo2rot';
        mainform.DevicePresets[j].ChanActive[7]:=preseteditor.CheckListBox1.checked[7];
        mainform.DevicePresets[j].ChanValue[7]:=preseteditor.gobo2rot.position;
        mainform.DevicePresets[j].ChanTyp[8]:='gobo3';
        mainform.DevicePresets[j].ChanActive[8]:=preseteditor.CheckListBox1.checked[8];
        mainform.DevicePresets[j].ChanValue[8]:=preseteditor.gobo3.position;
        mainform.DevicePresets[j].ChanTyp[9]:='goboextra';
        mainform.DevicePresets[j].ChanActive[9]:=preseteditor.CheckListBox1.checked[9];
        mainform.DevicePresets[j].ChanValue[9]:=preseteditor.goboextra.position;
        mainform.DevicePresets[j].ChanTyp[10]:='color1';
        mainform.DevicePresets[j].ChanActive[10]:=preseteditor.CheckListBox1.checked[10];
        mainform.DevicePresets[j].ChanValue[10]:=preseteditor.color1.position;
        mainform.DevicePresets[j].ChanTyp[11]:='color2';
        mainform.DevicePresets[j].ChanActive[11]:=preseteditor.CheckListBox1.checked[11];
        mainform.DevicePresets[j].ChanValue[11]:=preseteditor.color2.position;
        mainform.DevicePresets[j].ChanTyp[12]:='r';
        mainform.DevicePresets[j].ChanActive[12]:=preseteditor.CheckListBox1.checked[12];
        mainform.DevicePresets[j].ChanValue[12]:=preseteditor.r.position;
        mainform.DevicePresets[j].ChanTyp[13]:='g';
        mainform.DevicePresets[j].ChanActive[13]:=preseteditor.CheckListBox1.checked[13];
        mainform.DevicePresets[j].ChanValue[13]:=preseteditor.g.position;
        mainform.DevicePresets[j].ChanTyp[14]:='b';
        mainform.DevicePresets[j].ChanActive[14]:=preseteditor.CheckListBox1.checked[14];
        mainform.DevicePresets[j].ChanValue[14]:=preseteditor.b.position;
        mainform.DevicePresets[j].ChanTyp[15]:='iris';
        mainform.DevicePresets[j].ChanActive[15]:=preseteditor.CheckListBox1.checked[15];
        mainform.DevicePresets[j].ChanValue[15]:=preseteditor.iris.position;
        mainform.DevicePresets[j].ChanTyp[16]:='shutter';
        mainform.DevicePresets[j].ChanActive[16]:=preseteditor.CheckListBox1.checked[16];
        mainform.DevicePresets[j].ChanValue[16]:=preseteditor.shutter.position;
        mainform.DevicePresets[j].ChanTyp[17]:='dimmer';
        mainform.DevicePresets[j].ChanActive[17]:=preseteditor.CheckListBox1.checked[17];
        mainform.DevicePresets[j].ChanValue[17]:=preseteditor.dimmer.position;
        mainform.DevicePresets[j].ChanTyp[18]:='zoom';
        mainform.DevicePresets[j].ChanActive[18]:=preseteditor.CheckListBox1.checked[18];
        mainform.DevicePresets[j].ChanValue[18]:=preseteditor.zoom.position;
        mainform.DevicePresets[j].ChanTyp[19]:='focus';
        mainform.DevicePresets[j].ChanActive[19]:=preseteditor.CheckListBox1.checked[19];
        mainform.DevicePresets[j].ChanValue[19]:=preseteditor.focus.position;
        mainform.DevicePresets[j].ChanTyp[20]:='prism';
        mainform.DevicePresets[j].ChanActive[20]:=preseteditor.CheckListBox1.checked[20];
        mainform.DevicePresets[j].ChanValue[20]:=preseteditor.prism.position;
        mainform.DevicePresets[j].ChanTyp[21]:='frost';
        mainform.DevicePresets[j].ChanActive[21]:=preseteditor.CheckListBox1.checked[21];
        mainform.DevicePresets[j].ChanValue[21]:=preseteditor.frost.position;
        mainform.DevicePresets[j].ChanTyp[22]:='special1';
        mainform.DevicePresets[j].ChanActive[22]:=preseteditor.CheckListBox1.checked[22];
        mainform.DevicePresets[j].ChanValue[22]:=preseteditor.special1.position;
        mainform.DevicePresets[j].ChanTyp[23]:='special2';
        mainform.DevicePresets[j].ChanActive[23]:=preseteditor.CheckListBox1.checked[23];
        mainform.DevicePresets[j].ChanValue[23]:=preseteditor.special2.position;
        mainform.DevicePresets[j].ChanTyp[24]:='special3';
        mainform.DevicePresets[j].ChanActive[24]:=preseteditor.CheckListBox1.checked[24];
        mainform.DevicePresets[j].ChanValue[24]:=preseteditor.special3.position;

        mainform.DevicePresets[j].UseNewInterface:=not preseteditor.CheckBox1.Checked;

        case preseteditor.shuttercheck.State of
          cbChecked: mainform.DevicePresets[j].Shutter:=255;
          cbGrayed: mainform.DevicePresets[j].Shutter:=128;
          cbUnchecked: mainform.DevicePresets[j].Shutter:=0;
        end;
        case preseteditor.prismacheck.State of
          cbChecked: mainform.DevicePresets[j].PrismaEnabled:=255;
          cbGrayed: mainform.DevicePresets[j].PrismaEnabled:=128;
          cbUnchecked: mainform.DevicePresets[j].PrismaEnabled:=0;
        end;

        mainform.DevicePresets[j].Dimmer:=preseteditor.dimmerslider.position;
        mainform.DevicePresets[j].Strobe:=preseteditor.stroboslider.position;
        mainform.DevicePresets[j].Iris:=preseteditor.irisslider.position;
        mainform.DevicePresets[j].Focus:=preseteditor.fokusslider.position;
        mainform.DevicePresets[j].PrismaRot:=preseteditor.prismaslider.position;
        mainform.DevicePresets[j].GoboRot1:=preseteditor.goborot1slider.position;
        mainform.DevicePresets[j].GoboRot2:=preseteditor.goborot2slider.position;
        mainform.DevicePresets[j].Color:=preseteditor.colorpicker2.SelectedColor;
        mainform.DevicePresets[j].Pan:=preseteditor.panval;
        mainform.DevicePresets[j].PanFine:=preseteditor.panfineval;
        mainform.DevicePresets[j].Tilt:=preseteditor.tiltval;
        mainform.DevicePresets[j].TiltFine:=preseteditor.tiltfineval;

        mainform.DevicePresets[j].Gobo:=preseteditor.selectedgobo;

      end;
      break;
    end;
  end;
  // Automatikszene
  for j:=0 to length(Autoszenen)-1 do
  begin
    if IsEqualGUID(Autoszenen[j].ID,ID) then
    begin
      mainform.AktuelleAutoszene.ID:=mainform.autoszenen[j].ID;
      mainform.AktuelleAutoszene.Name:=mainform.autoszenen[j].Name;
      mainform.AktuelleAutoszene.Beschreibung:=mainform.autoszenen[j].Beschreibung;
      mainform.AktuelleAutoszene.fadetime:=mainform.autoszenen[j].fadetime;
      mainform.AktuelleAutoszene.R:=mainform.autoszenen[j].R;
      mainform.AktuelleAutoszene.G:=mainform.autoszenen[j].G;
      mainform.AktuelleAutoszene.B:=mainform.autoszenen[j].B;
      mainform.AktuelleAutoszene.A:=mainform.autoszenen[j].A;
      mainform.AktuelleAutoszene.W:=mainform.autoszenen[j].W;
      mainform.AktuelleAutoszene.accuracy:=mainform.autoszenen[j].accuracy;
      mainform.AktuelleAutoszene.helligkeit:=mainform.autoszenen[j].helligkeit;

      autoszeneform.ShowModal;

      if autoszeneform.ModalResult=mrOK then
      begin
        mainform.autoszenen[j].ID:=mainform.AktuelleAutoszene.ID;
        mainform.autoszenen[j].Name:=mainform.AktuelleAutoszene.Name;
        mainform.autoszenen[j].Beschreibung:=mainform.AktuelleAutoszene.Beschreibung;
        mainform.autoszenen[j].fadetime:=mainform.AktuelleAutoszene.fadetime;
        mainform.autoszenen[j].R:=mainform.AktuelleAutoszene.R;
        mainform.autoszenen[j].G:=mainform.AktuelleAutoszene.G;
        mainform.autoszenen[j].B:=mainform.AktuelleAutoszene.B;
        mainform.autoszenen[j].A:=mainform.AktuelleAutoszene.A;
        mainform.autoszenen[j].W:=mainform.AktuelleAutoszene.W;
        mainform.autoszenen[j].accuracy:=mainform.AktuelleAutoszene.accuracy;
        mainform.autoszenen[j].helligkeit:=mainform.AktuelleAutoszene.helligkeit;
      end;
      break;
    end;
  end;

  // MediaCenter Szene
  for j:=0 to length(mediacenterszenen)-1 do
  begin
    if IsEqualGUID(mediacenterszenen[j].ID,ID) then
    begin
      mainform.AktuelleMediaCenterSzene.ID:=mainform.MediaCenterSzenen[j].ID;
      mainform.AktuelleMediaCenterSzene.Name:=mainform.MediaCenterSzenen[j].Name;
      mainform.AktuelleMediaCenterSzene.Adresse:=mainform.MediaCenterSzenen[j].Adresse;
      mainform.AktuelleMediaCenterSzene.Port:=mainform.MediaCenterSzenen[j].Port;
      mainform.AktuelleMediaCenterSzene.Beschreibung:=mainform.MediaCenterSzenen[j].Beschreibung;
      mainform.AktuelleMediaCenterSzene.Befehl:=mainform.MediaCenterSzenen[j].Befehl;
      mainform.AktuelleMediaCenterSzene.Data1:=mainform.MediaCenterSzenen[j].Data1;
      mainform.AktuelleMediaCenterSzene.Data2:=mainform.MediaCenterSzenen[j].Data2;
      mainform.AktuelleMediaCenterSzene.Text:=mainform.MediaCenterSzenen[j].Text;

      mediacenterform.showmodal;

      if mediacenterform.modalresult=mrOK then
      begin
        mainform.MediaCenterSzenen[j].ID:=mainform.AktuelleMediaCenterSzene.ID;
        mainform.MediaCenterSzenen[j].Name:=mainform.AktuelleMediaCenterSzene.Name;
        mainform.MediaCenterSzenen[j].Adresse:=mainform.AktuelleMediaCenterSzene.Adresse;
        mainform.MediaCenterSzenen[j].Port:=mainform.AktuelleMediaCenterSzene.Port;
        mainform.MediaCenterSzenen[j].Beschreibung:=mainform.AktuelleMediaCenterSzene.Beschreibung;
        mainform.MediaCenterSzenen[j].Befehl:=mainform.AktuelleMediaCenterSzene.Befehl;
        mainform.MediaCenterSzenen[j].Data1:=mainform.AktuelleMediaCenterSzene.Data1;
        mainform.MediaCenterSzenen[j].Data2:=mainform.AktuelleMediaCenterSzene.Data2;
        mainform.MediaCenterSzenen[j].Text:=mainform.AktuelleMediaCenterSzene.Text;
      end;
      break;
    end;
  end;

  // Presetszene
  for j:=0 to length(PresetScenes)-1 do
  begin
    if IsEqualGUID(PresetScenes[j].ID,ID) then
    begin
      presetsceneeditor.Edit1.Text:=mainform.PresetScenes[j].Name;
      presetsceneeditor.Edit2.Text:=mainform.PresetScenes[j].Beschreibung;

      presetsceneeditor.mbXPImageComboBox1.Clear;
      for k:=0 to mainform.GoboPictures.Items.Count-1 do
      begin
    {
        Rect.Left:=0;
        Rect.Top:=0;
        Rect.Right:=mainform.GoboPictures.Items.Items[k].PngImage.Width;
        Rect.Bottom:=mainform.GoboPictures.Items.Items[k].PngImage.Height;
        mainform.GoboPictures.Items.Items[k].PngImage.Draw(bmp.Picture.Bitmap.Canvas, Rect);

        ImageList1.Add(bmp.Picture.Bitmap, bmp.Picture.Bitmap);
    }
        presetsceneeditor.mbXPImageComboBox1.Items.Add(mainform.GoboPictures.Items.Items[k].Name);
      end;
    //  mbXPImageComboBox1.Images:=ImageList1;
      presetsceneeditor.gobolbl.caption:=mainform.PresetScenes[j].Gobo;

      case mainform.PresetScenes[j].Shutter of
        255: presetsceneeditor.shuttercheck.State:=cbChecked;
        0: presetsceneeditor.shuttercheck.State:=cbUnchecked;
        else presetsceneeditor.shuttercheck.State:=cbGrayed;
      end;
      case mainform.PresetScenes[j].PrismaEnabled of
        255: presetsceneeditor.prismacheck.State:=cbChecked;
        0: presetsceneeditor.prismacheck.State:=cbUnchecked;
        else presetsceneeditor.prismacheck.State:=cbGrayed;
      end;

      presetsceneeditor.dimmerslider.position:=mainform.PresetScenes[j].Dimmer;
      presetsceneeditor.stroboslider.position:=mainform.PresetScenes[j].Strobe;
      presetsceneeditor.irisslider.position:=mainform.PresetScenes[j].Iris;
      presetsceneeditor.fokusslider.position:=mainform.PresetScenes[j].Focus;
      presetsceneeditor.prismaslider.position:=mainform.PresetScenes[j].PrismaRot;
      presetsceneeditor.goborot1slider.position:=mainform.PresetScenes[j].GoboRot1;
      presetsceneeditor.goborot2slider.position:=mainform.PresetScenes[j].GoboRot2;
      presetsceneeditor.colorpicker2.SelectedColor:=mainform.PresetScenes[j].Color;

      presetsceneeditor.PositionXY2.Left:=round(presetsceneeditor.Fadenkreuz2.Width * mainform.PresetScenes[j].pan/255)-(presetsceneeditor.PositionXY2.Width div 2);
      presetsceneeditor.PositionXY2.Top:=round(presetsceneeditor.Fadenkreuz2.Height * mainform.PresetScenes[j].tilt/255)-(presetsceneeditor.PositionXY2.Height div 2);
      presetsceneeditor.selectedgobo:=mainform.PresetScenes[j].Gobo;

      presetsceneeditor.TreeViewRefresh;
      // Geräte ausklappen
      for k:=0 to length(presetscenes[j].devices)-1 do
      for l:=0 to PresetSceneEditor.Treeview1.Items.Count-1 do
      begin
        if (PresetSceneEditor.Treeview1.Items[l].HasChildren=false) then
        begin
          if IsEqualGUID(presetscenes[j].devices[k], PresetSceneEditor.NodeGUID[PresetSceneEditor.Treeview1.Items[l].Parent.Parent.Index][PresetSceneEditor.Treeview1.Items[l].Parent.Index][PresetSceneEditor.Treeview1.Items[l].Index]) then
          begin
            PresetSceneEditor.Treeview1.Items[l].Expand(true);
            break;
          end;
        end;
      end;
      // Geräte selektieren
      for k:=0 to length(presetscenes[j].devices)-1 do
      for l:=0 to PresetSceneEditor.Treeview1.Items.Count-1 do
      begin
        if (PresetSceneEditor.Treeview1.Items[l].HasChildren=false) then
        begin
          if IsEqualGUID(presetscenes[j].devices[k], PresetSceneEditor.NodeGUID[PresetSceneEditor.Treeview1.Items[l].Parent.Parent.Index][PresetSceneEditor.Treeview1.Items[l].Parent.Index][PresetSceneEditor.Treeview1.Items[l].Index]) then
          begin
            PresetSceneEditor.Treeview1.Select(PresetSceneEditor.Treeview1.Items[l], [ssCtrl]);
            break;
          end;
        end;
      end;

      presetsceneeditor.showmodal;

      if presetsceneeditor.ModalResult=mrOK then
      begin
        mainform.PresetScenes[j].Name:=presetsceneeditor.Edit1.Text;
        mainform.PresetScenes[j].Beschreibung:=presetsceneeditor.Edit2.Text;

        // Selektierte Geräte in Preset speichern
        for i:=0 to PresetSceneEditor.Treeview1.SelectionCount-1 do
        begin
          if (PresetSceneEditor.Treeview1.Selections[i].HasChildren=false) {and PresetSceneEditor.Treeview1.Selections[i].Selected} then
          begin
            setlength(mainform.PresetScenes[j].Devices, length(mainform.PresetScenes[j].Devices)+1);
            mainform.PresetScenes[j].Devices[length(mainform.PresetScenes[j].Devices)-1]:=PresetSceneEditor.NodeGUID[PresetSceneEditor.Treeview1.Selections[i].Parent.Parent.Index][PresetSceneEditor.Treeview1.Selections[i].Parent.Index][PresetSceneEditor.Treeview1.Selections[i].Index];
          end;
        end;

        case presetsceneeditor.shuttercheck.State of
          cbChecked: mainform.PresetScenes[j].Shutter:=255;
          cbGrayed: mainform.PresetScenes[j].Shutter:=128;
          cbUnchecked: mainform.PresetScenes[j].Shutter:=0;
        end;
        case presetsceneeditor.prismacheck.State of
          cbChecked: mainform.PresetScenes[j].PrismaEnabled:=255;
          cbGrayed: mainform.PresetScenes[j].PrismaEnabled:=128;
          cbUnchecked: mainform.PresetScenes[j].PrismaEnabled:=0;
        end;

        mainform.PresetScenes[j].Dimmer:=presetsceneeditor.dimmerslider.position;
        mainform.PresetScenes[j].Strobe:=presetsceneeditor.stroboslider.position;
        mainform.PresetScenes[j].Iris:=presetsceneeditor.irisslider.position;
        mainform.PresetScenes[j].Focus:=presetsceneeditor.fokusslider.position;
        mainform.PresetScenes[j].PrismaRot:=presetsceneeditor.prismaslider.position;
        mainform.PresetScenes[j].GoboRot1:=presetsceneeditor.goborot1slider.position;
        mainform.PresetScenes[j].GoboRot2:=presetsceneeditor.goborot2slider.position;
        mainform.PresetScenes[j].Color:=presetsceneeditor.colorpicker2.SelectedColor;
        mainform.PresetScenes[j].Pan:=presetsceneeditor.panval;
        mainform.PresetScenes[j].PanFine:=presetsceneeditor.panfineval;
        mainform.PresetScenes[j].Tilt:=presetsceneeditor.tiltval;
        mainform.PresetScenes[j].TiltFine:=presetsceneeditor.tiltfineval;

        mainform.PresetScenes[j].Gobo:=presetsceneeditor.selectedgobo;
      end;
      break;
    end;
  end;

  // CodeSzenen
  for j:=0 to length(CodeScenes)-1 do
  begin
    if IsEqualGUID(CodeScenes[j].ID,ID) then
    begin
      codeeditorform.nameedit.Text:=mainform.CodeScenes[j].Name;
      codeeditorform.descriptionedit.Text:=mainform.CodeScenes[j].Beschreibung;
      codeeditorform.Memo1.Lines.Clear;
      //codeeditorform.Memo1.Lines.Add(CodeScenes[j].Code);
      codeeditorform.Memo1.Text:=CodeScenes[j].Code;

      codeeditorform.Panel3.Visible:=true;
      codeeditorform.MouseDown.Visible:=false;
      codeeditorform.MouseUp.Visible:=false;

      codeeditorform.ShowModal;

      if codeeditorform.ModalResult=mrOK then
      begin
        mainform.CodeScenes[j].Name:=codeeditorform.nameedit.Text;
        mainform.CodeScenes[j].Beschreibung:=codeeditorform.descriptionedit.Text;
        mainform.CodeScenes[j].Code:=codeeditorform.Memo1.Text;//codeeditorform.Memo1.Lines.Text;
        InitCodeScene(mainform.codescenes[j].ID);
      end;

      codeeditorform.Panel3.Visible:=false;
      codeeditorform.MouseDown.Visible:=true;
      codeeditorform.MouseUp.Visible:=true;

      break;
    end;
  end;

  // Plugin Szene
  for j:=0 to length(PluginSzenen)-1 do
  begin
    if IsEqualGUID(PluginSzenen[j].ID,ID) then
    begin
      SendMSG(MSG_EDITPLUGINSCENE, GUIDToString(ID), 0);
      break;
    end;
  end;
end;

function Tmainform.ChangeSceneWithLibrary(ID:TGUID):TGUID;
var
  SzenenData:PTreeData;
begin
  setlength(szenenverwaltung_formarray,length(szenenverwaltung_formarray)+1);
  szenenverwaltung_formarray[length(szenenverwaltung_formarray)-1]:=Tszenenverwaltungform.Create(self);

  szenenverwaltung_formarray[length(szenenverwaltung_formarray)-1].Positionselection:=ID;
  if (szenenverwaltung_formarray[length(szenenverwaltung_formarray)-1].showmodal=mrOK) then
  begin
    if szenenverwaltung_formarray[length(szenenverwaltung_formarray)-1].VST.SelectedCount>0 then
	begin
		SzenenData:=szenenverwaltung_formarray[length(szenenverwaltung_formarray)-1].VST.GetNodeData(szenenverwaltung_formarray[length(szenenverwaltung_formarray)-1].VST.GetFirstSelected(false));

		result:=SzenenData^.ID;
	end;
  end else
  begin
    result:=ID;
  end;
  szenenverwaltung_formarray[length(szenenverwaltung_formarray)-1].Free;
  setlength(szenenverwaltung_formarray,length(szenenverwaltung_formarray)-1);
end;

function Tmainform.IsSceneActive(ID:TGUID):Boolean;
var
  j:integer;
  nop:boolean;
begin
  Result:=false;
  nop:=False;
  for j:=0 to length(Audioszenen)-1 do
  begin
    if IsEqualGUID(Audioszenen[j].ID,ID) then
    begin
      Result:=BASS_ChannelIsActive(AudioszenenCHAN[j].StandardHandle)>0;
      nop:=true;
      break;
    end;
  end;

  if not nop then
  for j:=0 to length(Bewegungsszenen)-1 do
  begin
    if IsEqualGUID(Bewegungsszenen[j].ID,ID) then
    begin
      Result:=BewegungsszenenAktiv[j].Aktiv;
      nop:=true;
      break;
    end;
  end;

  if not nop then
  for j:=0 to length(Effektsequenzereffekte)-1 do
  begin
    if IsEqualGUID(Effektsequenzereffekte[j].ID,ID) then
    begin
      Result:=AktuellerEffekt[j].Aktiv;
//      nop:=true;
      break;
    end;
  end;
end;

procedure Tmainform.StartScene(ID:TGUID);
begin
  StartScene(ID, false, false);
end;

procedure Tmainform.StartScene(ID:TGUID; Fadetime:integer);
begin
  audioeffektplayerform.RecordAudioeffekt(ID, false);
  StartSceneWithoutRecord(ID, false, false, 255, Fadetime);
end;

procedure Tmainform.StartScene(ID:TGUID; NoFadetime, NoDelay:boolean; Intensity:Byte; Fadetime:integer);
begin
  audioeffektplayerform.RecordAudioeffekt(ID, false);
  StartSceneWithoutRecord(ID, NoFadetime, NoDelay, Intensity, Fadetime);
end;

procedure Tmainform.StartScene(ID:TGUID; NoFadetime, NoDelay:boolean; Fadetime:integer);
begin
  audioeffektplayerform.RecordAudioeffekt(ID, false);
  StartSceneWithoutRecord(ID, NoFadetime, NoDelay, 255, Fadetime);
end;

procedure Tmainform.StartScene(ID:TGUID; NoFadetime, NoDelay:boolean);
begin
  audioeffektplayerform.RecordAudioeffekt(ID, false);
  StartSceneWithoutRecord(ID, NoFadetime, NoDelay, 255, -1);
end;

procedure Tmainform.StartSceneWithoutRecord(ID:TGUID; NoFadetime, NoDelay: boolean; Intensity:Byte; Fadetime:integer);
var
  j:integer;
  nop:boolean;
  scenefound:boolean;
begin
  SendMSG(MSG_STARTSCENE, GUIDtoString(ID), 0);

  scenefound:=false;
  nop:=false;

  // Einfache Einblendszene
  for j:=0 to length(EinfacheSzenen)-1 do
  begin
    if IsEqualGUID(EinfacheSzenen[j].ID,ID) then
    begin
      StartEinfacheSzene(EinfacheSzenen[j].ID, NoFadetime, NoDelay, Fadetime);
      scenefound:=true;
      nop:=true;
      break;
    end;
  end;
  // Audioszene
  if not nop then
  for j:=0 to length(AudioSzenen)-1 do
  begin
    if IsEqualGUID(AudioSzenen[j].ID,ID) then
    begin
      StartAudioSzene(AudioSzenen[j].ID);
      scenefound:=true;
      nop:=true;
      break;
    end;
  end;
  // Bewegungsszene
  if not nop then
  for j:=0 to length(Bewegungsszenen)-1 do
  begin
    if IsEqualGUID(Bewegungsszenen[j].ID,ID) then
    begin
      StartBewegungsSzene(Bewegungsszenen[j].ID);
      scenefound:=true;
      nop:=true;
      break;
    end;
  end;
  // Befehle
  if not nop then
  for j:=0 to length(Befehle2)-1 do
  begin
    if IsEqualGUID(Befehle2[j].ID,ID) then
    begin
      StartBefehl(Befehle2[j].ID);
      scenefound:=true;
      nop:=true;
      break;
    end;
  end;
  // Komposition
  if not nop then
  for j:=0 to length(Kompositionsszenen)-1 do
  begin
    if IsEqualGUID(Kompositionsszenen[j].ID,ID) then
    begin
      StartKompositionsszene(Kompositionsszenen[j].ID, NoFadetime, NoDelay, Fadetime);
      scenefound:=true;
      nop:=true;
      break;
    end;
  end;
  // Presets
  if not nop then
  for j:=0 to length(devicepresets)-1 do
  begin
    if IsEqualGUID(devicepresets[j].ID,ID) then
    begin
      StartPreset(devicepresets[j].ID);
      scenefound:=true;
      nop:=true;
      break;
    end;
  end;
  // Geräteszene
  if not nop then
  for j:=0 to length(devicescenes)-1 do
  begin
    if IsEqualGUID(devicescenes[j].ID,ID) then
    begin
      StartDeviceScene(devicescenes[j].ID, NoFadetime, NoDelay, Intensity, Fadetime);
      scenefound:=true;
      nop:=true;
      break;
    end;
  end;
  // Autoszenen
  if not nop then
  for j:=0 to length(autoszenen)-1 do
  begin
    if IsEqualGUID(autoszenen[j].ID,ID) then
    begin
      StartAutoszene(autoszenen[j].ID, NoFadetime, NoDelay, Fadetime);
      scenefound:=true;
      nop:=true;
      break;
    end;
  end;
  // Effekte
  if not nop then
  for j:=0 to length(effektsequenzereffekte)-1 do
  begin
    if IsEqualGUID(effektsequenzereffekte[j].ID,ID) then
    begin
      StartEffekt(effektsequenzereffekte[j].ID);
      scenefound:=true;
      nop:=true;
      break;
    end;
  end;

  // MediaCenter Szenen
  if not nop then
  for j:=0 to length(mediacenterszenen)-1 do
  begin
    if IsEqualGUID(mediacenterszenen[j].ID,ID) then
    begin
      StartMediaCenterSzene(mediacenterszenen[j].ID);
      scenefound:=true;
//        nop:=true;
      break;
    end;
  end;

  // Presetszenen
  if not nop then
  for j:=0 to length(presetscenes)-1 do
  begin
    if IsEqualGUID(presetscenes[j].ID,ID) then
    begin
      StartPresetscene(presetscenes[j].ID);
      scenefound:=true;
      nop:=true;
      break;
    end;
  end;

  // Codeszenen
  if not nop then
  for j:=0 to length(codescenes)-1 do
  begin
    if IsEqualGUID(codescenes[j].ID,ID) then
    begin
      ExecuteCodeScene(codescenes[j].ID, 'StartScene');
      scenefound:=true;
      nop:=true;
      break;
    end;
  end;

  // Plugin Szenen
  if not nop then
  for j:=0 to length(PluginSzenen)-1 do
  begin
    if IsEqualGUID(PluginSzenen[j].ID,ID) then
    begin
      SendMSG(MSG_STARTPLUGINSCENE, GUIDToString(PluginSzenen[j].ID), Fadetime);
      scenefound:=true;
//        nop:=true;
      break;
    end;
  end;

  if (not scenefound) and (not IsEqualGUID(ID, StringToGUID('{00000000-0000-0000-0000-000000000000}'))) then
  begin
    scenenotfoundform.guidlbl.Caption:=GUIDtoString(ID);
    scenenotfoundform.show;
  end;
end;

procedure Tmainform.StopScene(ID:TGUID);
begin
  audioeffektplayerform.RecordAudioeffekt(ID, true);
  StopSceneWithoutRecord(ID);
end;

procedure Tmainform.StopSceneWithoutRecord(ID:TGUID);
var
  j:integer;
  nop:boolean;
  scenefound:boolean;
begin
  SendMSG(MSG_STOPSCENE, GUIDtoString(ID), 0);

  scenefound:=false;
  nop:=false;
  // Einfache Einblendszene
  for j:=0 to length(EinfacheSzenen)-1 do
  begin
    if IsEqualGUID(EinfacheSzenen[j].ID,ID) then
    begin
      StopEinfacheSzene(EinfacheSzenen[j].ID);
      scenefound:=true;
      nop:=true;
      break;
    end;
  end;
  // Audioszene
  if not nop then
  for j:=0 to length(AudioSzenen)-1 do
  begin
    if IsEqualGUID(AudioSzenen[j].ID,ID) then
    begin
      StopAudioSzene(AudioSzenen[j].ID);
      scenefound:=true;
      nop:=true;
      break;
    end;
  end;
  // Bewegungsszene
  if not nop then
  for j:=0 to length(Bewegungsszenen)-1 do
  begin
    if IsEqualGUID(Bewegungsszenen[j].ID,ID) then
    begin
      StopBewegungsSzene(Bewegungsszenen[j].ID);
      scenefound:=true;
      nop:=true;
      break;
    end;
  end;
  // Befehle
  if not nop then
  for j:=0 to length(Befehle2)-1 do
  begin
    if IsEqualGUID(Befehle2[j].ID,ID) then
    begin
      // Es macht bei einem Befehl keinen Sinn, eine StopScene-Funktion zu implementieren...
      scenefound:=true;
      nop:=true;
      break;
    end;
  end;
  // Presets
  if not nop then
  for j:=0 to length(DevicePresets)-1 do
  begin
    if IsEqualGUID(DevicePresets[j].ID,ID) then
    begin
      scenefound:=true;
      nop:=true;
      break;
    end;
  end;
  // Komposition
  if not nop then
  for j:=0 to length(Kompositionsszenen)-1 do
  begin
    if IsEqualGUID(Kompositionsszenen[j].ID,ID) then
    begin
      StopKompositionsszene(Kompositionsszenen[j].ID);
      scenefound:=true;
      nop:=true;
      break;
    end;
  end;
  // Geräteszene
  if not nop then
  for j:=0 to length(devicescenes)-1 do
  begin
    if IsEqualGUID(devicescenes[j].ID,ID) then
    begin
      StopDeviceScene(devicescenes[j].ID);
      scenefound:=true;
      nop:=true;
      break;
    end;
  end;
  // Autoszene
  if not nop then
  for j:=0 to length(autoszenen)-1 do
  begin
    if IsEqualGUID(autoszenen[j].ID,ID) then
    begin
      StopAutoszene(autoszenen[j].ID);
      scenefound:=true;
      nop:=true;
      break;
    end;
  end;
  // Effekte
  if not nop then
  for j:=0 to length(effektsequenzereffekte)-1 do
  begin
    if IsEqualGUID(effektsequenzereffekte[j].ID,ID) then
    begin
      StopEffekt(effektsequenzereffekte[j].ID);
      scenefound:=true;
      nop:=true;
      break;
    end;
  end;
  // MediaCenter Szenen
  if not nop then
  for j:=0 to length(mediacenterszenen)-1 do
  begin
    if IsEqualGUID(mediacenterszenen[j].ID,ID) then
    begin
      scenefound:=true;
      nop:=true;
      break;
    end;
  end;
  // Preset-Szenen
  if not nop then
  for j:=0 to length(PresetScenes)-1 do
  begin
    if IsEqualGUID(PresetScenes[j].ID,ID) then
    begin
      scenefound:=true;
      nop:=true;
      break;
    end;
  end;
  // Code-Szenen
  if not nop then
  for j:=0 to length(CodeScenes)-1 do
  begin
    if IsEqualGUID(CodeScenes[j].ID,ID) then
    begin
      ExecuteCodeScene(CodeScenes[j].ID, 'StopScene');
      scenefound:=true;
      nop:=true;
      break;
    end;
  end;
  // Plugin Szenen
  if not nop then
  for j:=0 to length(PluginSzenen)-1 do
  begin
    if IsEqualGUID(PluginSzenen[j].ID,ID) then
    begin
      scenefound:=true;
//      nop:=true;
      break;
    end;
  end;

  if (not scenefound) and (not IsEqualGUID(ID, StringToGUID('{00000000-0000-0000-0000-000000000000}'))) then
  begin
    scenenotfoundform.guidlbl.Caption:=GUIDtoString(ID);
    scenenotfoundform.show;
  end;
end;

procedure Tmainform.BlackoutDeviceScene(ID:TGUID; Fadetime:integer);
var
  i,j,k,m:integer;
  PositionInDeviceArray,PositionInGroupArray:integer;
  channeltype:string;
begin
  for i:=0 to length(devicescenes)-1 do
  begin
    if IsEqualGUID(devicescenes[i].ID, ID) then
    begin
      for j:=0 to length(devicescenes[i].Devices)-1 do
      begin
        PositionInDeviceArray:=-1;
        PositionInGroupArray:=-1;

        for m:=0 to length(devices)-1 do
        begin
          if IsEqualGUID(devices[m].ID,devicescenes[i].Devices[j].ID) then
          begin
            PositionInDeviceArray:=m;
            break;
          end;
        end;

        for m:=0 to length(devicegroups)-1 do
        begin
          if IsEqualGUID(devicegroups[m].ID,devicescenes[i].Devices[j].ID) then
          begin
            PositionInGroupArray:=m;
            break;
          end;
        end;

        if PositionInDeviceArray>-1 then
        begin
          for k:=0 to length(devicescenes[i].Devices[j].ChanActive)-1 do
          begin
            if devicescenes[i].Devices[j].ChanActive[k] or devicescenes[i].Devices[j].ChanActiveRandom[k] then
            begin
              channeltype:=mainform.devices[PositionInDeviceArray].kanaltyp[k];
              if (lowercase(channeltype)='dimmer') or (lowercase(channeltype)='r') or (lowercase(channeltype)='g') or (lowercase(channeltype)='b') or (lowercase(channeltype)='a') or (lowercase(channeltype)='w') or (lowercase(channeltype)='uv') then
                geraetesteuerung.set_channel(devicescenes[i].Devices[j].ID, channeltype, -1, 0, Fadetime);
              if (lowercase(channeltype)='shutter') then
                geraetesteuerung.set_shutter(devicescenes[i].Devices[j].ID, 0);
            end;
          end;
        end else if PositionInGroupArray>-1 then
        begin
          for k:=0 to length(devicescenes[i].Devices[j].ChanActive)-1 do
          begin
            if devicescenes[i].Devices[j].ChanActive[k] or devicescenes[i].Devices[j].ChanActiveRandom[k] then
            begin
              channeltype:=DeviceChannelNames[k];
              if (lowercase(channeltype)='dimmer') or (lowercase(channeltype)='r') or (lowercase(channeltype)='g') or (lowercase(channeltype)='b') or (lowercase(channeltype)='a') or (lowercase(channeltype)='w') or (lowercase(channeltype)='uv') then
                geraetesteuerung.set_group(devicescenes[i].Devices[j].ID, channeltype, -1, 0, Fadetime, devicescenes[i].Devices[j].ChanDelay[k]);
              if (lowercase(channeltype)='shutter') then
                geraetesteuerung.set_shutter(devicescenes[i].Devices[j].ID, 0, devicescenes[i].Devices[j].ChanDelay[k]);
            end;
          end;
        end;
      end;
      break;
    end;
  end;
end;

function Tmainform.DoesSceneExists(ID:TGUID):boolean;
var
  j:integer;
  nop:boolean;
  scenefound:integer;
begin
  scenefound:=-1;
  nop:=false;
  // Einfache Einblendszene
  for j:=0 to length(EinfacheSzenen)-1 do
  begin
    if IsEqualGUID(EinfacheSzenen[j].ID,ID) then
    begin
      scenefound:=0;
      nop:=true;
      break;
    end;
  end;
  // Audioszene
  if not nop then
  for j:=0 to length(AudioSzenen)-1 do
  begin
    if IsEqualGUID(AudioSzenen[j].ID,ID) then
    begin
      scenefound:=1;
      nop:=true;
      break;
    end;
  end;
  // Bewegungsszene
  if not nop then
  for j:=0 to length(Bewegungsszenen)-1 do
  begin
    if IsEqualGUID(Bewegungsszenen[j].ID,ID) then
    begin
      scenefound:=2;
      nop:=true;
      break;
    end;
  end;
  // Befehle
  if not nop then
  for j:=0 to length(Befehle2)-1 do
  begin
    if IsEqualGUID(Befehle2[j].ID,ID) then
    begin
      scenefound:=3;
      nop:=true;
      break;
    end;
  end;
  // Komposition
  if not nop then
  for j:=0 to length(Kompositionsszenen)-1 do
  begin
    if IsEqualGUID(Kompositionsszenen[j].ID,ID) then
    begin
      scenefound:=4;
      nop:=true;
      break;
    end;
  end;
  // Geräteszene
  if not nop then
  for j:=0 to length(devicescenes)-1 do
  begin
    if IsEqualGUID(devicescenes[j].ID,ID) then
    begin
      scenefound:=5;
      nop:=true;
      break;
    end;
  end;
  // Preset
  if not nop then
  for j:=0 to length(devicepresets)-1 do
  begin
    if IsEqualGUID(devicepresets[j].ID,ID) then
    begin
      scenefound:=6;
      nop:=true;
      break;
    end;
  end;
  // Autoszene
  if not nop then
  for j:=0 to length(autoszenen)-1 do
  begin
    if IsEqualGUID(autoszenen[j].ID,ID) then
    begin
      scenefound:=7;
      nop:=true;
      break;
    end;
  end;
  // Effekte
  if not nop then
  for j:=0 to length(effektsequenzereffekte)-1 do
  begin
    if IsEqualGUID(effektsequenzereffekte[j].ID,ID) then
    begin
      scenefound:=8;
      nop:=true;
      break;
    end;
  end;
  // MediaCenter Szenen
  if not nop then
  for j:=0 to length(mediacenterszenen)-1 do
  begin
    if IsEqualGUID(mediacenterszenen[j].ID,ID) then
    begin
      scenefound:=9;
//        nop:=true;
      break;
    end;
  end;
  // Preset
  if not nop then
  for j:=0 to length(presetscenes)-1 do
  begin
    if IsEqualGUID(presetscenes[j].ID,ID) then
    begin
      scenefound:=10;
      nop:=true;
      break;
    end;
  end;
  // Codeszenen
  if not nop then
  for j:=0 to length(codescenes)-1 do
  begin
    if IsEqualGUID(codescenes[j].ID,ID) then
    begin
      scenefound:=11;
      nop:=true;
      break;
    end;
  end;
  // Plugin Szenen
  if not nop then
  for j:=0 to length(PluginSzenen)-1 do
  begin
    if IsEqualGUID(PluginSzenen[j].ID,ID) then
    begin
      scenefound:=12;
//        nop:=true;
      break;
    end;
  end;

  result:=(scenefound>-1);
end;

procedure Tmainform.StopAllEffects;
var
  i,j:integer;
begin
  for i:=0 to length(einfacheszenen)-1 do
    mainform.StopScene(einfacheszenen[i].ID);

  for i:=0 to length(devicescenes)-1 do
    mainform.StopScene(devicescenes[i].ID);

  for i:=0 to length(bewegungsszenen)-1 do
    mainform.StopScene(bewegungsszenen[i].ID);

  for i:=0 to length(audioszenen)-1 do
    mainform.StopScene(audioszenen[i].ID);

  for i:=0 to length(effektsequenzereffekte)-1 do
    mainform.StopEffekt(effektsequenzereffekte[i].ID);

  if videoscreenform<>nil then
  begin
    videoscreenform.FilterGraph1.Stop;
    videoscreenform.FilterGraph2.Stop;
    videoscreenform.FilterGraph3.Stop;
    videoscreenform.FilterGraph4.Stop;
  end;

  Audioeffektplayerform.StopEffektaudioClick(nil);

  for j:=length(DimmerKernelChannelArray)-1 downto 0 do
  begin
    pDimmerKernelChannel2:=DimmerKernelChannelArray[j];
    channel_endvalue[pDimmerKernelChannel2.channel]:=channel_value[pDimmerKernelChannel2.channel];
    pDimmerKernelChannel2.DeleteChannel:=true;
  end;

  // Garbage-Collector: Alle zum Löschen freigegebenen Kanäle löschen
  for j:=length(DimmerKernelChannelArray)-1 downto 0 do
  begin
    pDimmerKernelChannel2:=DimmerKernelChannelArray[j];
    if pDimmerKernelChannel2<>nil then
    begin
      if (pDimmerKernelChannel2.DeleteChannel) then
      begin
        dispose(pDimmerKernelChannel2);
        DimmerKernelChannelArray[j]:=DimmerKernelChannelArray[length(DimmerKernelChannelArray)-1];
        setlength(DimmerKernelChannelArray,length(DimmerKernelChannelArray)-1);
      end;
    end else
    begin
      DimmerKernelChannelArray[j]:=DimmerKernelChannelArray[length(DimmerKernelChannelArray)-1];
      setlength(DimmerKernelChannelArray,length(DimmerKernelChannelArray)-1);
    end;
  end;
end;

procedure Tmainform.SetSceneTime(ID:TGUID; Zeit:integer);
var
  j:integer;
  nop:boolean;
begin
  nop:=false;
  // Einfache Einblendszene
  for j:=0 to length(EinfacheSzenen)-1 do
  begin
    if IsEqualGUID(EinfacheSzenen[j].ID,ID) then
    begin
      einfacheszenen[j].einblendzeit:=Zeit;
      nop:=true;
      break;
    end;
  end;
  // Audioszene
  if not nop then
  for j:=0 to length(AudioSzenen)-1 do
  begin
    if IsEqualGUID(AudioSzenen[j].ID,ID) then
    begin
      audioszenen[j].dauer:=Zeit;
      nop:=true;
      break;
    end;
  end;
  // Bewegungsszene
  if not nop then
  for j:=0 to length(Bewegungsszenen)-1 do
  begin
    if IsEqualGUID(Bewegungsszenen[j].ID,ID) then
    begin
      bewegungsszenen[j].dauer:=Zeit;
      nop:=true;
      break;
    end;
  end;
  // Geräteszene
  if not nop then
  for j:=0 to length(devicescenes)-1 do
  begin
    if IsEqualGUID(devicescenes[j].ID,ID) then
    begin
      devicescenes[j].Fadetime:=Zeit;
      nop:=true;
      break;
    end;
  end;
  // Autoszenen
  if not nop then
  for j:=0 to length(autoszenen)-1 do
  begin
    if IsEqualGUID(autoszenen[j].ID,ID) then
    begin
      autoszenen[j].fadetime:=Zeit;
//        nop:=true;
      break;
    end;
  end;
end;

procedure TMainform.Effektsequenzer1Click(Sender: TObject);
begin
  if not UserAccessGranted(1) then exit;

  effektsequenzer.show;
end;

procedure TMainform.GlobaleTastenabfrage1Click(Sender: TObject);
begin
  if not UserAccessGranted(1) then exit;

  with Tastenabfrage do
  begin
    lastrow:=StringGrid1.Row;

    StringGrid1.RowCount:=length(mainform.TastencodeArray)+1;
    StringGrid1.Enabled:=(length(mainform.TastencodeArray)>0);
    RefreshGrid;
    Button4.Enabled:=(length(TastencodeArray)>0);
    Combobox1.Enabled:=(length(TastencodeArray)>0);
    Combobox2.Enabled:=(length(TastencodeArray)>0);
    Hotkey1.Enabled:=(length(TastencodeArray)>0);
    EnableHotKeys.Checked:=mainform.EnableHotKeys;

    ShowModal;

{
    if EnableHotKeys.Checked then
    begin
      for i:=0 to length(mainform.TastencodeArray)-1 do
      begin
        ShortCutToKey(mainform.TastencodeArray[i].Hotkey,Key,Shift);
        ShiftNumber:=0;
        if Shift=[ssAlt] then
          ShiftNumber:=1
        else if Shift=[ssCtrl] then
          ShiftNumber:=ShiftNumber+2
        else if Shift=[ssShift] then
        begin
          ShiftNumber:=ShiftNumber+4;
        end;
      end;
    end;
}
  end;
end;

procedure TMainform.ShortCutCheckerTimer(Sender: TObject);
var
  i:integer;
  key:Word;
  Shift:TShiftState;
begin
  if shutdown then exit;

  if EnableHotKeys=false then
  begin
    ShortCutChecker.Enabled:=false;
    exit;
  end;

  for i:=0 to length(TastencodeArray)-1 do
  begin
    ShortCutToKey(TastencodeArray[i].Hotkey,Key,Shift);

    if TastencodeArray[i].active then
    begin
      if TastencodePressedArray[i] then
      begin
        // hier wird nur Loslassen der Taste überprüft
        if (GetAsyncKeyState(Key)=0) or // prüfen, ob Taste losgelassen
        (((ssShift in Shift) and (GetAsyncKeyState(vk_shift)=0))) or // prüfen, ob Shift-Taste losgelassen, falls in Hotkey verwendet
        (((ssCtrl in Shift) and (GetAsyncKeyState(vk_control)=0))) or // prüfen, ob STRG-Taste losgelassen, falls in Hotkey verwendet
        (((ssAlt in Shift) and (GetAsyncKeyState(vk_menu)=0))) then // prüfen, ob ALT-Taste losgelassen, falls in Hotkey verwendet
        begin
          TastencodePressedArray[i]:=false;

          if TastencodeArray[i].UseKeyUp then
          begin
            StartBefehl(TastencodeArray[i].ID, TastencodeArray[i].KeyUpValue);

            if (not shutdown) and (Tastenabfrage<>nil) and (Tastenabfrage.showing) then
            begin
              Tastenabfrage.Stringgrid1.Cells[6, i+1]:=inttostr(TastencodeArray[i].KeyUpValue);
            end;
          end;
        end;
      end;
    end;

    // Man muss auf <0 für einen Tastendruck, und auf >=0 für keinen Tastendruck abfragen
    // GetAsyncKeyState(Key)=0      // Taste Key nicht gedrückt
    // GetAsyncKeyState(Key)=-32767 // Taste gedrückt und erste Mal abgefragt
    // GetAsyncKeyState(Key)=-32768 // Taste seit letztem Prüfen gedrückt

    if TastencodeArray[i].active then
    begin
      if (TastencodePressedArray[i] and TastencodeArray[i].Repeated) or (not TastencodePressedArray[i]) then
      begin
        // Taste noch nicht gedrückt, oder für diese Kombination wurde Repeat-Modus aktiviert
        if ((not TastencodeArray[i].Global) and mainform.Active) or (TastencodeArray[i].Global) or (Tastenabfrage.showing) then
        begin
          // Taste wurde mit aktivierter Mainform gedrückt, oder für diese Kombination wurde Global-Modus aktiviert
          if ((GetAsyncKeyState(Key)<0) and ((not (ssCtrl in Shift)) and (GetAsyncKeyState(vk_control)=0)) and ((not (ssAlt in Shift)) and (GetAsyncKeyState(vk_menu)=0)) and ((not (ssShift in Shift)) and (GetAsyncKeyState(vk_shift)=0))) or // reiner Key

          ((GetAsyncKeyState(Key)<0) and ((ssCtrl in Shift) and (GetAsyncKeyState(vk_control)<0)) and ((not (ssAlt in Shift)) and (GetAsyncKeyState(vk_menu)=0)) and ((not (ssShift in Shift)) and (GetAsyncKeyState(vk_shift)=0))) or // STRG+Key
          ((GetAsyncKeyState(Key)<0) and ((not (ssCtrl in Shift)) and (GetAsyncKeyState(vk_control)=0)) and ((ssAlt in Shift) and (GetAsyncKeyState(vk_menu)<0)) and ((not (ssShift in Shift)) and (GetAsyncKeyState(vk_shift)=0))) or // ALT+Key
          ((GetAsyncKeyState(Key)<0) and ((not (ssCtrl in Shift)) and (GetAsyncKeyState(vk_control)=0)) and ((not (ssAlt in Shift)) and (GetAsyncKeyState(vk_menu)=0)) and ((ssShift in Shift) and (GetAsyncKeyState(vk_shift)<0))) or // SHIFT+Key

          ((GetAsyncKeyState(Key)<0) and ((ssCtrl in Shift) and (GetAsyncKeyState(vk_control)<0)) and ((ssAlt in Shift) and (GetAsyncKeyState(vk_menu)<0)) and ((not (ssShift in Shift)) and (GetAsyncKeyState(vk_shift)=0))) or // STRG+ALT+Key
          ((GetAsyncKeyState(Key)<0) and ((ssCtrl in Shift) and (GetAsyncKeyState(vk_control)<0)) and ((not (ssAlt in Shift)) and (GetAsyncKeyState(vk_menu)=0)) and ((ssShift in Shift) and (GetAsyncKeyState(vk_shift)<0))) or // STRG+SHIFT+Key
          ((GetAsyncKeyState(Key)<0) and ((not (ssCtrl in Shift)) and (GetAsyncKeyState(vk_control)=0)) and ((ssAlt in Shift) and (GetAsyncKeyState(vk_menu)<0)) and ((ssShift in Shift) and (GetAsyncKeyState(vk_shift)<0))) or // SHIFT+ALT+Key

          ((GetAsyncKeyState(Key)<0) and ((ssCtrl in Shift) and (GetAsyncKeyState(vk_control)<0)) and ((ssAlt in Shift) and (GetAsyncKeyState(vk_menu)<0)) and ((ssShift in Shift) and (GetAsyncKeyState(vk_shift)<0))) then // STRG+ALT+SHIFT+Key
          begin
            // Taste wurde (ggfs. mit entsprechenden Zusatztasten) gedrückt
            TastencodePressedArray[i]:=true;

            StartBefehl(TastencodeArray[i].ID, TastencodeArray[i].KeyDownValue);

            if (not shutdown) and (Tastenabfrage<>nil) and (Tastenabfrage.showing) then
            begin
              Tastenabfrage.Stringgrid1.Cells[6, i+1]:=inttostr(TastencodeArray[i].KeyDownValue);
            end;
          end;
        end;
      end;
    end;
  end;
end;

procedure TMainform.Gertesteuerung2Click(Sender: TObject);
begin
  if not UserAccessGranted(1) then exit;

  geraetesteuerung.show;
end;

procedure TMainform.Effektschaltvorgang(WelcherEffekt: Integer; Sender: TObject);
var
  i:integer;
  oldposition:integer;
begin
  i:=WelcherEffekt;

  if AktuellerEffekt[i].PleaseStopOnNextStep then
  begin
    StopEffekt(effektsequenzereffekte[i].ID);
  end else
  begin
    if ((not (Sender=Optotimer))) or ((AktuellerEffekt[i].Aktiv) and (AktuellerEffekt[i].beatgesteuert) and (Sender=Optotimer)) then
    begin
      // Effektablauf wieder stoppen, falls nur manueller SingleStep
      if AktuellerEffekt[i].SingleStep then
      begin
        AktuellerEffekt[i].Aktiv:=false;
        AktuellerEffekt[i].SingleStep:=false;
      end;

      // bereits durchgeführte Schritte um eins erhöhen
      AktuellerEffekt[i].AnzahlderSchritte:=AktuellerEffekt[i].AnzahlderSchritte+1;

      // Anzahl der bisherigen Durchläufe um eins erhöhen, wenn Schrittzahl des Effekts einmal erreicht
      if AktuellerEffekt[i].AnzahlderSchritte>=length(effektsequenzereffekte[i].Effektschritte) then
      begin
        AktuellerEffekt[i].Durchlauf:=AktuellerEffekt[i].Durchlauf+1;
        AktuellerEffekt[i].AnzahlderSchritte:=0;
      end;

      // Wenn Anzahl der Durchläufe begrenzt, dann nach erreichen Abschalten
      if not effektsequenzereffekte[i].Repeating then
      begin
        if AktuellerEffekt[i].Durchlauf>=effektsequenzereffekte[i].AnzahlderDurchlaufe then
        begin
          AktuellerEffekt[i].PleaseStopOnNextStep:=true; // -> Stoppen vormerken -> Wartezeit wird abgewartet
          //StopEffekt(effektsequenzereffekte[i].ID); // direkt stoppen -> Wartezeit des letzten Schritts wird ignoriert
        end;
      end;

      case effektsequenzereffekte[i].modus of
        0:
        begin // Nächsten Schritt ausführen
          if AktuellerEffekt[i].AktuellerSchritt<length(effektsequenzereffekte[i].Effektschritte)-1 then
            AktuellerEffekt[i].AktuellerSchritt:=AktuellerEffekt[i].AktuellerSchritt+1
          else
            AktuellerEffekt[i].AktuellerSchritt:=0;

          StartEffektstep(effektsequenzereffekte[i].ID, AktuellerEffekt[i].AktuellerSchritt);
        end;
        1:
        begin // Rückwärts laufen
          if AktuellerEffekt[i].AktuellerSchritt>0 then
            AktuellerEffekt[i].AktuellerSchritt:=AktuellerEffekt[i].AktuellerSchritt-1
          else
            AktuellerEffekt[i].AktuellerSchritt:=length(effektsequenzereffekte[i].Effektschritte)-1;

          StartEffektstep(effektsequenzereffekte[i].ID, AktuellerEffekt[i].AktuellerSchritt);
        end;
        2:
        begin // Pendeln
          if AktuellerEffekt[i].rueckwaerts then
          begin // Rückwärts
            if AktuellerEffekt[i].AktuellerSchritt>0 then
            begin
              AktuellerEffekt[i].AktuellerSchritt:=AktuellerEffekt[i].AktuellerSchritt-1;
            end else
            begin
              AktuellerEffekt[i].rueckwaerts:=false;
              AktuellerEffekt[i].AktuellerSchritt:=AktuellerEffekt[i].AktuellerSchritt+1;
            end;
          end else
          begin // Vorwärts
            if AktuellerEffekt[i].AktuellerSchritt<length(effektsequenzereffekte[i].Effektschritte)-1 then
            begin
              AktuellerEffekt[i].AktuellerSchritt:=AktuellerEffekt[i].AktuellerSchritt+1;
            end else
            begin
              AktuellerEffekt[i].rueckwaerts:=true;
              AktuellerEffekt[i].AktuellerSchritt:=AktuellerEffekt[i].AktuellerSchritt-1;
            end;
          end;

          StartEffektstep(effektsequenzereffekte[i].ID, AktuellerEffekt[i].AktuellerSchritt);
        end;
        3:
        begin // Zufall
          oldposition:=AktuellerEffekt[i].AktuellerSchritt;
          Randomize;
          AktuellerEffekt[i].AktuellerSchritt:=Random(length(effektsequenzereffekte[i].Effektschritte));
          if AktuellerEffekt[i].AktuellerSchritt=oldposition then
          repeat
            AktuellerEffekt[i].AktuellerSchritt:=Random(length(effektsequenzereffekte[i].Effektschritte));
          until AktuellerEffekt[i].AktuellerSchritt<>oldposition;

          StartEffektstep(effektsequenzereffekte[i].ID, AktuellerEffekt[i].AktuellerSchritt);
        end;
      end;

      effektsequenzer.RefreshGUI:=true;
    end;
  end;
end;

procedure TMainform.AppException(Sender: TObject; E: Exception);
begin
  if (E.ClassName='EConvertError') then
  begin
    //ShowMessage(E.Message); // EConvertError ist nur nervig
  end else if (E.ClassName='EDivByZero') then
  begin
    ShowMessage(E.Message+#13#10+#13#10+_('Es wurde aufgrund eines Fehlers versucht eine Größe durch Null zu teilen.'));
  end else
  begin
    DebugAdd('ERROR: '+E.Message+'Type: '+E.ClassName+'Encountered by: '+sender.ClassName{+' "'+TControl(Sender).Name+'"'});

    exceptionform.memo1.Clear;
    exceptionform.Memo1.Text:=E.Message;
    exceptionform.label4.caption:=_('Fehlertyp: ')+E.ClassName;
    exceptionform.label5.caption:=_('Verursacher: ')+sender.ClassName;//+' "'+TControl(Sender).Name+'"';

    exceptionform.FLastActiveControl := mainform.ActiveControl;

    exceptionform.DetailsMemo.Lines.Clear;
    exceptionform.DetailsMemo.Lines.Add('PHOENIXstudios PC_DIMMER - '+GetFileVersionBuild(paramstr(0)));
    exceptionform.DetailsMemo.Lines.Add(_('Fehlerbericht vom ')+DateToStr(now)+' um '+TimeToStr(now));
    exceptionform.DetailsMemo.Lines.Add('----------------------------------------------------------------------------------------------------');
    exceptionform.DetailsMemo.Lines.Add(_('Fehlertyp: ')+E.ClassName);
    exceptionform.DetailsMemo.Lines.Add(Format(RsExceptionAddr, [ExceptAddr]));
    exceptionform.DetailsMemo.Lines.Add(_('Verursacher: ')+sender.ClassName);//+' "'+TControl(Sender).Name+'"');
    exceptionform.DetailsMemo.Lines.Add('----------------------------------------------------------------------------------------------------');
        //  exceptionform.CreateExceptionReport([siStackList, siOsInfo, siModuleList, siActiveControls]);
//    exceptionform.CreateExceptionReport([siStackList, siOsInfo, siActiveControls]);
    exceptionform.CreateExceptionReport([siStackList, siOsInfo]);

    if (errorhandlingmode=0) or ((errorhandlingmode=1) and (E.ClassName='EAccessviolation')) then
    begin
      if not exceptionform.Showing then
        exceptionform.showmodal
      else
        exceptionform.BringToFront;
    end;
  end;
end;

procedure TMainform.Bhnenansicht1Click(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  if FirstStartofStageview then
  begin
    FirstStartofStageview:=false;
    grafischebuehnenansicht.RefreshStageView;
  end;
  grafischebuehnenansicht.show;
end;

procedure TMainform.Submaster1Click(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  submasterform.show;
end;

procedure TMainform.Joysticksteuerung1Click(Sender: TObject);
begin
  if not UserAccessGranted(1) then exit;

  joystickform.CheckBox1.Checked:=enablejoystick;
  joystickform.show;
end;

procedure TMainform.DataInEinstellungenClick(Sender: TObject);
begin
  if not UserAccessGranted(1) then exit;

  refreshdatain;
  dataineventfrm.show;
end;

procedure TMainform.ippsundTricks1Click(Sender: TObject);
begin
  if tippoftheday=nil then
    tippoftheday:=Ttippoftheday.Create(tippoftheday);

  tippoftheday.showmodal;
end;

procedure TMainform.ResetWindowPositionsClick(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  kontrollpanel.Left:=0;
  kontrollpanel.Top:=0;
  kontrollpanel.ClientWidth:=780;
  kontrollpanel.ClientHeight:=372;

  effektsequenzer.Left:=0;
  effektsequenzer.Top:=0;
  effektsequenzer.ClientWidth:=682;
  effektsequenzer.ClientHeight:=561;

  geraetesteuerung.Left:=0;
  geraetesteuerung.Top:=0;
  geraetesteuerung.ClientWidth:=692;
  geraetesteuerung.ClientHeight:=482;

  grafischebuehnenansicht.Left:=0;
  grafischebuehnenansicht.Top:=0;
  grafischebuehnenansicht.ClientWidth:=760;
  grafischebuehnenansicht.ClientHeight:=441;

  submasterform.Left:=0;
  submasterform.Top:=0;

  groupeditorform.Left:=0;
  groupeditorform.Top:=0;
  groupeditorform.ClientWidth:=681;
  groupeditorform.ClientHeight:=424;

  joystickform.Left:=0;
  joystickform.Top:=0;

  beatform.Left:=0;
  beatform.top:=0;

  pmmform.Left:=0;
  pmmform.top:=0;

  touchscreenform.Left:=0;
  touchscreenform.top:=0;

  dynguiform.Left:=0;
  dynguiform.top:=0;

  kanaluebersichtform.Left:=0;
  kanaluebersichtform.top:=0;
  kanaluebersichtform.ClientWidth:=600;
  kanaluebersichtform.ClientHeight:=370;

  audioeffektplayerform.Left:=0;
  audioeffektplayerform.top:=0;
  Audioeffektplayerform.ClientWidth:=1016;
  Audioeffektplayerform.ClientHeight:=553;

  cuelistform.Left:=0;
  cuelistform.top:=0;
  cuelistform.ClientWidth:=779;
  cuelistform.ClientHeight:=476;

  textbuchform.Left:=0;
  textbuchform.top:=0;
  textbuchform.ClientWidth:=800;
  textbuchform.ClientHeight:=411;

  timecodeplayerform.Left:=0;
  timecodeplayerform.top:=0;
  timecodeplayerform.ClientWidth:=774;
  timecodeplayerform.ClientHeight:=394;

  cuelistform.Left:=0;
  cuelistform.top:=0;
  cuelistform.ClientWidth:=779;
  cuelistform.ClientHeight:=476;

  if videoscreenform<>nil then
  begin
    videoscreenform.Left:=0;
    videoscreenform.top:=0;
  end;

  szenenverwaltung_formarray[0].Top:=0;
  szenenverwaltung_formarray[0].Left:=0;
  szenenverwaltung_formarray[0].ClientWidth:=522;
  szenenverwaltung_formarray[0].ClientHeight:=418;

  faderpanelform.Top:=0;
  faderpanelform.Left:=0;

  masterform.Top:=0;
  masterform.Left:=0;

  audiomanagerform.Top:=0;
  audiomanagerform.Left:=0;

  ambilightform.Top:=0;
  ambilightform.Left:=0;

  schedulerform.Top:=0;
  schedulerform.Left:=0;

  nodecontrolform.Top:=0;
  nodecontrolform.Left:=0;
  nodecontrolform.ClientWidth:=761;
  nodecontrolform.ClientHeight:=546;

  xtouchcontrolform.Top:=0;
  xtouchcontrolform.Left:=0;

  elgatostreamdeckform.Top:=0;
  elgatostreamdeckform.Left:=0;
end;

procedure TMainform.AutobackuptimerTimer(Sender: TObject);
var
  i:integer;
begin
  if Autobackupcountermax=0 then
  begin
    Autobackuptimer.Enabled:=false;
    exit;
  end;

  Autobackupcounter:=Autobackupcounter+1;

  if Autobackupcounter>=Autobackupcountermax then
  begin
    Autobackupcounter:=0;

    // Autobackupdatei von alter PC_DIMMER Version löschen
    if FileExists(userdirectory+'Autobackup~'+inttostr(maxautobackupfiles)+'.pcdbkup') then
      DeleteFile(userdirectory+'Autobackup~'+inttostr(maxautobackupfiles)+'.pcdbkup');

    // Autobackupdateien chronologisch versetzen
    for i:=maxautobackupfiles-1 downto 1 do
    begin
      if FileExists(userdirectory+'Autobackup~'+inttostr(i)+'.pcdbkup') then
        RenameFile(userdirectory+'Autobackup~'+inttostr(i)+'.pcdbkup',userdirectory+'Autobackup~'+inttostr(i+1)+'.pcdbkup');
    end;

    if FileExists(userdirectory+'Autobackup.pcdbkup') then
      RenameFile(userdirectory+'Autobackup.pcdbkup',userdirectory+'Autobackup~1.pcdbkup');

    saveproject(true, true, true);
  end;
end;

procedure TMainform.LoadAutoBackupBtnClick(Sender: TObject);
begin
  if not UserAccessGranted(1) then exit;

  recoveryform:=Trecoveryform.Create(Application);
{
  if FileExists(userdirectory+'Autobackup.pcdbkup') then
  begin
    If not DirectoryExists(userdirectory+'ProjectTemp') then
    	CreateDir(userdirectory+'ProjectTemp');
    copyfile(PChar(userdirectory+'Autobackup.pcdbkup'),PChar(userdirectory+'ProjectTemp\Projekt'),true);
    OpenProject('',true);
  end;
}
  if recoveryform.showmodal=mrOK then
  begin
    If FileExists(userdirectory+recoveryform.listbox1.Items[recoveryform.listbox1.Itemindex]) then
    begin
      If not DirectoryExists(userdirectory+'ProjectTemp') then
      begin
      	CreateDir(userdirectory+'ProjectTemp');
      	CreateDir(userdirectory+'ProjectTemp\Kontrollpanel');
      end;
      copyfile(PChar(userdirectory+recoveryform.listbox1.Items[recoveryform.listbox1.Itemindex]),PChar(userdirectory+'ProjectTemp\Projekt'),false);
      OpenProject('',true);
    end;
  end;
  recoveryform.Release;
end;

procedure TMainform.AutoFaderTimer(Sender: TObject);
begin
  if DimmerkernelResolutionAutoset and (trunc(mainform.KernelLaufzeit*1000)>AutoFader.Interval) then // Wenn Ausführungszeit vom Kernel höher als Timer, dann Timer langsamer stellen
  begin
  	DimmerkernelResolution:=trunc(mainform.KernelLaufzeit*1000*2); // Derzeitige KernelLaufzeit in ms x2
    AutoFader.Interval:=DimmerkernelResolution;
  end;

  ExecuteDimmerkernelEvent;
end;

procedure TMainform.BewegungsszenenTimerTimer(Sender: TObject);
begin
  ExecuteBewegungsszenenEvent;
end;

function TMainform.FilterWithDimmcurve(channel:Word; value:byte):byte;
var
  NewValue:integer;
begin                   
{
0 Linear
1 Schalter
2 Viertel-Sinus
3 Exponentiell
4 Doppelt-Exponentiell
5 Doppelt-Exponentiell 2
6 Treppenstufe
7 Stufenverlauf
8 Sinuswackeln klein
9 Sinuswackeln groß
10 Logarithmisch 1 (für LEDs)
11 Logarithmisch 2 (für LEDs)
}

  // Dimmkurve anwenden
  NewValue:=value;
  case channel_absolutedimmcurve[channel] of
    0: NewValue:=value;
    1: if value<128 then NewValue:=0 else NewValue:=255;
    2: NewValue:=round(sin((value/255)*(pi/2))*255);
    3: NewValue:=round(255-(sin(((255-value)/255)*(pi/2))*255));
    4: NewValue:=round((power(((cos((power(((255-value)/255),2))*pi)+1)/2),4))*255);
    5: NewValue:=round((power(((value-127)/25.266),3)+127));
    6: NewValue:=round(power(((value-127)/25.266),3)+127);
    7:
    begin
      if (value<51) then NewValue:=0;
      if (value>=51) and (value<102) then NewValue:=51;
      if (value>=102) and (value<153) then NewValue:=102;
      if (value>=153) and (value<204) then NewValue:=153;
      if (value>=204) then NewValue:=204;
    end;
    8: NewValue:=round((value+sin(value/4)*10));
    9: NewValue:=round((value+sin(value/4)*40));
    10:
    begin
      if value=255 then
        NewValue:=255
      else
        NewValue:=round((log2((255-value)/255)/-8)*255);
    end;
    11:
    begin
      if (value-1)=0 then
        NewValue:=0
      else
        NewValue:=round((((power(100,(value/500))-1)/(value-1)*value)/9.5)*255);
    end;
  else
    NewValue:=value;
  end;

  if NewValue>255 then
    NewValue:=255
  else if NewValue<0 then
    NewValue:=0;

  result:=NewValue;
end;

procedure TMainform.TBItem20Click(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  ddfeditorform.show;
end;

procedure TMainform.TBItem13Click(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  audioeffektplayerform.show;
end;

procedure TMainform.TBItem22Click(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  if messagedlg(_('Möchten Sie wirklich alle laufenden Effekte und Szenen beenden?'),mtConfirmation, [mbYes,mbNo],0)=mrYes then
  begin
    StopAllEffects;
  end;
end;

procedure TMainform.TBItem23Click(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  timecodeplayerform.show;
end;

procedure TMainform.AkkuTimerTimer(Sender: TObject);
begin
  if (akkulevel<=15) and showakkuwarnings and (akkulevel<=akkuwarningmessageshownext) and (not netzbetrieb) and (akkulevel>-1) then
  begin
    akkuwarningmessageshownext:=akkulevel-5;
    accumessageform.percent.Caption:='< '+inttostr(akkulevel)+'%';
    accumessageform.show;
//    MessageDlg('Sie arbeiten derzeit im Akkubetrieb mit einer niedrigen Energieleistung von <'+inttostr(acculevel2.position)+'%'+#13#10#13#10+'Es wird dringend empfohlen ein Netzteil anzuschließen!', mtWarning, [mbOK], 0);
//    ShowMessage('Sie arbeiten derzeit im Akkubetrieb mit einer niedrigen Energieleistung von <'+inttostr(acculevel.Percent)+'%'+#13#10#13#10+'Es wird dringend empfohlen ein Netzteil anzuschließen!');
  end;
  if (akkulevel>15) or netzbetrieb then
  begin
    akkuwarningmessageshownext:=15;
  end;

      if (akkulevel=-1) or (_killaccu) then
      begin
        acculevel2.Visible:=false;
        accupercent.Visible:=false;
        AkkuTimer.Enabled:=false;
      end;

      acculevel2.percent:=akkulevel;

      if (akkulevel > 20) then
      begin
        acculevel2.pfmaincolor:=clLime;
      end else if (akkulevel < 15) and (akkulevel > 10) then
      begin
        acculevel2.pfmaincolor:=clYellow;
      end else if (akkulevel <= 10) then
      begin
        acculevel2.pfmaincolor:=clRed;
      end;

      accupercent.Caption:=_('  Akku: ')+inttostr(akkulevel)+'% ';
end;

procedure TMainform.TBItem25Click(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  schedulerform.show;
end;

function TMainform.MillisecondsToTime(ms:Integer):String;
var
  h,m,s,msec:string;
begin
	h:=inttostr(ms div 3600000);
  m:=inttostr((ms mod 3600000) div 60000);
  s:=inttostr(((ms mod 3600000) mod 60000) div 1000);
  msec:=inttostr((((ms mod 3600000) mod 60000) mod 1000));

  if length(m)=1 then m:='0'+m;
  if length(s)=1 then s:='0'+s;
  if length(msec)=1 then msec:='0'+msec;
  if length(msec)=2 then msec:='0'+msec;

  Result:=h+'h '+m+'min '+s+'s '+msec+'ms';
end;

function TMainform.MillisecondsToTimeShort(ms:Integer):String;
var
  h,m,s,msec,tempstr:string;
begin
	h:=inttostr(ms div 3600000);
  m:=inttostr((ms mod 3600000) div 60000);
  s:=inttostr(((ms mod 3600000) mod 60000) div 1000);
  msec:=inttostr((((ms mod 3600000) mod 60000) mod 1000));

{
  if length(m)=1 then m:='0'+m;
  if length(s)=1 then s:='0'+s;
  if length(msec)=1 then msec:='0'+msec;
  if length(msec)=2 then msec:='0'+msec;
}

  if not (h='0') then tempstr:=h+'h ';
  if not (m='0') then tempstr:=tempstr+m+'min ';
  if not (s='0') then tempstr:=tempstr+s+'s ';
  if not (msec='0') then tempstr:=tempstr+msec+'ms ';

  // minimal z.B. "02s"
  // maximal z.B. "3h 23min 06s 400ms"
  // maximal z.B. "3h 7min 6s 50ms"
  if copy(tempstr,0,length(tempstr)-1)='' then
    Result:='0s'
  else
    Result:=copy(tempstr,0,length(tempstr)-1);
end;

procedure TMainform.TBItem27Click(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  if videoscreenform=nil then
    videoscreenform:=Tvideoscreenform.Create(videoscreenform);
  videoscreenform.Show;
end;

procedure TMainform.TBItem29Click(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  kanaluebersichtform.show;
end;

function Tmainform.GetFileSize2(const FileName: String): Int64;
var
  fFile: THandle;
  wfd: TWIN32FINDDATA;
begin
  result := 0;
  if not FileExists(FileName) then exit;
  fFile := FindFirstfile(pchar(FileName),wfd);
  if fFile = INVALID_HANDLE_VALUE then exit;
  result := (wfd.nFileSizeHigh*(MAXDWORD))+wfd.nFileSizeLow;
  windows.FindClose(fFile);
end;

function Tmainform.FileSize2String(filesize: cardinal):string;
begin
  if (filesize div 1024=0) then
  begin // Byte
    Result:=inttostr(filesize)+' Byte'; // Byte
  end else if (filesize div 1048576=0) then
  begin // kB
    Result:=FloatToStrF((filesize / 1024), ffFixed, 8, 2)+' kB'; // kB
  end else if (filesize div 1073741824=0) then
  begin // MB
    Result:=FloatToStrF((filesize / 1048576), ffFixed, 8, 2)+' MB'; // MB
  end else // GB und höher
  begin
    Result:=FloatToStrF((filesize / 1099511627776), ffFixed, 8, 2)+' GB'; // GB
  end;
end;

procedure TMainform.TBItem31Click(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  beatform.Show;
end;

procedure TMainform.FormDeactivate(Sender: TObject);
begin
  AlphaBlend:=mainform.blendoutforms;
  if mainform.blendoutforms then
    AlphaBlendValue:=mainform.blendvalue;
end;

procedure TMainform.FormActivate(Sender: TObject);
begin
  if blendoutforms then
    mainform.AlphaBlendValue:=255;

  // Workaround für verschwinden von Ribbons
{
  if mainform.WindowState=wsMaximized then
  begin
    dxRibbon1.ShowTabGroups:=not dxRibbon1.ShowTabGroups;
    dxRibbon1.ShowTabGroups:=not dxRibbon1.ShowTabGroups;
  end;
}
end;

procedure Tmainform.DeSelectAllDevices;
var
  i:integer;
begin
  setlength(mainform.SelektierteGeraete,0);
  for i:=0 to length(mainform.Devices)-1 do
  begin
    mainform.DeviceSelected[i]:=false;
  end;
  mainform.DeviceSelectionChanged(nil);
end;

procedure Tmainform.DeSelectDeviceGroup(ID: TGUID);
var
  j,k:integer;
begin
    for j:=0 to length(devicegroups)-1 do
    begin
      if IsEqualGUID(devicegroups[j].ID,ID) then
      begin
        for k:=0 to length(devicegroups[j].IDs)-1 do
        begin
          deviceselected[geraetesteuerung.GetDevicePositionInDeviceArray(@devicegroups[j].IDs[k])]:=false;
        end;
        break;
      end;
    end;
    DeviceSelectionChanged(nil);
end;

procedure Tmainform.SelectDeviceGroup(ID: TGUID; KeepOldSelection: boolean);
var
  i,j,k,tempvar:integer;
begin
  if KeepOldSelection then
  begin
    for j:=0 to length(devicegroups)-1 do
    begin
      if IsEqualGUID(devicegroups[j].ID,ID) then
      begin
        for k:=0 to length(devicegroups[j].IDs)-1 do
        begin
          deviceselected[geraetesteuerung.GetDevicePositionInDeviceArray(@devicegroups[j].IDs[k])]:=true;
        end;
        break;
      end;
    end;
    DeviceSelectionChanged(nil);
  end else
  begin
    setlength(mainform.SelektierteGeraete,0);
    for i:=0 to length(mainform.Devices)-1 do
    begin
      mainform.DeviceSelected[i]:=false;
    end;

    for j:=0 to length(devicegroups)-1 do
    begin
      if IsEqualGUID(devicegroups[j].ID,ID) then
      begin
        for k:=0 to length(devicegroups[j].IDs)-1 do
        begin
          tempvar:=geraetesteuerung.GetDevicePositionInDeviceArray(@devicegroups[j].IDs[k]);
          deviceselected[tempvar]:=true;

          if length(SelektierteGeraete)+1<=length(SendValueOfSelectedDevicesToMidi) then
          begin
            setlength(SelektierteGeraete, length(SelektierteGeraete)+1);
            SelektierteGeraete[length(SelektierteGeraete)-1]:=tempvar;
            
            if MIDIActiveRibbonBox.Down then
            begin
              if SendValueOfSelectedDevicesToMidi[length(SelektierteGeraete)-1].UseData2 then
                SendMidi(SendValueOfSelectedDevicesToMidi[length(SelektierteGeraete)-1].MSG,SendValueOfSelectedDevicesToMidi[length(SelektierteGeraete)-1].Data1,round(geraetesteuerung.get_dimmer(mainform.Devices[tempvar].ID)/255*127))
              else
                SendMidi(SendValueOfSelectedDevicesToMidi[length(SelektierteGeraete)-1].MSG,round(geraetesteuerung.get_dimmer(mainform.Devices[tempvar].ID)/255*127),0);
            end;
          end;
        end;
        break;
      end;
    end;
    UseGroupForValue2Midi:=true;
    DeviceSelectionChanged(nil);
    UseGroupForValue2Midi:=false;
  end;
end;

procedure Tmainform.DeviceSelectionChanged(Sender: TObject);
var
  i,j,k,LastPosition,InsertPosition,newwidth:integer;
  IsInList,MinusOneIsLast:boolean;
//  Data:PTreeData;
  GoboIsInList:boolean;
  showcolor, showdimmer, showiris, showzoom, showstrobo, showfocus, showprisma, showgobo, showxy:boolean;
  dunklefarbe:boolean;
begin
  if startingup then exit;

  dunklefarbe:=false;

  showcolor:=false;
  showdimmer:=false;
  showiris:=false;
  showzoom:=false;
  showstrobo:=false;
  showfocus:=false;
  showprisma:=false;
  showgobo:=false;
  showxy:=false;
  
{
  // Gerätesteuerung aktualisieren
  if geraetesteuerung.Showing then
  if not (Sender=geraetesteuerung) then
  begin
    for i:=0 to length(geraetesteuerung.VSTDeviceNodes)-1 do
    for j:=0 to length(geraetesteuerung.VSTDeviceNodes[i])-1 do
    for k:=0 to length(geraetesteuerung.VSTDeviceNodes[i][j])-1 do
    begin
      Data:=geraetesteuerung.VST.GetNodeData(geraetesteuerung.VSTDeviceNodes[i][j][k]);

      for l:=0 to length(devices)-1 do
      begin
        if IsEqualGUID(Data^.ID, devices[l].ID) then
        begin
          geraetesteuerung.VST.Selected[geraetesteuerung.VSTDeviceNodes[i][j][k]]:=DeviceSelected[l];
          break;
        end;
      end;
    end;
  end;
}
  if (length(SendValueOfSelectedDevicesToMidi)>0) and (not UseGroupForValue2Midi) then
  begin
    for i:=0 to length(mainform.Devices)-1 do
    begin // alle Geräte abklappern
      if mainform.DeviceSelected[i] then
      begin
        // Gerät ist selektiert
        IsInList:=false;
        for j:=0 to length(SelektierteGeraete)-1 do
        begin
          if SelektierteGeraete[j]=i then
          begin
            IsInList:=true;
            break;
          end;
        end;

        if not IsInList then
        begin
          InsertPosition:=-1;
          for j:=0 to length(SelektierteGeraete)-1 do
          begin
            if SelektierteGeraete[j]=-1 then
            begin
              InsertPosition:=j;
              break;
            end;
          end;
          if InsertPosition=-1 then
          begin
            setlength(SelektierteGeraete,length(SelektierteGeraete)+1);
            InsertPosition:=length(SelektierteGeraete)-1;
          end;
          SelektierteGeraete[InsertPosition]:=i;

          if MIDIActiveRibbonBox.Down then
          begin
            if SendValueOfSelectedDevicesToMidi[InsertPosition].UseData2 then
              SendMidi(SendValueOfSelectedDevicesToMidi[InsertPosition].MSG,SendValueOfSelectedDevicesToMidi[InsertPosition].Data1,round(geraetesteuerung.get_dimmer(mainform.Devices[i].ID)/255*127))
            else
              SendMidi(SendValueOfSelectedDevicesToMidi[InsertPosition].MSG,round(geraetesteuerung.get_dimmer(mainform.Devices[i].ID)/255*127),0);
          end;
        end;
      end else
      begin
        // Gerät ist nicht mehr selektiert
        for j:=0 to length(SelektierteGeraete)-1 do
        begin
          if SelektierteGeraete[j]=i then
          begin
            SelektierteGeraete[j]:=-1;
            break;
          end;
        end;
      end;
    end;
    // Array aufräumen
    MinusOneIsLast:=true;
    IsInList:=false;
    LastPosition:=length(SelektierteGeraete);
    for j:=length(SelektierteGeraete)-1 downto 0 do
    begin
      if SelektierteGeraete[j]=-1 then
      begin
        LastPosition:=j;
        IsInList:=true;
        if ((j-1)>=0) and (SelektierteGeraete[j-1]>-1) then
          break;
      end else
      begin
        MinusOneIsLast:=false;
      end;
    end;
    if IsInList and MinusOneIsLast then
      setlength(SelektierteGeraete,LastPosition);
  end;

  // Goboliste in Sidebar aktualisieren
  setlength(sidebarform.Gobolist, 0);
  sidebarform.GoboOffset:=0;

  // Alle selektierten Geräte durchgehen
  for i:=0 to length(mainform.devices)-1 do
  if DeviceSelected[i] then
  begin
    // Gobo1 durchsuchen
    if mainform.devices[i].hasGobo then
    for j:=0 to length(mainform.devices[i].gobos)-1 do
    begin
      // Ist Gobo bereits in der Liste?
      GoboIsInList:=false;
      for k:=0 to length(sidebarform.Gobolist)-1 do
      begin
        if (mainform.devices[i].gobos[j]=sidebarform.Gobolist[k]) then
        begin
          GoboIsInList:=true;
          break;
        end;
      end;
      // Wenn Gobo noch nicht drin, dann einfügen
      if not GoboIsInList then
      begin
        setlength(sidebarform.Gobolist, length(sidebarform.Gobolist)+1);
        sidebarform.Gobolist[length(sidebarform.Gobolist)-1]:=mainform.devices[i].gobos[j];
      end;
    end;

    // Gobo2 durchsuchen
    if mainform.devices[i].hasGobo2 then
    for j:=0 to length(mainform.devices[i].gobos2)-1 do
    begin
      // Ist Gobo bereits in der Liste?
      GoboIsInList:=false;
      for k:=0 to length(sidebarform.Gobolist)-1 do
      begin
        if (mainform.devices[i].gobos2[j]=sidebarform.Gobolist[k]) then
        begin
          GoboIsInList:=true;
          break;
        end;
      end;
      // Wenn Gobo noch nicht drin, dann einfügen
      if not GoboIsInList then
      begin
        setlength(sidebarform.Gobolist, length(sidebarform.Gobolist)+1);
        sidebarform.Gobolist[length(sidebarform.Gobolist)-1]:=mainform.devices[i].gobos2[j];
      end;
    end;

    // Dynamische Oberfläche anpassen
    if mainform.devices[i].hasRGB or mainform.devices[i].hasCMY or mainform.devices[i].hasColor or mainform.devices[i].hasColor2 then
    begin
      showcolor:=true;
    end;
    if mainform.devices[i].hasDimmer then
    begin
      showdimmer:=true;
    end;
    //Iris
    for j:=0 to length(mainform.devices[i].kanaltyp)-1 do
    begin
      if uppercase(mainform.devices[i].kanaltyp[j])='IRIS' then
      begin
        showiris:=true;
        break;
      end;
    end;
    //Zoom
    for j:=0 to length(mainform.devices[i].kanaltyp)-1 do
    begin
      if uppercase(mainform.devices[i].kanaltyp[j])='ZOOM' then
      begin
        showzoom:=true;
        break;
      end;
    end;
    //Strobe/Shutter
    for j:=0 to length(mainform.devices[i].kanaltyp)-1 do
    begin
      if uppercase(mainform.devices[i].kanaltyp[j])='SHUTTER' then
      begin
        showstrobo:=true;
        break;
      end;
    end;
    if uppercase(mainform.devices[i].StrobeChannel)<>'SHUTTER' then
    begin
      showstrobo:=true;
    end;
    if uppercase(mainform.devices[i].ShutterChannel)<>'SHUTTER' then
    begin
      showstrobo:=true;
    end;
    //Focus
    for j:=0 to length(mainform.devices[i].kanaltyp)-1 do
    begin
      if uppercase(mainform.devices[i].kanaltyp[j])='FOCUS' then
      begin
        showfocus:=true;
        break;
      end;
    end;
    //Prisma
    for j:=0 to length(mainform.devices[i].kanaltyp)-1 do
    begin
      if uppercase(mainform.devices[i].kanaltyp[j])='PRISMA' then
      begin
        showprisma:=true;
        break;
      end;
    end;
    if mainform.devices[i].hasGobo or mainform.devices[i].hasGobo2 then
    begin
      showgobo:=true;
    end;
    if mainform.devices[i].hasPANTILT then
    begin
      showxy:=true;
    end;
  end;

  // Elemente einblenden
  dynguiform.colorpanel.Visible:=false;
  dynguiform.dimmerpanel.Visible:=false;
  dynguiform.irispanel.Visible:=false;
  dynguiform.zoompanel.Visible:=false;
  dynguiform.strobopanel.Visible:=false;
  dynguiform.focuspanel.Visible:=false;
  dynguiform.prismapanel.Visible:=false;
  dynguiform.gobopanel.Visible:=false;
  dynguiform.xypanel.Visible:=false;

  dynguiform.Label10.Visible:=not (showcolor or showdimmer or showiris or showzoom or showstrobo or showfocus or showprisma
  or showgobo or showxy);

  dynguiform.colorpanel.Visible:=showcolor;
  dynguiform.dimmerpanel.Visible:=showdimmer;
    dynguiform.dimmerpanel.Left:=2000;
  dynguiform.irispanel.Visible:=showiris;
    dynguiform.irispanel.Left:=2000;
  dynguiform.zoompanel.Visible:=showzoom;
    dynguiform.zoompanel.Left:=2000;
  dynguiform.strobopanel.Visible:=showstrobo;
    dynguiform.strobopanel.Left:=2000;
  dynguiform.focuspanel.Visible:=showfocus;
    dynguiform.focuspanel.Left:=2000;
  dynguiform.prismapanel.Visible:=showprisma;
    dynguiform.prismapanel.Left:=2000;
  dynguiform.gobopanel.Visible:=showgobo;
    dynguiform.gobopanel.Left:=2000;
  dynguiform.xypanel.Visible:=showxy;
    dynguiform.xypanel.Left:=2000;

  // Größe und Farbe der dynamischen Oberfläche anpassen
  newwidth:=0;
  if dynguiform.colorpanel.Visible then
  begin
    dunklefarbe:=not dunklefarbe;
    if dunklefarbe then
      dynguiform.Shape1.Brush.Color:=clNavy
    else
      dynguiform.Shape1.Brush.Color:=clBlue;
    newwidth:=newwidth+dynguiform.colorpanel.Width;
  end;
  if dynguiform.dimmerpanel.Visible then
  begin
    dunklefarbe:=not dunklefarbe;
    if dunklefarbe then
      dynguiform.Shape2.Brush.Color:=clNavy
    else
      dynguiform.Shape2.Brush.Color:=clBlue;
    newwidth:=newwidth+dynguiform.dimmerpanel.Width;
  end;
  if dynguiform.irispanel.Visible then
  begin
    dunklefarbe:=not dunklefarbe;
    if dunklefarbe then
      dynguiform.Shape3.Brush.Color:=clNavy
    else
      dynguiform.Shape3.Brush.Color:=clBlue;
    newwidth:=newwidth+dynguiform.irispanel.Width;
  end;
  if dynguiform.zoompanel.Visible then
  begin
    dunklefarbe:=not dunklefarbe;
    if dunklefarbe then
      dynguiform.Shape4.Brush.Color:=clNavy
    else
      dynguiform.Shape4.Brush.Color:=clBlue;
    newwidth:=newwidth+dynguiform.zoompanel.Width;
  end;
  if dynguiform.strobopanel.Visible then
  begin
    dunklefarbe:=not dunklefarbe;
    if dunklefarbe then
      dynguiform.Shape5.Brush.Color:=clNavy
    else
      dynguiform.Shape5.Brush.Color:=clBlue;
    newwidth:=newwidth+dynguiform.strobopanel.Width;
  end;
  if dynguiform.focuspanel.Visible then
  begin
    dunklefarbe:=not dunklefarbe;
    if dunklefarbe then
      dynguiform.Shape6.Brush.Color:=clNavy
    else
      dynguiform.Shape6.Brush.Color:=clBlue;
    newwidth:=newwidth+dynguiform.focuspanel.Width;
  end;
  if dynguiform.prismapanel.Visible then
  begin
    dunklefarbe:=not dunklefarbe;
    if dunklefarbe then
      dynguiform.Shape7.Brush.Color:=clNavy
    else
      dynguiform.Shape7.Brush.Color:=clBlue;
    newwidth:=newwidth+dynguiform.prismapanel.Width;
  end;
  if dynguiform.gobopanel.Visible then
  begin
    dunklefarbe:=not dunklefarbe;
    if dunklefarbe then
      dynguiform.Shape8.Brush.Color:=clNavy
    else
      dynguiform.Shape8.Brush.Color:=clBlue;
    newwidth:=newwidth+dynguiform.gobopanel.Width;
  end;
  if dynguiform.xypanel.Visible then
  begin
    dunklefarbe:=not dunklefarbe;
    if dunklefarbe then
      dynguiform.Shape9.Brush.Color:=clNavy
    else
      dynguiform.Shape9.Brush.Color:=clBlue;
    newwidth:=newwidth+dynguiform.xypanel.Width;
  end;
  if newwidth=0 then
    newwidth:=160;
  if dynguiform.BorderStyle=bsSingle then
    dynguiform.ClientWidth:=newwidth;
  dynguiform.mywidth:=newwidth;

  sidebarform.RefreshGoboList;
  if touchscreenform.Showing then
  begin
    touchscreenform.RefreshGoboList;
    if touchscreenform.channelbox.Visible then
      touchscreenform.RefreshChannelbox;
  end;
  if dynguiform.Showing then
    dynguiform.RefreshGoboList;
end;

procedure TMainform.TBItem34Click(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  SaveWindowPositions('all');
end;

procedure Tmainform.SaveWindowPositions(Window:string);
var
  LReg:TPCDRegistry;
begin

  LReg := TPCDRegistry.Create;

  if (window='kontrollpanel') or (window='all') then
    LReg.SaveWndEx('Kontrollpanel', kontrollpanel);
  if (window='effektsequenzer') or (window='all') then
    LReg.SaveWndEx('Effektsequenzer', effektsequenzer);
  if (window='geraetesteuerung') or (window='all') then
    LReg.SaveWndEx('Geraetesteuerung', geraetesteuerung);
  if (window='buehnenansicht') or (window='all') then
    LReg.SaveWndEx('Buehnenansicht', grafischebuehnenansicht);
  if (window='submaster') or (window='all') then
    LReg.SaveWndEx('Submaster', submasterform);
  if (window='kanaluebersicht') or (window='all') then
    LReg.SaveWndEx('Kanaluebersicht', kanaluebersichtform);
  if (window='audioeffektplayer') or (window='all') then
    LReg.SaveWndEx('Audioeffektplayer', audioeffektplayerform);
  if (window='szenenverwaltung') or (window='all') then
    LReg.SaveWndEx('Szenenverwaltung', szenenverwaltung_formarray[0]);
  if (window='uhrzeitanzeige') or (window='all') then
    LReg.SaveWndEx('Uhrzeitanzeige', clockform);
  if (window='textbuch') or (window='all') then
    LReg.SaveWndEx('Textbuch', Textbuchform);
  if (window='cuelist') or (window='all') then
    LReg.SaveWndEx('Cuelist', cuelistform);
  if (window='timecodeplayer') or (window='all') then
    LReg.SaveWndEx('Timecodeplayer', Timecodeplayerform);

  if (window='master') or (window='all') then
    LReg.SaveWndPosEx('Master', masterform);
  if (window='cdplayer') or (window='all') and (cdplayerform<>nil) then
    LReg.SaveWndPosEx('CD-Player', cdplayerform);
  if (window='faderpanel') or (window='all') then
    LReg.SaveWndPosEx('Faderpanel', faderpanelform);
  if (window='beattool') or (window='all') then
    LReg.SaveWndPosEx('Beattool', beatform);
  if (window='PartyModul') or (window='all') then
    LReg.SaveWndPosEx('PartyModul', pmmform);
  if (window='touchscreen') or (window='all') then
    LReg.SaveWndPosEx('Touchscreen', touchscreenform);
  if (window='dyngui') or (window='all') then
    LReg.SaveWndPosEx('DynGUI', dynguiform);
  if (window='nodecontrol') or (window='all') then
    LReg.SaveWndPosEx('NodeControl', nodecontrolform);

  LReg.Free;
end;

procedure TMainform.TBItem35Click(Sender: TObject);
begin
  clockform.show;
end;

procedure TMainform.TBItem36Click(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  IsFreezeMode:=not IsFreezeMode;

  if IsFreezeMode then
  begin
    OutputOffRibbonBtn.Down:=true;
  end else
  begin
    OutputOffRibbonBtn.Down:=false;
  end;
end;

procedure Tmainform.EffectsChanged;
begin
  if effektsequenzer.Showing then
  begin
    effektsequenzer.RefreshTimer.enabled:=false;
    effektsequenzer.RefreshTreeView;
    effektsequenzer.RefreshTimer.enabled:=true;
  end;

  if szenenverwaltung_formarray[0].Showing then
    szenenverwaltung_formarray[0].FormShow(nil);
end;

procedure TMainform.TBItem37Click(Sender: TObject);
begin
  if DimmerkernelQueueForm=nil then
    DimmerkernelQueueForm:=TDimmerkernelQueueForm.Create(DimmerkernelQueueForm);

  DimmerkernelQueueForm.show;
end;

procedure TMainform.TBItem39Click(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  Textbuchform.show;
end;

function TMainform.FileSearch(Pathname, Filename:string; IncludeSubdirectories:boolean):string;
var
  Rec  : TSearchRec;
  Path : string;
  FoundFileName:string;
begin
  FoundFileName:='';

  Path := IncludeTrailingPathDelimiter(PathName);
  if FindFirst(Path+FileName, faAnyFile-faDirectory, Rec)=0 then
  try
    repeat
      FoundFileName:=Path+Rec.Name;
    until (FindNext(Rec)<>0) or (FoundFileName<>'');
  finally
    FindClose(Rec);
  end;

  If (not IncludeSubdirectories) or (FoundFileName<>'') then
  begin
    Result:=FoundFileName;
    Exit;
  end;

  if FindFirst(Path+'*.*', faDirectory, Rec) = 0 then
  try
    repeat
      if ((Rec.Attr and faDirectory) <> 0)  and (Rec.Name<>'.') and (Rec.Name<>'..') then
        FileSearch(Path+Rec.Name, FileName, True);
    until (FindNext(Rec)<>0) or (FoundFileName<>'');
  finally
    FindClose(Rec);
  end;

  Result:=FoundFileName;
end;


function TMainform.SearchFileBeneathProject(filename: string):string;
var
  newfilename:string;
begin
  ProgressScreenSmall.show;
  ProgressScreenSmall.Label1.Caption:=_('Datei wird gesucht...');
  ProgressScreenSmall.Label2.Caption:='';
  ProgressScreenSmall.ProgressBar1.Position:=0;
  ProgressScreenSmall.Refresh;

  if filename='' then
  begin
    result:='';
    exit;
  end;

  newfilename:='';

  // project_folder:=userdirectory+'ProjectTemp\'

  if FileExists(filename) then
  begin
    // Datei ist im fest angegebenen Pfad
    newfilename:=filename;
  end else if FileExists(project_folder+ExtractFileName(filename)) and (project_folder<>'') then
  begin
    // Datei ist im ProjectTemp
    newfilename:=project_folder+ExtractFileName(filename);
  end else if FileExists(ExtractFilePath(project_file)+ExtractFileName(filename)) and (project_file<>'') then
  begin
    // Datei ist im Verzeichnis, wo die Projektdatei ist
    newfilename:=ExtractFilePath(project_file)+ExtractFileName(filename);
  end else if FileExists(project_folder+filename) and (project_folder<>'') then
  begin
    // Datei ist in einem Unterverzeichnis von ProjectTemp
    newfilename:=project_folder+filename;
  end else if FileExists(ExtractFilePath(project_file)+filename) and (project_file<>'') then
  begin
    newfilename:=ExtractFilePath(project_file)+filename;
  end else if FileExists(mainform.pcdimmerdirectory+'\Devicepictures\32 x 32\'+ExtractFileName(filename)) and (project_file<>'') then
  begin
    // Datei ist im Bildverzeichnis 32x32
    newfilename:=mainform.pcdimmerdirectory+'\Devicepictures\32 x 32\'+ExtractFileName(filename);
  end else if FileExists(mainform.pcdimmerdirectory+'\Devicepictures\32 x 32\'+ExtractFileName(filename)) and (project_file<>'') then
  begin
    // Datei ist im Bildverzeichnis 64x64
    newfilename:=mainform.pcdimmerdirectory+'\Devicepictures\64 x 64\'+ExtractFileName(filename);
  end else if FileExists(mainform.pcdimmerdirectory+'\Devicepictures\64 x 64\'+ExtractFileName(filename)) and (project_file<>'') then
  begin
    // Datei ist im Bildverzeichnis 96x96
    newfilename:=mainform.pcdimmerdirectory+'\Devicepictures\96 x 96\'+ExtractFileName(filename);
  end else if FileExists(mainform.pcdimmerdirectory+'\Devicepictures\96 x 96\'+ExtractFileName(filename)) and (project_file<>'') then
  begin
    // Datei ist im Bildverzeichnis 128x128
    newfilename:=mainform.pcdimmerdirectory+'\Devicepictures\128x128\'+ExtractFileName(filename);
  end else
  begin
    ProgressScreenSmall.Label2.Caption:=_('Suche nach Datei')+' "'+ExtractFileName(filename)+'" '+_('im Ordner')+' "'+project_folder+'"';
    ProgressScreenSmall.ProgressBar1.Position:=50;
    ProgressScreenSmall.Refresh;

    // Datei wurde noch nicht gefunden. Nun echte Suchfunktion verwenden:
    // Suchen im Project-Temp
    newfilename:=FileSearch(project_folder, ExtractFileName(filename), True);
    if newfilename='' then
    begin
      ProgressScreenSmall.Label2.Caption:=_('Suche nach Datei')+' "'+ExtractFileName(filename)+'" '+_('im Ordner')+' "'+ExtractFilePath(project_file)+'"';
      ProgressScreenSmall.ProgressBar1.Position:=50;
      ProgressScreenSmall.Refresh;

      // Suchen im Verzeichnis der Projektdatei
      newfilename:=FileSearch(ExtractFilePath(project_file), ExtractFileName(filename), True);

      if newfilename='' then
      begin
        // Datei wurde nicht gefunden.
        newfilename:=filename;
      end;
    end;
  end;

//  ProgressScreenSmall.close;
  ProgressScreenSmall.Label1.Caption:=_('Dateioperation abgeschlossen.');
  ProgressScreenSmall.Label2.Caption:=newfilename;
  ProgressScreenSmall.Refresh;
  ProgressScreenSmall.Timer1.Enabled:=true; // Timer1 blendet Dialog dann aus

  Result:=newfilename;
end;

procedure TMainform.MidiBackTrack;
var
  i, j:integer;
  procedure SwitchMidi(ArrayPosition: integer; SwitchOn: boolean);
  var
    OnValue:Byte;
  begin
    if MidiEventArray[ArrayPosition].UseMidiBackTrack then
    begin
      if SwitchOn then OnValue:=127 else OnValue:=0;

      if MidiEventArray[ArrayPosition].Data1orData2=2 then
        SendMidi(MidiEventArray[ArrayPosition].MIDIMessage,MidiEventArray[ArrayPosition].MIDIData1,OnValue)
      else
        SendMidi(MidiEventArray[ArrayPosition].MIDIMessage,OnValue,0);
    end;
  end;
  procedure FadeMIDI(ArrayPosition: integer; Value: Byte);
  begin
    if MidiEventArray[ArrayPosition].UseMidiBacktrack then
    begin
      if MidiEventArray[ArrayPosition].Data1orData2=2 then
        SendMidi(MidiEventArray[ArrayPosition].MIDIMessage,MidiEventArray[ArrayPosition].MIDIData1,Value)
      else
        SendMidi(MidiEventArray[ArrayPosition].MIDIMessage,Value,0);
    end;
  end;
begin
  try
    // MIDI-BACKTRACK
    if MIDIActiveRibbonBox.Down and UseMidiBackTrack then
    begin
      for i:=0 to length(MidiEventArray)-1 do
      begin
        if IsEqualGUID(Befehlssystem[0].Steuerung[0].GUID, MidiEventArray[i].Befehl.Typ) then
        begin
          // AEP Start/Pause
          if MidiEventArray[i].IstState<>(BASS_ChannelIsActive(audioeffektplayerform._chan[0]) = BASS_ACTIVE_PLAYING) then
          begin
            MidiEventArray[i].IstState:=(BASS_ChannelIsActive(audioeffektplayerform._chan[0]) = BASS_ACTIVE_PLAYING);
            SwitchMIDI(i, MidiEventArray[i].IstState);
          end;
        end;
        if IsEqualGUID(Befehlssystem[0].Steuerung[1].GUID, MidiEventArray[i].Befehl.Typ) then
        begin
          // AEP Start
          if MidiEventArray[i].IstState<>(BASS_ChannelIsActive(audioeffektplayerform._chan[0]) = BASS_ACTIVE_PLAYING) then
          begin
            MidiEventArray[i].IstState:=(BASS_ChannelIsActive(audioeffektplayerform._chan[0]) = BASS_ACTIVE_PLAYING);
            SwitchMIDI(i, MidiEventArray[i].IstState);
          end;
        end;
        if IsEqualGUID(Befehlssystem[0].Steuerung[2].GUID, MidiEventArray[i].Befehl.Typ) then
        begin
          // AEP Stop
          if MidiEventArray[i].IstState<>(not (BASS_ChannelIsActive(audioeffektplayerform._chan[0]) = BASS_ACTIVE_PLAYING)) then
          begin
            MidiEventArray[i].IstState:=(not (BASS_ChannelIsActive(audioeffektplayerform._chan[0]) = BASS_ACTIVE_PLAYING));
            SwitchMIDI(i, MidiEventArray[i].IstState);
          end;
        end;
        if IsEqualGUID(Befehlssystem[0].Steuerung[4].GUID, MidiEventArray[i].Befehl.Typ) then
        begin
          // Audioeffektplayer Repeat ein/aus
          if MidiEventArray[i].IstState<>(audioeffektplayerform.Repeataktiviert.Checked) then
          begin
            MidiEventArray[i].IstState:=(audioeffektplayerform.Repeataktiviert.Checked);
            SwitchMIDI(i, MidiEventArray[i].IstState);
          end;
        end;
        if IsEqualGUID(Befehlssystem[0].Steuerung[5].GUID, MidiEventArray[i].Befehl.Typ) then
        begin
          // Audioeffektplayer Aufnahme ein/aus
          if MidiEventArray[i].IstState<>(audioeffektplayerform.recordbtn_off.Visible) then
          begin
            MidiEventArray[i].IstState:=(audioeffektplayerform.recordbtn_off.Visible);
            SwitchMIDI(i, MidiEventArray[i].IstState);
          end;
        end;
        if IsEqualGUID(Befehlssystem[0].Steuerung[6].GUID, MidiEventArray[i].Befehl.Typ) then
        begin
          // Effekte ein/aus
          if MidiEventArray[i].IstState<>(audioeffektplayerform.effekteein.Checked) then
          begin
            MidiEventArray[i].IstState:=(audioeffektplayerform.effekteein.Checked);
            SwitchMIDI(i, MidiEventArray[i].IstState);
          end;
        end;
        //############################
        if IsEqualGUID(Befehlssystem[1].Steuerung[0].GUID, MidiEventArray[i].Befehl.Typ) then
        begin
          // Szene starten
          if length(MidiEventArray[i].Befehl.ArgGUID)>0 then
          begin
            if MidiEventArray[i].IstState<>(IsSceneActive(MidiEventArray[i].Befehl.ArgGUID[0])) then
            begin
              MidiEventArray[i].IstState:=(IsSceneActive(MidiEventArray[i].Befehl.ArgGUID[0]));
              SwitchMIDI(i, MidiEventArray[i].IstState);
            end;
          end;
        end;
        if IsEqualGUID(Befehlssystem[1].Steuerung[1].GUID, MidiEventArray[i].Befehl.Typ) then
        begin
          // Szene stoppen
          if length(MidiEventArray[i].Befehl.ArgGUID)>0 then
          begin
            if MidiEventArray[i].IstState<>(not IsSceneActive(MidiEventArray[i].Befehl.ArgGUID[0])) then
            begin
              MidiEventArray[i].IstState:=(not IsSceneActive(MidiEventArray[i].Befehl.ArgGUID[0]));
              SwitchMIDI(i, MidiEventArray[i].IstState);
            end;
          end;
        end;
        if IsEqualGUID(Befehlssystem[1].Steuerung[2].GUID, MidiEventArray[i].Befehl.Typ) then
        begin
          // Szene start/stop
          if length(MidiEventArray[i].Befehl.ArgGUID)>0 then
          begin
            if MidiEventArray[i].IstState<>(IsSceneActive(MidiEventArray[i].Befehl.ArgGUID[0])) then
            begin
              MidiEventArray[i].IstState:=(IsSceneActive(MidiEventArray[i].Befehl.ArgGUID[0]));
              SwitchMIDI(i, MidiEventArray[i].IstState);
            end;
          end;
        end;
        //############################
        if IsEqualGUID(Befehlssystem[2].Steuerung[0].GUID, MidiEventArray[i].Befehl.Typ) then
        begin
          if MidiEventArray[i].IstState<>((beatform.beat_syncBtn.Caption='Stop')) then
          begin
            MidiEventArray[i].IstState:=((beatform.beat_syncBtn.Caption='Stop'));
            SwitchMIDI(i, MidiEventArray[i].IstState);
          end;
        end;
        //############################
        if IsEqualGUID(Befehlssystem[3].Steuerung[0].GUID, MidiEventArray[i].Befehl.Typ) or
        IsEqualGUID(Befehlssystem[3].Steuerung[1].GUID, MidiEventArray[i].Befehl.Typ) or
        IsEqualGUID(Befehlssystem[3].Steuerung[2].GUID, MidiEventArray[i].Befehl.Typ) then
        begin
          // Grandmaster
          if (MidiEventArray[i].IstWert<>(round((255-masterform.dimmerMaster.Position)*0.499))) then
          begin
            MidiEventArray[i].IstWert:=(round((255-masterform.dimmerMaster.Position)*0.499));
            FadeMidi(i, MidiEventArray[i].IstWert);
          end;
        end;
        if IsEqualGUID(Befehlssystem[3].Steuerung[3].GUID, MidiEventArray[i].Befehl.Typ) or
        IsEqualGUID(Befehlssystem[3].Steuerung[4].GUID, MidiEventArray[i].Befehl.Typ) or
        IsEqualGUID(Befehlssystem[3].Steuerung[5].GUID, MidiEventArray[i].Befehl.Typ) then
        begin
          // Flashmaster
          if (MidiEventArray[i].IstWert<>(round((255-masterform.Flashmaster.Position)*0.499))) then
          begin
            MidiEventArray[i].IstWert:=(round((255-masterform.Flashmaster.Position)*0.499));
            FadeMidi(i, MidiEventArray[i].IstWert);
          end;
        end;
        //############################
        if IsEqualGUID(Befehlssystem[4].Steuerung[0].GUID, MidiEventArray[i].Befehl.Typ) or
        IsEqualGUID(Befehlssystem[4].Steuerung[1].GUID, MidiEventArray[i].Befehl.Typ) or
        IsEqualGUID(Befehlssystem[4].Steuerung[2].GUID, MidiEventArray[i].Befehl.Typ) or
        IsEqualGUID(Befehlssystem[4].Steuerung[3].GUID, MidiEventArray[i].Befehl.Typ) or
        IsEqualGUID(Befehlssystem[4].Steuerung[4].GUID, MidiEventArray[i].Befehl.Typ) then
        begin
          // Einzelkanal
          if (MidiEventArray[i].IstWert<>(round(channel_value[MidiEventArray[i].Befehl.ArgInteger[0]]*0.499))) then
          begin
            MidiEventArray[i].IstWert:=(round(channel_value[MidiEventArray[i].Befehl.ArgInteger[0]]*0.499));
            FadeMidi(i, MidiEventArray[i].IstWert);
          end;
        end;
        //##############################
        if IsEqualGUID(Befehlssystem[7].Steuerung[8].GUID, MidiEventArray[i].Befehl.Typ) then
        begin
          // Cuelist Crossfader
          if (MidiEventArray[i].IstWert<>round(cuelistform.TrackBar1.Position*0.499)) then
          begin
            MidiEventArray[i].IstWert:=round(cuelistform.TrackBar1.Position*0.499);
            FadeMIDI(i, MidiEventArray[i].IstWert);
          end;
          break;
        end;
        //##############################
        if IsEqualGUID(Befehlssystem[9].Steuerung[0].GUID, MidiEventArray[i].Befehl.Typ) then
        begin
          // Effekt Start / Stop
          for j:=0 to length(effektsequenzereffekte)-1 do
          begin
            if length(MidiEventArray[i].Befehl.ArgGUID)>0 then
            if IsEqualGUID(MidiEventArray[i].Befehl.ArgGUID[0],effektsequenzereffekte[j].ID) then
            begin
              if MidiEventArray[i].IstState<>(AktuellerEffekt[j].Aktiv) then
              begin
                MidiEventArray[i].IstState:=(AktuellerEffekt[j].Aktiv);
                SwitchMIDI(i, MidiEventArray[i].IstState);
              end;
              break;
            end;
          end;
        end;
        if IsEqualGUID(Befehlssystem[9].Steuerung[1].GUID, MidiEventArray[i].Befehl.Typ) then
        begin
        // Effekt Start
          for j:=0 to length(effektsequenzereffekte)-1 do
          begin
            if length(MidiEventArray[i].Befehl.ArgGUID)>0 then
            if IsEqualGUID(MidiEventArray[i].Befehl.ArgGUID[0],effektsequenzereffekte[j].ID) then
            begin
              if MidiEventArray[i].IstState<>(AktuellerEffekt[j].Aktiv) then
              begin
                MidiEventArray[i].IstState:=(AktuellerEffekt[j].Aktiv);
                SwitchMIDI(i, MidiEventArray[i].IstState);
              end;
              break;
            end;
          end;
        end;
        if IsEqualGUID(Befehlssystem[9].Steuerung[2].GUID, MidiEventArray[i].Befehl.Typ) then
  //      102: // Effekt Stop
        begin
          for j:=0 to length(effektsequenzereffekte)-1 do
          begin
            if length(MidiEventArray[i].Befehl.ArgGUID)>0 then
            if IsEqualGUID(MidiEventArray[i].Befehl.ArgGUID[0],effektsequenzereffekte[j].ID) then
            begin
              if MidiEventArray[i].IstState<>(not AktuellerEffekt[j].Aktiv) then
              begin
                MidiEventArray[i].IstState:=(not AktuellerEffekt[j].Aktiv);
                SwitchMIDI(i, MidiEventArray[i].IstState);
              end;
              break;
            end;
          end;
        end;
        if IsEqualGUID(Befehlssystem[9].Steuerung[7].GUID, MidiEventArray[i].Befehl.Typ) then
  //      106: // Effekt Wiederholung ein/aus
        begin
          for j:=0 to length(effektsequenzereffekte)-1 do
            if length(MidiEventArray[i].Befehl.ArgGUID)>0 then
            if IsEqualGUID(MidiEventArray[i].Befehl.ArgGUID[0],effektsequenzereffekte[j].ID) then
            begin
              if MidiEventArray[i].IstState<>(effektsequenzereffekte[j].Repeating) then
              begin
                MidiEventArray[i].IstState:=(effektsequenzereffekte[j].Repeating);
                SwitchMIDI(i, MidiEventArray[i].IstState);
              end;
              break;
            end;
        end;
        //#########################
        if IsEqualGUID(Befehlssystem[10].Steuerung[0].GUID, MidiEventArray[i].Befehl.Typ) or
        IsEqualGUID(Befehlssystem[10].Steuerung[1].GUID, MidiEventArray[i].Befehl.Typ) or
        IsEqualGUID(Befehlssystem[10].Steuerung[2].GUID, MidiEventArray[i].Befehl.Typ) or
        IsEqualGUID(Befehlssystem[10].Steuerung[3].GUID, MidiEventArray[i].Befehl.Typ) then
        begin
          // Submaster Einzelkanal
          if (MidiEventArray[i].IstWert<>trunc(Submasterbank[submasterform.BankSelect.ItemIndex].CurrentValue[MidiEventArray[i].Befehl.ArgInteger[0]]*0.5)) then
          begin
            MidiEventArray[i].IstWert:=trunc(Submasterbank[submasterform.BankSelect.ItemIndex].CurrentValue[MidiEventArray[i].Befehl.ArgInteger[0]]*0.5);
            FadeMidi(i, MidiEventArray[i].IstWert);
          end;
        end;
        //#########################
        if IsEqualGUID(Befehlssystem[11].Steuerung[0].GUID, MidiEventArray[i].Befehl.Typ) then
  //      140: // Kontrollpanel
        begin
          if (MidiEventArray[i].Befehl.ArgInteger[0]-1<length(kontrollpanelbuttons)) and (MidiEventArray[i].Befehl.ArgInteger[1]-1<length(kontrollpanelbuttons[MidiEventArray[i].Befehl.ArgInteger[0]-1])) then
          if MidiEventArray[i].IstState<>(kontrollpanelbuttons[MidiEventArray[i].Befehl.ArgInteger[0]-1][MidiEventArray[i].Befehl.ArgInteger[1]-1].Active) then
          begin
            MidiEventArray[i].IstState:=(kontrollpanelbuttons[MidiEventArray[i].Befehl.ArgInteger[0]-1][MidiEventArray[i].Befehl.ArgInteger[1]-1].Active);
            SwitchMIDI(i, MidiEventArray[i].IstState);
          end;
        end;
        if IsEqualGUID(Befehlssystem[11].Steuerung[1].GUID, MidiEventArray[i].Befehl.Typ) then
  //      141: // Kontrollpanel
        begin
          if (MidiEventArray[i].Befehl.ArgInteger[0]-1<length(kontrollpanelbuttons)) and (MidiEventArray[i].Befehl.ArgInteger[1]-1<length(kontrollpanelbuttons[MidiEventArray[i].Befehl.ArgInteger[0]-1])) then
          if MidiEventArray[i].IstState<>(kontrollpanelbuttons[MidiEventArray[i].Befehl.ArgInteger[0]-1][MidiEventArray[i].Befehl.ArgInteger[1]-1].Active) then
          begin
            MidiEventArray[i].IstState:=(kontrollpanelbuttons[MidiEventArray[i].Befehl.ArgInteger[0]-1][MidiEventArray[i].Befehl.ArgInteger[1]-1].Active);
            SwitchMIDI(i, MidiEventArray[i].IstState);
          end;
        end;
        //#########################
        if IsEqualGUID(Befehlssystem[5].Steuerung[0].GUID, MidiEventArray[i].Befehl.Typ) then
        begin
  //      Selektierte Geräte
          for j:=0 to length(DeviceSelected)-1 do
          begin
            if DeviceSelected[j] then
            begin
              if (MidiEventArray[i].IstWert<>(round(geraetesteuerung.get_channel(Devices[j].ID,DeviceChannelNames[MidiEventArray[i].Befehl.ArgInteger[0]])*0.499))) then
              begin
                MidiEventArray[i].IstWert:=(round(geraetesteuerung.get_channel(Devices[j].ID,DeviceChannelNames[MidiEventArray[i].Befehl.ArgInteger[0]])*0.499));
                FadeMidi(i, MidiEventArray[i].IstWert);
              end;
              break;
            end;
          end;
        end;
        if IsEqualGUID(Befehlssystem[5].Steuerung[2].GUID, MidiEventArray[i].Befehl.Typ) or
        IsEqualGUID(Befehlssystem[5].Steuerung[3].GUID, MidiEventArray[i].Befehl.Typ) or
        IsEqualGUID(Befehlssystem[5].Steuerung[12].GUID, MidiEventArray[i].Befehl.Typ) or
        IsEqualGUID(Befehlssystem[5].Steuerung[13].GUID, MidiEventArray[i].Befehl.Typ) or
        IsEqualGUID(Befehlssystem[5].Steuerung[17].GUID, MidiEventArray[i].Befehl.Typ) then
        begin
  //      Bühnenansichtgerät verändern
          if (grafischebuehnenansicht.MouseOnDeviceHover>-1) then
          begin
            if (MidiEventArray[i].IstWert<>round(geraetesteuerung.get_channel(grafischebuehnenansicht.MouseOnDeviceID,DeviceChannelNames[MidiEventArray[i].Befehl.ArgInteger[0]])*0.499)) then
            begin
              MidiEventArray[i].IstWert:=round(geraetesteuerung.get_channel(grafischebuehnenansicht.MouseOnDeviceID,DeviceChannelNames[MidiEventArray[i].Befehl.ArgInteger[0]])*0.499);
              FadeMidi(i, MidiEventArray[i].IstWert);
            end;
          end;
        end;
        if IsEqualGUID(Befehlssystem[5].Steuerung[1].GUID, MidiEventArray[i].Befehl.Typ) or
        IsEqualGUID(Befehlssystem[5].Steuerung[4].GUID, MidiEventArray[i].Befehl.Typ) or
        IsEqualGUID(Befehlssystem[5].Steuerung[6].GUID, MidiEventArray[i].Befehl.Typ) then
  //      161: // Definiertes Gerät
        begin
          for j:=0 to length(devices)-1 do
          begin
            if length(MidiEventArray[i].Befehl.ArgGUID)>0 then
            if IsEqualGUID(MidiEventArray[i].Befehl.ArgGUID[0],devices[j].ID) then
            begin
              if (MidiEventArray[i].IstWert<>(round(geraetesteuerung.get_channel(Devices[j].ID,DeviceChannelNames[MidiEventArray[i].Befehl.ArgInteger[0]])*0.499))) then
              begin
                MidiEventArray[i].IstWert:=(round(geraetesteuerung.get_channel(Devices[j].ID,DeviceChannelNames[MidiEventArray[i].Befehl.ArgInteger[0]])*0.499));
                FadeMidi(i, MidiEventArray[i].IstWert);
              end;
              break;
            end;
          end;
        end;
      end;
    end;
  except
  end;
end;

procedure TMainform.MidiCallbackTimerTimer(Sender: TObject);
var
  i, tempvalue:integer;
begin
  MidiBackTrack;

  if RefreshValuesOfSelectedDevicesByMIDI then
  begin
    RefreshValuesOfSelectedDevicesByMIDI:=false;

    for i:=0 to length(SelektierteGeraete)-1 do
    begin
      if MIDIActiveRibbonBox.Down and (i<length(SelektierteGeraete)) and (i<length(mainform.SendValueOfSelectedDevicesToMidi)) and (SelektierteGeraete[i]<length(mainform.Devices)) then
      begin
        tempvalue:=geraetesteuerung.get_dimmer(mainform.Devices[SelektierteGeraete[i]].ID);

        if tempvalue<>SendValueOfSelectedDevicesToMidi[i].LastValue then
        begin
          if SendValueOfSelectedDevicesToMidi[i].UseData2 then
            SendMidi(SendValueOfSelectedDevicesToMidi[i].MSG,SendValueOfSelectedDevicesToMidi[i].Data1,round(tempvalue/maxres*127))
          else
            SendMidi(SendValueOfSelectedDevicesToMidi[i].MSG,round(tempvalue/maxres*127),0);
        end;

        SendValueOfSelectedDevicesToMidi[i].LastValue:=tempvalue;
      end;
    end;
  end;

  if PageControl1.ActivePageIndex=1 then
    RefreshMainformScreen:=true;
end;

procedure TMainform.TBItem41Click(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  cuelistform.show;
end;

procedure TMainform.GetSceneInfo(ID: TGUID; var Name: string; var Beschreibung: string; var Blendzeit: string; var Typ:string);
var
  j,k,t,scenetype:integer;
  tempcardinal,gesamtzeit:cardinal;
begin
  scenetype:=-1;

  // Einfache Szene
  if DoesSceneExists(ID) then
  begin
    for j:=0 to length(mainform.EinfacheSzenen)-1 do
    begin
      if IsEqualGUID(mainform.EinfacheSzenen[j].ID,ID) then
      begin
        Name:=mainform.EinfacheSzenen[j].Name; // Name
        Beschreibung:=mainform.EinfacheSzenen[j].Beschreibung;
        t:=mainform.EinfacheSzenen[j].einblendzeit;
        Blendzeit:=MillisecondsToTimeShort(t);
        Typ:=_('Einfache Szene');
        scenetype:=0;
        break;
      end;
    end;
    // Geräteszenen
    if scenetype=-1 then
    for j:=0 to length(mainform.Devicescenes)-1 do
    begin
      if IsEqualGUID(mainform.Devicescenes[j].ID,ID) then
      begin
        Name:=mainform.Devicescenes[j].Name; // Name
        Beschreibung:=mainform.Devicescenes[j].Beschreibung;
        t:=mainform.Devicescenes[j].fadetime;
        Blendzeit:=MillisecondsToTimeShort(t);
        Typ:=_('Geräteszene');
        scenetype:=1;
        break;
      end;
    end;
    // Audioszene
    if scenetype=-1 then
    for j:=0 to length(mainform.Audioszenen)-1 do
    begin
      if IsEqualGUID(mainform.Audioszenen[j].ID,ID) then
      begin
        Name:=mainform.Audioszenen[j].Name; // Name
        Beschreibung:=mainform.Audioszenen[j].Beschreibung;
        t:=mainform.Audioszenen[j].dauer;
        Blendzeit:=MillisecondsToTimeShort(t);
        Typ:=_('Audioszene');
        scenetype:=2;
        break;
      end;
    end;
    // Bewegungsszene
    if scenetype=-1 then
    for j:=0 to length(mainform.Bewegungsszenen)-1 do
    begin
      if IsEqualGUID(mainform.Bewegungsszenen[j].ID,ID) then
      begin
        Name:=mainform.Bewegungsszenen[j].Name; // Name
        Beschreibung:=mainform.Bewegungsszenen[j].Beschreibung;

        if mainform.Bewegungsszenen[j].repeats>-1 then
        begin
          tempcardinal:=mainform.Bewegungsszenen[j].repeats+1;
          t:=mainform.Bewegungsszenen[j].dauer*tempcardinal;
          Blendzeit:=MillisecondsToTimeShort(t);
        end else
        begin
          Blendzeit:=_('Unbegrenzt');
        end;
        Typ:=_('Bewegungsszene');
        scenetype:=3;
        break;
      end;
    end;
    // Befehl
    if scenetype=-1 then
    for j:=0 to length(mainform.Befehle2)-1 do
    begin
      if IsEqualGUID(mainform.Befehle2[j].ID,ID) then
      begin
        Name:=mainform.Befehle2[j].Name; // Name
        Beschreibung:=mainform.Befehle2[j].Beschreibung;
        Blendzeit:='-';
        Typ:=_('Befehl');
        scenetype:=4;
        break;
      end;
    end;
    // Komposition
    if scenetype=-1 then
    for j:=0 to length(mainform.Kompositionsszenen)-1 do
    begin
      if IsEqualGUID(mainform.Kompositionsszenen[j].ID,ID) then
      begin
        Name:=mainform.Kompositionsszenen[j].Name; // Name
        Beschreibung:=mainform.Kompositionsszenen[j].Beschreibung;
        Blendzeit:='-';
        Typ:=_('Kombinationsszene');
        scenetype:=5;
        break;
      end;
    end;
    // Preset
    if scenetype=-1 then
    for j:=0 to length(mainform.DevicePresets)-1 do
    begin
      if IsEqualGUID(mainform.DevicePresets[j].ID,ID) then
      begin
        Name:=mainform.DevicePresets[j].Name; // Name
        Beschreibung:=mainform.DevicePresets[j].Beschreibung;
        t:=0;
        Blendzeit:=MillisecondsToTimeShort(t);
        Typ:=_('Preset');
        scenetype:=6;
        break;
      end;
    end;
    // Automatikszene
    if scenetype=-1 then
    for j:=0 to length(mainform.Autoszenen)-1 do
    begin
      if IsEqualGUID(mainform.Autoszenen[j].ID,ID) then
      begin
        Name:=mainform.Autoszenen[j].Name; // Name
        Beschreibung:=mainform.Autoszenen[j].Beschreibung;
        t:=mainform.Autoszenen[j].fadetime;
        Blendzeit:=MillisecondsToTimeShort(t);
        Typ:=_('Automatikszene');
        scenetype:=7;
        break;
      end;
    end;
    // Effekt
    if scenetype=-1 then
    for j:=0 to length(mainform.Effektsequenzereffekte)-1 do
    begin
      if IsEqualGUID(mainform.Effektsequenzereffekte[j].ID,ID) then
      begin
        Name:=mainform.Effektsequenzereffekte[j].Name; // Name
        Beschreibung:=mainform.Effektsequenzereffekte[j].Beschreibung;

        gesamtzeit:=0;
        if mainform.Effektsequenzereffekte[j].AnzahlderDurchlaufe>-1 then
        begin
          for k:=0 to length(mainform.Effektsequenzereffekte[j].Effektschritte)-1 do
          begin
            gesamtzeit:=gesamtzeit+mainform.Effektsequenzereffekte[j].Effektschritte[k].einblendzeit+mainform.Effektsequenzereffekte[j].Effektschritte[k].wartezeit;
          end;
          tempcardinal:=mainform.Effektsequenzereffekte[j].AnzahlderDurchlaufe;
          gesamtzeit:=gesamtzeit*tempcardinal;
        end;

        t:=gesamtzeit;
        if gesamtzeit=0 then
          Blendzeit:=_('Unendlich')
        else
          Blendzeit:=MillisecondsToTimeShort(t);
        Typ:=_('Effekt');
        scenetype:=8;
        break;
      end;
    end;
    // MediaCenterSzenen
    if scenetype=-1 then
    for j:=0 to length(mainform.MediaCenterSzenen)-1 do
    begin
      if IsEqualGUID(mainform.MediaCenterSzenen[j].ID,ID) then
      begin
        Name:=mainform.MediaCenterSzenen[j].Name; // Name
        Beschreibung:=mainform.MediaCenterSzenen[j].Beschreibung;
        Blendzeit:='-';
        Typ:=_('MediaCenter Szene');
        scenetype:=9;
        break;
      end;
    end;
    // Presetszene
    if scenetype=-1 then
    for j:=0 to length(mainform.presetscenes)-1 do
    begin
      if IsEqualGUID(mainform.presetscenes[j].ID,ID) then
      begin
        Name:=mainform.presetscenes[j].Name; // Name
        Beschreibung:=mainform.presetscenes[j].Beschreibung;
        t:=0;
        Blendzeit:=MillisecondsToTimeShort(t);
        Typ:=_('Presetszene');
        scenetype:=10;
        break;
      end;
    end;
    // Codeszenen
    if scenetype=-1 then
    for j:=0 to length(mainform.codescenes)-1 do
    begin
      if IsEqualGUID(mainform.codescenes[j].ID,ID) then
      begin
        Name:=mainform.codescenes[j].Name; // Name
        Beschreibung:=mainform.codescenes[j].Beschreibung;
        t:=0;
        Blendzeit:=MillisecondsToTimeShort(t);
        Typ:=_('Codeszene');
        scenetype:=11;
        break;
      end;
    end;
    // Plugin
    if scenetype=-1 then
    for j:=0 to length(mainform.PluginSzenen)-1 do
    begin
      if IsEqualGUID(mainform.PluginSzenen[j].ID,ID) then
      begin
        Name:=mainform.PluginSzenen[j].Name; // Name
        Beschreibung:='';
        Blendzeit:='-';
        Typ:=_('Plugin Szene');
//        scenetype:=12;
        break;
      end;
    end;
  end else
  begin
    Name:=_('...');//GUIDtoString(ID); // Name
    Beschreibung:=_('...');
    Blendzeit:='-';
    Typ:=_('...');
  end;
end;

function TMainform.GetSceneInfo2(ID: TGUID; InfoType:string):string;
var
  name, desc, time, typ:string;
begin
  GetSceneInfo(ID, name, desc, time, typ);

  if lowercase(InfoType)='name' then
    result:=name
  else if lowercase(InfoType)='desc' then
    result:=desc
  else if lowercase(InfoType)='time' then
    result:=time
  else if lowercase(InfoType)='type' then
    result:=typ;
end;

function TMainform.GetSceneType(ID: TGUID):integer;
var
  j,typ:integer;
begin
  typ:=-1;
  
  // Einfache Szene
  if DoesSceneExists(ID) then
  begin
    for j:=0 to length(mainform.EinfacheSzenen)-1 do
    begin
      if IsEqualGUID(mainform.EinfacheSzenen[j].ID,ID) then
      begin
        typ:=0;
        break;
      end;
    end;
    // Geräteszenen
    if typ=-1 then
    for j:=0 to length(mainform.Devicescenes)-1 do
    begin
      if IsEqualGUID(mainform.Devicescenes[j].ID,ID) then
      begin
        typ:=1;
        break;
      end;
    end;
    // Audioszene
    if typ=-1 then
    for j:=0 to length(mainform.Audioszenen)-1 do
    begin
      if IsEqualGUID(mainform.Audioszenen[j].ID,ID) then
      begin
        typ:=2;
        break;
      end;
    end;
    // Bewegungsszene
    if typ=-1 then
    for j:=0 to length(mainform.Bewegungsszenen)-1 do
    begin
      if IsEqualGUID(mainform.Bewegungsszenen[j].ID,ID) then
      begin
        typ:=3;
        break;
      end;
    end;
    // Befehl
    if typ=-1 then
    for j:=0 to length(mainform.Befehle2)-1 do
    begin
      if IsEqualGUID(mainform.Befehle2[j].ID,ID) then
      begin
        typ:=4;
        break;
      end;
    end;
    // Komposition
    if typ=-1 then
    for j:=0 to length(mainform.Kompositionsszenen)-1 do
    begin
      if IsEqualGUID(mainform.Kompositionsszenen[j].ID,ID) then
      begin
        typ:=5;
        break;
      end;
    end;
    // Preset
    if typ=-1 then
    for j:=0 to length(mainform.Devicepresets)-1 do
    begin
      if IsEqualGUID(mainform.Devicepresets[j].ID,ID) then
      begin
        typ:=6;
        break;
      end;
    end;
    // Automatikszene
    if typ=-1 then
    for j:=0 to length(mainform.Autoszenen)-1 do
    begin
      if IsEqualGUID(mainform.Autoszenen[j].ID,ID) then
      begin
        typ:=7;
        break;
      end;
    end;
    // Effekt
    if typ=-1 then
    for j:=0 to length(mainform.Effektsequenzereffekte)-1 do
    begin
      if IsEqualGUID(mainform.Effektsequenzereffekte[j].ID,ID) then
      begin
        typ:=8;
        break;
      end;
    end;
    // MediaCenterSzenen
    if typ=-1 then
    for j:=0 to length(mainform.MediaCenterSzenen)-1 do
    begin
      if IsEqualGUID(mainform.MediaCenterSzenen[j].ID,ID) then
      begin
        typ:=9;
        break;
      end;
    end;
    // Presetszenen
    if typ=-1 then
    for j:=0 to length(mainform.PresetScenes)-1 do
    begin
      if IsEqualGUID(mainform.PresetScenes[j].ID,ID) then
      begin
        typ:=10;
        break;
      end;
    end;
    // Codeszenen
    if typ=-1 then
    for j:=0 to length(mainform.CodeScenes)-1 do
    begin
      if IsEqualGUID(mainform.CodeScenes[j].ID,ID) then
      begin
        typ:=11;
        break;
      end;
    end;
    // PluginSzenen
    if typ=-1 then
    for j:=0 to length(mainform.PluginSzenen)-1 do
    begin
      if IsEqualGUID(mainform.PluginSzenen[j].ID,ID) then
      begin
        typ:=12;
        break;
      end;
    end;
  end;
  result:=typ;
end;

procedure TMainform.SetSceneCategory(ID: TGUID; Cat:String);
var
  typ,j:integer;
begin
  typ:=-1;

  // Einfache Szene
  if DoesSceneExists(ID) then
  begin
    for j:=0 to length(mainform.EinfacheSzenen)-1 do
    begin
      if IsEqualGUID(mainform.EinfacheSzenen[j].ID,ID) then
      begin
        typ:=0;
        mainform.EinfacheSzenen[j].Category:=Cat;
        break;
      end;
    end;
    // Geräteszenen
    if typ=-1 then
    for j:=0 to length(mainform.Devicescenes)-1 do
    begin
      if IsEqualGUID(mainform.Devicescenes[j].ID,ID) then
      begin
        typ:=1;
        mainform.Devicescenes[j].Category:=Cat;
        break;
      end;
    end;
    // Audioszene
    if typ=-1 then
    for j:=0 to length(mainform.Audioszenen)-1 do
    begin
      if IsEqualGUID(mainform.Audioszenen[j].ID,ID) then
      begin
        typ:=2;
        mainform.Audioszenen[j].Category:=Cat;
        break;
      end;
    end;
    // Bewegungsszene
    if typ=-1 then
    for j:=0 to length(mainform.Bewegungsszenen)-1 do
    begin
      if IsEqualGUID(mainform.Bewegungsszenen[j].ID,ID) then
      begin
        typ:=3;
        mainform.Bewegungsszenen[j].Category:=Cat;
        break;
      end;
    end;
    // Befehl
    if typ=-1 then
    for j:=0 to length(mainform.Befehle2)-1 do
    begin
      if IsEqualGUID(mainform.Befehle2[j].ID,ID) then
      begin
        typ:=4;
        mainform.Befehle2[j].Category:=Cat;
        break;
      end;
    end;
    // Komposition
    if typ=-1 then
    for j:=0 to length(mainform.Kompositionsszenen)-1 do
    begin
      if IsEqualGUID(mainform.Kompositionsszenen[j].ID,ID) then
      begin
        typ:=5;
        mainform.Kompositionsszenen[j].Category:=Cat;
        break;
      end;
    end;
    // Preset
    if typ=-1 then
    for j:=0 to length(mainform.Devicepresets)-1 do
    begin
      if IsEqualGUID(mainform.Devicepresets[j].ID,ID) then
      begin
        typ:=6;
        mainform.Devicepresets[j].Category:=Cat;
        break;
      end;
    end;
    // Automatikszene
    if typ=-1 then
    for j:=0 to length(mainform.Autoszenen)-1 do
    begin
      if IsEqualGUID(mainform.Autoszenen[j].ID,ID) then
      begin
        typ:=7;
        mainform.Autoszenen[j].Category:=Cat;
        break;
      end;
    end;
{
    // Effekt
    if typ=-1 then
    for j:=0 to length(mainform.Effektsequenzereffekte)-1 do
    begin
      if IsEqualGUID(mainform.Effektsequenzereffekte[j].ID,ID) then
      begin
        typ:=8;
        break;
      end;
    end;
}
    // MediaCenterSzenen
    if typ=-1 then
    for j:=0 to length(mainform.MediaCenterSzenen)-1 do
    begin
      if IsEqualGUID(mainform.MediaCenterSzenen[j].ID,ID) then
      begin
        typ:=9;
        mainform.MediaCenterSzenen[j].Category:=Cat;
        break;
      end;
    end;
    // Presetszenen
    if typ=-1 then
    for j:=0 to length(mainform.PresetScenes)-1 do
    begin
      if IsEqualGUID(mainform.PresetScenes[j].ID,ID) then
      begin
        typ:=10;
        mainform.PresetScenes[j].Category:=Cat;
        break;
      end;
    end;
    // Codeszenen
    if typ=-1 then
    for j:=0 to length(mainform.CodeScenes)-1 do
    begin
      if IsEqualGUID(mainform.CodeScenes[j].ID,ID) then
      begin
        typ:=11;
        mainform.CodeScenes[j].Category:=Cat;
        break;
      end;
    end;
    // PluginSzenen
    if typ=-1 then
    for j:=0 to length(mainform.PluginSzenen)-1 do
    begin
      if IsEqualGUID(mainform.PluginSzenen[j].ID,ID) then
      begin
//        typ:=12;
        mainform.PluginSzenen[j].Category:=Cat;
        break;
      end;
    end;
  end;
end;

procedure TMainform.GetInfo(ID: TGUID; var Name: string);
var
  i:integer;
  text:string;
begin
  // Gerät
  text:='';
  for i:=0 to length(devices)-1 do
  begin
    if IsEqualGUID(ID, devices[i].ID) then
    begin
      text:=devices[i].Name;
      break;
    end;
  end;

  // Gerätegruppe
  if text='' then
  begin
    for i:=0 to length(devicegroups)-1 do
    begin
      if IsEqualGUID(ID, devicegroups[i].ID) then
      begin
        text:=devicegroups[i].Name;
        break;
      end;
    end;
  end;

  // Effekt
  if text='' then
  begin
    for i:=0 to length(effektsequenzereffekte)-1 do
    begin
      if IsEqualGUID(ID, effektsequenzereffekte[i].ID) then
      begin
        text:=effektsequenzereffekte[i].Name;
        break;
      end;
    end;
  end;

  // Szenen
  if text='' then
  begin
    for i:=0 to length(EinfacheSzenen)-1 do
    begin
      if IsEqualGUID(ID, EinfacheSzenen[i].ID) then
      begin
        text:=EinfacheSzenen[i].Name;
        break;
      end;
    end;
  end;
  if text='' then
  begin
    for i:=0 to length(DeviceScenes)-1 do
    begin
      if IsEqualGUID(ID, DeviceScenes[i].ID) then
      begin
        text:=DeviceScenes[i].Name;
        break;
      end;
    end;
  end;
  if text='' then
  begin
    for i:=0 to length(Bewegungsszenen)-1 do
    begin
      if IsEqualGUID(ID, Bewegungsszenen[i].ID) then
      begin
        text:=Bewegungsszenen[i].Name;
        break;
      end;
    end;
  end;
  if text='' then
  begin
    for i:=0 to length(Audioszenen)-1 do
    begin
      if IsEqualGUID(ID, Audioszenen[i].ID) then
      begin
        text:=Audioszenen[i].Name;
        break;
      end;
    end;
  end;
  if text='' then
  begin
    for i:=0 to length(Befehle2)-1 do
    begin
      if IsEqualGUID(ID, Befehle2[i].ID) then
      begin
        text:=Befehle2[i].Name;
        break;
      end;
    end;
  end;
  if text='' then
  begin
    for i:=0 to length(Kompositionsszenen)-1 do
    begin
      if IsEqualGUID(ID, Kompositionsszenen[i].ID) then
      begin
        text:=Kompositionsszenen[i].Name;
        break;
      end;
    end;
  end;
  if text='' then
  begin
    for i:=0 to length(DevicePresets)-1 do
    begin
      if IsEqualGUID(ID, DevicePresets[i].ID) then
      begin
        text:=DevicePresets[i].Name;
        break;
      end;
    end;
  end;
  if text='' then
  begin
    for i:=0 to length(Autoszenen)-1 do
    begin
      if IsEqualGUID(ID, Autoszenen[i].ID) then
      begin
        text:=Autoszenen[i].Name;
        break;
      end;
    end;
  end;
  if text='' then
  begin
    for i:=0 to length(MediaCenterSzenen)-1 do
    begin
      if IsEqualGUID(ID, MediaCenterSzenen[i].ID) then
      begin
        text:=MediaCenterSzenen[i].Name;
        break;
      end;
    end;
  end;
  if text='' then
  begin
    for i:=0 to length(presetscenes)-1 do
    begin
      if IsEqualGUID(ID, presetscenes[i].ID) then
      begin
        text:=presetscenes[i].Name;
        break;
      end;
    end;
  end;
  if text='' then
  begin
    for i:=0 to length(codescenes)-1 do
    begin
      if IsEqualGUID(ID, codescenes[i].ID) then
      begin
        text:=codescenes[i].Name;
        break;
      end;
    end;
  end;
  if text='' then
  begin
    for i:=0 to length(PluginSzenen)-1 do
    begin
      if IsEqualGUID(ID, PluginSzenen[i].ID) then
      begin
        text:=PluginSzenen[i].Name;
        break;
      end;
    end;
  end;

  Name:=text;
end;

procedure TMainform.TBItem43Click(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  masterform.show;
end;

procedure TMainform.OpenPCDIMMERFile(FileName: string);
var
  filetoopen:string;
  j,Count:integer;
begin
  filetoopen:=SearchFileBeneathProject(FileName);

  if FileExists(filetoopen) then
  begin
    // Falls Textdatei (z.B. nach Onlineupdate)
    if copy(filetoopen,length(filetoopen)-2,3)='txt' then
    begin
			textbox.Items.LoadFromFile(filetoopen);
     	ShowMessage(textbox.Items.GetText);
    end;

    // Falls Figurendatei
    if copy(filetoopen,length(filetoopen)-6,7)='pcdfigr' then
    begin
      figureneditorform.OpenFile(filetoopen);
    end;

    // Falls Kontrollpaneldatei
    if copy(filetoopen,length(filetoopen)-6,7)='pcdcpnl' then
    begin
      kontrollpanel.OpenFile(filetoopen);
    end;

    // Falls Skripttimerdatei
    if copy(filetoopen,length(filetoopen)-6,7)='pcdstmr' then
    begin
      FileStream.Create(filetoopen,fmOpenRead);
  		Filestream.ReadBuffer(Count,sizeof(Count));
      setlength(AblaufTimer,Count);
      for j:=0 to Count-1 do
    	begin
        Filestream.ReadBuffer(AblaufTimer[j].Aktiviert,sizeof(AblaufTimer[j].Aktiviert));
        Filestream.ReadBuffer(AblaufTimer[j].Name,sizeof(AblaufTimer[j].Name));
        Filestream.ReadBuffer(AblaufTimer[j].Beschreibung,sizeof(AblaufTimer[j].Beschreibung));
        Filestream.ReadBuffer(AblaufTimer[j].Datum,sizeof(AblaufTimer[j].Datum));
        Filestream.ReadBuffer(AblaufTimer[j].Uhrzeit,sizeof(AblaufTimer[j].Uhrzeit));
        Filestream.ReadBuffer(AblaufTimer[j].TimerTyp,sizeof(AblaufTimer[j].TimerTyp));
        Filestream.ReadBuffer(AblaufTimer[j].Skriptdatei,sizeof(AblaufTimer[j].Skriptdatei));
        Filestream.ReadBuffer(AblaufTimer[j].LoadTyp,sizeof(AblaufTimer[j].LoadTyp));
        Filestream.ReadBuffer(AblaufTimer[j].LoadID,sizeof(AblaufTimer[j].LoadID));
        Filestream.ReadBuffer(AblaufTimer[j].Weekday,sizeof(AblaufTimer[j].Weekday));
      end;
      Filestream.Free;
      schedulerform.skripttimer_listbox.Clear;
      for j:=0 to Count-1 do
      begin
        case Ablauftimer[j].LoadTyp of
          0..1: schedulerform.skripttimer_listbox.ItemIndex:=schedulerform.skripttimer_listbox.Items.Add(Ablauftimer[j].Datum+' '+Ablauftimer[j].Uhrzeit+' : '+Ablauftimer[j].Name);
          2: schedulerform.skripttimer_listbox.ItemIndex:=schedulerform.skripttimer_listbox.Items.Add(Ablauftimer[j].Datum+' '+Ablauftimer[j].Uhrzeit+' : '+ExtractFileName(Ablauftimer[j].Skriptdatei));
        end;
      end;

      schedulerform.checkskripttimerbuttons();
      schedulerform.show;
    end;

    // Falls Projektdatei
    if copy(filetoopen,length(filetoopen)-6,7)='pcdproj' then
    begin
      autoload_project_file:=filetoopen;
      openproject(filetoopen, false);
    end;

    // Falls Audioeffektdatei
    if copy(filetoopen,length(filetoopen)-6,7)='pcdeaud' then
    begin
      audioeffektplayerform.openeffektaudiofile(filetoopen);
    end;

    // Falls Effektdatei
    if copy(filetoopen,length(filetoopen)-6,7)='pcdefct' then
    begin
      effektsequenzer.OpenFile(filetoopen);
    end;

    // Falls Kontrollpanel
    if copy(filetoopen,length(filetoopen)-6,7)='pcdcpnl' then
    begin
      kontrollpanel.OpenFile(filetoopen);
    end;
    
    // Falls Kontrollpanel
    if copy(filetoopen,length(filetoopen)-6,7)='pcdsubm' then
    begin
      submasterform.Openfile(filetoopen);
    end;

    // Falls PMM
    if copy(filetoopen,length(filetoopen)-6,7)='pcdpmmp' then
    begin
      pmmform.Openfile(filetoopen);
    end;

    // Falls MIDI-Einstellungen
    if copy(filetoopen,length(filetoopen)-6,7)='pcdmidi' then
    begin
      midieventfrm.Openfile(filetoopen);
    end;
    
    // Falls Tastaturbelegung
    if copy(filetoopen,length(filetoopen)-6,7)='pcdshct' then
    begin
      Tastenabfrage.Openfile(filetoopen);
    end;    
    
    // Falls Cuelistdatei
    if copy(filetoopen,length(filetoopen)-6,7)='pcdcuel' then
    begin
      cuelistform.Openfile(filetoopen);
    end;    
    
    // Falls Joysticksteuerungsdatei
    if copy(filetoopen,length(filetoopen)-6,7)='pcdjstk' then
    begin
      joystickform.Openfile(filetoopen);
    end;
    
    // Falls Timecodeplayerdatei
    if copy(filetoopen,length(filetoopen)-6,7)='pcdtmcl' then
    begin
      timecodeplayerform.Openfile(filetoopen);
    end;
  end else
  begin
    DebugAdd('ERROR: '+_('Die zu öffnende Datei konnte nicht gefunden werden')+': '+filetoopen);
  end;
end;

function TMainform.SetThreadAffinityMaskByID(ID, AffinityMask: Cardinal): Boolean;
var
  Handle: THandle;
  WhichCPU:Cardinal;
begin
  Result:=False;

  WhichCPU:=1;
  if CPUCount>=AffinityMask then
  begin
    WhichCPU:=AffinityMask;
  end;

  Handle:=OpenThread(THREAD_SET_INFORMATION or THREAD_QUERY_INFORMATION, False, ID);
  if Handle<>0 then begin
     Result:=SetThreadAffinityMask(Handle, WhichCPU)<>0;
     CloseHandle(Handle);
  end;
end;

procedure TMainform.AddToOpenHistory(FileName: string);
var
  projectfilepath,projectfilename:string;
  i:integer;
  DoesAlreadyExists:integer;
  tempstring:string;
begin
  // OpenHistory aktualisieren
  projectfilepath:=ExtractFilePath(FileName);
  projectfilename:=ExtractFileName(FileName);

  DoesAlreadyExists:=-1;
  for i:=0 to 4 do
  begin
    if data.openhistory[i]=projectfilepath+projectfilename then
    begin
      DoesAlreadyExists:=i;
      break;
    end;
  end;

  if (not (data.openhistory[0]=projectfilepath+projectfilename)) and (DoesAlreadyExists=-1) and ((projectfilepath+projectfilename)<>(userdirectory+'ProjectTemp\Projekt')) and (projectfilename<>'Projekt') then
  begin
    // Alle Positionen um eins nach unten verschieben und neues Projekt an oberste Stelle
    for i:=0 to 3 do
      data.openhistory[4-i]:=data.openhistory[3-i];
    data.openhistory[0]:=projectfilepath+projectfilename;
  end else if (DoesAlreadyExists>-1) then
  begin
    for i:=DoesAlreadyExists downto 1 do
    begin
      tempstring:=data.openhistory[i]; // Aktuelle Position Speichern
      data.openhistory[i]:=data.openhistory[i-1]; // Obere Position auf aktuelle Position
      data.openhistory[i-1]:=tempstring; // Gesicherte Position auf obere Position
    end;
  end;

  // Menü aktualisieren
  dxBarApplicationMenu1.ExtraPane.Items.Clear;
  for i:=1 to 5 do
  begin
    TdxBarButton(FindComponent('openhistory'+inttostr(i)+'ribbon')).Caption:=ExtractFileName(data.openhistory[i-1]);
    if data.openhistory[i-1]='' then
    begin
      TdxBarButton(FindComponent('openhistory'+inttostr(i)+'ribbon')).Visible:=ivNever;
    end else
    begin
      TdxBarButton(FindComponent('openhistory'+inttostr(i)+'ribbon')).Visible:=ivAlways;
      historyribbonitem:=dxBarApplicationMenu1.ExtraPane.Items.Add;
      historyribbonitem.DisplayText:=ExtractFileName(data.openhistory[i-1]);
      historyribbonitem.Data:=i;
    end;
  end;
end;

procedure TMainform.TBItem46Click(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  if cdplayerform=nil then
    cdplayerform:=Tcdplayerform.Create(cdplayerform);
  cdplayerform.Show;
end;

procedure TMainform.TBItem48Click(Sender: TObject);
begin
  if not UserAccessGranted(1) then exit;

  groupeditorform.show;
end;

procedure TMainform.TBItem50Click(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  SendMessage(mainform.Handle, 274, 61808, 1); // StandBy
end;

procedure TMainform.TBItem51Click(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  SendMessage(mainform.Handle, 274, 61808, 2); // aus
end;

procedure TMainform.TBItem52Click(Sender: TObject);
begin
  SendMessage(mainform.Handle, 274, 61808, -1); // ein
end;

procedure TMainform.SendMidi(MSG, Data1, Data2: byte);
var
  i:integer;
  thisControl: TMidiOutput;
begin
  MIDIOutPackets:=MIDIOutPackets+1;

  for i:=0 to length(MidioutControls)-1 do
  begin
    thisControl:=MidioutControls[i];
    if midieventfrm.midioutdevicelist.Checked[i] then
      thisControl.PutShort(MSG, Data1, Data2);
  end;
end;

procedure TMainform.CompressCompletedAction(Sender: TObject);
begin
  if startingup and (splashscreenvalue=1) then
    splash.ShowFortschritt2:=false;
end;

procedure TMainform.TBItem53Click(Sender: TObject);
begin
  if USBViewForm=nil then
    USBViewForm:=TUSBViewForm.Create(USBViewForm);
  USBViewForm.Show;
end;

procedure Tmainform.WriteSettingsToRegistry;
var
  LReg:TPCDRegistry;
  i:integer;
begin
  LReg := TPCDRegistry.Create;
  if LReg.OpenRegKey('') then
  begin
    LReg.WriteBool('Startup with old scene',startupwitholdscene);
    LReg.WriteBool('Switchoff Lights on Shutdown',switchofflightsatshutdown);
    LReg.WriteBool('Ask for saving projectfile',askforsaveproject);
    LReg.WriteBool('Deactivate powerbutton',powerswitchoff);
    LReg.WriteString('Last used directory',userdirectory);
    LReg.WriteInteger('Style of Leveldisplay',levelanzeigeoptionen);
    LReg.WriteBool('Deactivate Outputplugins on Shutdown',deactivateoutputdllsonclose);
    LReg.WriteBool('Deactivate Inputplugins on Shutdown',deactivateinputdllsonclose);
    LReg.WriteInteger('Used Speakers',sounddevicespeakers);
    LReg.WriteInteger('Last used Audiodevice',sounddevice);
    LReg.WriteInteger('Min Screenbrightness',round(strtoint(Optionenbox.bildschirmhelligkeit.Text)*255 / 100));
    LReg.WriteBool('Show last used Plugins',showlastplugins);
    LReg.WriteBool('Beat to Scroll-Lock LED',flashscrolllockled);
    LReg.WriteBool('Show Accuwarnings',showakkuwarnings);
    LReg.WriteBool('Blendout unfocused forms',blendoutforms);
    LReg.WriteInteger('Autobackup',Autobackupcountermax);
    LReg.WriteInteger('Autobackup Files',maxautobackupfiles);
    LReg.WriteInteger('Timer',animationtimer);
    LReg.WriteBool('Use HTTP Password',OptionenBox.HTTPServerPasswordCheckbox.Checked);
    LReg.WriteString('MQTT Host', mqtt.Host);
    LReg.WriteInteger('MQTT Port', mqtt.Port);
    LReg.WriteString('MQTT User', mqtt.Username);
    LReg.WriteBool('MidiBeatSignal On',MBS_Online);
    LReg.WriteInteger('MidiBeatSignal MSG On',MBS_MSGon);
    LReg.WriteInteger('MidiBeatSignal MSG Off',MBS_MSGoff);
    LReg.WriteInteger('MidiBeatSignal Data1 On',MBS_Data1on);
    LReg.WriteInteger('MidiBeatSignal Data1 Off',MBS_Data1off);
    LReg.WriteInteger('MidiBeatSignal Data2 On',MBS_Data2on);
    LReg.WriteInteger('MidiBeatSignal Data2 Off',MBS_Data2off);
    LReg.WriteString('Position of MEVP.DLL', mevp.MEVPDLLPath);
    LReg.WriteBool('Mevp Use Thread', mevp.UseThread);
    LReg.WriteInteger('Mevp Thread Priority', ThreadPriorityToInt(mevp.ThreadPriority));

    plugin_blacklist_new:='';
    for i:=0 to length(Outputplugins)-1 do
    begin
      if OutputPlugins[i].IsBlacklisted then
        plugin_blacklist_new:=plugin_blacklist_new+Outputplugins[i].Filename;
    end;
    LReg.WriteString('Plugin Blacklist',plugin_blacklist+plugin_blacklist_new);
    LReg.WriteInteger('MinimumDimmerkernelResolution', MinDimmerkernelResolution);
    LReg.WriteBool('Autoset DimmerkernelResolution', DimmerkernelResolutionAutoset);
    LReg.WriteInteger('Autolocktime',autolocktime);
    LReg.WriteInteger('Terminal IP Port',terminalport);
    LReg.WriteInteger('MediaCenter IP Port',mediacenterport);
    LReg.WriteBool('Check updates on Startup', CheckUpdatesOnStartup);
    LReg.WriteBool('Do not ask for exit', QuitWithoutConfirmation);
    LReg.WriteBool('AutoAmberCalculation', UseAutoAmberCalculation);
    LReg.WriteInteger('Autologouttime',autologouttime);
    LReg.WriteString('StartupUser',StartupUser);

    with TCipher_Blowfish.Create do
    try
      Init(blowfishscramblekey);
      httppasswordscrambled := EncodeBinary(OptionenBox.HTTPServerPassword.Text, TFormat_Copy);
    finally
      Free;
    end;
    LReg.WriteBinaryData('HTTP Password',httppasswordscrambled,sizeof(httppasswordscrambled));

    with TCipher_Blowfish.Create do
    try
      Init(blowfishscramblekey);
      mqttpasswordscrambled := EncodeBinary(mqtt.Password, TFormat_Copy);
    finally
      Free;
    end;
    LReg.WriteBinaryData('MQTT Password',mqttpasswordscrambled,sizeof(mqttpasswordscrambled));

    with TCipher_Blowfish.Create do
    try
      Init(blowfishscramblekey);
      autolockcodescrambled := EncodeBinary(autolockcode, TFormat_Copy);
    finally
      Free;
    end;
    LReg.WriteBinaryData('Autolockcode',autolockcodescrambled,sizeof(autolockcodescrambled));

    LReg.CloseKey;
  end;
  LReg.Free;
end;

procedure Tmainform.WriteConfiguration;
var
  LReg:TPCDRegistry;
  i:integer;
begin
  LReg := TPCDRegistry.Create;
  if LReg.OpenRegKey('') then
  begin
    LReg.WriteString('Openhistory1',data.openhistory[0]);
    LReg.WriteString('Openhistory2',data.openhistory[1]);
    LReg.WriteString('Openhistory3',data.openhistory[2]);
    LReg.WriteString('Openhistory4',data.openhistory[3]);
    LReg.WriteString('Openhistory5',data.openhistory[4]);
    LReg.CloseKey;

    // Speichere verwendete Plugins
    for i:=0 to length(OutputPlugins)-1 do
    begin
      if LReg.OpenRegKey(OutputPlugins[i].Filename) then
      begin
        LReg.WriteBool('Plugin Enabled', OutputPlugins[i].IsEnabled);
        LReg.WriteBool('Plugin Blacklisted', OutputPlugins[i].IsBlacklisted);
        LReg.WriteInteger('Plugin Startaddress', OutputPlugins[i].Startaddress);
        LReg.WriteInteger('Plugin Stopaddress', OutputPlugins[i].Stopaddress);
        LReg.CloseKey;
      end;
    end;
  end;
  LReg.Free;
end;

procedure Tmainform.ReadConfiguration;
var
  i:integer;
  LReg:TPCDRegistry;
begin
  // Konfiguration aus Registry lesen
  LReg := TPCDRegistry.Create;
  if LReg.OpenRegKey('') then
  begin
    if LReg.ValueExists('Openhistory1') then
      data.openhistory[0]:=LReg.ReadString('Openhistory1');
    if LReg.ValueExists('Openhistory2') then
      data.openhistory[1]:=LReg.ReadString('Openhistory2');
    if LReg.ValueExists('Openhistory3') then
      data.openhistory[2]:=LReg.ReadString('Openhistory3');
    if LReg.ValueExists('Openhistory4') then
      data.openhistory[3]:=LReg.ReadString('Openhistory4');
    if LReg.ValueExists('Openhistory5') then
      data.openhistory[4]:=LReg.ReadString('Openhistory5');

    LReg.CloseKey;
  end;
  LReg.Free;

  for i:=0 to length(OutputPlugins)-1 do
  begin
    if (OutputPlugins[i].Startaddress=0) and (OutputPlugins[i].Stopaddress=0) then
    begin
      OutputPlugins[i].Startaddress:=1;
      OutputPlugins[i].Stopaddress:=512;
    end;
  end;
end;

procedure TMainform.TBItem54Click(Sender: TObject);
begin
  firststepsform.Show;
  firststepsform.BringToFront;
end;

procedure TMainform.TBItem56Click(Sender: TObject);
begin
  if not UserAccessGranted(1) then exit;

  winlircform.show;
end;

procedure TMainform.MediaCenterSocketRead(Sender: TObject;
  Socket: TCustomWinSocket);
var
  MediaCenterCommand:TMediaCenterCommand;
  tempvar:integer;
begin
  Socket.ReceiveBuf(MediaCenterCommand, sizeof(MediaCenterCommand));

  case MediaCenterCommand.Befehl of
    8:
    begin
      if mediacenterform.Showing then
      begin
        mediacenterform.videopositionlabel.caption:=mainform.MillisecondsToTime(MediaCenterCommand.Data1);
        mediacenterform.videolengthlabel.Caption:=mainform.MillisecondsToTime(MediaCenterCommand.Data2);
      end;
    end;
    9:
    begin
      if mediacenterform.Showing then
      begin
        tempvar:=MediaCenterCommand.Data2;
        while mediacenterform.videoindeviceslistbox.Items.Count<tempvar do
        begin
          mediacenterform.videoindeviceslistbox.Items.Add('');
        end;
        tempvar:=MediaCenterCommand.Data2;
        while mediacenterform.videoindeviceslistbox.Items.Count>tempvar do
        begin
          mediacenterform.videoindeviceslistbox.Items.Delete(mediacenterform.videoindeviceslistbox.Items.Count-1);
        end;
        mediacenterform.videoindeviceslistbox.Items[MediaCenterCommand.Data1]:=inttostr(MediaCenterCommand.Data1)+': '+MediaCenterCommand.Text;
      end;
    end;
  end;
end;

procedure TMainform.MediaCenterSocketError(Sender: TObject;
  Socket: TCustomWinSocket; ErrorEvent: TErrorEvent;
  var ErrorCode: Integer);
begin
  ShowMessage(_('MediaCenter Verbindung:')+#13#10+#13#10+SysErrorMessage(errorcode));
  ErrorCode:=0;
end;

procedure TMainform.commandeditoldEnter(Sender: TObject);
begin
  if commandedit.text=_('Kommando hier eingeben...') then
  begin
    commandedit.Text:='';
//    commandedit.Font.Color:=clBlack;
  end;
end;

procedure TMainform.commandeditoldExit(Sender: TObject);
begin
  if commandedit.Text='' then
  begin
    commandedit.Text:=_('Kommando hier eingeben...');
//    commandedit.Font.Color:=clGray;
  end;
end;

procedure TMainform.commandeditoldKeyUp(Sender: TObject; var Key: Word;
  Shift: TShiftState);
var
  temp:string;
  first, last, value, i, dimmtime:integer;
  changevalue:boolean;
  ispercent:boolean;
begin
  if not UserAccessGranted(2) then exit;

  if Key=vk_return then
  begin
    if commandedit.text=_('Kommando hier eingeben...') then
    begin
      commandedit.Text:='';
      commandedit.Font.Color:=clBlack;
    end;

    if (commandedit.text='?') or (lowercase(commandedit.text)='hilfe') or (lowercase(commandedit.text)='help') then
    begin
      ShowMessage('+'+#9+'Wertzuweisung (schaltend)'+#10#13+
                  '*'+#9+'Wertzuweisung (dimmend)'+#10#13+
                  '-'+#9+'THRU'+#10#13+#10#13+
                  'Beispieleingabe 1: "1-8+255" = Kanäle 1 bis 8 auf 100%'+#10#13+
                  'Beispieleingabe 2: "10*127" = Kanal 10 auf 50% dimmen'+#10#13+
                  'Beispieleingabe 3: "*255" oder "+255" = Dimmen oder Schalten der letzten gewählten Kanäle auf 100%'+#10#13+
                  ''+#10#13+
                  'Das Postfix "/" gibt Werte als Prozenz an: z.B. "1-8+100/"'
                  );
      commandedit.text:=_('Kommando hier eingeben...');
      commandedit.Text:='';
      commandedit.Font.Color:=clBlack;
      exit;
    end;

    value:=0;
    changevalue:=false;

    // Kommando Stück für Stück auswerten
    temp:=uppercase(commandedit.Text);

    try
      if length(temp)>0 then
      begin
        ispercent:=pos('%',temp)>0;
        temp:=StringReplace(temp, '%', '', [rfReplaceAll, rfIgnoreCase	]);

        while (temp[1]=' ') do
        begin
          temp:=Copy(temp, 2, length(temp));
        end;

        if pos('DIMM',temp)>0 then
        begin
          temp:=stringreplace(temp, 'DIMM', '@', [rfReplaceAll, rfIgnoreCase]);
          dimmtime:=3000;
        end else
        begin
          dimmtime:=0;
        end;

        if pos('THRU',temp)>0 then            //1 Thru 5 @ 255
        begin
          for i:=1 to chan do commandline_changechannel[i]:=false;
          try
            first:=strtoint(copy(temp,0,pos(' ',temp)-1));

            if pos('@',temp)>0 then
            begin
              last:=strtoint(copy(temp,pos('THRU',temp)+5,pos('@',temp)-1-(pos('THRU',temp)+5)));
              value:=strtoint(copy(temp,pos('@',temp)+2,length(temp)));
              changevalue:=true;
            end else
            begin
              // nur Kanäle auswählen
              last:=strtoint(copy(temp,pos('THRU',temp)+5,length(temp)));
            end;

            for i:=first to last do commandline_changechannel[i]:=true;
          except
            value:=0;
            changevalue:=false;
          end;

          temp:='';
        end;

        if pos('@',temp)=1 then
        begin
          value:=strtoint(copy(temp,2,length(temp)));
          changevalue:=true;
          temp:='';
        end;

        if pos('@',temp)>0 then
        begin
          for i:=1 to chan do commandline_changechannel[i]:=false;
          commandline_changechannel[strtoint(copy(temp,0,pos(' ',temp)-1))]:=true;
          value:=strtoint(copy(temp,pos('@',temp)+2,length(temp)));
          changevalue:=true;
          temp:='';
        end;

        if ispercent then
        begin
          value:=round(value*2.55);
        end;

        if changevalue then
        for i:=1 to mainform.lastchan do
        begin
          if commandline_changechannel[i] then
          begin
            Senddata(i, 255-mainform.channel_value[i], 255-value, dimmtime);
          end;
        end;
      end;
    except
      temp:='';
    end;
    commandedit.text:='';
  end;

  if length(commandedit.Text)>0 then
  begin
    if (commandedit.Text[length(commandedit.Text)]='-')and (pos('THRU',commandedit.Text)=0)  then
    begin
      commandedit.Text:=Copy(commandedit.Text, 0, length(commandedit.Text)-1);
      commandedit.Text:=commandedit.Text+' THRU ';
      commandedit.SelStart:=length(commandedit.Text);
    end;

    if (commandedit.Text[length(commandedit.Text)]='+') and (pos('@',commandedit.Text)=0) then
    begin
      commandedit.Text:=Copy(commandedit.Text, 0, length(commandedit.Text)-1);
      commandedit.Text:=commandedit.Text+' @ ';
      commandedit.SelStart:=length(commandedit.Text);
    end;

    if (commandedit.Text[length(commandedit.Text)]='/') then
    begin
      commandedit.Text:=StringReplace(commandedit.Text, '/', '%', [rfReplaceAll	, rfIgnoreCase	]);
    end;

    if (commandedit.Text[length(commandedit.Text)]='*') and (pos('DIMM',commandedit.Text)=0) then
    begin
      commandedit.Text:=Copy(commandedit.Text, 0, length(commandedit.Text)-1);
      commandedit.Text:=commandedit.Text+' DIMM ';
      commandedit.SelStart:=length(commandedit.Text);
    end;
  end;
end;

procedure TMainform.TBItem57Click(Sender: TObject);
var
  LReg:TPCDRegistry;
begin
  if sidebarform.Visible=true then
  begin
    sidebarform.Visible:=false;
    SidebarRibbonBtn.Down:=false;
  end
  else
  begin
    sidebarform.Visible:=true;
    SidebarRibbonBtn.Down:=true;
  end;

  LReg := TPCDRegistry.Create;
  LReg.WriteBoolEx('', 'Sidebar visible', Sidebarform.Showing);
  LReg.Free;
end;

procedure TMainform.TBItem59Click(Sender: TObject);
var
  LReg:TPCDRegistry;
begin
  if not UserAccessGranted(1) then exit;

  if MCTRibbonBox.Down then
  begin
    MediaCenterTimeCodeSocket.LocalPort:=mediacenterport;
    MediaCenterTimeCodeSocket.RemotePort:=mediacenterport;
    MediaCenterTimecodeSocket.Open;
  end else
  begin
    MediaCenterTimecodeSocket.Close;
  end;

  LReg := TPCDRegistry.Create;
  LReg.WriteBoolEx('', 'MediaCenter Timercodeserver active', MCTRibbonBox.Down);
  LReg.Free;
end;

procedure TMainform.TBItem60Click(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  joystickform.CheckBox1.Checked:=ActiveJoystickRibbonBox.Down;
  joystickform.JoystickTimer.Enabled:=ActiveJoystickRibbonBox.Down;
  enablejoystick:=ActiveJoystickRibbonBox.Down;
end;

procedure TMainform.TBItem61Click(Sender: TObject);
var
  LReg:TPCDRegistry;
begin
  if leistungssteuerungform2.Visible=true then
  begin
    leistungssteuerungform2.Visible:=false;
    LeistungssteuerungRibbonBtn.Down:=false;
  end
  else
  begin
    leistungssteuerungform2.Visible:=true;
    LeistungssteuerungRibbonBtn.Down:=true;
  end;

  LReg := TPCDRegistry.Create;
  LReg.WriteBoolEx('', 'Powercontrol visible', leistungssteuerungform2.Showing);
  LReg.Free;
end;

procedure TMainform.TBItem63Click(Sender: TObject);
begin
  if not UserAccessGranted(1) then exit;

  RetranslateProgram('de');
  SendMSG(MSG_SETLANGUAGE, integer(3), 0);
end;

procedure TMainform.TBItem62Click(Sender: TObject);
begin
  if not UserAccessGranted(1) then exit;

  RetranslateProgram('en');
  SendMSG(MSG_SETLANGUAGE, integer(0), 0);
end;

procedure TMainform.TBItem70Click(Sender: TObject);
begin
  if not UserAccessGranted(1) then exit;

  RetranslateProgram('fr');
  SendMSG(MSG_SETLANGUAGE, integer(1), 0);
end;

procedure TMainform.TBItem64Click(Sender: TObject);
var
  name, code:PChar;
begin
  if not UserAccessGranted(2) then exit;

  // WORKAROUND FOR MEVP
  if fileexists(mevp.MEVPDLLPath) then
  begin
    SetCurrentDir(ExtractFilePath(mevp.MEVPDLLPath));

    if MEVPDLL=0 then
    begin
      MEVPDLL:=LoadLibrary(PChar(mevp.MEVPDLLPath));

      DasMevAreFixturesModified:=GetProcAddress(MEVPDLL,'DasMevAreFixturesModified');
      DasMevClose:=GetProcAddress(MEVPDLL,'DasMevClose');
      DasMevCommand:=GetProcAddress(MEVPDLL,'DasMevCommand');
      DasMevGetFixtureParam:=GetProcAddress(MEVPDLL,'DasMevGetFixtureParam');
      DasMevGetFixturesCount:=GetProcAddress(MEVPDLL,'DasMevGetFixturesCount');
      DasMevGetLanguage:=GetProcAddress(MEVPDLL,'DasMevGetLanguage');
      DasMevGetSupportedDeviceTypes:=GetProcAddress(MEVPDLL,'DasMevGetSupportedDeviceTypes');
      DasMevGetVersion:=GetProcAddress(MEVPDLL,'DasMevGetVersion');
      DasMevIsOpened:=GetProcAddress(MEVPDLL,'DasMevIsOpened');
      DasMevIsUsingDasHard:=GetProcAddress(MEVPDLL,'DasMevIsUsingDasHard');
      DasMevSetLanguage:=GetProcAddress(MEVPDLL,'DasMevSetLanguage');
      DasMevSetSupportedDeviceTypes:=GetProcAddress(MEVPDLL,'DasMevSetSupportedDeviceTypes');
      DasMevStart:=GetProcAddress(MEVPDLL,'DasMevStart');
      DasMevWriteDmx:=GetProcAddress(MEVPDLL,'DasMevWriteDmx');
    end;
    // 3D Visualizer starten
    if Assigned(DasMevStart) then
    begin
      name:=PChar('PC_DIMMER');
      code:=PCHar('');
      DasMevStart(name, code);
    end;

    // Sprache des 3D-Visualizers setzen
    if (MEVPDLL<>0) and Assigned(DasMevSetLanguage) then
    begin
      if (gnugettext.GetCurrentLanguage='en') then
      begin
        DasMevSetLanguage(0);
      end else if (gnugettext.GetCurrentLanguage='de') then
      begin
        DasMevSetLanguage(3);
      end;
    end;
  end else
  begin
    ShowMessage(_('Der 3D Visualizer wurde nicht gefunden. Bitte kontrollieren Sie die Pfadangabe in den erweiterten Einstellungen...'));
  end;
  // END OF WORKAROUND FOR MEVP
{
  // NEW CODE FOR MEVP
  mevp.Start;
  if mevp.Running then
  begin
    EasyViewRibbonBtn.ButtonStyle := bsDropDown;
  end else
  begin
    ShowMessage(_('Der 3D Visualizer wurde nicht gefunden. Bitte kontrollieren Sie die Pfadangabe in den erweiterten Einstellungen...'));
  end;
  // END OF NEW CODE FOR MEVP
}
end;

procedure TMainform.StopVisualizerClick(Sender: TObject);
begin
  mevp.Stop;
  EasyViewRibbonBtn.ButtonStyle := bsDefault;
end;

procedure Tmainform.CreateValueBackup;
var
  i:integer;
begin
  FileStream:=TFileStream.Create(userdirectory+'~LastSession.val',fmCreate);

  FileStream.WriteBuffer(lastchan,sizeof(lastchan));
  for i:=1 to lastchan do
    FileStream.WriteBuffer(channel_value[i],sizeof(channel_value[i]));

  FileStream.Free;

  if FileExists(userdirectory+'LastSession.val') then
    DeleteFile(userdirectory+'LastSession.val');
  MoveFile(PCHar(userdirectory+'~LastSession.val'),PChar(userdirectory+'LastSession.val'));
end;

procedure Tmainform.RestoreValueBackup;
var
  i,last:integer;
  values:array[1..chan] of byte;
begin
  if FileExists(userdirectory+'LastSession.val') then
  begin
    CopyFile(PCHar(userdirectory+'LastSession.val'), PChar(userdirectory+'LastSessionR.val'), false);

    FileStream:=TFileStream.Create(userdirectory+'LastSessionR.val',fmOpenRead);

    FileStream.ReadBuffer(last,sizeof(last));
    for i:=1 to last do
    begin
      if last<=chan then
        FileStream.ReadBuffer(values[i],sizeof(values[i]));
    end;
    FileStream.Free;

    if FileExists(userdirectory+'LastSessionR.val') then
      DeleteFile(userdirectory+'LastSessionR.val');

    for i:=1 to lastchan do
    begin
      Senddata(i, -1, maxres-values[i], 0);
    end;
  end;
end;

procedure TMainform.TBItem17Click(Sender: TObject);
begin
  if not UserAccessGranted(3) then exit;

  if autolockcode='' then
    lockedform.itsmylife:=inputbox(_('Kennwort festlegen'), _('In den erweiterten Optionen ist kein Standardkennwort hinterlegt. Geben Sie daher bitte ein Kennwort für die aktuelle Sperrung ein:'),'')
  else
    lockedform.itsmylife:=autolockcode;
  lockedform.showmodal;
end;

procedure TMainform.TBItem66Click(Sender: TObject);
var
  i,j:integer;
  CSV,Values:TStrings;
  myaddress:byte;
  myaddress_string:string;
begin
  SaveDialog.InitialDir:=JvComputerInfoEx1.Folders.Desktop;
  SaveDialog.DefaultExt:='*.csv';
  SaveDialog.Filter:=_('CSV-Datei (*.csv)|*.csv|*.*|*.*');
  SaveDialog.Title:=_('Gerätedaten exportieren');

  if SaveDialog.Execute then
  begin
    CSV:=TStringList.Create;
    Values:=TStringList.Create;

    // HEADER
    Values.Add(_('Gerätename'));
    Values.Add(_('Hersteller'));
    Values.Add(_('Startadresse'));
    Values.Add(_('Kanalanzahl'));
    Values.Add(_('Leistung [W]'));
    Values.Add(_('Phase'));

    Values.Add(_('Dimmer'));
    Values.Add(_('Shutter'));
    Values.Add(_('V-Dimmer'));
    Values.Add(_('RGB'));
    Values.Add(_('CMY'));
    Values.Add(_('Amber'));
    Values.Add(_('Weiß'));
    Values.Add(_('UV'));
    Values.Add(_('Nebel'));
    Values.Add(_('Pan/Tilt'));
    Values.Add(_('Farbrad'));
    Values.Add(_('Farbrad 2'));
    Values.Add(_('Goborad'));
    Values.Add(_('Goborad 2'));
    Values.Add(_('Autoscening'));
    Values.Add(_('DIP-Startadresse'));
    CSV.Add(MakeCSVLine(Values, ',', '"'));
    Values.Clear;

    setlength(devicelistform.DeviceOrder, length(mainform.devices));
    for i:=0 to length(mainform.devices)-1 do
    begin
      devicelistform.DeviceOrder[i].Startaddress:=mainform.devices[i].Startaddress;
      devicelistform.DeviceOrder[i].PositionInDeviceArray:=i;
    end;
    if length(devicelistform.DeviceOrder)>1 then
      devicelistform.SortDeviceOrder(Low(devicelistform.DeviceOrder),High(devicelistform.DeviceOrder));

    for j:=0 to length(devices)-1 do
    begin
      i:=devicelistform.DeviceOrder[j].PositionInDeviceArray;

      Values.Add(devices[i].Name);
      Values.Add(devices[i].Vendor);
      Values.Add(inttostr(devices[i].Startaddress));
      Values.Add(inttostr(devices[i].MaxChan));
      Values.Add(inttostr(devices[i].Power));
      Values.Add(inttostr(devices[i].Phase));

      if devices[i].hasDimmer then Values.Add('X') else Values.Add('');
      if devices[i].hasShutter then Values.Add('X') else Values.Add('');
      if devices[i].hasVirtualRGBAWDimmer then Values.Add('X') else Values.Add('');
      if devices[i].hasRGB then Values.Add('X') else Values.Add('');
      if devices[i].hasCMY then Values.Add('X') else Values.Add('');
      if devices[i].hasAmber then Values.Add('X') else Values.Add('');
      if devices[i].hasWhite then Values.Add('X') else Values.Add('');
      if devices[i].hasUV then Values.Add('X') else Values.Add('');
      if devices[i].hasFog then Values.Add('X') else Values.Add('');
      if devices[i].hasPANTILT then Values.Add('X') else Values.Add('');
      if devices[i].hasColor then Values.Add('X') else Values.Add('');
      if devices[i].hasColor2 then Values.Add('X') else Values.Add('');
      if devices[i].hasGobo then Values.Add('X') else Values.Add('');
      if devices[i].hasGobo2 then Values.Add('X') else Values.Add('');
      if devices[i].autoscening then Values.Add('X') else Values.Add('');
      // Kanaladresse als BITs
      myaddress:=devices[i].Startaddress;
      myaddress_string:='';
      if BitSet(myaddress, 1) then myaddress_string:=myaddress_string+'X' else myaddress_string:=myaddress_string+'o';
      if BitSet(myaddress, 2) then myaddress_string:=myaddress_string+'X' else myaddress_string:=myaddress_string+'o';
      if BitSet(myaddress, 4) then myaddress_string:=myaddress_string+'X' else myaddress_string:=myaddress_string+'o';
      if BitSet(myaddress, 8) then myaddress_string:=myaddress_string+'X' else myaddress_string:=myaddress_string+'o';
      if BitSet(myaddress, 16) then myaddress_string:=myaddress_string+'X' else myaddress_string:=myaddress_string+'o';
      if BitSet(myaddress, 32) then myaddress_string:=myaddress_string+'X' else myaddress_string:=myaddress_string+'o';
      if BitSet(myaddress, 64) then myaddress_string:=myaddress_string+'X' else myaddress_string:=myaddress_string+'o';
      if BitSet(myaddress, 128) then myaddress_string:=myaddress_string+'X' else myaddress_string:=myaddress_string+'o';
      myaddress:=devices[i].Startaddress shr 8;
      if BitSet(myaddress, 1) then myaddress_string:=myaddress_string+'X' else myaddress_string:=myaddress_string+'o';
      if BitSet(myaddress, 2) then myaddress_string:=myaddress_string+'X' else myaddress_string:=myaddress_string+'o';
      Values.Add(myaddress_string);

      CSV.Add(MakeCSVLine(Values, ',', '"'));
      Values.Clear;
    end;

    CSV.SaveToFile(SaveDialog.FileName);
    CSV.Free;
    Values.Free;
  end;
end;

procedure TMainform.TBItem67Click(Sender: TObject);
begin
  devicelistform.show;
end;

procedure TMainform.CommandservericonClick(Sender: TObject);
var
  LReg:TPCDRegistry;
begin
  if not UserAccessGranted(1) then exit;

  if not FHTTPServer.Active then
  begin
    HTTPServerActivateRibbonBox.Down:=true;
    FHTTPServer.Active:=true;
  end;

  Commandserver.DefaultPort:=terminalport;
  Commandserver.Active:=ActivateCommandReceiverRibbonBox.Down;

  LReg := TPCDRegistry.Create;
  LReg.WriteBoolEx('', 'Terminalserver active',ActivateCommandReceiverRibbonBox.Down);
  LReg.Free;
end;

procedure TMainform.CommandServerException(AContext: TIdContext;
  AException: Exception);
begin
  DebugAdd('ERROR: CommandServer "'+AContext.Connection.Socket.Host+' ('+AContext.Connection.Socket.BoundIP+')" raised an error: '+AException.Message);
end;

procedure TMainform.CommandServerExecute(AContext: TIdContext);
var
  cmd,cmdtemp,temp,deviceid:string;
  i,j,devpos,buttonx,buttony,minchan, maxchan:integer;
  r,g,b:byte;
  DEVGUID:TGUID;
  value:array[0..2] of string;
begin
  cmd:=AContext.Connection.Socket.ReadLn;
  AContext.Connection.Socket.WriteLn(cmd);

//  debuglistbox.ItemIndex:=debuglistbox.Items.Add('['+inttostr(debuglistbox.Items.Count)+'] ['+Timetostr(now)+'] ['+Datetostr(now)+'] INFO: CommandServer received: "'+cmd+'"');

  if cmd<>'' then
  begin
    if pos('unit',cmd)>0 then
    begin
      ScriptInterpreter.Pas.Clear;
      ScriptInterpreter.Pas.Text:=cmd;
      ScriptInterpreter.Compile;
      ScriptInterpreter.CallFunction('RunCommand',nil,[]);
//      ScriptInterpreter.Run;
      AContext.Connection.Socket.WriteLn('Done');
    end else if pos('get_devices',cmd)>0 then
    begin
      temp:='devices '+inttostr(length(devices));
      for i:=0 to length(devices)-1 do
        temp:=temp+' '+inttostr(i+1)+':'+FilterTextForNetwork(devices[i].Name)+','+guidtostring(devices[i].ID);
      AContext.Connection.Socket.WriteLn(temp);
    end else if pos('get_groups',cmd)>0 then
    begin
      temp:='groups '+inttostr(length(devicegroups));
      for i:=0 to length(devicegroups)-1 do
        temp:=temp+' '+inttostr(i+1)+':'+FilterTextForNetwork(devicegroups[i].Name)+','+guidtostring(devicegroups[i].ID);
      AContext.Connection.Socket.WriteLn(temp);
    end else if pos('get_deviceinfo',cmd)>0 then
    begin
      deviceid:=copy(cmd, Pos('{', cmd), length(cmd));

      temp:='deviceinfo ';
      DEVGUID:=StringToGUID(deviceid);
      devpos:=geraetesteuerung.GetDevicePositionInDeviceArray(@DEVGUID);

      Tcolor2rgb(devices[devpos].color, r,g,b);

      // Antwort zusammenstellen:
      // NAME,STARTADRESSE,FARBFILTERFARBE,KANALZAHL,1:KANALTYP1,2:KANALTYP2, ...
      temp:=temp+' name:'+
      FilterTextForNetwork(devices[devpos].Name)+', address:'+
      inttostr(devices[devpos].Startaddress)+', r:'+
      inttostr(r)+', g:'+inttostr(g)+', b:'+inttostr(b)+', chancount:'+
      inttostr(length(devices[devpos].kanaltyp));
      for i:=0 to length(devices[devpos].kanaltyp)-1 do
        temp:=temp+', ch'+inttostr(i+1)+':'+devices[devpos].kanaltyp[i];
      AContext.Connection.Socket.WriteLn(temp);
    end else if pos('get_deviceinfo2',cmd)>0 then
    begin
      deviceid:=copy(cmd, Pos('{', cmd), length(cmd));

      temp:='deviceinfo2 ';
      DEVGUID:=StringToGUID(deviceid);
      devpos:=geraetesteuerung.GetDevicePositionInDeviceArray(@DEVGUID);

      Tcolor2rgb(devices[devpos].color, r,g,b);

      // Antwort zusammenstellen:
      // NAME,STARTADRESSE,FARBFILTERFARBE,KANALZAHL,1:KANALTYP1,2:KANALTYP2, ..., PICTURE:
      temp:=temp+' name:'+
      FilterTextForNetwork(devices[devpos].Name)+', address:'+
      inttostr(devices[devpos].Startaddress)+', r:'+
      inttostr(r)+', g:'+inttostr(g)+', b:'+inttostr(b)+', chancount:'+
      inttostr(length(devices[devpos].kanaltyp));
      for i:=0 to length(devices[devpos].kanaltyp)-1 do
        temp:=temp+', ch'+inttostr(i+1)+':'+devices[devpos].kanaltyp[i];
      temp:=temp+', picture:'+devices[devpos].Bildadresse;
      AContext.Connection.Socket.WriteLn(temp);
    end else if pos('get_controlpanel',cmd)>0 then
    begin
      cmd:=copy(cmd, Pos('get_controlpanel', cmd)+17, length(cmd));

      if length(cmd)=0 then
      begin
        temp:='countX:'+inttostr(length(kontrollpanelbuttons[0]))+','+
          temp+'countY:'+inttostr(length(kontrollpanelbuttons));
      end else
      begin
        buttonx:=strtoint(copy(cmd, 0, Pos(' ', cmd)-1));
        buttony:=strtoint(copy(cmd, Pos(' ', cmd)+1, length(cmd)));

        if (buttonx=0) and (buttony=0) then
        begin
          // Antwort zusammenstellen:
          // BUTTON 1x1, NAME, R, G, B, TYP, ID, BUTTON 1x2, NAME....
          for i:=0 to length(kontrollpanelbuttons)-1 do
          begin
            for j:=0 to length(kontrollpanelbuttons[0])-1 do
            begin
              Tcolor2rgb(kontrollpanelbuttons[i][j].Color, r,g,b);
              if temp='' then
                temp:='button: '+inttostr(i+1)+'x'+inttostr(j+1)+', name:'+FilterTextForNetwork(kontrollpanelbuttons[i][j].Name)+', r:'+inttostr(r)+', g:'+inttostr(g)+', b:'+inttostr(b)+', type:'+FilterTextForNetwork(kontrollpanelbuttons[i][j].TypName)+', id:'+guidtostring(kontrollpanelbuttons[i][j].ID)
              else
                temp:=temp+', button: '+inttostr(i+1)+'x'+inttostr(j+1)+', name:'+FilterTextForNetwork(kontrollpanelbuttons[i][j].Name)+', r:'+inttostr(r)+', g:'+inttostr(g)+', b:'+inttostr(b)+', type:'+FilterTextForNetwork(kontrollpanelbuttons[i][j].TypName)+', id:'+guidtostring(kontrollpanelbuttons[i][j].ID);
            end;
          end;
        end else
        begin
          // Antwort zusammenstellen:
          // BUTTON 1x1, NAME, R, G, B, TYP, ID
          j:=buttonx-1;
          i:=buttony-1;
          if (i>=0) and (j>=0) and (i<length(kontrollpanelbuttons)) and (j<length(kontrollpanelbuttons[i])) then
          begin
            Tcolor2rgb(kontrollpanelbuttons[i][j].Color, r,g,b);
            temp:='button: '+inttostr(i+1)+'x'+inttostr(j+1)+', name:'+FilterTextForNetwork(kontrollpanelbuttons[i][j].Name)+', r:'+inttostr(r)+', g:'+inttostr(g)+', b:'+inttostr(b)+', type:'+FilterTextForNetwork(kontrollpanelbuttons[i][j].TypName)+', id:'+guidtostring(kontrollpanelbuttons[i][j].ID);
          end;
        end;
      end;
      AContext.Connection.Socket.WriteLn(temp);
    end else if (pos('get_channel',cmd)>0) or (pos('get_ch',cmd)>0) or (pos('GetChannel',cmd)>0) or (pos('GC',cmd)>0) then
    begin
      temp:=cmd;
      temp:=copy(temp, pos(' ',temp)+1, length(temp));

      i:=strtoint(temp);

      if i=0 then
      begin
        // Alle Kanäle senden
        temp:='CVS ';
        for i:=1 to 511 do
          temp:=temp+inttostr(i)+':'+inttostr(channel_value[i])+',';
        temp:=temp+'512:'+inttostr(channel_value[512]);
      end else
      begin
        // Einzelnen Kanal senden
        temp:='CV '+inttostr(i)+' '+inttostr(channel_value[i]);
      end;
      AContext.Connection.Socket.WriteLn(temp);
    end else if pos('get_range',cmd)>0 then
    begin
      temp:=cmd; // get_range 16 32
      temp:=copy(temp, pos(' ',temp)+1, length(temp)); // 16 32

      minchan:=strtoint(copy(temp, 0, pos(' ',temp)-1));
      maxchan:=strtoint(copy(temp, pos(' ',temp)+1, length(temp))); // 32

      // Kanalabschnitt senden
      temp:='CVS ';
      for i:=minchan to maxchan-1 do
        temp:=temp+inttostr(i)+':'+inttostr(channel_value[i])+',';
      temp:=temp+inttostr(maxchan)+':'+inttostr(channel_value[maxchan]);
      AContext.Connection.Socket.WriteLn(temp);
    end else if (pos('get_devchannel',cmd)>0) then // get_devchannel GUID DIMMER -1 255 5000 0
    begin
      temp:=cmd;
      temp:=copy(temp, pos(' ',temp)+1, length(temp));

      value[0]:=copy(temp, 0, pos(' ',temp)-1);
      temp:=copy(temp, pos(' ',temp)+1, length(temp));

      // Leerzeichen entfernen, sofern vorhanden
      if pos(' ', temp)>0 then
        temp:=copy(temp, 0, pos(' ', temp)-1);
      value[1]:=temp;

      temp:='DCV '+inttostr(geraetesteuerung.get_channel(stringtoguid(value[0]), value[1]));
      AContext.Connection.Socket.WriteLn(temp);
    end else if (pos('get_dimmer',cmd)>0) then // get_dimmer GUID
    begin
      temp:=cmd;
      temp:=copy(temp, pos(' ',temp)+1, length(temp));

      // Leerzeichen entfernen, sofern vorhanden
      if pos(' ', temp)>0 then
        temp:=copy(temp, 0, pos(' ', temp)-1);
      value[0]:=temp;

      temp:='DDV '+inttostr(geraetesteuerung.get_dimmer(stringtoguid(value[0])));
      AContext.Connection.Socket.WriteLn(temp);
    end else if (pos('get_strobe',cmd)>0) then // get_strobe GUID
    begin
      temp:=cmd;
      temp:=copy(temp, pos(' ',temp)+1, length(temp));

      // Leerzeichen entfernen, sofern vorhanden
      if pos(' ', temp)>0 then
        temp:=copy(temp, 0, pos(' ', temp)-1);
      value[0]:=temp;

      temp:='DSV '+inttostr(geraetesteuerung.get_strobe(stringtoguid(value[0])));
      AContext.Connection.Socket.WriteLn(temp);
    end else if (pos('get_shutter',cmd)>0) then // get_shutter GUID
    begin
      temp:=cmd;
      temp:=copy(temp, pos(' ',temp)+1, length(temp));

      // Leerzeichen entfernen, sofern vorhanden
      if pos(' ', temp)>0 then
        temp:=copy(temp, 0, pos(' ', temp)-1);
      value[0]:=temp;

      temp:='DShV '+inttostr(geraetesteuerung.get_shutter(stringtoguid(value[0])));
      AContext.Connection.Socket.WriteLn(temp);
    end else if (pos('get_scenes',cmd)>0) then // get_scenes NUMMER
    begin
      temp:=cmd;
      temp:=copy(temp, pos(' ',temp)+1, length(temp));

      // Leerzeichen entfernen, sofern vorhanden
      if pos(' ', temp)>0 then
        temp:=copy(temp, 0, pos(' ', temp)-1);
      value[0]:=temp;

      temp:='scenes ';
      case strtoint(value[0]) of
        0: // Einfache Szenen
        begin
          temp:=temp+inttostr(length(EinfacheSzenen));
          for i:=0 to length(EinfacheSzenen)-1 do
          begin
            temp:=temp+' '+inttostr(i+1)+':'+FilterTextForNetwork(EinfacheSzenen[i].Name)+','+GUIDtoString(EinfacheSzenen[i].ID);
          end;
        end;
        1: // Geräteszenen
        begin
          temp:=temp+inttostr(length(DeviceScenes));
          for i:=0 to length(DeviceScenes)-1 do
          begin
            temp:=temp+' '+inttostr(i+1)+':'+FilterTextForNetwork(DeviceScenes[i].Name)+','+GUIDtoString(DeviceScenes[i].ID);
          end;
        end;
        2: // Audioszenen
        begin
          temp:=temp+inttostr(length(AudioSzenen));
          for i:=0 to length(AudioSzenen)-1 do
          begin
            temp:=temp+' '+inttostr(i+1)+':'+FilterTextForNetwork(AudioSzenen[i].Name)+','+GUIDtoString(AudioSzenen[i].ID);
          end;
        end;
        3: // Bewegungsszenen
        begin
          temp:=temp+inttostr(length(BewegungsSzenen));
          for i:=0 to length(BewegungsSzenen)-1 do
          begin
            temp:=temp+' '+inttostr(i+1)+':'+FilterTextForNetwork(BewegungsSzenen[i].Name)+','+GUIDtoString(BewegungsSzenen[i].ID);
          end;
        end;
        4: // Befehle
        begin
          temp:=temp+inttostr(length(Befehle2));
          for i:=0 to length(Befehle2)-1 do
          begin
            temp:=temp+' '+inttostr(i+1)+':'+FilterTextForNetwork(Befehle2[i].Name)+','+GUIDtoString(Befehle2[i].ID);
          end;
        end;
        5: // Kombinationsszenen
        begin
          temp:=temp+inttostr(length(Kompositionsszenen));
          for i:=0 to length(Kompositionsszenen)-1 do
          begin
            temp:=temp+' '+inttostr(i+1)+':'+FilterTextForNetwork(Kompositionsszenen[i].Name)+','+GUIDtoString(Kompositionsszenen[i].ID);
          end;
        end;
        6: // Presets
        begin
          temp:=temp+inttostr(length(DevicePresets));
          for i:=0 to length(DevicePresets)-1 do
          begin
            temp:=temp+' '+inttostr(i+1)+':'+FilterTextForNetwork(DevicePresets[i].Name)+','+GUIDtoString(DevicePresets[i].ID);
          end;
        end;
        7: // Automatikszenen
        begin
          temp:=temp+inttostr(length(Autoszenen));
          for i:=0 to length(Autoszenen)-1 do
          begin
            temp:=temp+' '+inttostr(i+1)+':'+FilterTextForNetwork(Autoszenen[i].Name)+','+GUIDtoString(Autoszenen[i].ID);
          end;
        end;
        8: // Effekte
        begin
          temp:=temp+inttostr(length(Effektsequenzereffekte));
          for i:=0 to length(Effektsequenzereffekte)-1 do
          begin
            temp:=temp+' '+inttostr(i+1)+':'+FilterTextForNetwork(Effektsequenzereffekte[i].Name)+','+GUIDtoString(Effektsequenzereffekte[i].ID);
          end;
        end;
        9: // MediaCenter Szenen
        begin
          temp:=temp+inttostr(length(MediaCenterSzenen));
          for i:=0 to length(MediaCenterSzenen)-1 do
          begin
            temp:=temp+' '+inttostr(i+1)+':'+FilterTextForNetwork(MediaCenterSzenen[i].Name)+','+GUIDtoString(MediaCenterSzenen[i].ID);
          end;
        end;
        10: // Presetszene
        begin
          temp:=temp+inttostr(length(presetscenes));
          for i:=0 to length(presetscenes)-1 do
          begin
            temp:=temp+' '+inttostr(i+1)+':'+FilterTextForNetwork(presetscenes[i].Name)+','+GUIDtoString(presetscenes[i].ID);
          end;
        end;
        11: // Codeszenen
        begin
          temp:=temp+inttostr(length(codescenes));
          for i:=0 to length(codescenes)-1 do
          begin
            temp:=temp+' '+inttostr(i+1)+':'+FilterTextForNetwork(codescenes[i].Name)+','+GUIDtoString(codescenes[i].ID);
          end;
        end;
        12: // Pluginszenen
        begin
          temp:=temp+inttostr(length(PluginSzenen));
          for i:=0 to length(PluginSzenen)-1 do
          begin
            temp:=temp+' '+inttostr(i+1)+':'+FilterTextForNetwork(PluginSzenen[i].Name)+','+GUIDtoString(PluginSzenen[i].ID);
          end;
        end;
      end;

      AContext.Connection.Socket.WriteLn(temp);
    end else if (pos('get_nodesets',cmd)>0) then // get_nodesets
    begin
      temp:=cmd;
      temp:=copy(temp, pos(' ',temp)+1, length(temp));

      // Leerzeichen entfernen, sofern vorhanden
      if pos(' ', temp)>0 then
        temp:=copy(temp, 0, pos(' ', temp)-1);
      value[0]:=temp;

      temp:='nodesets ';
      temp:=temp+inttostr(length(nodecontrolsets));
      for i:=0 to length(nodecontrolsets)-1 do
      begin
        temp:=temp+' '+inttostr(i+1)+':'+FilterTextForNetwork(nodecontrolsets[i].Name)+','+GUIDtoString(nodecontrolsets[i].ID);
      end;

      AContext.Connection.Socket.WriteLn(temp);
    end else if (pos('get_nodes',cmd)>0) then // get_nodes GUID
    begin
      temp:=cmd;
      temp:=copy(temp, pos(' ',temp)+1, length(temp));

      // Leerzeichen entfernen, sofern vorhanden
      if pos(' ', temp)>0 then
        temp:=copy(temp, 0, pos(' ', temp)-1);
      value[0]:=temp;

      for i:=0 to length(nodecontrolsets)-1 do
      begin
        if IsEqualGUID(stringtoguid(value[0]), nodecontrolsets[i].ID) then
        begin
          temp:='nodes ';
          temp:=temp+inttostr(length(nodecontrolsets[i].NodeControlNodes));
          for j:=0 to length(nodecontrolsets[i].NodeControlNodes)-1 do
          begin
            temp:=temp+' '+inttostr(j+1)+':'+FilterTextForNetwork(nodecontrolsets[i].NodeControlNodes[j].Name)+','+GUIDtoString(nodecontrolsets[i].NodeControlNodes[j].ID);
          end;

          break;
        end else
        begin
          temp:='nodes 0'; // keine passende ID gefunden
        end;
      end;

      AContext.Connection.Socket.WriteLn(temp);
    end else
    begin
      if pos(';',cmd)>0 then
      begin
        cmdtemp:=cmd;

        temp:=copy(cmdtemp, 0, pos(';',cmdtemp)-1); // temp=xxxx;....;....;....
        ExecuteCommandServerCmd(temp);

        repeat
          cmdtemp:=copy(cmdtemp, pos(';',cmdtemp)+1, length(cmdtemp)-(pos(';',cmdtemp))); //cmdtemp= ....;....;....

          if pos(';',cmdtemp)>0 then
            temp:=copy(cmdtemp, 0, pos(';',cmdtemp)-1) // temp=xxxx;....;....
          else
            temp:=cmdtemp; // temp=xxxx

          ExecuteCommandServerCmd(temp);
        until (pos(';',cmdtemp)<=0);
      end else
      begin
        ExecuteCommandServerCmd(cmd);
      end;
      AContext.Connection.Socket.WriteLn('Done');
    end;
  end;
end;

procedure TMainform.ExecuteCommandServerCmd(cmd: string);
var
  temp:string;
  value:array[0..8] of string;
  i, j:integer;
  Pos1, Pos2:integer;
begin
  if (pos('set_channel',cmd)>0) or (pos('set_ch',cmd)>0) then  // set_ch GUID DIMMER -1 255 5000 0
  begin
    temp:=cmd;
//    temp:=copy(temp, 13, length(temp));
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[0]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[1]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[2]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[3]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[4]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    // Leerzeichen entfernen, sofern vorhanden
    if pos(' ', temp)>0 then
      temp:=copy(temp, 0, pos(' ', temp)-1);
    value[5]:=temp;

    geraetesteuerung.set_channel(stringtoguid(value[0]), value[1], strtoint(value[2]), strtoint(value[3]), strtoint(value[4]), strtoint(value[5]));
  end;
  if (pos('set_pantilt',cmd)>0) or (pos('set_pt',cmd)>0) then  // set_pt GUID -1 255 -1 255 5000 0
  begin
    temp:=cmd;
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[0]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[1]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[2]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[3]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[4]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[5]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    // Leerzeichen entfernen, sofern vorhanden
    if pos(' ', temp)>0 then
      temp:=copy(temp, 0, pos(' ', temp)-1);
    value[6]:=temp;

    geraetesteuerung.set_pantilt(stringtoguid(value[0]), strtoint(value[1]), strtoint(value[2]), strtoint(value[3]), strtoint(value[4]), strtoint(value[5]), strtoint(value[6]));
  end;
  if (pos('set_color',cmd)>0) then  // set_color GUID R G B 5000 0
  begin
    temp:=cmd;
//    temp:=copy(temp, 13, length(temp));
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[0]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[1]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[2]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[3]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[4]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    // Leerzeichen entfernen, sofern vorhanden
    if pos(' ', temp)>0 then
      temp:=copy(temp, 0, pos(' ', temp)-1);
    value[5]:=temp;

    geraetesteuerung.set_color(stringtoguid(value[0]), strtoint(value[1]), strtoint(value[2]), strtoint(value[3]), strtoint(value[4]), strtoint(value[5]));
  end;
  if (pos('set_shutter',cmd)>0) then  // set_shutter GUID OPENorCLOSE DELAYTIME
  begin
    temp:=cmd;
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[0]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[1]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    // Leerzeichen entfernen, sofern vorhanden
    if pos(' ', temp)>0 then
      temp:=copy(temp, 0, pos(' ', temp)-1);
    value[2]:=temp;

    geraetesteuerung.set_shutter(stringtoguid(value[0]), strtoint(value[1]), strtoint(value[2]));
  end;
  if (pos('set_strobe',cmd)>0) then  // set_strobe GUID VALUE FADETIME DELAYTIME
  begin
    temp:=cmd;
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[0]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[1]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[2]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    // Leerzeichen entfernen, sofern vorhanden
    if pos(' ', temp)>0 then
      temp:=copy(temp, 0, pos(' ', temp)-1);
    value[3]:=temp;

    geraetesteuerung.set_strobe(stringtoguid(value[0]), strtoint(value[1]), strtoint(value[2]), strtoint(value[3]));
  end;
  if (pos('set_dimmer',cmd)>0) then  // set_dimmer GUID VALUE FADETIME DELAYTIME
  begin
    temp:=cmd;
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[0]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[1]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[2]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    // Leerzeichen entfernen, sofern vorhanden
    if pos(' ', temp)>0 then
      temp:=copy(temp, 0, pos(' ', temp)-1);
    value[3]:=temp;

    geraetesteuerung.set_dimmer(stringtoguid(value[0]), strtoint(value[1]), strtoint(value[2]), strtoint(value[3]));
  end;
  if (pos('set_fog',cmd)>0) then  // set_fog VALUE FADETIME
  begin
    temp:=cmd;
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[0]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[1]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    // Leerzeichen entfernen, sofern vorhanden
    if pos(' ', temp)>0 then
      temp:=copy(temp, 0, pos(' ', temp)-1);
    value[2]:=temp;

    for i:=0 to length(devices)-1 do
    begin
      if devices[i].hasFog then
      begin
        geraetesteuerung.set_fog(devices[i].ID, strtoint(value[0]), strtoint(value[1]), strtoint(value[2]));
      end;
    end;
  end;
  if (pos('set_highlight',cmd)>0) then  // set_highlight GUID VALUE FADETIME
  begin
    temp:=cmd;
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[0]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[1]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    // Leerzeichen entfernen, sofern vorhanden
    if pos(' ', temp)>0 then
      temp:=copy(temp, 0, pos(' ', temp)-1);
    value[2]:=temp;

    if strtoint(value[1])>0 then
      geraetesteuerung.set_shutter(stringtoguid(value[0]), 255)
    else
      geraetesteuerung.set_shutter(stringtoguid(value[0]), 0);

    geraetesteuerung.set_color(stringtoguid(value[0]), strtoint(value[1]), strtoint(value[1]), strtoint(value[1]), strtoint(value[2]), 0);
    geraetesteuerung.set_dimmer(stringtoguid(value[0]), strtoint(value[1]), strtoint(value[2]), 0);
    geraetesteuerung.set_channel(stringtoguid(value[0]), 'a', strtoint(value[1]), strtoint(value[2]), 0);
    geraetesteuerung.set_channel(stringtoguid(value[0]), 'w', strtoint(value[1]), strtoint(value[2]), 0);
  end;
  if (pos('set_devaddress',cmd)>0) then  // set_devaddress GUID NEWADDRESS
  begin
    temp:=cmd;
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[0]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    // Leerzeichen entfernen, sofern vorhanden
    if pos(' ', temp)>0 then
      temp:=copy(temp, 0, pos(' ', temp)-1);
    value[1]:=temp;

    for i:=0 to length(devices)-1 do
    begin
      if IsEqualGUID(StringToGUID(value[0]), devices[i].ID) then
      begin
        if (strtoint(value[1])>=1) and (strtoint(value[1])<=8192) then
          devices[i].Startaddress:=strtoint(value[1]);
        break;
      end;
    end;
  end;
  if (pos('set_devcolor',cmd)>0) then  // set_devcolor GUID R G B
  begin
    temp:=cmd;
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[0]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[1]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[2]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    // Leerzeichen entfernen, sofern vorhanden
    if pos(' ', temp)>0 then
      temp:=copy(temp, 0, pos(' ', temp)-1);
    value[3]:=temp;

    for i:=0 to length(devices)-1 do
    begin
      if IsEqualGUID(StringToGUID(value[0]), devices[i].ID) then
      begin
        devices[i].color:=RGB2TColor(strtoint(value[1]), strtoint(value[2]), strtoint(value[3]));
        break;
      end;
    end;
  end;
  if (pos('set_gobo1rot',cmd)>0) then  // set_gobo1rot GUID VALUE
  begin
    temp:=cmd;
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[0]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[1]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[2]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    // Leerzeichen entfernen, sofern vorhanden
    if pos(' ', temp)>0 then
      temp:=copy(temp, 0, pos(' ', temp)-1);
    value[3]:=temp;

    geraetesteuerung.set_gobo1rot(stringtoguid(value[0]), strtoint(value[1]), strtoint(value[2]), strtoint(value[3]));
  end;
  if (pos('set_gobo2rot',cmd)>0) then  // set_gobo2rot GUID VALUE
  begin
    temp:=cmd;
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[0]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[1]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[2]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    // Leerzeichen entfernen, sofern vorhanden
    if pos(' ', temp)>0 then
      temp:=copy(temp, 0, pos(' ', temp)-1);
    value[3]:=temp;

    geraetesteuerung.set_gobo2rot(stringtoguid(value[0]), strtoint(value[1]), strtoint(value[2]), strtoint(value[3]));
  end;
  if (pos('set_gobo1+',cmd)>0) then  // set_gobo1+ GUID
  begin
    temp:=cmd;
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    // Leerzeichen entfernen, sofern vorhanden
    if pos(' ', temp)>0 then
      temp:=copy(temp, 0, pos(' ', temp)-1);
    value[0]:=temp;

    geraetesteuerung.set_gobo1plus(StringToGUID(value[0]));
  end;
  if (pos('set_gobo1-',cmd)>0) then  // set_gobo1- GUID
  begin
    temp:=cmd;
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    // Leerzeichen entfernen, sofern vorhanden
    if pos(' ', temp)>0 then
      temp:=copy(temp, 0, pos(' ', temp)-1);
    value[0]:=temp;

    geraetesteuerung.set_gobo1minus(StringToGUID(value[0]));
  end;
  if (pos('set_gobo2+',cmd)>0) then  // set_gobo2+ GUID
  begin
    temp:=cmd;
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    // Leerzeichen entfernen, sofern vorhanden
    if pos(' ', temp)>0 then
      temp:=copy(temp, 0, pos(' ', temp)-1);
    value[0]:=temp;

    geraetesteuerung.set_gobo2plus(StringToGUID(value[0]));
  end;
  if (pos('set_gobo2-',cmd)>0) then  // set_gobo2- GUID
  begin
    temp:=cmd;
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    // Leerzeichen entfernen, sofern vorhanden
    if pos(' ', temp)>0 then
      temp:=copy(temp, 0, pos(' ', temp)-1);
    value[0]:=temp;

    geraetesteuerung.set_gobo2minus(StringToGUID(value[0]));
  end;
  if (pos('set_prisma',cmd)>0) then  // set_prisma GUID SINGLEorTRIPLE DELAYTIME
  begin
    temp:=cmd;
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[0]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[1]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    // Leerzeichen entfernen, sofern vorhanden
    if pos(' ', temp)>0 then
      temp:=copy(temp, 0, pos(' ', temp)-1);
    value[2]:=temp;

    geraetesteuerung.set_prisma(stringtoguid(value[0]), strtoint(value[1]), strtoint(value[2]));
  end;
  if (pos('set_prismarot',cmd)>0) then  // set_prismarot GUID VALUE FADETIME DELAYTIME
  begin
    temp:=cmd;
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[0]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[1]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[2]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    // Leerzeichen entfernen, sofern vorhanden
    if pos(' ', temp)>0 then
      temp:=copy(temp, 0, pos(' ', temp)-1);
    value[3]:=temp;

    geraetesteuerung.set_prismarot(stringtoguid(value[0]), strtoint(value[1]), strtoint(value[2]), strtoint(value[3]));
  end;
  if (pos('set_iris',cmd)>0) then  // set_iris GUID VALUE FADETIME DELAYTIME
  begin
    temp:=cmd;
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[0]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[1]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[2]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    // Leerzeichen entfernen, sofern vorhanden
    if pos(' ', temp)>0 then
      temp:=copy(temp, 0, pos(' ', temp)-1);
    value[3]:=temp;

    geraetesteuerung.set_iris(stringtoguid(value[0]), strtoint(value[1]), strtoint(value[2]), strtoint(value[3]));
  end;
  if (pos('set_absolutchannel',cmd)>0) or (pos('set_ach',cmd)>0) then  // set_ach 1 -1 255 5000 0
  begin
    temp:=cmd;
//    temp:=copy(temp, 13, length(temp));
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[0]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[1]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[2]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[3]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    // Leerzeichen entfernen, sofern vorhanden
    if pos(' ', temp)>0 then
      temp:=copy(temp, 0, pos(' ', temp)-1);
    value[4]:=temp;

    if (strtoint(value[1])>-1) and (strtoint(value[2])>-1) then
      senddata(strtoint(value[0]), 255-strtoint(value[1]), 255-strtoint(value[2]), strtoint(value[3]), strtoint(value[4]))
    else if (strtoint(value[1])>-1) then
      senddata(strtoint(value[0]), 255-strtoint(value[1]), strtoint(value[2]), strtoint(value[3]), strtoint(value[4]))
    else if (strtoint(value[2])>-1) then
      senddata(strtoint(value[0]), strtoint(value[1]), 255-strtoint(value[2]), strtoint(value[3]), strtoint(value[4]));
  end;
  if (pos('set_datainchannel',cmd)>0) or (pos('set_dch',cmd)>0) or (pos('SetChannel',cmd)>0) or (pos('SC',cmd)>0) then  // DMXControl-Kompatibilität
  begin
    temp:=cmd;
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[0]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    // Leerzeichen entfernen, sofern vorhanden
    if pos(' ', temp)>0 then
      temp:=copy(temp, 0, pos(' ', temp)-1);
    value[1]:=temp;

    ExecuteDataInEvent(strtoint(value[0]), strtoint(value[1]));
  end;
  if (pos('start_scene',cmd)>0) or (pos('start_sc',cmd)>0) then // start_scene GUID
  begin
    temp:=cmd;
//    temp:=copy(temp, 13, length(temp));
    temp:=copy(temp, pos(' ',temp)+1, length(temp));
    // Leerzeichen entfernen, sofern vorhanden
    if pos(' ', temp)>0 then
      temp:=copy(temp, 0, pos(' ', temp)-1);

    StartScene(StringToGuid(temp));
  end;
  if (pos('stop_scene',cmd)>0) or (pos('stop_sc',cmd)>0) then  // stop_scene GUID
  begin
    temp:=cmd;               
    temp:=copy(temp, pos(' ',temp)+1, length(temp));
    // Leerzeichen entfernen, sofern vorhanden
    if pos(' ', temp)>0 then
      temp:=copy(temp, 0, pos(' ', temp)-1);

    StopScene(StringToGuid(temp));
  end;
  if (pos('click_button',cmd)>0) or (pos('click_btn',cmd)>0) then  // click_btn X Y
  begin
    temp:=cmd;
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[0]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    // Leerzeichen entfernen, sofern vorhanden
    if pos(' ', temp)>0 then
      temp:=copy(temp, 0, pos(' ', temp)-1);
    value[1]:=temp;

    kontrollpanel.OverBtn.X:=strtoint(value[0])-1;
    kontrollpanel.OverBtn.Y:=strtoint(value[1])-1;
    //kontrollpanel.PaintBox1MouseMove(nil, [], trunc(kontrollpanel.btnwidth.Value*(strtoint(value[0])-1)+(kontrollpanel.btnwidth.Value / 2)), trunc(kontrollpanel.btnheight.Value*(strtoint(value[1])-1)+(kontrollpanel.btnheight.Value / 2)));
    kontrollpanel.PaintBox1MouseDown(nil, mbLeft, [ssLeft], trunc(kontrollpanel.btnwidth.Value*(strtoint(value[0])-1)+(kontrollpanel.btnwidth.Value / 2)), trunc(kontrollpanel.btnheight.Value*(strtoint(value[1])-1)+(kontrollpanel.btnheight.Value / 2)));
    kontrollpanel.PaintBox1MouseUp(nil, mbLeft, [], trunc(kontrollpanel.btnwidth.Value*(strtoint(value[0])-1)+(kontrollpanel.btnwidth.Value / 2)), trunc(kontrollpanel.btnheight.Value*(strtoint(value[1])-1)+(kontrollpanel.btnheight.Value / 2)));
  end;
  if (pos('save_stageview',cmd)>0) then // save stageview as image
  begin
    temp:=cmd;
    temp:=copy(temp, pos(' ',temp)+1, length(temp));
    // Leerzeichen entfernen, sofern vorhanden
    if pos(' ', temp)>0 then
      temp:=copy(temp, 0, pos(' ', temp)-1);
    value[0]:=temp;

    grafischebuehnenansicht.SaveStageviewToFile(value[0]);
  end;
  if (pos('run_command',cmd)>0) or (pos('run_cmd',cmd)>0) then  // run_cmd GUID(Type) Integer1 Integer2 String1 String 2 GUID1 GUID2 VALUE
  begin
    temp:=cmd;
//    temp:=copy(temp, 13, length(temp));
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[0]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[1]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[2]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[3]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[4]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[5]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[6]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    // Leerzeichen entfernen, sofern vorhanden
    if pos(' ', temp)>0 then
      temp:=copy(temp, 0, pos(' ', temp)-1);
    value[7]:=temp;

    TerminalSystem.BefehlsTyp:=StringToGUID(value[0]);
    TerminalSystem.IntegerArg1:=strtoint(value[1]);
    TerminalSystem.IntegerArg2:=strtoint(value[2]);
    TerminalSystem.StringArg1:=value[3];
    TerminalSystem.StringArg2:=value[4];
    TerminalSystem.GUID1:=StringToGUID(value[5]);
    TerminalSystem.GUID2:=StringToGUID(value[6]);
    StartBefehl(StringToGUID('{46368186-DF3D-467A-9792-DAC6B03A21E3}'), strtoint(value[7]));
  end;
  if (pos('set_node',cmd)>0) then // set_node nodeID X Y R G B A W D
  begin
    temp:=cmd;
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[0]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[1]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[2]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[3]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[4]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[5]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[6]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[7]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    // Leerzeichen entfernen, sofern vorhanden
    if pos(' ', temp)>0 then
      temp:=copy(temp, 0, pos(' ', temp)-1);
    value[8]:=temp;

    Pos1:=-1;
    Pos2:=-1;
    for i:=0 to length(nodecontrolsets)-1 do
    for j:=0 to length(nodecontrolsets[i].NodeControlNodes)-1 do
    begin
      if IsEqualGUID(nodecontrolsets[i].NodeControlNodes[j].ID, stringtoguid(value[0])) then
      begin
        Pos1:=i;
        Pos2:=j;
        break;
      end;
      if (Pos1>-1) and (Pos2>-1) then
        break;
    end;

    if (Pos1>=0) and (Pos1<nodecontrolform.nodecontrolsetscombobox.Items.Count) then
    begin
      if nodecontrolform.nodecontrolsetscombobox.ItemIndex<>Pos1 then
      begin
        nodecontrolform.nodecontrolsetscombobox.ItemIndex:=Pos1;
        nodecontrolform.nodecontrolsetscomboboxChange(nodecontrolform.nodecontrolsetscombobox);
      end;

      if (Pos2>=0) and (Pos2<nodecontrolform.nodelist.Items.Count) then
      begin
        if nodecontrolform.nodelist.ItemIndex<>Pos2 then
        begin
          nodecontrolform.nodelist.ItemIndex:=Pos2;
          nodecontrolform.nodelistClick(nodecontrolform.nodelist);
        end;

        i:=round(nodecontrolform.PaintBox1.Width*strtoint(value[1])/10000);
        j:=round(nodecontrolform.PaintBox1.Height*strtoint(value[2])/10000);

        if i<0 then
          NodeControlSets[Pos1].NodeControlNodes[Pos2].X:=0
        else if i>(nodecontrolform.Paintbox1.Width) then
          NodeControlSets[Pos1].NodeControlNodes[Pos2].X:=nodecontrolform.Paintbox1.Width
        else
          NodeControlSets[Pos1].NodeControlNodes[Pos2].X:=i;

        if j<0 then
          NodeControlSets[Pos1].NodeControlNodes[Pos2].Y:=0
        else if j>(nodecontrolform.Paintbox1.Height) then
          NodeControlSets[Pos1].NodeControlNodes[Pos2].Y:=nodecontrolform.Paintbox1.Height
        else
          NodeControlSets[Pos1].NodeControlNodes[Pos2].Y:=j;

        if (value[3]='-1') or (value[4]='-1') or (value[5]='-1') then
        begin
          nodecontrolform.rgbcheckbox.Checked:=false;
        end else
        begin
          nodecontrolform.rgbcheckbox.Checked:=true;
          nodecontrolform.colorpicker.SelectedColor:=pcdUtils.RGB2TColor(strtoint(value[3]), strtoint(value[4]), strtoint(value[5]));
        end;

        if (value[6]='-1') then
        begin
          nodecontrolform.ambercheckbox.Checked:=false;
        end else
        begin
          nodecontrolform.ambercheckbox.Checked:=true;
          nodecontrolform.amberslider.Value:=strtoint(value[6]);
        end;

        if (value[7]='-1') then
        begin
          nodecontrolform.whitecheckbox.Checked:=false;
        end else
        begin
          nodecontrolform.whitecheckbox.Checked:=true;
          nodecontrolform.whiteslider.Value:=strtoint(value[7]);
        end;

        if (value[8]='-1') then
        begin
          nodecontrolform.dimmercheckbox.Checked:=false;
        end else
        begin
          nodecontrolform.dimmercheckbox.Checked:=true;
          nodecontrolform.dimmerslider.Position:=strtoint(value[8]);
        end;

        nodecontrolform.GUItoNodesets;
        nodecontrolform.GUItoNode;
      end;
    end;
  end;
  if (pos('set_nodeset',cmd)>0) then  // set_nodeset nodesetID Ausdehnung Kontrast Fadetime UseRGB UseA UseW UseD
  begin
    temp:=cmd;
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[0]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[1]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[2]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[3]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[4]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[5]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    value[6]:=copy(temp, 0, pos(' ',temp)-1);
    temp:=copy(temp, pos(' ',temp)+1, length(temp));

    // Leerzeichen entfernen, sofern vorhanden
    if pos(' ', temp)>0 then
      temp:=copy(temp, 0, pos(' ', temp)-1);
    value[7]:=temp;

    Pos1:=-1;
    for i:=0 to length(nodecontrolsets)-1 do
    begin
      if IsEqualGUID(nodecontrolsets[i].ID, stringtoguid(value[0])) then
      begin
        Pos1:=i;
        break;
      end;
    end;

    if (Pos1>=0) and (Pos1<nodecontrolform.nodecontrolsetscombobox.Items.Count) then
    begin
      if nodecontrolform.nodecontrolsetscombobox.ItemIndex<>Pos1 then
      begin
        nodecontrolform.nodecontrolsetscombobox.ItemIndex:=Pos1;
        nodecontrolform.nodecontrolsetscomboboxChange(nodecontrolform.nodecontrolsetscombobox);
      end;

      nodecontrolform.narrowslider.Position:=strtoint(value[1]);
      nodecontrolform.contrastslider.Position:=strtoint(value[2]);
      nodecontrolform.fadetimemsedit.Value:=strtoint(value[3]);

      nodecontrolform.setrgbcheckbox.checked:=(value[4]<>'-1');
      nodecontrolform.setambercheckbox.checked:=(value[5]<>'-1');
      nodecontrolform.setwhitecheckbox.checked:=(value[6]<>'-1');
      nodecontrolform.setdimmercheckbox.checked:=(value[7]<>'-1');
      nodecontrolform.GUItoNodesets;
    end;
  end;
end;

procedure TMainform.FormMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  autolocktimecounter:=0;
  autologouttimecounter:=0;
end;

procedure TMainform.TBItem68Click(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  faderpanelform.show;
end;

procedure TMainform.dxBarApplicationMenu1ExtraPaneItemClick(
  Sender: TObject; AIndex: Integer);
begin
  if FileExists(data.openhistory[dxBarApplicationMenu1.ExtraPane.Items[AIndex].Data-1]) then
    openproject(data.openhistory[dxBarApplicationMenu1.ExtraPane.Items[AIndex].Data-1], false)
  else
  begin
    ShowMessage(_('Die Datei "')+data.openhistory[dxBarApplicationMenu1.ExtraPane.Items[AIndex].Data-1]+_('" ist nicht mehr verfügbar!'));
    data.openhistory[dxBarApplicationMenu1.ExtraPane.Items[AIndex].Data-1]:='';
  end;
end;

procedure TMainform.BrightnessBarRibbonChange(Sender: TObject);
begin
  if strtoint(brightnesseditribbon.text)<25 then
    brightnesseditribbon.text:='25';

  if blenddown.Showing then
    blenddown.AlphaBlendValue:=255-strtoint(brightnesseditribbon.text)
  else
    blenddown.endalphablendvalue:=255-strtoint(brightnesseditribbon.text);
end;

procedure TMainform.BlenddownRibbonBtnClick(Sender: TObject);
begin
  if blenddown=nil then
    blenddown:=Tblenddown.Create(blenddown);

  with blenddown do
  begin
    if not blenddown.Showing then
    begin
      brightnessEditribbon.Visible:=ivAlways;
      screenfaded:=false;
      blendfadein.Enabled:=true;
      blendfadeout.Enabled:=false;
      Left:=0;
      Top:=0;
      Width:=screen.Width;
      Height:=screen.Height;
      Show;
      blenddown.endalphablendvalue:=255-strtoint(brightnesseditribbon.text);
      brightnessEditribbon.Enabled:=true;
    end else
    begin
      brightnessEditribbon.Visible:=ivNever;
      blendfadeout.Enabled:=true;
      blendfadein.Enabled:=false;
      brightnessEditribbon.Enabled:=false;
    end;
  end;
end;

procedure TMainform.PaintBox1MouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  i,j,offset:integer;
  row,col,channelperrow:integer;
begin
  if combobox1.ItemIndex=-1 then
    combobox1.itemindex:=3;

  if (faderpanelup and (y>Paintbox1.Height-258)) or (Y>(Paintbox1.Height-48)) then
  begin
    if not UserAccessGranted(2, false) then exit;

    if faderpanelup then
      offset:=258
    else
      offset:=48;

    mousey:=y;
    mouseoverfader:=trunc((x/(maxfaders*40))*maxfaders);
    abletomove:=((y-(Paintbox1.Height-offset))<=24);
    Paintbox1.PopupMenu:=FaderpanelPopupMenu1;
  end else
  begin
    case pagecontrol1.ActivePageIndex of
      0:  // Bühne
      begin
        if not UserAccessGranted(2, false) then exit;

        grafischebuehnenansicht.MouseDownPoint.X:=X;
        grafischebuehnenansicht.MouseDownPoint.Y:=Y;

        paintbox1.PopupMenu:=grafischebuehnenansicht.popupmenu1;

        if grafischebuehnenansicht.ClickOnProgress(X,Y)>-1 then
        begin
          paintbox1.PopupMenu:=nil;
        end else if grafischebuehnenansicht.ClickOnBuehnenansichtProgress(X,Y)>-1 then
        begin
          paintbox1.PopupMenu:=nil;
        end else if grafischebuehnenansicht.ClickOnLabel(X,Y)>-1 then
        begin
          paintbox1.PopupMenu:=nil;
        end else if grafischebuehnenansicht.ClickOnNumber(X,Y)>-1 then
        begin
          paintbox1.PopupMenu:=nil;
        end else if grafischebuehnenansicht.ClickOnBuehnenansichtNumber(X,Y)>-1 then
        begin
          paintbox1.PopupMenu:=nil;
        end else if grafischebuehnenansicht.ClickOnBuehnenansichtColor(X,Y)>-1 then
        begin
          paintbox1.PopupMenu:=nil;
        end else if (grafischebuehnenansicht.ClickOnDevice(X,Y,Shift)>-1) or (grafischebuehnenansicht.ClickOnBuehnenansichtDevice(X,Y)>-1) then
        begin
          grafischebuehnenansicht.ProcessorFriendlyRedraw:=true;

          paintbox1.PopupMenu:=nil;

          for i:=0 to length(mainform.devices)-1 do
          for j:=0 to length(mainform.devices[i].OldPos)-1 do
          begin
            mainform.devices[i].OldPos[j].X:=mainform.devices[i].Left[j];
            mainform.devices[i].OldPos[j].Y:=mainform.devices[i].Top[j];
          end;

          for i:=0 to length(mainform.buehnenansichtdevices)-1 do
          begin
            mainform.buehnenansichtdevices[i].OldPos.X:=mainform.buehnenansichtdevices[i].Left;
            mainform.buehnenansichtdevices[i].OldPos.Y:=mainform.buehnenansichtdevices[i].Top;
          end;
        end else
        begin
          grafischebuehnenansicht.DeviceSelectedTimer.enabled:=true;

          If (shift=[ssLeft,ssCtrl]) and not (Shift=[ssCtrl,ssShift]) then
          begin
            for i:=0 to length(mainform.DeviceSelected)-1 do
              mainform.DeviceSelected[i]:=false;
            mainform.DeviceSelectionChanged(nil);
          end;

          If (shift=[ssLeft]) or (shift=[ssLeft,ssShift]) then
          begin
            for i:=0 to length(mainform.buehnenansichtdevices)-1 do
            begin
              mainform.buehnenansichtdevices[i].selected:=false;
            end;
            for i:=0 to length(mainform.devices)-1 do
            for j:=0 to length(mainform.devices[i].selected)-1 do
            begin
              mainform.devices[i].selected[j]:=false;
            end;

            grafischebuehnenansicht.Auswahl.Left:=X;
            grafischebuehnenansicht.Auswahl.Top:=Y;
            grafischebuehnenansicht.Auswahl.Right:=X;
            grafischebuehnenansicht.Auswahl.Bottom:=Y;
            grafischebuehnenansicht.ShowAuswahl:=true;
          end;

          if not (Shift=[ssLeft,ssShift,ssCtrl]) and (Shift=[ssLeft,ssShift]) then
          begin
            for i:=0 to length(mainform.DeviceSelected)-1 do
              mainform.DeviceSelected[i]:=false;
            mainform.DeviceSelectionChanged(nil);

            grafischebuehnenansicht.Auswahl.Left:=X;
            grafischebuehnenansicht.Auswahl.Top:=Y;
            grafischebuehnenansicht.Auswahl.Right:=X;
            grafischebuehnenansicht.Auswahl.Bottom:=Y;
            grafischebuehnenansicht.ShowAuswahl:=true;
          end;

          if (Shift=[ssLeft,ssShift,ssCtrl]) and not (Shift=[ssLeft,ssShift]) then
          begin
            grafischebuehnenansicht.Auswahl.Left:=X;
            grafischebuehnenansicht.Auswahl.Top:=Y;
            grafischebuehnenansicht.Auswahl.Right:=X;
            grafischebuehnenansicht.Auswahl.Bottom:=Y;
            grafischebuehnenansicht.ShowAuswahl:=true;
          end;
        end;
      end;
      1:  // Kanäle
      begin
        if not UserAccessGranted(2, false) then exit;

        mouseychannel:=y;
        scrollbarpositiononmousedown:=ScrollBar1.Position;

        TrackBarSelected:=false;
        lastposition:=AktuellerKanal;
        col:=(x div ChannelWidth)+1;
        row:=(y div ChannelHeight)+ErsteZeile;
        channelperrow:=paintbox1.Width div ChannelWidth;
        AktuellerKanal:=channelperrow*row+col;
        MouseOverKanal:=channelperrow*row+col;
        ChannelValueOnClick:=mainform.channel_value[AktuellerKanal];

        RefreshMainformScreen:=true;
      end;
      2:  // Panel
      begin
        if not UserAccessGranted(3, false) then exit;

        kontrollpanel.PaintBox1MouseDown(nil, Button, Shift, X, Y);
      end;
    end;
  end;
end;

procedure TMainform.PaintBox1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  CurrentMousePositionX:=X;
  CurrentMousePositionY:=Y;
  CurrentMouseMoveShiftState:=Shift;
  HandleMouseMove:=true;
end;

procedure TMainform.PaintBox1MouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
var
  i,j,k,m,oldvalue,channel,offset,raster:integer;
  ddfwindowposition:integer;
  toppos, leftpos:single;
begin
  CurrentMousePositionX:=X;
  CurrentMousePositionY:=Y;
  CurrentMouseMoveShiftState:=Shift;
  HandleMouseMove:=true;

  if (faderpanelup and (Y>Paintbox1.Height-258)) or (Y>(Paintbox1.Height-48)) then
  begin
    if not UserAccessGranted(2) then exit;

    if faderpanelup then
      offset:=258
    else
      offset:=48;

    if Shift=[ssCtrl] then faderselected[faderchannel[mouseoverfader]-1]:=not faderselected[faderchannel[mouseoverfader]-1];
    if Shift=[ssAlt] then faderselectedalt[faderchannel[mouseoverfader]-1]:=not faderselectedalt[faderchannel[mouseoverfader]-1];
    if Shift=[ssShift] then faderselectedshift[faderchannel[mouseoverfader]-1]:=not faderselectedshift[faderchannel[mouseoverfader]-1];
    if (x>=(paintbox1.Width-8)) and ((y-Paintbox1.Height-offset)<=8) then close;
  end else
  begin
    case pagecontrol1.ActivePageIndex of
      0:  // Bühne
      begin
        if not UserAccessGranted(2) then exit;

        grafischebuehnenansicht.ProcessorFriendlyRedraw:=false;

        grafischebuehnenansicht.MouseUpPoint.X:=X;
        grafischebuehnenansicht.MouseUpPoint.Y:=Y;

        paintbox1.PopupMenu:=grafischebuehnenansicht.popupmenu1;

        if grafischebuehnenansicht.MouseOnDevice>-1 then
        begin
          paintbox1.PopupMenu:=nil;
    
            // Strg+Klick
            if (Shift=[ssCtrl]) and (Button=mbLeft) and not (Shift=[ssCtrl,ssShift]) then
            begin
              mainform.devices[grafischebuehnenansicht.MouseOnDevice].selected[grafischebuehnenansicht.MouseOnDeviceCopy]:=not mainform.devices[grafischebuehnenansicht.MouseOnDevice].selected[grafischebuehnenansicht.MouseOnDeviceCopy];
            end;

            // Rechtsklick mit STRG oder Linksklick mit Shift
            if ((Shift=[ssCtrl]) and (Button=mbRight)) or ((Shift=[ssShift]) and (Button=mbLeft)) then
            begin
              mainform.DeviceSelected[grafischebuehnenansicht.MouseOnDevice]:=not mainform.DeviceSelected[grafischebuehnenansicht.MouseOnDevice];
              mainform.DeviceSelectionChanged(nil);
            end;

            // Nur Rechtsklick
            if (Shift=[]) and (Button=mbRight) then
            begin
              if Checkbox5.Checked then
              begin
                for j:=0 to length(ddfwindows)-1 do
                begin
                  if ddfwindows[j].Showing then
                    ddfwindows[j].Close;
                  ddfwindows[j].Free;
                end;
                setlength(ddfwindows,0);
              end;

              ddfwindowposition:=-1;

              for j:=0 to length(ddfwindows)-1 do
              begin
                if IsEqualGUID(ddfwindows[j].thisddfwindowDeviceID,mainform.devices[grafischebuehnenansicht.MouseOnDevice].ID) then
                begin
                  ddfwindowposition:=j;
                  break;
                end;
              end;

              if ddfwindowposition=-1 then
              for j:=0 to length(ddfwindows)-1 do
              begin
                if ddfwindows[j].readyfordelete then
                begin
                  ddfwindowposition:=j;
                end;
              end;

              if ddfwindowposition=-1 then
              begin
                setlength(ddfwindows,length(ddfwindows)+1);
                ddfwindows[length(ddfwindows)-1]:=TDDFWindow.Create(self);
                ddfwindowposition:=length(ddfwindows)-1;
              end;
              ddfwindows[ddfwindowposition].readyfordelete:=false;
              ddfwindows[ddfwindowposition].thisddfwindowDeviceID:=mainform.devices[grafischebuehnenansicht.MouseOnDevice].ID;
              ddfwindows[ddfwindowposition].Top:=mainform.Top+16+mainform.devices[grafischebuehnenansicht.MouseOnDevice].Top[grafischebuehnenansicht.MouseOnDeviceCopy]+(mainform.devices[grafischebuehnenansicht.MouseOnDevice].picturesize div 2);
              ddfwindows[ddfwindowposition].Left:=mainform.Left+mainform.devices[grafischebuehnenansicht.MouseOnDevice].Left[grafischebuehnenansicht.MouseOnDeviceCopy]+(mainform.devices[grafischebuehnenansicht.MouseOnDevice].picturesize div 2);
              ddfwindows[ddfwindowposition].loadDDF(mainform.devices[grafischebuehnenansicht.MouseOnDevice].ID);
            end;

            if Checkbox4.Checked and (not (Checkbox3.Checked)) then
            begin
              raster:=32;
              case Combobox2.ItemIndex of
                0: raster:=8;
                1: raster:=16;
                2: raster:=24;
                3: raster:=32;
                4: raster:=48;
                5: raster:=64;
              end;

              // Geräte am Raster ausrichten
              for j:=0 to length(mainform.devices)-1 do
              begin
                for k:=0 to length(mainform.devices[j].left)-1 do
                begin
                  toppos:=mainform.devices[j].Top[k]/raster;
                  leftpos:=mainform.devices[j].Left[k]/raster;

                  if frac(toppos)<0.5 then
                    toppos:=trunc(toppos)
                  else
                    toppos:=trunc(toppos)+1;

                  if frac(leftpos)<0.5 then
                    leftpos:=trunc(leftpos)
                  else
                    leftpos:=trunc(leftpos)+1;

                  mainform.devices[j].Top[k]:=round(toppos*raster);
                  mainform.devices[j].Left[k]:=round(leftpos*raster);
                end;
              end;
              for k:=0 to length(mainform.buehnenansichtdevices)-1 do
              begin
                toppos:=mainform.buehnenansichtdevices[k].top/raster;
                leftpos:=mainform.buehnenansichtdevices[k].left/raster;

                if frac(toppos)<0.5 then
                  toppos:=trunc(toppos)
                else
                  toppos:=trunc(toppos)+1;

                if frac(leftpos)<0.5 then
                  leftpos:=trunc(leftpos)
                else
                  leftpos:=trunc(leftpos)+1;

                mainform.buehnenansichtdevices[k].top:=round(toppos*raster);
                mainform.buehnenansichtdevices[k].left:=round(leftpos*raster);
              end;
              grafischebuehnenansicht.RedrawPictures:=true;
            end;
        end else if grafischebuehnenansicht.MouseOnBuehnenansichtDevice>-1 then
        begin
          paintbox1.PopupMenu:=grafischebuehnenansicht.devicepicture_popup;

          // Strg+Klick
          if (Shift=[ssCtrl]) and (Button=mbLeft) and not (Shift=[ssCtrl,ssShift]) then
          begin
            mainform.Buehnenansichtdevices[grafischebuehnenansicht.MouseOnBuehnenansichtDevice].selected:=not mainform.Buehnenansichtdevices[grafischebuehnenansicht.MouseOnBuehnenansichtDevice].selected;
          end;
        end else if grafischebuehnenansicht.MouseOnProgress>-1 then
        begin
          paintbox1.PopupMenu:=nil;
        end else if grafischebuehnenansicht.MouseOnBuehnenansichtProgress>-1 then
        begin
          paintbox1.PopupMenu:=nil;
        end else if grafischebuehnenansicht.MouseOnBuehnenansichtColor>-1 then
        begin
          //Farbe ändern
          paintbox1.PopupMenu:=nil;
          colorbox1.Top:=mainform.buehnenansichtdevices[grafischebuehnenansicht.MouseOnBuehnenansichtColor].Top;
          colorbox1.Left:=mainform.buehnenansichtdevices[grafischebuehnenansicht.MouseOnBuehnenansichtColor].Left+mainform.buehnenansichtdevices[grafischebuehnenansicht.MouseOnBuehnenansichtColor].picturesize;
          colorbox1.SelectedColor:=mainform.buehnenansichtdevices[grafischebuehnenansicht.MouseOnBuehnenansichtColor].color;
          colorbox1.BringToFront;
          colorbox1.Visible:=(mainform.buehnenansichtdevices[grafischebuehnenansicht.MouseOnBuehnenansichtColor].bank=BankSelect.Itemindex);
        end else if grafischebuehnenansicht.MouseOnLabel>-1 then
        begin
          paintbox1.PopupMenu:=nil;
          if Button=mbRight then
          begin
{
            mainform.Devices[grafischebuehnenansicht.MouseOnLabel].Name:=InputBox('Beschriftung für "'+mainform.Devices[grafischebuehnenansicht.MouseOnLabel].Name+'"','Bitte geben Sie eine neue Bezeichnung für das aktuelle Gerät ein:',mainform.Devices[grafischebuehnenansicht.MouseOnLabel].Name);

            for k:=0 to  mainform.Devices[grafischebuehnenansicht.MouseOnLabel].MaxChan-1 do
              mainform.data.Names[mainform.Devices[grafischebuehnenansicht.MouseOnLabel].Startaddress+k]:=mainform.Devices[grafischebuehnenansicht.MouseOnLabel].Name+': '+mainform.Devices[grafischebuehnenansicht.MouseOnLabel].Kanalname[k];
}
            if mainform.Devices[grafischebuehnenansicht.MouseOnLabel].MatrixDeviceLevel=0 then
              mainform.Devices[grafischebuehnenansicht.MouseOnLabel].Name:=InputBox(_('Beschriftung für "')+mainform.Devices[grafischebuehnenansicht.MouseOnLabel].Name+'"',_('Bitte geben Sie eine neue Bezeichnung für das aktuelle Gerät ein:'),mainform.Devices[grafischebuehnenansicht.MouseOnLabel].Name)
            else begin
              mainform.Devices[grafischebuehnenansicht.MouseOnLabel].Name:='[M] '+InputBox(_('Beschriftung für "')+mainform.Devices[grafischebuehnenansicht.MouseOnLabel].Name+'"',_('Bitte geben Sie eine neue Bezeichnung für das gewählte Matrix-Gerät ein:'),copy(mainform.Devices[grafischebuehnenansicht.MouseOnLabel].Name, 5, length(mainform.Devices[grafischebuehnenansicht.MouseOnLabel].Name)));

              for m:=0 to length(mainform.Devices)-1 do
              begin
                if (mainform.Devices[m].MatrixDeviceLevel=2) and (IsEqualGUID(mainform.Devices[m].MatrixMainDeviceID, mainform.devices[grafischebuehnenansicht.MouseOnLabel].ID)) then
                begin
                  mainform.Devices[m].Name:='[M '+inttostr(mainform.Devices[m].MatrixXPosition+1)+'x'+inttostr(mainform.Devices[m].MatrixYPosition+1)+'] '+copy(mainform.Devices[grafischebuehnenansicht.MouseOnLabel].Name, 5, length(mainform.Devices[grafischebuehnenansicht.MouseOnLabel].Name));
                end;
              end;
            end;

            for k:=0 to mainform.Devices[grafischebuehnenansicht.MouseOnLabel].MaxChan-1 do
              mainform.data.Names[mainform.Devices[grafischebuehnenansicht.MouseOnLabel].Startaddress+k]:=mainform.Devices[grafischebuehnenansicht.MouseOnLabel].Name+': '+mainform.Devices[grafischebuehnenansicht.MouseOnLabel].Kanalname[k];
          end;
        end else if grafischebuehnenansicht.MouseOnNumber>-1 then
        begin
          paintbox1.PopupMenu:=nil;
          if Button=mbRight then
          begin
{
            // Kanalnummer ändern
            oldvalue:=mainform.devices[grafischebuehnenansicht.MouseOnNumber].Startaddress;
            try
              channel:=strtoint(InputBox('Kanaleinstellung','Welcher Kanal soll für dieses Gerät gelten:',inttostr(mainform.devices[grafischebuehnenansicht.MouseOnNumber].Startaddress)));
              if channel>mainform.lastchan then
                mainform.devices[grafischebuehnenansicht.MouseOnNumber].Startaddress:=mainform.lastchan
              else if channel<1 then
                mainform.devices[grafischebuehnenansicht.MouseOnNumber].Startaddress:=1
              else
                mainform.devices[grafischebuehnenansicht.MouseOnNumber].Startaddress:=channel;
            except
              mainform.devices[grafischebuehnenansicht.MouseOnNumber].Startaddress:=oldvalue;
            end;
}
            // Kanalnummer ändern
            if mainform.Devices[grafischebuehnenansicht.MouseOnNumber].MatrixDeviceLevel=0 then
            begin
              try
                channel:=strtoint(InputBox(_('Kanaleinstellung'),_('Welche Startadresse soll für dieses Gerät gelten:'),inttostr(mainform.devices[grafischebuehnenansicht.MouseOnNumber].Startaddress)));
                geraetesteuerung.ChangeDeviceStartaddress(mainform.devices[grafischebuehnenansicht.MouseOnNumber].ID, channel);
              except
              end;
            end else
            begin
              try
                channel:=strtoint(InputBox(_('Kanaleinstellung'),_('Welche Startadresse soll für dieses Matrix-Gerät gelten:'),inttostr(mainform.devices[grafischebuehnenansicht.MouseOnNumber].Startaddress)));
                geraetesteuerung.ChangeDeviceStartaddress(mainform.devices[grafischebuehnenansicht.MouseOnNumber].ID, channel);

                for m:=0 to length(mainform.Devices)-1 do
                begin
                  if (mainform.Devices[m].MatrixDeviceLevel=2) and (IsEqualGUID(mainform.Devices[m].MatrixMainDeviceID, mainform.devices[grafischebuehnenansicht.MouseOnNumber].ID)) then
                  begin
                    geraetesteuerung.ChangeDeviceStartaddress(mainform.Devices[m].ID, geraetesteuerung.GetMatrixDeviceStartAddress(mainform.Devices[m].MatrixMainDeviceID, mainform.devices[m].MatrixXPosition, mainform.devices[m].MatrixYPosition));
                  end;
                end;
              except
              end;
            end;
          end;
        end else if grafischebuehnenansicht.MouseOnBuehnenansichtNumber>-1 then
        begin
          paintbox1.PopupMenu:=nil;
          if Button=mbRight then
          begin
            // Kanalnummer ändern
            oldvalue:=mainform.buehnenansichtdevices[grafischebuehnenansicht.MouseOnBuehnenansichtNumber].channel;
            try
              channel:=strtoint(InputBox(_('Kanaleinstellung'),_('Welcher Kanal soll für dieses Gerät gelten:'),inttostr(mainform.buehnenansichtdevices[grafischebuehnenansicht.MouseOnBuehnenansichtNumber].channel)));
              if channel>mainform.lastchan then
                mainform.buehnenansichtdevices[grafischebuehnenansicht.MouseOnBuehnenansichtNumber].channel:=mainform.lastchan
              else if channel<1 then
                mainform.buehnenansichtdevices[grafischebuehnenansicht.MouseOnBuehnenansichtNumber].channel:=1
              else
                mainform.buehnenansichtdevices[grafischebuehnenansicht.MouseOnBuehnenansichtNumber].channel:=channel;
            except
              mainform.buehnenansichtdevices[grafischebuehnenansicht.MouseOnBuehnenansichtNumber].channel:=oldvalue;
            end;
          end;
        end else
        begin
          grafischebuehnenansicht.DeviceSelectedTimer.enabled:=false;

          grafischebuehnenansicht.Auswahl.Left:=X;
          grafischebuehnenansicht.Auswahl.Top:=Y;
          grafischebuehnenansicht.Auswahl.Right:=X;
          grafischebuehnenansicht.Auswahl.Bottom:=Y;
          grafischebuehnenansicht.ShowAuswahl:=false;

          mainform.DeviceSelectionChanged(nil);
        end;

        grafischebuehnenansicht.MouseOnBuehnenansichtdevice:=-1;
        grafischebuehnenansicht.MouseOnDevice:=-1;
        grafischebuehnenansicht.MouseOnDeviceHover:=-1;
        grafischebuehnenansicht.MouseOnDeviceID:=StringToGUID('{00000000-0000-0000-0000-000000000000}');
        grafischebuehnenansicht.MouseOnDeviceCopy:=-1;
        grafischebuehnenansicht.MouseOnLabel:=-1;
        grafischebuehnenansicht.MouseOnNumber:=-1;
        grafischebuehnenansicht.MouseOnProgress:=-1;
        grafischebuehnenansicht.MouseOnBuehnenansichtProgress:=-1;
        grafischebuehnenansicht.MouseOnBuehnenansichtColor:=-1;
      end;
      1:  // Kanäle
      begin
        if not UserAccessGranted(2) then exit;

        if Shift=[ssCtrl] then
        begin
          SelektierteKanaele[AktuellerKanal]:=not SelektierteKanaele[AktuellerKanal];
        end else if Shift=[ssShift] then
        begin
          for i:=1 to chan do
            SelektierteKanaele[i]:=false;
          if lastposition<AktuellerKanal then
          begin
            for i:=lastposition to AktuellerKanal do
              SelektierteKanaele[i]:=true;
          end else
          begin
            for i:=AktuellerKanal to lastposition do
              SelektierteKanaele[i]:=true;
          end;
        end else
        begin
          for i:=1 to chan do
            SelektierteKanaele[i]:=false;
          SelektierteKanaele[AktuellerKanal]:=true;
        end;

        if Shift=[ssAlt] then
        begin
          for i:=0 to length(mainform.devices)-1 do
          begin
            if (AktuellerKanal>=mainform.devices[i].Startaddress) and (AktuellerKanal<mainform.devices[i].Startaddress+mainform.devices[i].MaxChan) then
            begin
              mainform.DeviceSelected[i]:=not mainform.DeviceSelected[i];
            end;
          end;
        end;

        if Shift=[ssAlt, ssCtrl] then
        begin
          for i:=0 to length(mainform.devices)-1 do
          begin
            if (AktuellerKanal>=mainform.devices[i].Startaddress) and (AktuellerKanal<mainform.devices[i].Startaddress+mainform.devices[i].MaxChan) then
            begin
              ddfwindowposition:=-1;

              for j:=0 to length(ddfwindows)-1 do
              begin
                if IsEqualGUID(ddfwindows[j].thisddfwindowDeviceID,mainform.Devices[i].ID) then
                  ddfwindowposition:=j;
              end;

              if ddfwindowposition=-1 then
              for j:=0 to length(ddfwindows)-1 do
              begin
                if ddfwindows[j].readyfordelete then
                  ddfwindowposition:=j;
              end;

              if ddfwindowposition=-1 then
              begin
                setlength(ddfwindows,length(ddfwindows)+1);
                ddfwindows[length(ddfwindows)-1]:=TDDFWindow.Create(self);
                ddfwindowposition:=length(ddfwindows)-1;
              end;
              ddfwindows[ddfwindowposition].readyfordelete:=false;
              ddfwindows[ddfwindowposition].thisddfwindowDeviceID:=mainform.Devices[i].ID;
              ddfwindows[ddfwindowposition].Top:=mainform.Top+paintbox1.Top+y+(mainform.height-mainform.ClientHeight);
              ddfwindows[ddfwindowposition].Left:=mainform.Left+paintbox1.Left+x+(mainform.Width-mainform.ClientWidth);
              ddfwindows[ddfwindowposition].loadDDF(mainform.Devices[i].ID);
            end;
          end;
        end;
        Trackbar2.Position:=255-mainform.channel_value[AktuellerKanal];
        TrackBarSelected:=true;

        RefreshMainformScreen:=true;
      end;
      2:  // Panel
      begin
        if not UserAccessGranted(3) then exit;

        kontrollpanel.PaintBox1MouseUp(nil, Button, Shift, X, Y);
      end;
    end;
  end;
end;

procedure TMainform.CheckBox1MouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  grafischebuehnenansicht.CheckBox1.Checked:=checkbox1.Checked;
  grafischebuehnenansicht.RedrawPictures:=true;
end;

procedure TMainform.CheckBox2MouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  grafischebuehnenansicht.CheckBox2.Checked:=checkbox2.Checked;
  grafischebuehnenansicht.RedrawPictures:=true;
end;

procedure TMainform.CheckBox2KeyUp(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  grafischebuehnenansicht.CheckBox2.Checked:=checkbox2.Checked;
  grafischebuehnenansicht.RedrawPictures:=true;
end;

procedure TMainform.CheckBox1KeyUp(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  grafischebuehnenansicht.CheckBox1.Checked:=checkbox1.Checked;
end;

procedure TMainform.Button2Click(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  grafischebuehnenansicht.Button2Click(nil);
end;

procedure TMainform.Button1Click(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  grafischebuehnenansicht.Button1Click(nil);
end;

procedure TMainform.BankSelectSelect(Sender: TObject);
begin
  grafischebuehnenansicht.BankSelectSelect(nil);
end;

procedure TMainform.AddBtnClick(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  grafischebuehnenansicht.AddBtnClick(nil);
end;

procedure TMainform.ChangeBtnClick(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  grafischebuehnenansicht.ChangeBtnClick(nil);
end;

procedure TMainform.DeleteBtnClick(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  grafischebuehnenansicht.DeleteBtnClick(nil);
end;

procedure TMainform.BankCopySelect(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  grafischebuehnenansicht.BankCopySelect(nil);
end;

procedure TMainform.Button6Click(Sender: TObject);
begin
  grafischebuehnenansicht.Button6Click(nil);
end;

procedure TMainform.TrackBar1Change(Sender: TObject);
begin
  grafischebuehnenansicht.Trackbar1.Position:=Trackbar1.Position;
  grafischebuehnenansicht.Trackbar1Change(nil);
end;

procedure TMainform.FormResize(Sender: TObject);
begin
  _MainformBuffer.Width:= mainform.PaintBox1.Width;
  _MainformBuffer.Height:= mainform.PaintBox1.Height;
  _MainformPreBuffer.Width:= mainform.PaintBox1.Width;
  _MainformPreBuffer.Height:= mainform.PaintBox1.Height;

  Scrollbar1.Min:=0;
  if (mainform.lastchan div (mainform.paintbox1.Width div ChannelWidth))-1>0 then
    Scrollbar1.Max:=(mainform.lastchan div (mainform.paintbox1.Width div ChannelWidth))-1;
end;

procedure TMainform.WidthTrackbarChange(Sender: TObject);
begin
  if WidthTrackbar.Position>0 then
    ChannelWidth:=WidthTrackbar.Position;
  RefreshMainformScreen:=true;
end;

procedure TMainform.ScrollBar1Enter(Sender: TObject);
begin
  Scrollbar1.Min:=0;
  if (mainform.lastchan div (mainform.paintbox1.Width div ChannelWidth))-1>0 then
    Scrollbar1.Max:=(mainform.lastchan div (mainform.paintbox1.Width div ChannelWidth))-1;
end;

procedure TMainform.ScrollBar1Scroll(Sender: TObject;
  ScrollCode: TScrollCode; var ScrollPos: Integer);
begin
  ErsteZeile:=Scrollbar1.position;
  RefreshMainformScreen:=true;
end;

procedure TMainform.PaintBox1DblClick(Sender: TObject);
var
  AlterWert,NeuerWert:integer;
begin
  case Pagecontrol1.ActivePageIndex of
    0:
    begin
      if not UserAccessGranted(2) then exit;
    end;
    1:
    begin
      if not UserAccessGranted(2) then exit;

      AlterWert:=255-mainform.data.ch[AktuellerKanal];
      AlterWert:=round(AlterWert/255*100);
      NeuerWert:=StrToInt(InputBox(_('Kanalwert ändern'),_('Bitte geben Sie einen neuen Endwert an:'),inttostr(AlterWert)));
      if NeuerWert>100 then
        NeuerWert:=100;
      NeuerWert:=trunc(NeuerWert/100*255);
      mainform.Senddata(AktuellerKanal,255-mainform.channel_value[aktuellerkanal],255-neuerwert,1000);
    end;
    2:
    begin
      if not UserAccessGranted(3) then exit;
    end;
  end;
end;

procedure TMainform.TrackBar2Change(Sender: TObject);
var
  i:integer;
begin
  if not mainform.UserAccessGranted(2) then exit;

  if (Sender=TrackBar2) and (TrackBarSelected) and (Trackbar2.Focused) then
  begin
    for i:=1 to mainform.lastchan do
    begin
      if SelektierteKanaele[i] then
      begin
        mainform.Senddata(i,Trackbar2.Position,Trackbar2.Position,0);
      end;
    end;
  end;
  RefreshMainformScreen:=true;
end;

procedure TMainform.TrackBar2Enter(Sender: TObject);
begin
  TrackBarSelected:=true;
end;

procedure TMainform.TrackBar2Exit(Sender: TObject);
begin
  TrackBarSelected:=false;
end;

procedure TMainform.PageControl1Change(Sender: TObject);
begin
  case PageControl1.ActivePageIndex of
    0:  // Bühnenansicht
    begin
      grafischebuehnenansicht.RefreshTimer.enabled:=true;
      grafischebuehnenansicht.RedrawPictures:=true;
      kontrollpanel.RefreshTimer.Enabled:=kontrollpanel.Showing;

      Paintbox1.Popupmenu:=grafischebuehnenansicht.PopupMenu1;
      Scrollbar1.Visible:=false;
    end;
    1:  // Kanalübersicht
    begin
      RefreshMainformScreen:=true;

      grafischebuehnenansicht.RefreshTimer.enabled:=grafischebuehnenansicht.Showing;
      kontrollpanel.RefreshTimer.Enabled:=kontrollpanel.Showing;

      Paintbox1.Popupmenu:=kanaluebersichtform.PopupMenu1;
      Scrollbar1.Visible:=true;
    end;
    2:  // Kontrollpanel
    begin
      grafischebuehnenansicht.RefreshTimer.enabled:=grafischebuehnenansicht.Showing;
      kontrollpanel.RefreshTimer.Enabled:=true;
      kontrollpanel.RedrawMainformPanel;

      Scrollbar1.Visible:=false;
    end;
  end;
end;

procedure TMainform.PngBitBtn2MouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  kontrollpanel.PngBitBtn2MouseUp(nil, Button, Shift, X, Y);
end;

procedure TMainform.PngBitBtn1MouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  kontrollpanel.PngBitBtn1MouseUp(nil, Button, Shift, X, Y);
end;

procedure TMainform.PngBitBtn3MouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  kontrollpanel.PngBitBtn3MouseUp(nil, Button, Shift, X, Y);
end;

procedure TMainform.buttonnameEnter(Sender: TObject);
begin
  if not UserAccessGranted(1) then exit;

	if buttonname.Text='Button '+inttostr(kontrollpanel.SelectedBtn.Y+1)+'x'+inttostr(kontrollpanel.SelectedBtn.X+1) then
  	buttonname.Text:='';
end;

procedure TMainform.buttonnameKeyUp(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  if not UserAccessGranted(1) then exit;

	if not shutdown then
	begin
  	mainform.kontrollpanelbuttons[kontrollpanel.SelectedBtn.Y][kontrollpanel.SelectedBtn.X].Name:=buttonname.Text;
		if buttonname.Text=_('Rot') then mainform.kontrollpanelbuttons[kontrollpanel.SelectedBtn.Y][kontrollpanel.SelectedBtn.X].Color:=clRed;
		if buttonname.Text=_('Gelb') then mainform.kontrollpanelbuttons[kontrollpanel.SelectedBtn.Y][kontrollpanel.SelectedBtn.X].Color:=clYellow;
		if buttonname.Text=_('Grün') then mainform.kontrollpanelbuttons[kontrollpanel.SelectedBtn.Y][kontrollpanel.SelectedBtn.X].Color:=clLime;
		if buttonname.Text=_('Schwarz') then mainform.kontrollpanelbuttons[kontrollpanel.SelectedBtn.Y][kontrollpanel.SelectedBtn.X].Color:=clBlack;
		if buttonname.Text=_('Weiß') then mainform.kontrollpanelbuttons[kontrollpanel.SelectedBtn.Y][kontrollpanel.SelectedBtn.X].Color:=clWhite;
		if buttonname.Text=_('Grau') then mainform.kontrollpanelbuttons[kontrollpanel.SelectedBtn.Y][kontrollpanel.SelectedBtn.X].Color:=clGray;
		if buttonname.Text=_('Rosa') then mainform.kontrollpanelbuttons[kontrollpanel.SelectedBtn.Y][kontrollpanel.SelectedBtn.X].Color:=clFuchsia;
		if buttonname.Text=_('Blau') then mainform.kontrollpanelbuttons[kontrollpanel.SelectedBtn.Y][kontrollpanel.SelectedBtn.X].Color:=clBlue;
	end;
end;

procedure TMainform.ComboBox1Select(Sender: TObject);
begin
  if not UserAccessGranted(1) then exit;

  kontrollpanel.ComboBox1.ItemIndex:=Combobox1.ItemIndex;
  kontrollpanel.ComboBox1Select(nil);
end;

procedure TMainform.buttonglyphbtnClick(Sender: TObject);
begin
  if not UserAccessGranted(1) then exit;

  picturechangeform.aktuellebilddatei:=mainform.kontrollpanelbuttons[kontrollpanel.SelectedBtn.Y][kontrollpanel.SelectedBtn.X].Picture;
  picturechangeform.Showmodal;
  if (picturechangeform.ModalResult=mrOK) and FileExists(picturechangeform.aktuellebilddatei) then
  begin
    mainform.kontrollpanelbuttons[kontrollpanel.SelectedBtn.Y][kontrollpanel.SelectedBtn.X].Picture:=picturechangeform.aktuellebilddatei;

    mainform.kontrollpanelbuttons[kontrollpanel.SelectedBtn.Y][kontrollpanel.SelectedBtn.X].PNG.Free;
    mainform.kontrollpanelbuttons[kontrollpanel.SelectedBtn.Y][kontrollpanel.SelectedBtn.X].PNG:=nil;
    mainform.kontrollpanelbuttons[kontrollpanel.SelectedBtn.Y][kontrollpanel.SelectedBtn.X].PNG:=TPNGObject.Create;
    mainform.kontrollpanelbuttons[kontrollpanel.SelectedBtn.Y][kontrollpanel.SelectedBtn.X].PNG.LoadFromFile(mainform.kontrollpanelbuttons[kontrollpanel.SelectedBtn.Y][kontrollpanel.SelectedBtn.X].Picture);
  end;
end;

procedure TMainform.zeilenChange(Sender: TObject);
begin
  kontrollpanel.zeilen.Value:=zeilen.Value;
  kontrollpanel.zeilenChange(nil);
end;

procedure TMainform.spaltenChange(Sender: TObject);
begin
  kontrollpanel.spalten.Value:=spalten.Value;
  kontrollpanel.spaltenChange(nil);
end;

procedure TMainform.btnwidthChange(Sender: TObject);
begin
  if not UserAccessGranted(1) then exit;

  kontrollpanel.btnwidth.Value:=btnwidth.value;
  kontrollpanel.btnheight.Value:=btnheight.value;
  kontrollpanel.btnwidthChange(nil);
end;

procedure TMainform.buttonfarbeChange(Sender: TObject);
begin
  if not UserAccessGranted(1, false) then exit;

	mainform.kontrollpanelbuttons[kontrollpanel.SelectedBtn.Y][kontrollpanel.SelectedBtn.X].Color:=buttonfarbe.Color;
end;

procedure TMainform.szenebearbeitenClick(Sender: TObject);
begin
  if not UserAccessGranted(1) then exit;

  kontrollpanel.szenebearbeitenClick(nil);
end;

procedure TMainform.MinimizeRibbonBtnClick(Sender: TObject);
begin
  dxRibbon1.ShowTabGroups:=not dxRibbon1.ShowTabGroups;
end;

procedure TMainform.FaderpanelhideTimerTimer(Sender: TObject);
begin
  FaderpanelhideTimer.enabled:=Panelautomatischausblenden1.Checked and (not scrolltoleft) and (not scrolltoright);

  if faderpaneltimerbyte>=4 then
  begin
    FaderpanelhideTimer.Enabled:=false;
    faderpanelup:=false;
    faderpaneltimerbyte:=0;
  end;

  faderpaneltimerbyte:=faderpaneltimerbyte+1;
end;

procedure TMainform.DrawFaderpanel(DrawCanvas: TCanvas; X1, Y1, X2, Y2:integer);
var
  i,j,k:integer;
  device_name,device_channame:string;
  device_color:TColor;
  nodevice:boolean;
  devicecounter:integer;
  devicetoggle:boolean;
  samedevice:boolean;

  device_value:byte;
  rectangleheight:byte;
  kanaltyp:string;
  R,G,B:byte;
  offset:integer;
  levelvalue:string;
  label Back;
begin
  if scrolltoleft and (Scrollbar2.Position>Scrollbar2.Min) then
    Scrollbar2.Position:=Scrollbar2.Position-1;
  if scrolltoright and (Scrollbar2.Position<Scrollbar2.Max) then
    Scrollbar2.Position:=Scrollbar2.Position+1;

  offset:=0;
  samedevice:=false;
  devicecounter:=-1;
  devicetoggle:=false;

  maxfaders:=round((X2-X1)/40);
  setlength(faderchannel, maxfaders);
  setlength(faderselected, mainform.lastchan);
  setlength(faderselectedalt, mainform.lastchan);
  setlength(faderselectedshift, mainform.lastchan);
  ScrollBar2.Max:=mainform.lastchan-maxfaders+1;

  DrawCanvas.Brush.Color := $00A6A6A6;
  DrawCanvas.Pen.Style:=psClear;
  DrawCanvas.Rectangle(X1, Y1, X2, Y2);
  DrawCanvas.Brush.Color := clblack;

  for i:=1 to maxfaders do
  begin
    Back:

    // Kanaleigenschaften finden
    device_channame:='';
    device_name:='';
    kanaltyp:='';
    device_color:=clBlack;
    nodevice:=true;
    rectangleheight:=255;
//    devicecounter:=-1;

    for j:=0 to length(mainform.devices)-1 do
    begin
      if ((scrollbar2.position+i-1+offset)>=mainform.devices[j].Startaddress) and ((scrollbar2.position+i-1+offset)<=(mainform.devices[j].Startaddress+mainform.devices[j].MaxChan-1)) then
      begin
        samedevice:=(devicecounter=j);
        if not samedevice then
        begin
          // neues Gerät
          devicecounter:=j;
          devicetoggle:=not devicetoggle;
        end;

        // Kanal liegt innerhalb des Geräts
        device_name:=mainform.Devices[j].Name;
        kanaltyp:=mainform.Devices[j].kanaltyp[((scrollbar2.position+i-1+offset)-mainform.devices[j].Startaddress)];
        device_channame:=mainform.Devices[j].kanalname[((scrollbar2.position+i-1+offset)-mainform.devices[j].Startaddress)];

        if (mainform.Devices[j].hasRGB) and (lowercase(kanaltyp)='r') then
        begin
          rectangleheight:=geraetesteuerung.get_channel(mainform.Devices[j].ID,'r');
          device_color:=RGB2TColor(rectangleheight,0,0);
          r:=255;
          g:=0;
          b:=0;
        end else if (mainform.Devices[j].hasRGB) and (lowercase(kanaltyp)='g') then
        begin
          rectangleheight:=geraetesteuerung.get_channel(mainform.Devices[j].ID,'g');
          device_color:=RGB2TColor(0,rectangleheight,0);
          r:=0;
          g:=255;
          b:=0;
        end else if (mainform.Devices[j].hasRGB) and (lowercase(kanaltyp)='b') then
        begin
          rectangleheight:=geraetesteuerung.get_channel(mainform.Devices[j].ID,'b');
          device_color:=RGB2TColor(0,0,rectangleheight);
          r:=0;
          g:=0;
          b:=255;
        end else if (mainform.Devices[j].hasCMY) and (lowercase(kanaltyp)='c') then
        begin
          rectangleheight:=geraetesteuerung.get_channel(mainform.Devices[j].ID,'c');
          device_color:=RGB2TColor(255-rectangleheight,255,255);
          r:=0;
          g:=255;
          b:=255;
        end else if (mainform.Devices[j].hasCMY) and (lowercase(kanaltyp)='m') then
        begin
          rectangleheight:=geraetesteuerung.get_channel(mainform.Devices[j].ID,'m');
          device_color:=RGB2TColor(255,255-rectangleheight,255);
          r:=255;
          g:=0;
          b:=255;
        end else if (mainform.Devices[j].hasCMY) and (lowercase(kanaltyp)='y') then
        begin
          rectangleheight:=geraetesteuerung.get_channel(mainform.Devices[j].ID,'y');
          device_color:=RGB2TColor(255,255,255-rectangleheight);
          r:=255;
          g:=255;
          b:=0;
        end else if (mainform.Devices[j].hasRGB or mainform.Devices[j].hasCMY) and (mainform.Devices[j].hasAmber) and (lowercase(kanaltyp)='a') then
        begin
          rectangleheight:=geraetesteuerung.get_channel(mainform.Devices[j].ID,'a');
          device_color:=RGB2TColor(0,0,rectangleheight);
          if (mainform.devices[j].AmberRatioG/mainform.devices[j].AmberRatioR)>1 then
          begin
            // mehr Grün als Rot
            r:=round((1/(mainform.devices[j].AmberRatioG/mainform.devices[j].AmberRatioR))*255);
            g:=255;
            b:=0;
          end else
          begin
            // mehr Rot als Grün
            r:=255;
            g:=round((mainform.devices[j].AmberRatioG/mainform.devices[j].AmberRatioR)*255);
            b:=0;
          end;
        end else if ((not mainform.Devices[j].hasRGB) and (not mainform.Devices[j].hasCMY)) and (mainform.Devices[j].hasAmber) and (lowercase(kanaltyp)='a') then
        begin
          rectangleheight:=geraetesteuerung.get_channel(mainform.Devices[j].ID,'w');
          device_color:=RGB2TColor(0,0,rectangleheight);
          r:=255;
          g:=191;
          b:=0;
        end else if (mainform.Devices[j].hasWhite) and (lowercase(kanaltyp)='w') then
        begin
          rectangleheight:=geraetesteuerung.get_channel(mainform.Devices[j].ID,'w');
          device_color:=RGB2TColor(0,0,rectangleheight);
          r:=255;
          g:=255;
          b:=255;
        end else if (mainform.Devices[j].hasUV) and (lowercase(kanaltyp)='uv') then
        begin
          rectangleheight:=geraetesteuerung.get_channel(mainform.Devices[j].ID,'uv');
          device_color:=RGB2TColor(0,0,rectangleheight);
          r:=128;
          g:=0;
          b:=128;
        end else if mainform.Devices[j].hasColor and (lowercase(kanaltyp)='color1') then
        begin
          rectangleheight:=255;
          for k:=0 to length(mainform.devices[j].colorlevels)-1 do
          begin
            if (mainform.devices[j].colorlevels[k]<=geraetesteuerung.get_channel(mainform.devices[j].ID, 'color1')) and
              (mainform.devices[j].colorendlevels[k]>=geraetesteuerung.get_channel(mainform.devices[j].ID, 'color1')) then
            begin
              device_color:=mainform.devices[j].colors[k];
              TColor2RGB(device_color, r,g,b);
              break;
            end;
          end;
        end else if mainform.Devices[j].hasDimmer and (lowercase(kanaltyp)='dimmer') then
        begin
          TColor2RGB(mainform.Devices[j].color,r,g,b);
          device_value:=geraetesteuerung.get_channel(mainform.devices[j].ID,'dimmer');
          rectangleheight:=device_value;
          device_color:=RGB2TColor(round(r*device_value/255),round(g*device_value/255),round(b*device_value/255));
        end else
        begin
          rectangleheight:=mainform.channel_value[(scrollbar2.position+i-1+offset)];
          device_color:=RGB2TColor(mainform.channel_value[(scrollbar2.position+i-1+offset)],mainform.channel_value[(scrollbar2.position+i-1+offset)],mainform.channel_value[(scrollbar2.position+i-1+offset)]);
          TColor2RGB($00A6A6A6, r,g,b);
        end;

        nodevice:=false;
        break;
      end;
    end;
    if nodevice then
    begin
      if faderpanelform.blendoutdevicelesschannel and ((scrollbar2.position+i-1+offset)<(scrollbar2.Max+maxfaders)) then
      begin
        offset:=offset+1;
        goto Back;
      end else
      begin
        TColor2RGB(clYellow,r,g,b);
        rectangleheight:=mainform.channel_value[(scrollbar2.position+i-1)];
        device_color:=RGB2TColor(round(r*(mainform.channel_value[(scrollbar2.position+i-1)]/255)),round(g*(mainform.channel_value[(scrollbar2.position+i-1)]/255)),round(b*(mainform.channel_value[(scrollbar2.position+i-1)]/255)));
      end;
    end;

    if (scrollbar2.position+i-1+offset)>mainform.lastchan then
    begin
      DrawCanvas.Brush.Color:=clBtnFace;
      DrawCanvas.Rectangle(X1+40*(i-1)+5,Y1+24,X1+40*i+5,Y1+45);
    end else
    begin
      if faderpanelform.Kstchenimmervoll1.Checked then
        rectangleheight:=255;
      DrawCanvas.Brush.Color:=device_color;
      DrawCanvas.Rectangle(X1+40*(i-1)+5,Y1+round(45-21*(rectangleheight/255)),X1+40*i+5,Y1+45);

      DrawCanvas.Pen.Color:=RGB2TColor(r,g,b);
      DrawCanvas.Pen.Style:=psSolid;
      DrawCanvas.MoveTo(X1+40*(i-1)+5, Y1+44);
      DrawCanvas.LineTo(X1+40*i+4, Y1+44);
      DrawCanvas.MoveTo(X1+40*(i-1)+5, Y1+45);
      DrawCanvas.LineTo(X1+40*i+4, Y1+45);
    end;

    // Schrift einstellen
    DrawCanvas.Font.Name:='Arial';
    DrawCanvas.Font.Size:=8;

    // Kanalwert zeichnen
    TColor2RGB(device_color,r,g,b);
    DrawCanvas.Font.Style:=[fsBold];
    if (g<127) and (r<225) and (rectangleheight>100) then
      DrawCanvas.Font.Color:=clWhite
    else
      DrawCanvas.Font.Color:=clBlack;
    levelvalue:=mainform.levelstr(mainform.channel_value[(scrollbar2.position+i-1+offset)]);

    DrawCanvas.Brush.Style:=bsClear;
    if length(levelvalue)<2 then
      DrawCanvas.TextOut(X1+40*(i-1)+5+17, Y1+27, levelvalue)
    else if length(levelvalue)<3 then
      DrawCanvas.TextOut(X1+40*(i-1)+5+14, Y1+27, levelvalue)
    else if length(levelvalue)<4 then
      DrawCanvas.TextOut(X1+40*(i-1)+5+11, Y1+27, levelvalue)
    else if length(levelvalue)<5 then
      DrawCanvas.TextOut(X1+40*(i-1)+5+8, Y1+27, levelvalue)
    else if length(levelvalue)<6 then
      DrawCanvas.TextOut(X1+40*(i-1)+5+5, Y1+27, levelvalue)
    else
      DrawCanvas.TextOut(X1+40*(i-1)+5+2, Y1+27, levelvalue);
    DrawCanvas.Brush.Style:=bsSolid;
    DrawCanvas.Font.Color:=clBlack;
    DrawCanvas.Font.Style:=[];
    DrawCanvas.Font.Size:=7;
    DrawCanvas.Brush.Color:=$00A6A6A6;
    DrawCanvas.Pen.Style:=psClear;

    if (scrollbar2.position+i-1+offset)>mainform.lastchan then
    begin
      DrawCanvas.TextOut(X1+40*(i-1)+5, Y1+0, _('n/a'));
      DrawCanvas.TextOut(X1+40*(i-1)+5, Y1+10, '');
      if (Y2-Y1)>100 then
        DrawCanvas.Draw(X1+40*(i-1)+8,Y1+54,image2.Picture.Graphic);
    end else
    begin
      if (Y2-Y1)>100 then
      begin
        DrawCanvas.Draw(X1+40*(i-1)+8,Y1+54,image1.Picture.Graphic);
        DrawCanvas.Draw(X1+40*(i-1)+8+9,Y1+54+round((187-25)*((255-mainform.channel_value[(scrollbar2.position+i-1+offset)])/255)),image3.Picture.Graphic);
      end;

      // Kanalnummer zeichnen
      DrawCanvas.Brush.Style:=bsClear;
      if faderselected[scrollbar2.position+i-1+offset-1] then
      begin
        DrawCanvas.Font.Color:=clRed;
      end else
      begin
        DrawCanvas.Font.Color:=clBlack;
      end;
      DrawCanvas.TextOut(X1+40*(i-1)+5, Y1+0, 'Ch '+inttostr(scrollbar2.position+i-1+offset));

      // Gerätenamen zeichnen
      if faderselectedalt[scrollbar2.position+i-1+offset-1] then
      begin
        DrawCanvas.Font.Color:=clGreen;
      end else
      begin
        DrawCanvas.Font.Color:=clBlack;
      end;

      if (not samedevice) and (not nodevice) then
      begin
        DrawCanvas.Brush.Style:=bsSolid;
        if devicetoggle then
          DrawCanvas.Brush.Color:=$00CFCFCF
        else
          DrawCanvas.Brush.Color:=$00FFFFFF;
        DrawCanvas.Rectangle(X1+40*(i-1)+5, Y1+10, X1+40*(i+mainform.Devices[devicecounter].MaxChan-1)+5, Y1+23);
        DrawCanvas.Brush.Style:=bsClear;
        DrawCanvas.TextOut(X1+40*(i-1)+5, Y1+10, device_name);
      end else if nodevice then
      begin
        DrawCanvas.Brush.Style:=bsSolid;
        DrawCanvas.Brush.Color:=$00A6A6A6;
        DrawCanvas.Rectangle(X1+40*(i-1)+5, Y1+10, X1+40*i+5, Y1+23);
        DrawCanvas.TextOut(X1+40*(i-1)+5, Y1+10, device_name);
      end;

      // Kanalnamen zeichnen
      // Text um 90° gedreht anzeigen
      if (Y2-Y1)>100 then
      begin
        if faderselectedshift[scrollbar2.position+i-1+offset-1] then
        begin
          DrawCanvas.Font.Color:=clBlue;
        end else
        begin
          DrawCanvas.Font.Color:=$00303030;
        end;
        SelectObject(DrawCanvas.Handle, GedrehteSchrift);
        DrawCanvas.TextOut(X1+40*(i-1), Y2-5, device_channame); // Beschreibung
      end;
      
      faderchannel[i-1]:=(scrollbar2.position+i-1+offset);
    end;
  end;

  // Topline zeichnen
  DrawCanvas.Pen.Style:=psSolid;
  DrawCanvas.Pen.Color:=clBlack;
  DrawCanvas.MoveTo(X1+0, Y1+0);
  DrawCanvas.LineTo((X2-X1), Y1+0);
end;

procedure TMainform.ScrollBar2Change(Sender: TObject);
begin
  faderpaneltimerbyte:=0;
  faderpanelup:=true;
  RefreshMainformScreen:=true;
end;

procedure TMainform.MainformScreenRefreshTimerTimer(Sender: TObject);
var
  i,x1,x2,y1,y2,channel,row,col,maxchan,channelperrow:integer;
  temptext:string;
  AddPoints:boolean;
  ShowText:String;
begin
  if not panel1.Visible then
  begin
    if not RefreshMainformScreen then
    for i:=1 to mainform.lastchan do
    begin
      if (oldvaluesChannelview[i]<>(mainform.channel_value[i])) then
      begin
        RefreshMainformScreen:=true;
        break;
      end;
    end;
    Move(mainform.channel_value, oldvaluesChannelview, sizeof(mainform.channel_value));

    // von Zeit zu Zeit aktualisieren
    if Counter>trunc(Rfr_Main/10) then
    begin
      RefreshMainformScreen:=true;
      Counter:=0;
    end;
    Counter:=Counter+1;

    if RefreshMainformScreen then
    begin
      RefreshMainformScreen:=false;

      if (_MainformBuffer.Width<>Paintbox2.Width) then
        _MainformBuffer.Width:=Paintbox2.Width;
      if (_MainformBuffer.Height<>Paintbox2.Height) then
        _MainformBuffer.Height:=Paintbox2.Height;
      if (_MainformPreBuffer.Width<>Paintbox2.Width) then
        _MainformPreBuffer.Width:=Paintbox2.Width;
      if (_MainformPreBuffer.Height<>Paintbox2.Height) then
        _MainformPreBuffer.Height:=Paintbox2.Height;

      _MainformPreBuffer.Canvas.Pen.Style:=psSolid;
      _MainformPreBuffer.Canvas.Pen.Color:=clBlack;
      _MainformPreBuffer.Canvas.Brush.Style:=bsSolid;
      _MainformPreBuffer.Canvas.Brush.Color:=clBlack;

      _MainformPreBuffer.Canvas.Rectangle(0, 0, _MainformPreBuffer.Width, _MainformPreBuffer.Height);
      _MainformPreBuffer.Canvas.Draw((_MainformPreBuffer.Width div 2)-(image4.Width div 2), 0, image4.Picture.Graphic);
      for i:=0 to paintbox2.Width do
      begin
        if i>lastchan then break;

        _MainformPreBuffer.Canvas.Pen.Style:=psSolid;
        _MainformPreBuffer.Canvas.Pen.Color:=clBlue; //GetColor3(0,192,255,channel_value[i+1],clBlue,clYellow,clRed,255);
        _MainformPreBuffer.Canvas.MoveTo(i, _MainformPreBuffer.Height);
        _MainformPreBuffer.Canvas.LineTo(i, round(_MainformPreBuffer.Height-(_MainformPreBuffer.Height*(channel_value[i+1]/255))));
      end;

      _MainformPreBuffer.Canvas.Font.Color:=clBlue;
      _MainformPreBuffer.Canvas.Font.Name:='Arial';
      _MainformPreBuffer.Canvas.Font.Size:=8;
      // Datenraten
      ShowText:=_('MIDI-In:')+' '+inttostr(MIDIInPacketsFreq)+' Pakete/s';
      _MainformPreBuffer.Canvas.TextOut(_MainformPreBuffer.Width-_MainformPreBuffer.Canvas.TextWidth(ShowText)-250, 10, ShowText);
      ShowText:=_('MIDI-Out:')+' '+inttostr(MIDIOutPacketsFreq)+' Pakete/s';
      _MainformPreBuffer.Canvas.TextOut(_MainformPreBuffer.Width-_MainformPreBuffer.Canvas.TextWidth(ShowText)-250, 25, ShowText);
      ShowText:=_('Data-In:')+' '+inttostr(DataInPacketsFreq)+' Pakete/s';
      _MainformPreBuffer.Canvas.TextOut(_MainformPreBuffer.Width-_MainformPreBuffer.Canvas.TextWidth(ShowText)-250, 40, ShowText);
      ShowText:=_('Data-Out:')+' '+inttostr(DMXOutPacketsFreq)+' Pakete/s';
      _MainformPreBuffer.Canvas.TextOut(_MainformPreBuffer.Width-_MainformPreBuffer.Canvas.TextWidth(ShowText)-250, 55, ShowText);

      // Installierte Geräte
      ShowText:=_('Installierte Geräte:')+' '+inttostr(length(mainform.devices));
      _MainformPreBuffer.Canvas.TextOut(_MainformPreBuffer.Width-_MainformPreBuffer.Canvas.TextWidth(ShowText)-16, 10, ShowText);
      // Anzahl der Szenen
      i:=length(mainform.EinfacheSzenen)+length(mainform.devicescenes)+length(mainform.Audioszenen)+length(mainform.Bewegungsszenen)+length(mainform.Autoszenen)+length(mainform.MediaCenterSzenen)+length(mainform.DevicePresets)+length(mainform.presetscenes)+length(mainform.codescenes)+length(mainform.PluginSzenen);
      ShowText:=_('Erstellte Szenen:')+' '+inttostr(i);
      _MainformPreBuffer.Canvas.TextOut(_MainformPreBuffer.Width-_MainformPreBuffer.Canvas.TextWidth(ShowText)-16, 25, ShowText);
      // Dimmerkernelzeit
      if length(mainform.DimmerkernelChannelArray)=1 then
        ShowText:=_('Dimmerkernel:')+' '+inttostr(length(mainform.DimmerkernelChannelArray))+' '+_('Job')
      else
        ShowText:=_('Dimmerkernel:')+' '+inttostr(length(mainform.DimmerkernelChannelArray))+' '+_('Jobs');

      if trunc(mainform.KernelLaufzeit*1000000)>1000 then
        ShowText:=ShowText+' ['+FloatToStrF(mainform.KernelLaufzeit*1000, ffFixed, 4, 2)+'ms/'
      else
        ShowText:=ShowText+' ['+FloatToStrF(mainform.KernelLaufzeit*1000000, ffFixed, 4, 2)+'µs/';
      ShowText:=ShowText+inttostr(DimmerkernelResolution)+'ms]';
      _MainformPreBuffer.Canvas.TextOut(_MainformPreBuffer.Width-_MainformPreBuffer.Canvas.TextWidth(ShowText)-16, 40, ShowText);
      // Kanaländerungen pro Sekunde
      ShowText:=_('Kanaländerung/s:')+' '+inttostr(DimmerkernelChangesPerSecond);
      _MainformPreBuffer.Canvas.TextOut(_MainformPreBuffer.Width-_MainformPreBuffer.Canvas.TextWidth(ShowText)-16, 55, ShowText);

      BitBlt(Paintbox2.Canvas.Handle,0,0,_MainformPreBuffer.Width,_MainformPreBuffer.Height,_MainformPreBuffer.Canvas.Handle,0,0,SRCCOPY);
    end;

    exit;
  end;

  if not RefreshMainformScreen then
  for i:=1 to mainform.lastchan do
  begin
    if (oldvaluesChannelview[i]<>(mainform.channel_value[i])) then
    begin
      RefreshMainformScreen:=true;
      break;
    end;
  end;
  Move(mainform.channel_value, oldvaluesChannelview, sizeof(mainform.channel_value));

  if (_MainformBuffer.Width<>Paintbox1.Width) then
    _MainformBuffer.Width:=Paintbox1.Width;
  if (_MainformBuffer.Height<>Paintbox1.Height) then
    _MainformBuffer.Height:=Paintbox1.Height;
  if (_MainformPreBuffer.Width<>Paintbox1.Width) then
    _MainformPreBuffer.Width:=Paintbox1.Width;
  if (_MainformPreBuffer.Height<>Paintbox1.Height) then
    _MainformPreBuffer.Height:=Paintbox1.Height;

  case PageControl1.ActivePageIndex of
    0:  //Bühne
    begin
      // Bühnenansicht wird in "GrafischeBuehnenansicht" nach _MainformBuffer gezeichnet
    end;
    1:  //Kanäle
    begin
      if not RefreshMainformScreen then exit;

      _MainformPreBuffer.Canvas.Brush.Color := clGray;
      _MainformPreBuffer.Canvas.FillRect(_MainformPreBuffer.ClipRect);

      row:=0;
      col:=-1;
      channelperrow:=mainform.paintbox1.Width div ChannelWidth;

      maxchan:=(ErsteZeile*(mainform.paintbox1.Width div ChannelWidth))+(mainform.paintbox1.Width div ChannelWidth)*(mainform.paintbox1.Height div ChannelHeight);
      if maxchan>mainform.lastchan then
        maxchan:=mainform.lastchan;

      for channel:=(ErsteZeile*(mainform.paintbox1.Width div ChannelWidth))+1 to maxchan do
      begin
        col:=col+1;

        if (ChannelWidth*col+ChannelWidth)>_MainformPreBuffer.Width then
        begin
          row:=row+1;
          col:=0;
        end;

        // Kanalfenster
        x1:=ChannelWidth*col;
        y1:=ChannelHeight*row;
        x2:=x1+ChannelWidth+1;
        y2:=y1+ChannelHeight+1;

        _MainformPreBuffer.FrameRectS(x1,y1,x2,y2,clBlack32); // Schwarzen Rahmen zeichnen
        _MainformPreBuffer.FillRect(x1+1,y1+1,x2-1,y2-1,$FF919191);  // $00919191

        if (mainform.channel_minvalue[channel]>0) or (mainform.channel_maxvalue[channel]<maxres) then // Gelben Rahmen zeichnen
          _MainformPreBuffer.FrameRectS(x1+1,y1+1,x2-1,y2-1,clYellow32);
        if channel=AktuellerKanal then // Roten Rahmen zeichnen
          _MainformPreBuffer.FrameRectS(x1+1,y1+1,x2-1,y2-1,clRed32);
        if SelektierteKanaele[channel] then // Orangene Balken zeichnen
          _MainformPreBuffer.FillRect(x1+2,y2-6,x2-2,y2-2,$00FF7F00);
        if channel=MouseOverKanal then // Blauen MouseOver Balken zeichnen
          _MainformPreBuffer.FillRect(x1+2,y2-8,x2-2,y2-6,$000000FF);

        _MainformPreBuffer.Font.Name:='Arial';
        _MainformPreBuffer.Font.Size:=8;
        _MainformPreBuffer.Font.Style:=[fsBold];
        _MainformPreBuffer.Font.Color:=clWhite;

        _MainformPreBuffer.Textout(x1+4,y1+3,inttostr(channel)); // Kanaladresse zeichnen
        _MainformPreBuffer.FillRect(x1+30,y1+3,x1+33,y1+16,$FF6B6B6B); // Progressbaranzeige anzeigen
        _MainformPreBuffer.FillRect(x1+30,trunc(y1+16-(13*mainform.channel_value[channel]/255)),x1+33,y1+16,clWhite32); // Progressbaranzeige anzeigen
        _MainformPreBuffer.Textout(x1+35,y1+3,mainform.levelstr(mainform.channel_value[channel])); // Kanalwert zeichnen

        _MainformPreBuffer.Font.Style:=[];

        for i:=0 to length(mainform.devices)-1 do
        begin
          if (channel>=mainform.devices[i].Startaddress) and (channel<mainform.devices[i].Startaddress+mainform.devices[i].MaxChan) then
          begin
            temptext:=mainform.devices[i].kanalname[channel-mainform.devices[i].Startaddress];
            AddPoints:=false;
            while (4+_MainformPreBuffer.TextWidth(temptext)>ChannelWidth) do
            begin
              AddPoints:=true;
              temptext:=Copy(temptext,0,length(temptext)-1);
            end;
            if AddPoints then
            begin
              temptext:=Copy(temptext,0,length(temptext)-3);
              temptext:=temptext+'...';
            end;
            _MainformPreBuffer.Textout(x1+4,y1+14,temptext); // Kanalnamen zeichnen

            if (channel=mainform.devices[i].Startaddress) and (channel=mainform.devices[i].Startaddress+mainform.devices[i].MaxChan-1) then // Kanal ist Startadresse eines Gerätes
            begin
              if mainform.DeviceSelected[i] then
                _MainformPreBuffer.FillRect(x1+4,y1+28,x2,y1+43,$00C6C6FF)
              else
                _MainformPreBuffer.FillRect(x1+4,y1+28,x2-4,y1+43,$00D1D1D1);
              _MainformPreBuffer.Font.Color:=clBlack;
    //          _MainformPreBuffer.Textout(x1+6,y1+29,mainform.devices[i].Name);
            end else if channel=mainform.devices[i].Startaddress then // Kanal ist Startadresse eines Gerätes
            begin
              if mainform.DeviceSelected[i] then
                _MainformPreBuffer.FillRect(x1+4,y1+28,x2,y1+43,$00C6C6FF)
              else
                _MainformPreBuffer.FillRect(x1+4,y1+28,x2,y1+43,$00D1D1D1);
              _MainformPreBuffer.Font.Color:=clBlack;
    //          _MainformPreBuffer.Textout(x1+6,y1+29,mainform.devices[i].Name);
            end else if channel=mainform.devices[i].Startaddress+mainform.devices[i].MaxChan-1 then // Kanal ist letzte Adresse eines Gerätes
            begin
              if mainform.DeviceSelected[i] then
                _MainformPreBuffer.FillRect(x1,y1+28,x2-4,y1+43,$00C6C6FF)
              else
                _MainformPreBuffer.FillRect(x1,y1+28,x2-4,y1+43,$00D1D1D1);
            end else // Kanal ist Zwischen Start- und Endadresse eines Gerätes
            begin
              if mainform.DeviceSelected[i] then
                _MainformPreBuffer.FillRect(x1,y1+28,x2,y1+43,$00C6C6FF)
              else
                _MainformPreBuffer.FillRect(x1,y1+28,x2,y1+43,$00D1D1D1);
            end;
          end;
        end;
      end;

      // Im Folgenden nur noch den Gerätenamen ausgeben (bei Mehrkanalgeräten über mehrere Felder)
      row:=0;
      col:=-1;
      for channel:=(ErsteZeile*(mainform.paintbox1.Width div ChannelWidth))+1 to maxchan do
      begin
        col:=col+1;
        if (ChannelWidth*col+ChannelWidth)>_MainformPreBuffer.Width then
        begin
          row:=row+1;
          col:=0;
        end;
        // Kanalfenster
        x1:=ChannelWidth*col;
        y1:=ChannelHeight*row;
    //    x2:=x1+ChannelWidth+1;
    //    y2:=y1+ChannelHeight+1;

        _MainformPreBuffer.Font.Name:='Arial';
        _MainformPreBuffer.Font.Size:=8;
        _MainformPreBuffer.Font.Style:=[];
        _MainformPreBuffer.Font.Color:=clBlack;

        for i:=0 to length(mainform.devices)-1 do
        begin
          if (channel=mainform.devices[i].Startaddress) then // Kanal ist Startadresse eines Gerätes
          begin
            temptext:=mainform.devices[i].Name;
            AddPoints:=false;
            while (6+_MainformPreBuffer.TextWidth(temptext)>(mainform.devices[i].MaxChan*ChannelWidth)) or (x1+6+_MainformPreBuffer.TextWidth(temptext)>channelperrow*ChannelWidth) do
            begin
              AddPoints:=true;
              temptext:=Copy(temptext,0,length(temptext)-1);
            end;
            if AddPoints then
            begin
              temptext:=Copy(temptext,0,length(temptext)-3);
              temptext:=temptext+'...';
            end;
            _MainformPreBuffer.Textout(x1+6,y1+29,temptext);
          end;
        end;
      end;
    end;
    2:  //Panel
    begin
    end;
  end;

  if RefreshMainformScreen or scrolltoleft or scrolltoright then
  begin
    BitBlt(_MainformBuffer.Canvas.Handle,0,0,_MainformPreBuffer.Width,_MainformPreBuffer.Height,_MainformPreBuffer.Canvas.Handle,0,0,SRCCOPY);

    // Faderpanel am unteren Rand zeichnen
    if faderpanelup then
      DrawFaderpanel(_MainformBuffer.Canvas, 0, _MainformBuffer.Height-258, _MainformBuffer.Width, _MainformBuffer.Height+1)
    else
      DrawFaderpanel(_MainformBuffer.Canvas, 0, _MainformBuffer.Height-48, _MainformBuffer.Width, _MainformBuffer.Height+1);

    RefreshMainformScreen:=false;
    BitBlt(Paintbox1.Canvas.Handle,0,0,_MainformBuffer.Width,_MainformBuffer.Height,_MainformBuffer.Canvas.Handle,0,0,SRCCOPY);
  end;
end;

procedure TMainform.ScrollBar2Enter(Sender: TObject);
begin
  ScrollBar2.Max:=mainform.lastchan-maxfaders+1;
end;

procedure TMainform.SmallWindowRibbonBtnClick(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  Panel1.Visible:=not Panel1.Visible;
  mainpanel.Visible:=not panel1.Visible;
  smallwindowstyle:=mainpanel.Visible;

  if Panel1.Visible then
  begin
    mainform.ClientHeight:=680;
    mainform.WindowState:=wsMaximized;
    mainform.BorderIcons:=[biSystemMenu,biMinimize,biMaximize];

{
    if DimmerkernelQueueForm=nil then
      MeasureKernelLaufzeit:=false
    else
      MeasureKernelLaufzeit:=DimmerkernelQueueForm.Showing;
}

    PageControl1Change(nil);
  end else
  begin
    mainform.WindowState:=wsNormal;
    mainform.BorderIcons:=[biSystemMenu,biMinimize];
    mainform.ClientHeight:={dxRibbon1.Height}147+dxRibbonStatusBar1.Height+mainpanel.Height;
    mainform.Top:=0;
    mainform.Width:=Screen.WorkAreaWidth;
    mainform.Left:=Screen.WorkAreaLeft;

    grafischebuehnenansicht.RefreshTimer.enabled:=grafischebuehnenansicht.Showing;
    kontrollpanel.RefreshTimer.Enabled:=kontrollpanel.Showing;
    RefreshMainformScreen:=true;
//    MeasureKernelLaufzeit:=true;
  end;
end;

procedure TMainform.FormCanResize(Sender: TObject; var NewWidth,
  NewHeight: Integer; var Resize: Boolean);
begin
  Resize:=(NewHeight>(dxRibbon1.Height+dxRibbonStatusbar1.Height+mainpanel.Height));
end;

procedure TMainform.dxRibbon1HelpButtonClick(Sender: TdxCustomRibbon);
begin
  ShellExecute(Handle, 'open', PChar('www.pcdimmer.de/wiki/index.php/Kategorie:Handbuch'), nil, nil, SW_SHOW);
end;

procedure TMainform.NetherlandsRibbonBtnClick(Sender: TObject);
begin
  if not UserAccessGranted(1) then exit;

  RetranslateProgram('nl');
  SendMSG(MSG_SETLANGUAGE, integer(13), 0);
end;

function Tmainform.RecordScene(RecordType: integer):TGUID;
var
  i,j,k:integer;
  position, oldlength:integer;
begin
{
  RecordType=0: Alle Kanäle
  RecordType=1: Selektierte Geräte
  RecordType=2: Geänderte Kanäle
  RecordType=3: Selektierte Geräte UND geänderte Kanäle
  RecordType=4: Szeneneditor
}
  oldlength:=length(mainform.DeviceScenes);

  if (RecordType=1) or (RecordType=2) or (RecordType=3) then
  begin
    setlength(mainform.DeviceScenes,length(mainform.devicescenes)+1);
    CreateGUID(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].ID);
    mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Name:=_('Geräteszene')+' ('+DateToStr(now)+' '+TimeToStr(now)+')';
    mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Beschreibung:='';
    mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Fadetime:=5000;
    mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Category:=_('Aufgenommen');

    for i:=0 to length(mainform.devices)-1 do
    begin
      if (((RecordType=1) or (RecordType=3)) and mainform.DeviceSelected[i]) then
      begin
        // Gesamtes Gerät in Szene aufnehmen, da selektiert (wenn Typ 1 oder 3)

        // Ist Gerät schon in Szene?
        position:=-1;
        for k:=0 to length(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices)-1 do
        begin
          if IsEqualGUID(mainform.devices[i].ID, mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[k].ID) then
          begin
            position:=k;
            break;
          end;
        end;
        // Gerät erstellen
        if position=-1 then
        begin
          setlength(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices, length(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices)+1);
          position:=length(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices)-1;

          mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ID:=mainform.devices[i].ID;
          setlength(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanActive, devices[i].MaxChan);
          setlength(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanActiveRandom, devices[i].MaxChan);
          setlength(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanValue, devices[i].MaxChan);
          setlength(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanValueRandom, devices[i].MaxChan);
          setlength(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanDelay, devices[i].MaxChan);
          setlength(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanFadetime, devices[i].MaxChan);
        end;
        for j:=0 to length(mainform.devices[i].kanaltyp)-1 do
        begin
          // Werte einfügen
          mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanActive[j]:=true;
          mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanActiveRandom[j]:=false;
          mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanValue[j]:=channel_value[mainform.devices[i].Startaddress+j];
          mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanValueRandom[j]:=false;
          mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanDelay[j]:=0;
          mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanFadetime[j]:=-1;
        end;
      end else if (RecordType=2) or (RecordType=3) then
      begin
        // Gerät nicht selektiert -> nur veränderte Kanäle aufnehmen (wenn Typ 3)
        // veränderte Kanäle aufnehmen (wenn Typ 2)
        for j:=0 to mainform.devices[i].MaxChan-1 do
        begin
          if ((mainform.devices[i].Startaddress+j)>=1) and ((mainform.devices[i].Startaddress+j)<=lastchan) then
          if changedchannels[mainform.devices[i].Startaddress+j] then
          begin
            // Gerät hat veränderten Kanal

            // Ist Gerät schon in Szene?
            position:=-1;
            for k:=0 to length(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices)-1 do
            begin
              if IsEqualGUID(mainform.devices[i].ID, mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[k].ID) then
              begin
                position:=k;
                break;
              end;
            end;

            // Gerät erstellen
            if position=-1 then
            begin
              setlength(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices, length(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices)+1);
              position:=length(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices)-1;

              mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ID:=mainform.devices[i].ID;
              setlength(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanActive, devices[i].MaxChan);
              setlength(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanActiveRandom, devices[i].MaxChan);
              setlength(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanValue, devices[i].MaxChan);
              setlength(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanValueRandom, devices[i].MaxChan);
              setlength(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanDelay, devices[i].MaxChan);
              setlength(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanFadetime, devices[i].MaxChan);
            end;

            // Werte einfügen
            mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanActive[j]:=true;
            mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanActiveRandom[j]:=false;
            mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanValue[j]:=channel_value[mainform.devices[i].Startaddress+j];
            mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanValueRandom[j]:=false;
            mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanDelay[j]:=0;
            mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanFadetime[j]:=-1;
          end;
        end;
      end;
    end;
  end else if (RecordType=0) then
  begin
    setlength(mainform.DeviceScenes,length(mainform.devicescenes)+1);
    CreateGUID(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].ID);
    mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Name:=_('Geräteszene')+' ('+DateToStr(now)+' '+TimeToStr(now)+')';
    mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Beschreibung:='';
    mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Fadetime:=5000;
    mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Category:=_('Aufgenommen');

    for i:=0 to length(mainform.devices)-1 do
    begin
      // Gesamtes Gerät in Szene aufnehmen, da alle Kanäle aufnehmen (Typ 0)

      // Ist Gerät schon in Szene?
      position:=-1;
      for k:=0 to length(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices)-1 do
      begin
        if IsEqualGUID(mainform.devices[i].ID, mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[k].ID) then
        begin
          position:=k;
          break;
        end;
      end;
      // Gerät erstellen
      if position=-1 then
      begin
        setlength(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices, length(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices)+1);
        position:=length(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices)-1;

        mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ID:=mainform.devices[i].ID;
        setlength(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanActive, devices[i].MaxChan);
        setlength(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanActiveRandom, devices[i].MaxChan);
        setlength(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanValue, devices[i].MaxChan);
        setlength(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanValueRandom, devices[i].MaxChan);
        setlength(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanDelay, devices[i].MaxChan);
        setlength(mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanFadetime, devices[i].MaxChan);
      end;
      for j:=0 to length(mainform.devices[i].kanaltyp)-1 do
      begin
        // Werte einfügen
        mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanActive[j]:=true;
        mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanActiveRandom[j]:=false;
        mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanValue[j]:=channel_value[mainform.devices[i].Startaddress+j];
        mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanValueRandom[j]:=false;
        mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanDelay[j]:=0;
        mainform.DeviceScenes[length(mainform.DeviceScenes)-1].Devices[position].ChanFadetime[j]:=-1;
      end;
    end;
  end else if (RecordType=4) then
  begin
    // Szeneneditor öffnen
    oldlength:=length(mainform.DeviceScenes);
    szenenverwaltung_formarray[0].Gerteszene1Click(mainform);
  end;
  
  if szenenverwaltung_formarray[0].Showing then
    szenenverwaltung_formarray[0].FormShow(nil);

  for i:=1 to lastchan-1 do
    changedchannels[i]:=false;

  if (oldlength<>length(mainform.DeviceScenes)) then
    result:=mainform.DeviceScenes[length(mainform.DeviceScenes)-1].ID
  else
    result:=StringToGUID('{00000000-0000-0000-0000-000000000000}');
end;

procedure TMainform.Image8MouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  if PageControl1.Width>100 then
  begin
    PageControl1.Width:=15;
    Panel4.Width:=15;
  end else
  begin
    PageControl1.Width:=192;
    Panel4.Width:=4;
  end;
end;

procedure Tmainform.LoadDDFPictures;
var
  bild:TPNGImageCollectionItem;
  SR: TSearchRec;
  i: integer;
begin
  // Bestehende Bilder löschen
  for i:=devicepictures32.Items.Count-1 downto 0 do
    devicepictures32.Items.Delete(i);
  for i:=devicepictures64.Items.Count-1 downto 0 do
    devicepictures64.Items.Delete(i);
  for i:=devicepictures96.Items.Count-1 downto 0 do
    devicepictures96.Items.Delete(i);
  for i:=devicepictures128.Items.Count-1 downto 0 do
    devicepictures128.Items.Delete(i);

  // neue Bilder laden
  if (FindFirst(pcdimmerdirectory+'\Devicepictures\32 x 32\*.png',faAnyFile-faDirectory,SR)=0) then
  begin
    repeat
      if (SR.Name<>'.') and (SR.Name<>'..') and (SR.Attr<>faDirectory) then
      begin
        bild:=devicepictures32.Items.Add(false);
        bild.PngImage.LoadFromFile(pcdimmerdirectory+'\Devicepictures\32 x 32\'+SR.Name);
        bild.Name:=SR.Name;

        if FileExists(pcdimmerdirectory+'\Devicepictures\64 x 64\'+SR.Name) then
        begin
          bild:=devicepictures64.Items.Add(false);
          bild.PngImage.LoadFromFile(pcdimmerdirectory+'\Devicepictures\64 x 64\'+SR.Name);
          bild.Name:=SR.Name;
        end else
        begin
          bild:=devicepictures64.Items.Add(false);
          bild.PngImage.LoadFromFile(pcdimmerdirectory+'\Devicepictures\standard64.png');
          bild.Name:=SR.Name;
        end;

        if FileExists(pcdimmerdirectory+'\Devicepictures\96 x 96\'+SR.Name) then
        begin
          bild:=devicepictures96.Items.Add(false);
          bild.PngImage.LoadFromFile(pcdimmerdirectory+'\Devicepictures\96 x 96\'+SR.Name);
          bild.Name:=SR.Name;
        end else
        begin
          bild:=devicepictures96.Items.Add(false);
          bild.PngImage.LoadFromFile(pcdimmerdirectory+'\Devicepictures\standard96.png');
          bild.Name:=SR.Name;
        end;

        if FileExists(pcdimmerdirectory+'\Devicepictures\128x128\'+SR.Name) then
        begin
          bild:=devicepictures128.Items.Add(false);
          bild.PngImage.LoadFromFile(pcdimmerdirectory+'\Devicepictures\128x128\'+SR.Name);
          bild.Name:=SR.Name;
        end else
        begin
          bild:=devicepictures128.Items.Add(false);
          bild.PngImage.LoadFromFile(pcdimmerdirectory+'\Devicepictures\standard128.png');
          bild.Name:=SR.Name;
        end;
      end;
    until FindNext(SR)<>0;
    FindClose(SR);
  end;
end;

procedure Tmainform.ExecuteBeat(Sender: TObject);
var
  i:integer;
begin
  // Beat ausführen
  beatform.TimeoutCounter:=BeatImpuls.Timeout;
  if not beatform.BeatStartSceneStarted then
  begin
    StartScene(BeatImpuls.SceneOnBeatStart);
    beatform.BeatStartSceneStarted:=true;
    beatform.BeatLostSceneStarted:=false;
  end;

  if beatform.beat.Color=clMaroon then
  begin
    beatform.beat.Color:=clblack;
    if flashscrolllockled then
      SetLedState(ktScrollLock, false);  // ScrollLock off

    if MBS_Online then
      SendMidi(MBS_MSGoff,MBS_Data1off,MBS_Data2off);

    SendMSG(MSG_BEATIMPULSE, 1, 0);

    if BeatImpuls.Active then
    begin
      // Beat an DataIn senden
      ExecuteDataInEvent(BeatImpuls.Channel, BeatImpuls.OffValue);
    end;
  end else
  begin
    beatform.beat.Color:=clMaroon;
    if flashscrolllockled then
      SetLedState(ktScrollLock, true);  // ScrollLock on

    if MBS_Online then
      SendMidi(MBS_MSGon,MBS_Data1on,MBS_Data2on);

    SendMSG(MSG_BEATIMPULSE, 0, 0);

    if BeatImpuls.Active then
    begin
      // Beat an DataIn senden
      ExecuteDataInEvent(BeatImpuls.Channel, BeatImpuls.OnValue);
    end;
  end;

  beatform.CalculateBeatTime;
  NextMovingSceneStep:=true;

  // PartyMuckenModul weiterschalten
  if pmmform.check3.Checked then
    pmmform.pmmstep;

  // Alle Effekte einen Schritt weiterschalten
  for i:=length(effektsequenzereffekte)-1 downto 0 do
  if i<length(effektsequenzereffekte) then
  begin
    if AktuellerEffekt[i].beatgesteuert and AktuellerEffekt[i].Aktiv then
    begin
      AktuellerEffekt[i].AnzahlBeats:=AktuellerEffekt[i].AnzahlBeats+1;

      if AktuellerEffekt[i].AktuellerSchritt<length(effektsequenzereffekte[i].Effektschritte) then
      begin
        if AktuellerEffekt[i].AnzahlBeats>=effektsequenzereffekte[i].Effektschritte[AktuellerEffekt[i].AktuellerSchritt].AnzahlBeats then
        begin
          AktuellerEffekt[i].AnzahlBeats:=0;
          Effektschaltvorgang(i, Sender);
        end;
      end;
    end;
  end;
end;

procedure TMainform.dxBarButton22Click(Sender: TObject);
var
  i:integer;
begin
  if not UserAccessGranted(2) then exit;

  if messagedlg(_('Möchten Sie wirklich alle laufenden Audiowiedergaben beenden?'),mtConfirmation, [mbYes,mbNo],0)=mrYes then
  begin
    for i:=0 to length(audioszenen)-1 do
      mainform.StopScene(audioszenen[i].ID);
    Audioeffektplayerform.StopEffektaudioClick(nil);
  end;
end;

procedure TMainform.SidebarselectRibbonBtnClick(Sender: TObject);
var
  LReg:TPCDRegistry;
begin
  if sidebarselectform.Visible=true then
  begin
    sidebarselectform.Visible:=false;
    SidebarselectRibbonBtn.Down:=false;
  end
  else
  begin
    sidebarselectform.Visible:=true;
    SidebarselectRibbonBtn.Down:=true;
  end;

  LReg := TPCDRegistry.Create;
  LReg.WriteBoolEx('', 'SelectionSidebar visible', sidebarselectform.Showing);
  LReg.Free;
end;

procedure TMainform.NurKanlemitGertenanzeigen1Click(Sender: TObject);
begin
  faderpanelform.blendoutdevicelesschannel:=NurKanlemitGertenanzeigen1.Checked;
  faderpanelform.SaveToRegistry;
end;

procedure TMainform.Panelautomatischausblenden1Click(Sender: TObject);
begin
  faderpanelform.Panelautomatischausblenden1.Checked:=Panelautomatischausblenden1.Checked;
  faderpanelform.SaveToRegistry;
end;

procedure TMainform.Kstchenimmervoll1Click(Sender: TObject);
begin
  faderpanelform.Kstchenimmervoll1.Checked:=Kstchenimmervoll1.Checked;
  faderpanelform.SaveToRegistry;
end;

procedure Tmainform.SplashAddText(Text:string);
var
  i:integer;
begin
  case splashscreenvalue of
    0:
    begin
      // kein Splashscreen
    end;
    1:
    begin
      for i:=0 to 3 do
      begin
        splash.text[i]:=splash.text[i+1];
      end;
      splash.text[4]:=Text;
      splash.BringToFront;
    end;
    2:
    begin
      splashscreen2.label2.Caption:=text;
      splashscreen2.BringToFront;
      splashscreen2.label2.refresh;
    end;
  end;
end;

procedure Tmainform.SplashSwitchinfo(Text:string);
begin
  case splashscreenvalue of
    1:
    begin
      splash.switchinfo:=splash.switchinfo+text;
    end;
  end;
end;

procedure Tmainform.SplashCaptioninfo(Text:string);
begin
  case splashscreenvalue of
    0:
    begin
      // kein Splashscreen
    end;
    1:
    begin
      splash.captioninfo:=text;
    end;
    2:
    begin
      splashscreen2.label2.Caption:=text;
      splashscreen2.label2.Refresh;
    end;
  end;
end;

procedure Tmainform.SplashVersioninfo(Text:string);
begin
  case splashscreenvalue of
    1:
    begin
      splash.versioninfo:=text;
    end;
  end;
end;

procedure Tmainform.SplashProgress(bar, position, max:integer);
begin
  case splashscreenvalue of
    0:
    begin
      // kein Splashscreen
    end;
    1:
    begin
      splash.BringToFront;
      if bar=1 then
      begin
        splash.FortschrittMax:=max;
        splash.Fortschritt:=position;
      end else
      begin
        splash.FortschrittMax2:=max;
        splash.Fortschritt2:=position;
      end;
    end;
    2:
    begin
      splashscreen2.BringToFront;
      splashscreen2.progressbar1.Maximum:=max;
      splashscreen2.progressbar1.position:=position;
      splashscreen2.progressbar1.Refresh;
    end;
  end;
end;

procedure Tmainform.RefreshSplashText;
begin
  if splashscreenvalue=1 then
    splash.Timer1Timer(nil);
end;

procedure Tmainform.RetranslateProgram(language: string);
begin
  if not UserAccessGranted(1) then exit;

  UseLanguage(language);
  mainform.ActualLanguage:=uppercase(language);

  ReTranslateComponent(self);

  ReTranslateComponent(mainform);

//  ReTranslateComponent(AboutBox);
  ReTranslateComponent(accumessageform);
  ReTranslateComponent(ActionDlg);
//  ReTranslateComponent(adddevice);
  ReTranslateComponent(adddevicetogroupform);
  ReTranslateComponent(addfunctionform);
  ReTranslateComponent(ambilightform);
  ReTranslateComponent(audioeffektplayerform);
  ReTranslateComponent(audioeffektplayerstretchform);
  ReTranslateComponent(audioszeneneditor);
  ReTranslateComponent(autoszeneform);
  ReTranslateComponent(beatform);
  ReTranslateComponent(bewegungsszeneneditorform);
//  ReTranslateComponent(blenddown);
  ReTranslateComponent(grafischebuehnenansicht);
//  ReTranslateComponent(cdplayerform);
  ReTranslateComponent(clockform);
  ReTranslateComponent(codeeditorform);
  ReTranslateComponent(colormanagerform);
  ReTranslateComponent(compileerrorform);
  ReTranslateComponent(cuelistform);
  ReTranslateComponent(dataineventfrm);
  ReTranslateComponent(ddfeditorform);
  ReTranslateComponent(devicechannelselectionform);
  ReTranslateComponent(devicelistform);
  ReTranslateComponent(devicepicturechangeform);
  ReTranslateComponent(devicepowerform);
  ReTranslateComponent(devicesceneform);
  ReTranslateComponent(dimmcurveform);
  ReTranslateComponent(dynguiform);
//  ReTranslateComponent(DimmerkernelQueueForm);
//  ReTranslateComponent(drucken);
  ReTranslateComponent(editdataineventfrm);
  ReTranslateComponent(editmidieventfrm);
  ReTranslateComponent(editskriptfrm);
  ReTranslateComponent(effektsequenzer);
  //ReTranslateComponent(exceptionform);
  ReTranslateComponent(faderpanelform);
  ReTranslateComponent(figureneditorform);
  ReTranslateComponent(firststepsform);
  ReTranslateComponent(askforremovingform);
  ReTranslateComponent(geraetesteuerung);
//  ReTranslateComponent(gnulicense);
  ReTranslateComponent(insscenedlg);
  ReTranslateComponent(joystickform);
  ReTranslateComponent(joysticksetupform);
  ReTranslateComponent(kanaluebersichtform);
  ReTranslateComponent(kontrollpanel);
  ReTranslateComponent(lauflichtassistentform);
  ReTranslateComponent(lauflichtassistentownpatternform);
  ReTranslateComponent(matrixeditorform);
  ReTranslateComponent(layerbezeichnungenform);
  ReTranslateComponent(leistungssteuerungform2);
  ReTranslateComponent(lockedform);
  ReTranslateComponent(masterform);
  ReTranslateComponent(mediacenterform);
  ReTranslateComponent(midieventfrm);
//  ReTranslateComponent(onlineupdate);
  ReTranslateComponent(OptionenBox);
  ReTranslateComponent(ownmessageform);
  ReTranslateComponent(preseteditor);
  ReTranslateComponent(presetsceneeditor);
//  ReTranslateComponent(presskeyfrm);
//  ReTranslateComponent(inprogress);
//  ReTranslateComponent(ProgressScreenSmall);
  ReTranslateComponent(projektverwaltung);
//  ReTranslateComponent(protocolbox);
//  ReTranslateComponent(recoveryform);
  ReTranslateComponent(groupeditorform);
  ReTranslateComponent(scannersynchronisationform);
  ReTranslateComponent(scenenotfoundform);
  ReTranslateComponent(schedulerform);
  ReTranslateComponent(sidebarform);
  ReTranslateComponent(sidebarselectform);
//  ReTranslateComponent(skripttimer_editform);
  ReTranslateComponent(submasterform);
  ReTranslateComponent(Tastenabfrage);
  ReTranslateComponent(textbuchform);
  ReTranslateComponent(timecodeplayerform);
//  ReTranslateComponent(tippoftheday);
//  ReTranslateComponent(videoscreenform);
  ReTranslateComponent(videoscreensynchronisierenform);
  ReTranslateComponent(winlircform);
  ReTranslateComponent(picturechangeform);
  ReTranslateComponent(nodecontrolform);
  ReTranslateComponent(usermgmtform);
  ReTranslateComponent(xtouchcontrolform);
  ReTranslateComponent(elgatostreamdeckform);

  // Plugins neu initiieren
  mainform.Pluginsreaktivieren1Click(nil);
end;

procedure TMainform.CheckBox4MouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  if not UserAccessGranted(2) then exit;

  grafischebuehnenansicht.CheckBox4.Checked:=checkbox4.Checked;
end;

procedure TMainform.CheckBox4KeyUp(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  if not UserAccessGranted(2) then exit;

  grafischebuehnenansicht.CheckBox4.Checked:=checkbox4.Checked;
end;

procedure TMainform.Button4Click(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  grafischebuehnenansicht.Button4Click(nil);
end;

procedure TMainform.ComboBox2Select(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  grafischebuehnenansicht.ComboBox1.Itemindex:=Combobox2.ItemIndex;
end;

procedure TMainform.MediaCenterTimecodeSocketReceive(Sender: TObject);
var
  Addr:in_addr;
  CurrentPosMs:Cardinal;
  t,h,min,s,ms:integer;
begin
//  MediaCenterTimecodeSocket.ReceiveText
//  MediaCenterTimecodeSocket.ReceiveBuf(CurrentPosMs, sizeof(CurrentPosMs));
  Addr:=MediaCenterTimecodeSocket.RemoteAddr;
  t:=0;
  MediaCenterTimecodeSocket.ReceiveBuf(CurrentPosMs, sizeof(CurrentPosMs), Addr, t);

  t:=CurrentPosMs;
  h:=t div 3600000; t:=t mod 3600000;
  min:=t div 60000; t:=t mod 60000;
  s:=t div 1000; ms:=t mod 1000;

  mediacenterform.mediacentertimecodelbl.caption:=MillisecondsToTimeShort(CurrentPosMs);

  MidiInTimecode[length(MidiInTimecode)-1].h:=h;
  MidiInTimecode[length(MidiInTimecode)-1].min:=min;
  MidiInTimecode[length(MidiInTimecode)-1].s:=s;
  MidiInTimecode[length(MidiInTimecode)-1].Frame:=(ms div 40); // Millisekunden zu 25fps Frame ändern
  MidiInTimecode[length(MidiInTimecode)-1].Framemode:=1;
end;

procedure TMainform.AmbilightRibbonBtnClick(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  if ambilightform.Showing then
    ambilightform.BringToFront
  else
  begin
    ambilightform.Show;
  end;
end;

procedure TMainform.PartyMuckenModulRibbonBtnClick(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  if pmmform.Showing then
    pmmform.BringToFront
  else
  begin
    pmmform.Show;
  end;
end;

procedure TMainform.dxBarLargeButton4Click(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  touchscreenform.show;
end;


function TMainform.FilterTextForNetwork(Text: string):string;
var
  TempString:string;
begin
  TempString:=StringReplace(Text, ',', ' ', [rfReplaceAll, rfIgnoreCase]);
  TempString:=StringReplace(TempString, '{', '(', [rfReplaceAll, rfIgnoreCase]);
  TempString:=StringReplace(TempString, '}', ')', [rfReplaceAll, rfIgnoreCase]);
  TempString:=StringReplace(TempString, ';', ' ', [rfReplaceAll, rfIgnoreCase]);
  TempString:=StringReplace(TempString, ':', ' ', [rfReplaceAll, rfIgnoreCase]);
  TempString:=StringReplace(TempString, 'ä', 'ae', [rfReplaceAll]);
  TempString:=StringReplace(TempString, 'ö', 'oe', [rfReplaceAll]);
  TempString:=StringReplace(TempString, 'ü', 'ue', [rfReplaceAll]);
  TempString:=StringReplace(TempString, 'Ä', 'Ae', [rfReplaceAll]);
  TempString:=StringReplace(TempString, 'Ö', 'Oe', [rfReplaceAll]);
  TempString:=StringReplace(TempString, 'Ü', 'Ue', [rfReplaceAll]);
  TempString:=StringReplace(TempString, 'ß', 'ss', [rfReplaceAll, rfIgnoreCase]);

  if TempString='' then
    TempString:=_('<Leer>');

  result:=TempString;
end;

procedure TMainform.DDFAssistantRibbonBtnClick(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  DDFEditorAssistantForm.show;
end;

procedure TMainform.dxBarLargeButton5Click(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  dynguiform.show;
end;

procedure Tmainform.ResetBass;
var
  i:integer;
  channel_0_position:Int64;
//  playing:boolean;
  BassDeviceInfo:BASS_DEVICEINFO;
  BassInfo: BASS_INFO;
begin
  channel_0_position:=BASS_ChannelGetPosition(audioeffektplayerform._chan[0], BASS_POS_BYTE);
//  playing:=(BASS_ChannelIsActive(audioeffektplayerform._chan[0])=1);

  BASS_ChannelPause(audioeffektplayerform._chan[0]);
  BASS_ChannelPause(audioeffektplayerform._chan[1]);
  BASS_ChannelPause(audioeffektplayerform._chan[2]);
  BASS_ChannelPause(audioeffektplayerform._chan[3]);

  BASS_Free;
  BASS_Init(Optionenbox.sounddevices.ItemIndex+1, BASSDLLFREQUENZ, BASS_DEVICE_SPEAKERS, Handle, nil);

  audioeffektplayerform._chan[0] := BASS_StreamCreateFile(false, PChar(audioeffektplayerform.effektaudioeffektefilename), 0, 0, BASS_SPEAKER_FRONT);
  audioeffektplayerform._chan[1] := BASS_StreamCreateFile(false, PChar(audioeffektplayerform.effektaudioeffektefilename), 0, 0, BASS_SPEAKER_REAR);
  audioeffektplayerform._chan[2] := BASS_StreamCreateFile(false, PChar(audioeffektplayerform.effektaudioeffektefilename), 0, 0, BASS_SPEAKER_CENLFE);
  audioeffektplayerform._chan[3] := BASS_StreamCreateFile(false, PChar(audioeffektplayerform.effektaudioeffektefilename), 0, 0, BASS_SPEAKER_REAR2);

  BASS_ChannelSetPosition(audioeffektplayerform._chan[0],channel_0_position, BASS_POS_BYTE);
  BASS_ChannelSetPosition(audioeffektplayerform._chan[1],BASS_ChannelGetPosition(audioeffektplayerform._chan[0], BASS_POS_BYTE), BASS_POS_BYTE);
  BASS_ChannelSetPosition(audioeffektplayerform._chan[2],BASS_ChannelGetPosition(audioeffektplayerform._chan[0], BASS_POS_BYTE), BASS_POS_BYTE);
  BASS_ChannelSetPosition(audioeffektplayerform._chan[3],BASS_ChannelGetPosition(audioeffektplayerform._chan[0], BASS_POS_BYTE), BASS_POS_BYTE);

  i:=1;
  Optionenbox.sounddevices.clear;
  while (BASS_GetDeviceInfo(i, BassDeviceInfo)) do
  begin
    Optionenbox.sounddevices.Items.Add(BassDeviceInfo.name);
    i := i + 1;
  end;
  if Optionenbox.sounddevices.Items.Count>0 then
  	Optionenbox.sounddevices.ItemIndex:=sounddevice;
  Optionenbox.frontspeaker.checked:=(sounddevicespeakers and 1)=1;
  Optionenbox.rearspeaker.checked:=(sounddevicespeakers and 2)=2;
  Optionenbox.centerlfespeaker.checked:=(sounddevicespeakers and 4)=4;
  Optionenbox.backsurroundspeaker.checked:=(sounddevicespeakers and 8)=8;

  BASS_GetInfo(BassInfo);

  if BassInfo.speakers<8 then
    Optionenbox.backsurroundspeaker.enabled:=false;
  if BassInfo.speakers<6 then
    Optionenbox.centerlfespeaker.enabled:=false;
  if BassInfo.speakers<4 then
    Optionenbox.rearspeaker.enabled:=false;
  if BassInfo.speakers<2 then
    Optionenbox.frontspeaker.enabled:=false;
end;

procedure TMainform.dxBarButton24Click(Sender: TObject);
begin
  ShellExecute(Handle, 'open', PChar('http://www.github.com/xn--nding-jua/PC_DIMMER/issues'), nil, nil, SW_SHOW);
end;

procedure TMainform.dxBarButton25Click(Sender: TObject);
begin
  ShellExecute(Handle, 'open', PChar('http://downloads.pcdimmer.de'), nil, nil, SW_SHOW);
end;

procedure TMainform.dxBarButton26Click(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  audiomanagerform.show;
end;

procedure TMainform.dxBarButton29Click(Sender: TObject);
begin
  ShellExecute(Handle, 'open', PChar('http://www.pcdimmer.de/wiki/index.php/Kategorie:Handbuch'), nil, nil, SW_SHOW);
end;

procedure TMainform.DebugAdd(Text: string; Save: boolean; InitText: boolean);
begin
  if (InitText) then
    debuglistbox.ItemIndex := debuglistbox.Items.Add('['+inttostr(debuglistbox.Items.Count)+'] ['+Timetostr(now)+'] ['+Datetostr(now)+'] ' + Text)
  else
    debuglistbox.ItemIndex := debuglistbox.Items.Add(Text);
  try
    debuglistbox.Items.SaveToFile(userdirectory+'\PC_DIMMER.log');
  except
    on E : Exception do
      debuglistbox.ItemIndex := debuglistbox.Items.Add('['+inttostr(debuglistbox.Items.Count)+'] ['+Timetostr(now)+'] ['+Datetostr(now)+'] ' + 'ERROR: Cannot write into log file: ' + E.Message);
  end;
end;

procedure TMainform.DebugAddToLine(Text: string; Save: boolean);
begin
  debuglistbox.Items.Strings[debuglistbox.Items.Count-1] := debuglistbox.Items.Strings[debuglistbox.Items.Count-1] + Text;
  try
    debuglistbox.Items.SaveToFile(userdirectory+'\PC_DIMMER.log');
  except
    on E : Exception do
      debuglistbox.ItemIndex := debuglistbox.Items.Add('['+inttostr(debuglistbox.Items.Count)+'] ['+Timetostr(now)+'] ['+Datetostr(now)+'] ' + 'ERROR: Cannot write into log file: ' + E.Message);
  end;
end;

procedure TMainform.dxBarButton2Click(Sender: TObject);
begin
  if not UserAccessGranted(1) then exit;

  RetranslateProgram('es');
  SendMSG(MSG_SETLANGUAGE, integer(4), 0);
end;

procedure TMainform.dxBarButton6Click(Sender: TObject);
begin
  if not UserAccessGranted(1) then exit;

  RetranslateProgram('it');
  SendMSG(MSG_SETLANGUAGE, integer(2), 0);
end;

procedure TMainform.NodeControlRibbonBtnClick(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  nodecontrolform.show;
end;

procedure TMainform.OnlineUpdateRibbonBtnClick(Sender: TObject);
begin
  ShellExecute(Handle, 'open', PChar('http://update.pcdimmer.de'), nil, nil, SW_SHOW);
end;

procedure TMainform.CheckBox6KeyUp(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  grafischebuehnenansicht.CheckBox6.Checked:=checkbox6.Checked;
end;

procedure TMainform.CheckBox6MouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  grafischebuehnenansicht.CheckBox6.Checked:=checkbox6.Checked;
end;

procedure TMainform.CheckBox5KeyUp(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  grafischebuehnenansicht.CheckBox5.Checked:=checkbox5.Checked;
end;

procedure TMainform.CheckBox5MouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  grafischebuehnenansicht.CheckBox5.Checked:=checkbox5.Checked;
end;

procedure TMainform.CheckBox3MouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  grafischebuehnenansicht.CheckBox3.Checked:=checkbox3.Checked;
end;

procedure TMainform.CheckBox3KeyUp(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  grafischebuehnenansicht.CheckBox3.Checked:=checkbox3.Checked;
end;

procedure TMainform.FormDragDrop(Sender, Source: TObject; X, Y: Integer);
begin
  showmessage('Dropped');
end;

procedure TMainform.ConvertBMPtoJPG(bmpSource, jpgDestination: string);
var
  Bmp: TBitmap;
  Jpg: TJpegImage;
  Quality: TJPEGQualityRange;
begin
  Bmp := TBitmap.Create;
  Jpg := TJpegImage.Create;
  try
    Bmp.LoadFromFile(bmpSource);
    Quality:=100;
    Jpg.CompressionQuality:=Quality;
    Jpg.Assign(Bmp);
    Jpg.SaveToFile(jpgDestination);
  finally
    Jpg.Free;
    Bmp.Free;
  end;
end;

procedure TMainform.ConvertBMPtoPNG(bmpSource, pngDestination: string);
var
  Bmp: TBitmap;
  Png: TPNGObject;
begin
  Bmp := TBitmap.Create;
  Png := TPNGObject.Create;
  try
    Bmp.LoadFromFile(bmpSource);
    Png.Transparent:=false;
    Png.Assign(Bmp);
    Png.SaveToFile(pngDestination);
  finally
    Png.Free;
    Bmp.Free;
  end;
end;

procedure Tmainform.SavePng(Bitmap: TBitmap; Destination:string);
var
  Png: TPNGObject;
begin
  Png := TPNGObject.Create;
  try
    Png.Transparent:=false;
    Png.Assign(Bitmap);
    Png.SaveToFile(Destination);
  finally
    Png.Free;
  end;
end;

procedure Tmainform.SaveJpg(Bitmap: TBitmap; Destination:string);
var
  Jpg: TJpegImage;
  Quality: TJPEGQualityRange;
begin
  Jpg := TJpegImage.Create;
  try
    Quality:=40;
    Jpg.CompressionQuality:=Quality;
    Jpg.Assign(Bitmap);
    Jpg.SaveToFile(Destination);
  finally
    Jpg.Free;
  end;
end;

procedure Tmainform.PluginRibbonBtnClick(Sender: TObject);
var
  i:integer;
  ProcCall:procedure;
begin
  if UserAccessGranted(2) then
  begin
    for i := 0 to length(ProgramPlugins)-1 do
    begin
      if TdxBarButton(Sender).Name='PluginShowRibbonBtn'+inttostr(i)then
      begin
        if ProgramPlugins[i].Handle<>0 then
        begin
          try
            @ProcCall := GetProcAddress(ProgramPlugins[i].Handle,'DLLShow');
            if Assigned(ProcCall) then
              Proccall;
          except
          end;
        end;
        break;
      end;
      if TdxBarButton(Sender).Name='PluginAboutRibbonBtn'+inttostr(i)then
      begin
          try
            @ProcCall := GetProcAddress(ProgramPlugins[i].Handle,'DLLAbout');
            if Assigned(ProcCall) then
              Proccall;
          except
          end;
        break;
      end;
    end;
  end;
end;

procedure TMainform.dxBarLargeButton6Click(Sender: TObject);
begin
  if not UserAccessGranted(0) then exit;

  usermgmtform.ShowModal;
end;

procedure TMainform.dxBarLargeButton7Click(Sender: TObject);
begin
  ChangeUser;
end;

function Tmainform.UserAccessGranted(Level: integer; ShowLoginWindow: boolean):boolean;
begin
  if (CurrentUserAccessLevel<=Level) then
  begin
    result:=true;
  end else
  begin
    result:=false;
    if ShowLoginWindow then
    begin
      if ChangeUser then
      begin
        if (CurrentUserAccessLevel<=Level) then
        begin
          result:=true;
        end else
        begin
          ShowMessage('"'+CurrentUser+'" '+_('besitzt keine ausreichenden Rechte für diese Operation!'));
          result:=false;
        end;
      end else
      begin
        ShowMessage('"'+CurrentUser+'" '+_('besitzt keine ausreichenden Rechte für diese Operation!'));
        result:=false;
      end;
    end;
  end;
end;

function Tmainform.ChangeUser(ShowWarning:boolean; ChangeToUser: String; ChangeToAccessLevel: integer):boolean;
var
  i:integer;
  AccessGranted:boolean;
begin
  changeuserform.edit1.Items.clear;
  for i:=0 to length(UserAccounts)-1 do
    changeuserform.Edit1.Items.Add(UserAccounts[i].Name);
  changeuserform.edit2.text:='';
  changeuserform.currentuserlbl.Caption:=CurrentUser;

  if ChangeToUser='' then
  begin
    changeuserform.showmodal;

    AccessGranted:=false;
    if changeuserform.modalresult=mrOK then
    begin
      for i:=0 to length(UserAccounts)-1 do
      begin
        if changeuserform.edit1.text=UserAccounts[i].Name then
        begin
          if changeuserform.edit2.text=UserAccounts[i].Password then
          begin
            // Change user
            CurrentUser:=UserAccounts[i].Name;
            CurrentUserAccessLevel:=UserAccounts[i].AccessLevel;
            AccessGranted:=true;
          end;
          break;
        end;
      end;

      if (not AccessGranted) and ShowWarning then
        ShowMessage(_('Zugang verweigert!'));

      result:=AccessGranted;
    end else
    begin
      result:=false;
    end;
  end else
  begin
    CurrentUser:=ChangeToUser;
    CurrentUserAccessLevel:=ChangeToAccessLevel;
    result:=false;
  end;

  dxRibbonStatusBar1.Panels[8].Text:=_('Benutzer:')+' '+CurrentUser;

  // Close Windows, for that the new user have no access:
  if CurrentUserAccessLevel>2 then
  begin
    if ambilightform.Showing then
      ambilightform.Close;
    if pmmform.Showing then
      pmmform.Close;
    if nodecontrolform.Showing then
      nodecontrolform.Close;
    if touchscreenform.Showing then
      touchscreenform.Close;
    if dynguiform.Showing then
      dynguiform.Close;
    if joystickform.Showing then
      joystickform.Close;
    if dataineventfrm.showing then
      dataineventfrm.Close;
    if midieventfrm.showing then
      midieventfrm.close;
    if winlircform.showing then
      winlircform.close;
    if xtouchcontrolform.Showing then
      xtouchcontrolform.Close;
    if elgatostreamdeckform.Showing then
      elgatostreamdeckform.Close;
  end;


  kontrollpanel.TestAccessLevelTimer.Enabled:=true;
end;

procedure TMainform.HTTPServerActivateRibbonBoxClick(Sender: TObject);
begin
  if not UserAccessGranted(1) then exit;

  FHTTPServer.Active:=HTTPServerActivateRibbonBox.Down;
end;

procedure TMainform.dxBarButton7Click(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  if (MEVPDLL<>0) and Assigned(DasMevIsOpened) then
  begin
    if DasMevIsOpened=1 then
    begin
      if Assigned(DasMevClose) then
        DasMevClose();
    end;
  end;
end;

procedure TMainform.dxBarLargeButton8Click(Sender: TObject);
begin
  close;
end;

procedure TMainform.TrackBar3Change(Sender: TObject);
begin
  grafischebuehnenansicht.Trackbar2.Position:=Trackbar3.Position;
  grafischebuehnenansicht.Trackbar2Change(nil);
end;

procedure TMainform.dxBarLargeButton9Click(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  if xtouchcontrolform.Showing then
    xtouchcontrolform.BringToFront
  else
  begin
    xtouchcontrolform.Show;
  end;
end;

procedure TMainform.dxBarLargeButton10Click(Sender: TObject);
begin
  if not UserAccessGranted(2) then exit;

  if elgatostreamdeckform.Showing then
    elgatostreamdeckform.BringToFront
  else
  begin
    elgatostreamdeckform.Show;
  end;
end;

procedure Tmainform.HidCtlDeviceCreateError(
  Controller: TJvHidDeviceController; PnPInfo: TJvHidPnPInfo; var Handled,
  RetryCreate: Boolean);
begin
  // handle errors if desired. For now: ignore error
  Handled:=true;
  RetryCreate:=false;
end;

function Tmainform.HidCtlEnumerate(HidDev: TJvHidDevice;
  const Idx: Integer): Boolean;
var
  i, btn, DeviceIndex, X, Y:integer;
begin
  try
    if HidDev.Attributes.VendorID=$0FD9 then
    begin
      if (HidDev.Attributes.ProductID=$006C) or
      (HidDev.Attributes.ProductID=$0080) or (HidDev.Attributes.ProductID=$0060) or
      (HidDev.Attributes.ProductID=$006D) or (HidDev.Attributes.ProductID=$0063) then
      begin
        // check if we already configured this device
        DeviceIndex:=-1;
        for i:=0 to length(ElgatoStreamDeckArray)-1 do
        begin
          if ElgatoStreamDeckArray[i].Serial=HidDev.SerialNumber then
          begin
            // device already in array
            DeviceIndex:=i;
            break;
          end;
        end;
        if DeviceIndex=-1 then
        begin
          // this is a new device -> put it to new-device-combobox
          setlength(ElgatoStreamDeckArray, length(ElgatoStreamDeckArray)+1);
          DeviceIndex:=length(ElgatoStreamDeckArray)-1;

          ElgatoStreamDeckArray[DeviceIndex].Brightness:=50; // set default brightness
          ElgatoStreamDeckArray[DeviceIndex].UseAutoModeOnLastButton:=true;
          ElgatoStreamDeckArray[DeviceIndex].CurrentButtonMode:=1;
          for btn:=0 to 31 do
          begin
            ElgatoStreamDeckArray[DeviceIndex].Buttons[btn].ButtonType:=0;
            ElgatoStreamDeckArray[DeviceIndex].Buttons[btn].Increment:=15;
            ElgatoStreamDeckArray[DeviceIndex].Buttons[btn].CurrentValue:=0;
            ElgatoStreamDeckArray[DeviceIndex].Buttons[btn].UseHoldToChange:=true;

            X:=0;
            Y:=0;
            if HidDev.Attributes.ProductID=$0063 then
            begin
              // 6 Buttons
              X:=btn-trunc(btn/3)*3;
              Y:=trunc(btn/3);
            end else if (HidDev.Attributes.ProductID=$0080) or (HidDev.Attributes.ProductID=$0060) or (HidDev.Attributes.ProductID=$006D) then
            begin
              // 15 Buttons
              X:=btn-trunc(btn/5)*5;
              Y:=trunc(btn/5);
            end else if HidDev.Attributes.ProductID=$006C then
            begin
              // 32 Buttons
              X:=btn-trunc(btn/8)*8;
              Y:=trunc(btn/8);
            end;

            ElgatoStreamDeckArray[DeviceIndex].Buttons[btn].KontrollpanelX:=X+1;
            ElgatoStreamDeckArray[DeviceIndex].Buttons[btn].KontrollpanelY:=Y+1;
            ElgatoStreamDeckArray[DeviceIndex].Buttons[btn].DataInChannel:=btn+1;
            CreateGUID(ElgatoStreamDeckArray[DeviceIndex].Buttons[btn].Befehl.ID);
            ElgatoStreamDeckArray[DeviceIndex].Buttons[btn].Befehl.Name:='Button '+inttostr(btn+1)+'-Event';
            ElgatoStreamDeckArray[DeviceIndex].Buttons[btn].Befehl.OnValue:=255;
            ElgatoStreamDeckArray[DeviceIndex].Buttons[btn].Befehl.SwitchValue:=128;
            ElgatoStreamDeckArray[DeviceIndex].Buttons[btn].Befehl.OffValue:=0;
          end;
        end;

        // connect this device
        HidCtl.CheckOutByIndex(ElgatoStreamDeckArray[DeviceIndex].HidDevice, Idx);
        // update ElgatoStreamDeckArray
        ElgatoStreamDeckArray[DeviceIndex].Serial:=HidDev.SerialNumber;
        ElgatoStreamDeckArray[DeviceIndex].Online:=true;

        if HidDev.Attributes.ProductID=$006C then
        begin
          // it is a Stream Deck XL
          // 32 buttons
          ElgatoStreamDeckArray[DeviceIndex].ButtonCount:=32;
        end else if (HidDev.Attributes.ProductID=$0080) or (HidDev.Attributes.ProductID=$0060) or (HidDev.Attributes.ProductID=$006D) then
        begin
          // it is a Stream Deck or Stream Deck original v2 or Stream Deck MK2
          // 15 buttons
          ElgatoStreamDeckArray[DeviceIndex].ButtonCount:=15;
        end else if HidDev.Attributes.ProductID=$0063 then
        begin
          // it is a Stream Deck Mini
          // 6 buttons
          ElgatoStreamDeckArray[DeviceIndex].ButtonCount:=6;
        end;

        // put this device to GUI
        elgatostreamdeckform.devicelistbox.ItemIndex:=elgatostreamdeckform.devicelistbox.Items.Add(HidDev.VendorName+' '+HidDev.ProductName+' ['+HidDev.SerialNumber+']');
        setlength(ElgatoStreamSerials, length(ElgatoStreamSerials)+1);
        ElgatoStreamSerials[length(ElgatoStreamSerials)-1]:=HidDev.SerialNumber;

        // set brightness
        elgatostreamdeckform.SetBrightness(HidDev.SerialNumber, ElgatoStreamDeckArray[DeviceIndex].Brightness);
      end;
    end;

    Result := True;
  except
    Result := False;
  end;
end;

procedure Tmainform.HidCtlDeviceChange(Sender: TObject);
var
  i: Integer;
begin
  // disconnect all devices and reconnect
  for i:=0 to length(ElgatoStreamDeckArray)-1 do
  begin
    ElgatoStreamDeckArray[i].Online:=false;
    try
      ElgatoStreamDeckArray[i].HidDevice.Free;
    except
    end;
  end;

  elgatostreamdeckform.devicelistbox.Clear;
  setlength(ElgatoStreamSerials, 0);

  // search for all connected devices
  try
    HidCtl.Enumerate;
  except
  end;
end;

procedure Tmainform.HidCtlDeviceData(HidDev: TJvHidDevice; ReportID: Byte;
  const Data: Pointer; Size: Word);
var
  Buffer: array of byte;
  i,b, DeviceIndex:integer;
  CurrentButtonMode:byte;
  AtLeastOneButtonPressed:boolean;
  PID:Word;
  PressedButton:integer;
begin
  if HidDev.Attributes.VendorID=$0FD9 then
  begin
    // it is a product of Elgato

    // check if we have a StreamDeck
    PID:=HidDev.Attributes.ProductID;

    if (PID=$0060) or (PID=$0063) or (PID=$006D) or (PID=$0080) or (PID=$006C) then
    begin
      // StreamDeck detected. Copy data
      setlength(Buffer, Size);
      Move(Data^, Pointer(Buffer)^, Size);
    end else
    begin
      // not a StreamDeck - exit
      exit;
    end;

    AtLeastOneButtonPressed:=false;

    // search for this product serial in array
    for i:=0 to length(ElgatoStreamDeckArray)-1 do
    begin
      if ElgatoStreamDeckArray[i].Serial=HidDev.SerialNumber then
      begin
        for b:=0 to ElgatoStreamDeckArray[i].ButtonCount-1 do
        begin
          // StreamDeck Original has inverted indexing of buttons
          if (PID=$0060) then
          begin
            PressedButton:=15-b; // StreamDeck Original has 15 buttons
          end else
          begin
            PressedButton:=b;
          end;

          if (mainform.ElgatoStreamDeckArray[i].UseAutoModeOnLastButton) then
          begin
            CurrentButtonMode:=mainform.ElgatoStreamDeckArray[i].CurrentButtonMode;
          end else
          begin
            CurrentButtonMode:=ElgatoStreamDeckArray[i].Buttons[PressedButton].ButtonType;
          end;

          if (Buffer[3+b]=1) and not ElgatoStreamDeckArray[i].Buttons[PressedButton].Pressed then
          begin
            // button pressed
            ElgatoStreamDeckArray[i].Buttons[PressedButton].Pressed:=true;
            AtLeastOneButtonPressed:=true;

            if (PressedButton=(ElgatoStreamDeckArray[i].ButtonCount-1)) and (mainform.ElgatoStreamDeckArray[i].UseAutoModeOnLastButton) then
            begin
              // we are at last button and we want to switch between modes
              if mainform.ElgatoStreamDeckArray[i].CurrentButtonMode<4 then
                mainform.ElgatoStreamDeckArray[i].CurrentButtonMode:=mainform.ElgatoStreamDeckArray[i].CurrentButtonMode+1
              else
                mainform.ElgatoStreamDeckArray[i].CurrentButtonMode:=1;
            end else
            begin
              if ElgatoStreamDeckArray[i].Buttons[PressedButton].UseHoldToChange then
              begin
                if (CurrentButtonMode=3) or (CurrentButtonMode=4) then
                begin
                  if mainform.ElgatoStreamDeckArray[i].Buttons[PressedButton].CurrentValue=255 then
                    mainform.ElgatoStreamDeckArray[i].Buttons[PressedButton].Increment:=-1*abs(mainform.ElgatoStreamDeckArray[i].Buttons[PressedButton].Increment)
                  else if mainform.ElgatoStreamDeckArray[i].Buttons[PressedButton].CurrentValue=0 then
                    mainform.ElgatoStreamDeckArray[i].Buttons[PressedButton].Increment:=abs(mainform.ElgatoStreamDeckArray[i].Buttons[PressedButton].Increment);
                end;
              end else
              begin
                mainform.ElgatoStreamDeckArray[i].Buttons[PressedButton].CurrentValue:=255;
              end;

              case CurrentButtonMode of
                1: // 1=Kontrollpanel
                begin
                  kontrollpanel.PaintBox1MouseMove(nil, [], trunc(kontrollpanel.btnwidth.Value*(ElgatoStreamDeckArray[i].Buttons[PressedButton].KontrollpanelX-1)+(kontrollpanel.btnwidth.Value / 2)), trunc(kontrollpanel.btnheight.Value*(ElgatoStreamDeckArray[i].Buttons[PressedButton].KontrollpanelY-1)+(kontrollpanel.btnheight.Value / 2)));
                  kontrollpanel.PaintBox1MouseDown(nil, mbLeft, [ssLeft], trunc(kontrollpanel.btnwidth.Value*(ElgatoStreamDeckArray[i].Buttons[PressedButton].KontrollpanelX-1)+(kontrollpanel.btnwidth.Value / 2)), trunc(kontrollpanel.btnheight.Value*(ElgatoStreamDeckArray[i].Buttons[PressedButton].KontrollpanelY-1)+(kontrollpanel.btnheight.Value / 2)));
                end;
                2: // 2=DeviceOrGroupSelection
                begin
                  DeviceIndex:=geraetesteuerung.GetDevicePositionInDeviceArray(@ElgatoStreamDeckArray[i].Buttons[PressedButton].DeviceOrGroupID);
                  if DeviceIndex>-1 then
                  begin
                    // it is a device -> deselect all devices and select only this device
                    DeSelectAllDevices;
                    deviceselected[geraetesteuerung.GetDevicePositionInDeviceArray(@ElgatoStreamDeckArray[i].Buttons[PressedButton].DeviceOrGroupID)]:=true;
                  end else
                  begin
                    // it is a Group
                    SelectDeviceGroup(ElgatoStreamDeckArray[i].Buttons[PressedButton].DeviceOrGroupID, false);
                  end;
                end;
                3: // 3=DataIn
                begin
                  if not ElgatoStreamDeckArray[i].Buttons[PressedButton].UseHoldToChange then
                  begin
                    mainform.ExecuteDataInEvent(ElgatoStreamDeckArray[i].Buttons[PressedButton].DataInChannel, 255);
                  end;
                end;
                4: // 4=Befehl
                begin
                  if not ElgatoStreamDeckArray[i].Buttons[PressedButton].UseHoldToChange then
                  begin
                    StartBefehl(ElgatoStreamDeckArray[i].Buttons[PressedButton].Befehl.ID, 255);
                  end;
                end;
              end;
            end;
          end else if (Buffer[3+b]=0) and ElgatoStreamDeckArray[i].Buttons[PressedButton].Pressed then
          begin
            // button released
            ElgatoStreamDeckArray[i].Buttons[PressedButton].Pressed:=false;

            if (CurrentButtonMode=3) or (CurrentButtonMode=4) then
            begin
              // change direction of value-change on each button-release
              ElgatoStreamDeckArray[i].Buttons[PressedButton].Increment:=-1*ElgatoStreamDeckArray[i].Buttons[PressedButton].Increment;
            end;

            if (PressedButton=(ElgatoStreamDeckArray[i].ButtonCount-1)) and (mainform.ElgatoStreamDeckArray[i].UseAutoModeOnLastButton) then
            begin
              // we are at last button and we want to switch between modes
              // nothing to do on release
            end else
            begin
              if not ElgatoStreamDeckArray[i].Buttons[PressedButton].UseHoldToChange then
                mainform.ElgatoStreamDeckArray[i].Buttons[PressedButton].CurrentValue:=0;

              case CurrentButtonMode of
                1: // 1=Kontrollpanel
                begin
                  kontrollpanel.PaintBox1MouseMove(nil, [], trunc(kontrollpanel.btnwidth.Value*(ElgatoStreamDeckArray[i].Buttons[PressedButton].KontrollpanelX-1)+(kontrollpanel.btnwidth.Value / 2)), trunc(kontrollpanel.btnheight.Value*(ElgatoStreamDeckArray[i].Buttons[PressedButton].KontrollpanelY-1)+(kontrollpanel.btnheight.Value / 2)));
                  kontrollpanel.PaintBox1MouseUp(nil, mbLeft, [], trunc(kontrollpanel.btnwidth.Value*(ElgatoStreamDeckArray[i].Buttons[PressedButton].KontrollpanelX-1)+(kontrollpanel.btnwidth.Value / 2)), trunc(kontrollpanel.btnheight.Value*(ElgatoStreamDeckArray[i].Buttons[PressedButton].KontrollpanelY-1)+(kontrollpanel.btnheight.Value / 2)));
                end;
                2: // 2=DeviceOrGroupSelection
                begin
                  // do nothing on release
                end;
                3: // 3=DataIn
                begin
                  if not ElgatoStreamDeckArray[i].Buttons[PressedButton].UseHoldToChange then
                    mainform.ExecuteDataInEvent(ElgatoStreamDeckArray[i].Buttons[PressedButton].DataInChannel, 0);
                end;
                4: // 4=Befehl
                begin
                  if not ElgatoStreamDeckArray[i].Buttons[PressedButton].UseHoldToChange then
                    StartBefehl(ElgatoStreamDeckArray[i].Buttons[PressedButton].Befehl.ID, 0);
                end;
              end;
            end;
          end;
        end;

        break;
      end;
    end;

    if AtLeastOneButtonPressed then
    begin
      elgatostreamdeckform.ElgatoStreamDeckDisplayTimer.Interval:=100;
      elgatostreamdeckform.ElgatoStreamDeckDisplayTimerTimer(nil); // direct refresh of button
    end else
    begin
      elgatostreamdeckform.ElgatoStreamDeckDisplayTimer.Interval:=500;
    end;
  end;
end;

procedure TMainform.MQTTClientActivateRibbonBoxClick(Sender: TObject);
begin
  if not UserAccessGranted(1) then exit;

  mqtt.Activate(HTTPServerActivateRibbonBox.Down);
end;

end.

